{
  "/docs/new-relic-one/use-new-relic-one/workloads/use-workloads": [
    {
      "sections": [
        "Workload status configuration",
        "Configure the automatic workload status",
        "Important",
        "Create custom rules",
        "A rule for remaining entities",
        "Set a static workload status",
        "Tip",
        "Understand the status value"
      ],
      "title": "Workload status configuration",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "279b7200d747d5fca3b0021cd0647de4705f0926",
      "image": "https://docs.newrelic.com/static/877d101d0e1d86f4c0b9b96c58d72885/c1b63/new-relic-workload-status-main.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workload-status-configuration/",
      "published_at": "2021-07-09T08:52:05Z",
      "updated_at": "2021-07-09T08:52:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can obtain your workload status in two ways, automatic and static: Automatic status: it is calculated from a series of rules. Static status: it overrides any automatic calculation of your workload status. To create or edit the workload status, click the Status details and setup icon from the workload overview. Configure the automatic workload status Important You must have workload management permissions to carry out this configuration. You can use the status of each one of the entities that belong to a workload in order to summarize the workload status into a single value. Not all entities in a workload are equally important from a performance, errors, or availability perspective: You might want your workload to show as disrupted if an essential Synthetics monitor or service has got a critical violation going on. However, if your host infrastructure has a certain redundancy and resilience to outages, you might not need to change your workload status from Operational just because a single host has an alert violation going on. By default, when you create a workload the following rules to calculate its status are added: For entity types close to the digital experience (that is, synthetic monitors, browser applications, mobile applications, and services), the worst available status is propagated. For any other entity type, which are basically infrastructure entities, the best available status is propagated. Create custom rules To customize the automatic workload status, you can define your own rules. A rule consists of a group of entities and a roll up mode: Define the group of entities based on entity types, tag values, GUIDs, or a combination of all of them. Decide how to propagate the status of these entities to the group status: Roll up the best status: the group status matches the less critical status of all belonging entities. Use this option when you want the group status to be operational as long as at least one entity in the group is still operational. Roll up the worst status: the group status matches the most critical status of all belonging entities. Use this option when you want the group status to indicate a degradation or a disruption of service as soon as one entity in the group is not operational. You can also decide to roll up the worst status only after a certain amount of entities are not operational. Save the rule and proceed to create another one if you need to. The final workload status equals the worst status among all the individual group statuses. Important In this final calculation, any automatically calculated status is overridden if a static status has been set by a workload manager. A rule for remaining entities For an easier and more dynamic status configuration, you can use a roll-up type for all entities that aren’t evaluated in any other rule that you have defined before. In particular, if you don't add any other rule at all, the rule for remaining entities will take into account all the entities in the workload. When combined with the grouping by entity type option, this special rule allows you to get a general sense of how each entity type in your workload is doing, without having to configure a rule for each entity type. Therefore, we recommend that you always set a rule for all remaining entities grouped by type, and roll up their worst status to quickly detect when all entities in a layer of your workload stack are not operational. Set a static workload status If you want to communicate the status for your workload regardless of any automatic calculation based on rules, you can set a static status value for your workload from one of the available status values. This is useful during maintenance tasks to communicate to other teams that the status of your workload is disrupted, to provide further information, or to give the time you expect the workload to be operational again. Tip If you regularly need to communicate a temporary status due to your deployment or operations processes, you can automate the static status set up by integrating the API into your workflows. Important Any static status set by a workload manager always overrides any other status values calculated automatically. To set up a static workload status: Set a static status value. Optionally, write a short summary for the status, and a longer description of what’s happening to the workload. Check that the static status is enabled. Understand the status value The workload Overview shows the result of the workload status. If you click on the Status details and setup icon (or just Status details if you don’t have the workload manager role), you’ll see how the status calculation was configured, and the result of all the rules and/or static statuses that were taken into account to calculate the global workload status value. Any change that you make on the workload status configuration will become effective only once you save the changes. For your convenience, while you’re setting the automatic rules or a static status, you’ll get a preview of what the status result would be if you saved the configuration at that point.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.9649,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Workload</em> status configuration",
        "sections": "<em>Workload</em> status configuration",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " the <em>workload</em> overview. Configure the automatic <em>workload</em> status Important You must have <em>workload</em> management permissions to carry out this configuration. You can <em>use</em> the status of each <em>one</em> of the entities that belong to a <em>workload</em> in order to summarize the <em>workload</em> status into a single value. Not all"
      },
      "id": "603e8a25e7b9d268262a07c5"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What is an entity?",
        "Find and explore entities",
        "Tip",
        "Entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services",
        "Group and organize entities"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-07-09T09:08:40Z",
      "updated_at": "2021-07-09T09:08:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of the entity. An entity is anything that reports data to New Relic. This document explains: What entities are How to find entity data How to modify existing entity types or create new ones How entities are related to one another How to organize them into groups for easier analysis What is an entity? From a New Relic product perspective, entity is a broad concept. An entity is anything we can identify that has data you can monitor. \"Entity\" can refer to fundamental data-reporting components like applications, hosts, and database services, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. This conceptual definition of \"entity\" is important because New Relic's goal is to give you practical information about the status of your business-important entities (and not just give you an unhelpfully large stream of assorted metrics and data). Our focus on entities, and the relationships between them, helps us optimize monitoring and troubleshooting of complex, modern systems. Find and explore entities You'll find your entities wherever you see your data reporting in New Relic. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's unique global identifier (GUID): from any list of monitored entities in the New Relic Explorer, hover over a specific entity and click the icon to see the GUID and other metadata. An entity's GUID is reported as the attribute entityGuid. You can query for an entity using this attribute in the query builder. Use the Related Entities view in the New Relic Explorer, service maps, distributed tracing, and our relationships API in GraphQL to see connections between entities. Explore entity data using our NerdGraph GraphiQL explorer (api.newrelic.com/graphiql). Entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic which matches your definition file will be synthesized into an entity. Tip For more information on how to modify existing entity types or create new ones please refer to our Entity Synthesis documentation. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you are aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relic’s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relic’s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relic’s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a single entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related Entities in the entity's mini overview. Related Entities is a visualization of the various entities connected directly to the current entity in focus. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip You can learn more about how entities are related using our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related Entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you don’t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are “dynamic” (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod that’s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: How to tag entities Create workloads (groups of related entities)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 289.92145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate ingested telemetry with an entity already created by <em>New</em> <em>Relic</em>. When the entity.guid attribute is sent, the value"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "New Relic feature end of life announcements July 2020",
        "Old Kubernetes integration agent versions",
        "Monitor listing page and Synthetic labels",
        "\"Rollup by\" in Synthetics",
        "Embedded charts",
        "Legacy distributed tracing UI",
        "Violations changes",
        "Connected agents page",
        "Inactive apps in New Relic One",
        "Synthetic monitor alert notifications and conditions"
      ],
      "title": "New Relic feature end of life announcements July 2020",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "1db1d6b3df6d5ac3b983f78f3264cab332cff05a",
      "image": "https://docs.newrelic.com/static/f2b139d12bd8cdc13a9907b7874a4452/0a867/nrone-embed-bb062520.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-feature-end-life-announcements-july-2020/",
      "published_at": "2021-07-09T10:18:47Z",
      "updated_at": "2021-07-09T10:18:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to improve your New Relic experience we've made some big improvements to our platform. As a result, we'll be ending support for some old features over the next few weeks. Many have already been publicly announced as \"end-of-life.\" These changes represent our commitment to improve your interactions with our platform. Our mission is one observability platform that unites your telemetry data, connects your full stack, and helps you build more perfect software. To that end we're focusing on simplifying your experience for troubleshooting, alerting, and visualizing data. Here are more details on what's changed, with some helpful links and guides on how to take advantage of new capabilities to achieve the same goals. As always, we're here to help. Please connect with us in the Explorers Hub, or contact your account team with any questions. Old Kubernetes integration agent versions To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in New Relic One. If you are already using the latest Kubernetes agent version, no action is necessary. If you are using v1.7 or older, you must update your integration in order to continue viewing Kubernetes performance data. Follow the instructions in our documentation to upgrade to the latest version of the Kubernetes integration. Action items for a successful transition: Review the Kubernetes agent deprecation notice. Follow standard procedures to upgrade your Kubernetes agent to the latest version. Learn about the Kubernetes cluster explorer UI in New Relic One. For more information, see the Explorers Hub post. Monitor listing page and Synthetic labels To improve the experience of Synthetic monitors and labels, we've moved both experiences into the New Relic One platform. If you use the REST API for Synthetic label management, you must update to the tags API moving forward. The good news: with the NerdGraph tags API, you can organize and group all your entities in a single request. For more information about any of the following, see the Explorers Hub post. Action items for a successful transition: Synthetic monitors transition Comments Monitor index list When migration is completed, no action is needed on your part to use the new Synthetics entity listing pages. The new experience will be available to you automatically after July 20, 2020. For more information, learn how the explorer in New Relic One replaces the Synthetics monitors index. Existing Synthetics labels You may have already seen an option in the UI to migrate your Synthetics monitor labels to New Relic One tags. If you did not select that option, we've got you covered. Automatic migration from labels to tags starts begins July 8, 2020. For more information, learn how tagging in New Relic One replaces labels for Synthetics monitors. REST API If you use the REST API for Synthetics label management, follow these steps to update to the tags API: Learn more about NerdGraph. Review the NerdGraph tagging API tutorial. Make sure you have a Personal API key to use NerdGraph. Follow the procedures in the Explorers Hub post (look for the How do I transition my scripts from the Synthetics API to the tag API (NerdGraph)? section), and update your existing tags with the GraphiQL explorer at api.newrelic.com/graphiql. NerdGraph is our GraphQL API, a query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time. \"Rollup by\" in Synthetics Synthetics is moving to New Relic One to provide a single platform for observability of your complex software systems. To do this we are unifying the tools you use to tag (or label) your services, applications, and monitors. The specific feature that is end-of-life is the Rollup by feature under the Search monitors dropdown menu. You can group monitors by tags in New Relic One without needing a separate Rollup by dropdown. No changes will be required to use the new Synthetic monitor listing pages. The new experiences will be available to you after July 20, 2020. Documentation: Tagging in New Relic One replaces labels for Synthetics monitors. Explorer in New Relic One replaces Synthetics monitors index. Action items for a successful transition: If you currently use Synthetics rollups: Follow the procedures in the Explorer Hub post to recreate the rollups that are being retired. Go to the Explorers Hub post about the rollups EOL. In particular, look for How can New Relic Workloads help me visualize groups of applications and monitors? in the post's FAQs section. Follow the procedures in the Explorers Hub post to recreate the rollups that are being retired. Embedded charts In order to reduce redundancy and provide a more unified experience, the embedded charts functionality will be replaced by the New Relic One Get chart. Embedded charts currently in use and hosted outside the New Relic domain will continue to function. The changes will include: The name on the chart's menu that generates them will change from Embed to Get chart link. For charts that are no longer supported, Embed will be replaced with Get chart link is not supported for this chart. The APM UI page that lists all embedded chart links will no longer be available. Documentation: Explorers Hub post New Relic One's enhanced query builder functionality replaces the EOL embed chart functionality. Action items for a successful transition: You can generate a publicly accessible link to add to internal and external websites. Users do not need to be logged in to New Relic to see the chart link. The ability to embed a chart will remain, but instead of clicking Embed (which will be removed from the UI), you will click Get chart link (which is in the same location). This gives you the ability to get links with an even broader range of chart visuals and behaviors than the one we are retiring. Here's an example of how it looks in New Relic One: To replace existing chart links you created with Embed, create new URLs with New Relic One's Get chart link, and insert them in webpages where they're used. If you have an embedded chart and get the message Get chart link is not supported for this chart, simply run a different query, select an available chart type, and then select Embed. Legacy distributed tracing UI To standardize our user experience, we will be deprecating the older distributed tracing UI, which exists within the rpm.newrelic.com domain. You can access distributed tracing through New Relic One, which provides a superior experience with all the functionality supported in the duplicate UI that is end-of-life. Documentation: Global and service-specific distributed tracing views in New Relic One Deprecated distributed tracing UI Action items for a successful transition: No action required, but you can get ready for the new UI experience. New Relic One's distributed tracing page builds on capabilities you are already familiar with. Get acquainted with the enhanced distributed tracing features in New Relic One, including search and filter capabilities with cross-account trace details, query options with the NerdGraph API, and histogram charts (which can help you quickly understand trace distribution for important values such as duration). Review the trace sampling options available with head-based sampling (standard distributed tracing) and tail-based sampling (Infinite Tracing). Violations changes In order to provide a unified experience, we're deprecating browser, mobile, and synthetics monitor violations and replacing them with the New Relic One equivalent. New Relic One users can access violations by using any of these options: Click the Alerts and AI link in New Relic One's main UI. Review the entity list activity stream. See alert details from inside a specific entity via the new indicator for Operational, Warning, and Critical violations. You will see alert details automatically when navigating to one.newrelic.com. Documentation: Applied Intelligence and alerting in New Relic One Browser alert violations (moving to New Relic One) Mobile violations (moving to New Relic One) Monitor violations (moving to New Relic One) Action items for a successful transition: No action required, but you can get ready for the new UI experience. Here's an example of the detailed information about an Alerts violation for a selected entity in New Relic One. Violation details in New Relic One Comments Holistic view From New Relic One's homepage, the entity list presents an activity stream of all entities with alert violations. You no longer need to jump around individual lists of end-user, mobile, or monitor violations. Enhanced troubleshooting tools From New Relic One's homepage, you will also see an Alerts & AI (Applied Intelligence) link. From here you can solve problems faster with anomaly detection, incident correlation, and noise reduction. Specific violation From a selected entity, you will see a new button identifying the violation as Operational, Warning, or Critical, as well as entity metadata and useful details about the incident. Connected agents page Finding your connected agents has never been easier! You can already do this via the Query your data link in New Relic One. Simply run these NrDailyUsage queries to get a list of connected agents and hosts. The old Connected agents page is end-of-life and will be removed. Documentation: Explorers Hub post NRQL query tools NrDailyUsage data definition Action items for a successful transition: To query your connected apps and hosts, you can use existing NRQL query tools, such as New Relic One's query builder or the GraphQL API. Recommendation: For best results exploring comprehensive data about your apps and hosts, use query builder in New Relic One or the NerdGraph API. For best results with Insights, run separate queries for apps and hosts. Inactive apps in New Relic One Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI. However, key metrics will continue to be available via the New Relic REST API based on subscription level. This is why the application name will remain reserved until the application is permanently deleted via the REST API Explorer. Action items for a successful transition: If you want to reuse an app name for an old app that is no longer reporting data: Use the REST API v2 or API Explorer to get summary data, including app ID, name, health status (look for gray), last reported, etc. Uninstall the agent for your app. Use the REST API or API Explorer to delete the apps. Synthetic monitor alert notifications and conditions In order to provide a unified experience, we're deprecating Synthetics monitor alert notifications and condition violations. We are replacing these pages with a new Synthetics monitor overview experience in New Relic One. This new experience provides visibility into a monitor's open violations and alert conditions with the monitor results in a single view, removing the need to open multiple tabs to view violations or alert conditions. Action items for a successful transition: No action required, but you can get ready for the new UI experience by reviewing our documentation about New Relic Applied Intelligence, which includes: The alerting functionality you are already familiar with in New Relic Alerts, and more Incident Intelligence, which reduces noise and accelerates your incident resolution process Proactive Detection, which surfaces relevant issues and provides automatic explanations to their cause",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 273.79453,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> feature end of life announcements July 2020",
        "sections": "Inactive apps in <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that <em>use</em> v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in <em>New</em> <em>Relic</em> <em>One</em>. If you are already using"
      },
      "id": "603e795364441ff1924e8872"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/workloads/workload-status-configuration": [
    {
      "sections": [
        "What is an entity in New Relic?",
        "What is an entity?",
        "Find and explore entities",
        "Tip",
        "Entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services",
        "Group and organize entities"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-07-09T09:08:40Z",
      "updated_at": "2021-07-09T09:08:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of the entity. An entity is anything that reports data to New Relic. This document explains: What entities are How to find entity data How to modify existing entity types or create new ones How entities are related to one another How to organize them into groups for easier analysis What is an entity? From a New Relic product perspective, entity is a broad concept. An entity is anything we can identify that has data you can monitor. \"Entity\" can refer to fundamental data-reporting components like applications, hosts, and database services, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. This conceptual definition of \"entity\" is important because New Relic's goal is to give you practical information about the status of your business-important entities (and not just give you an unhelpfully large stream of assorted metrics and data). Our focus on entities, and the relationships between them, helps us optimize monitoring and troubleshooting of complex, modern systems. Find and explore entities You'll find your entities wherever you see your data reporting in New Relic. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's unique global identifier (GUID): from any list of monitored entities in the New Relic Explorer, hover over a specific entity and click the icon to see the GUID and other metadata. An entity's GUID is reported as the attribute entityGuid. You can query for an entity using this attribute in the query builder. Use the Related Entities view in the New Relic Explorer, service maps, distributed tracing, and our relationships API in GraphQL to see connections between entities. Explore entity data using our NerdGraph GraphiQL explorer (api.newrelic.com/graphiql). Entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic which matches your definition file will be synthesized into an entity. Tip For more information on how to modify existing entity types or create new ones please refer to our Entity Synthesis documentation. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you are aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relic’s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relic’s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relic’s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a single entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related Entities in the entity's mini overview. Related Entities is a visualization of the various entities connected directly to the current entity in focus. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip You can learn more about how entities are related using our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related Entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you don’t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are “dynamic” (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod that’s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: How to tag entities Create workloads (groups of related entities)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 289.92126,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate ingested telemetry with an entity already created by <em>New</em> <em>Relic</em>. When the entity.guid attribute is sent, the value"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "New Relic feature end of life announcements July 2020",
        "Old Kubernetes integration agent versions",
        "Monitor listing page and Synthetic labels",
        "\"Rollup by\" in Synthetics",
        "Embedded charts",
        "Legacy distributed tracing UI",
        "Violations changes",
        "Connected agents page",
        "Inactive apps in New Relic One",
        "Synthetic monitor alert notifications and conditions"
      ],
      "title": "New Relic feature end of life announcements July 2020",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "1db1d6b3df6d5ac3b983f78f3264cab332cff05a",
      "image": "https://docs.newrelic.com/static/f2b139d12bd8cdc13a9907b7874a4452/0a867/nrone-embed-bb062520.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-feature-end-life-announcements-july-2020/",
      "published_at": "2021-07-09T10:18:47Z",
      "updated_at": "2021-07-09T10:18:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to improve your New Relic experience we've made some big improvements to our platform. As a result, we'll be ending support for some old features over the next few weeks. Many have already been publicly announced as \"end-of-life.\" These changes represent our commitment to improve your interactions with our platform. Our mission is one observability platform that unites your telemetry data, connects your full stack, and helps you build more perfect software. To that end we're focusing on simplifying your experience for troubleshooting, alerting, and visualizing data. Here are more details on what's changed, with some helpful links and guides on how to take advantage of new capabilities to achieve the same goals. As always, we're here to help. Please connect with us in the Explorers Hub, or contact your account team with any questions. Old Kubernetes integration agent versions To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in New Relic One. If you are already using the latest Kubernetes agent version, no action is necessary. If you are using v1.7 or older, you must update your integration in order to continue viewing Kubernetes performance data. Follow the instructions in our documentation to upgrade to the latest version of the Kubernetes integration. Action items for a successful transition: Review the Kubernetes agent deprecation notice. Follow standard procedures to upgrade your Kubernetes agent to the latest version. Learn about the Kubernetes cluster explorer UI in New Relic One. For more information, see the Explorers Hub post. Monitor listing page and Synthetic labels To improve the experience of Synthetic monitors and labels, we've moved both experiences into the New Relic One platform. If you use the REST API for Synthetic label management, you must update to the tags API moving forward. The good news: with the NerdGraph tags API, you can organize and group all your entities in a single request. For more information about any of the following, see the Explorers Hub post. Action items for a successful transition: Synthetic monitors transition Comments Monitor index list When migration is completed, no action is needed on your part to use the new Synthetics entity listing pages. The new experience will be available to you automatically after July 20, 2020. For more information, learn how the explorer in New Relic One replaces the Synthetics monitors index. Existing Synthetics labels You may have already seen an option in the UI to migrate your Synthetics monitor labels to New Relic One tags. If you did not select that option, we've got you covered. Automatic migration from labels to tags starts begins July 8, 2020. For more information, learn how tagging in New Relic One replaces labels for Synthetics monitors. REST API If you use the REST API for Synthetics label management, follow these steps to update to the tags API: Learn more about NerdGraph. Review the NerdGraph tagging API tutorial. Make sure you have a Personal API key to use NerdGraph. Follow the procedures in the Explorers Hub post (look for the How do I transition my scripts from the Synthetics API to the tag API (NerdGraph)? section), and update your existing tags with the GraphiQL explorer at api.newrelic.com/graphiql. NerdGraph is our GraphQL API, a query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time. \"Rollup by\" in Synthetics Synthetics is moving to New Relic One to provide a single platform for observability of your complex software systems. To do this we are unifying the tools you use to tag (or label) your services, applications, and monitors. The specific feature that is end-of-life is the Rollup by feature under the Search monitors dropdown menu. You can group monitors by tags in New Relic One without needing a separate Rollup by dropdown. No changes will be required to use the new Synthetic monitor listing pages. The new experiences will be available to you after July 20, 2020. Documentation: Tagging in New Relic One replaces labels for Synthetics monitors. Explorer in New Relic One replaces Synthetics monitors index. Action items for a successful transition: If you currently use Synthetics rollups: Follow the procedures in the Explorer Hub post to recreate the rollups that are being retired. Go to the Explorers Hub post about the rollups EOL. In particular, look for How can New Relic Workloads help me visualize groups of applications and monitors? in the post's FAQs section. Follow the procedures in the Explorers Hub post to recreate the rollups that are being retired. Embedded charts In order to reduce redundancy and provide a more unified experience, the embedded charts functionality will be replaced by the New Relic One Get chart. Embedded charts currently in use and hosted outside the New Relic domain will continue to function. The changes will include: The name on the chart's menu that generates them will change from Embed to Get chart link. For charts that are no longer supported, Embed will be replaced with Get chart link is not supported for this chart. The APM UI page that lists all embedded chart links will no longer be available. Documentation: Explorers Hub post New Relic One's enhanced query builder functionality replaces the EOL embed chart functionality. Action items for a successful transition: You can generate a publicly accessible link to add to internal and external websites. Users do not need to be logged in to New Relic to see the chart link. The ability to embed a chart will remain, but instead of clicking Embed (which will be removed from the UI), you will click Get chart link (which is in the same location). This gives you the ability to get links with an even broader range of chart visuals and behaviors than the one we are retiring. Here's an example of how it looks in New Relic One: To replace existing chart links you created with Embed, create new URLs with New Relic One's Get chart link, and insert them in webpages where they're used. If you have an embedded chart and get the message Get chart link is not supported for this chart, simply run a different query, select an available chart type, and then select Embed. Legacy distributed tracing UI To standardize our user experience, we will be deprecating the older distributed tracing UI, which exists within the rpm.newrelic.com domain. You can access distributed tracing through New Relic One, which provides a superior experience with all the functionality supported in the duplicate UI that is end-of-life. Documentation: Global and service-specific distributed tracing views in New Relic One Deprecated distributed tracing UI Action items for a successful transition: No action required, but you can get ready for the new UI experience. New Relic One's distributed tracing page builds on capabilities you are already familiar with. Get acquainted with the enhanced distributed tracing features in New Relic One, including search and filter capabilities with cross-account trace details, query options with the NerdGraph API, and histogram charts (which can help you quickly understand trace distribution for important values such as duration). Review the trace sampling options available with head-based sampling (standard distributed tracing) and tail-based sampling (Infinite Tracing). Violations changes In order to provide a unified experience, we're deprecating browser, mobile, and synthetics monitor violations and replacing them with the New Relic One equivalent. New Relic One users can access violations by using any of these options: Click the Alerts and AI link in New Relic One's main UI. Review the entity list activity stream. See alert details from inside a specific entity via the new indicator for Operational, Warning, and Critical violations. You will see alert details automatically when navigating to one.newrelic.com. Documentation: Applied Intelligence and alerting in New Relic One Browser alert violations (moving to New Relic One) Mobile violations (moving to New Relic One) Monitor violations (moving to New Relic One) Action items for a successful transition: No action required, but you can get ready for the new UI experience. Here's an example of the detailed information about an Alerts violation for a selected entity in New Relic One. Violation details in New Relic One Comments Holistic view From New Relic One's homepage, the entity list presents an activity stream of all entities with alert violations. You no longer need to jump around individual lists of end-user, mobile, or monitor violations. Enhanced troubleshooting tools From New Relic One's homepage, you will also see an Alerts & AI (Applied Intelligence) link. From here you can solve problems faster with anomaly detection, incident correlation, and noise reduction. Specific violation From a selected entity, you will see a new button identifying the violation as Operational, Warning, or Critical, as well as entity metadata and useful details about the incident. Connected agents page Finding your connected agents has never been easier! You can already do this via the Query your data link in New Relic One. Simply run these NrDailyUsage queries to get a list of connected agents and hosts. The old Connected agents page is end-of-life and will be removed. Documentation: Explorers Hub post NRQL query tools NrDailyUsage data definition Action items for a successful transition: To query your connected apps and hosts, you can use existing NRQL query tools, such as New Relic One's query builder or the GraphQL API. Recommendation: For best results exploring comprehensive data about your apps and hosts, use query builder in New Relic One or the NerdGraph API. For best results with Insights, run separate queries for apps and hosts. Inactive apps in New Relic One Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI. However, key metrics will continue to be available via the New Relic REST API based on subscription level. This is why the application name will remain reserved until the application is permanently deleted via the REST API Explorer. Action items for a successful transition: If you want to reuse an app name for an old app that is no longer reporting data: Use the REST API v2 or API Explorer to get summary data, including app ID, name, health status (look for gray), last reported, etc. Uninstall the agent for your app. Use the REST API or API Explorer to delete the apps. Synthetic monitor alert notifications and conditions In order to provide a unified experience, we're deprecating Synthetics monitor alert notifications and condition violations. We are replacing these pages with a new Synthetics monitor overview experience in New Relic One. This new experience provides visibility into a monitor's open violations and alert conditions with the monitor results in a single view, removing the need to open multiple tabs to view violations or alert conditions. Action items for a successful transition: No action required, but you can get ready for the new UI experience by reviewing our documentation about New Relic Applied Intelligence, which includes: The alerting functionality you are already familiar with in New Relic Alerts, and more Incident Intelligence, which reduces noise and accelerates your incident resolution process Proactive Detection, which surfaces relevant issues and provides automatic explanations to their cause",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 273.79437,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> feature end of life announcements July 2020",
        "sections": "Inactive apps in <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that <em>use</em> v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in <em>New</em> <em>Relic</em> <em>One</em>. If you are already using"
      },
      "id": "603e795364441ff1924e8872"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-07-09T09:38:01Z",
      "updated_at": "2021-07-09T09:38:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires Pro or Enterprise edition. If you are on Standard edition, you can still use the New Relic Lookout view in the New Relic Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade to a higher edition. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE ‘2021-03-07 07:00-0500’ UNTIL ‘2021-03-08 07:00-0500’ COMPARE WITH 1 month ago Copy Or: SINCE ‘today at midnight’ UNTIL ‘now’ COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 247.44125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "sections": "<em>New</em> <em>Relic</em> Lookout: Monitor your estate at a glance",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in <em>New</em> <em>Relic</em> database (NRDB), including third-party, open, and custom data. Launch into other areas of <em>New</em> <em>Relic</em> <em>One</em> for deeper"
      },
      "id": "603e821e64441f5a444e8845"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/workloads/workload-status-views-notifications": [
    {
      "sections": [
        "Workload status configuration",
        "Configure the automatic workload status",
        "Important",
        "Create custom rules",
        "A rule for remaining entities",
        "Set a static workload status",
        "Tip",
        "Understand the status value"
      ],
      "title": "Workload status configuration",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "279b7200d747d5fca3b0021cd0647de4705f0926",
      "image": "https://docs.newrelic.com/static/877d101d0e1d86f4c0b9b96c58d72885/c1b63/new-relic-workload-status-main.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workload-status-configuration/",
      "published_at": "2021-07-09T08:52:05Z",
      "updated_at": "2021-07-09T08:52:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can obtain your workload status in two ways, automatic and static: Automatic status: it is calculated from a series of rules. Static status: it overrides any automatic calculation of your workload status. To create or edit the workload status, click the Status details and setup icon from the workload overview. Configure the automatic workload status Important You must have workload management permissions to carry out this configuration. You can use the status of each one of the entities that belong to a workload in order to summarize the workload status into a single value. Not all entities in a workload are equally important from a performance, errors, or availability perspective: You might want your workload to show as disrupted if an essential Synthetics monitor or service has got a critical violation going on. However, if your host infrastructure has a certain redundancy and resilience to outages, you might not need to change your workload status from Operational just because a single host has an alert violation going on. By default, when you create a workload the following rules to calculate its status are added: For entity types close to the digital experience (that is, synthetic monitors, browser applications, mobile applications, and services), the worst available status is propagated. For any other entity type, which are basically infrastructure entities, the best available status is propagated. Create custom rules To customize the automatic workload status, you can define your own rules. A rule consists of a group of entities and a roll up mode: Define the group of entities based on entity types, tag values, GUIDs, or a combination of all of them. Decide how to propagate the status of these entities to the group status: Roll up the best status: the group status matches the less critical status of all belonging entities. Use this option when you want the group status to be operational as long as at least one entity in the group is still operational. Roll up the worst status: the group status matches the most critical status of all belonging entities. Use this option when you want the group status to indicate a degradation or a disruption of service as soon as one entity in the group is not operational. You can also decide to roll up the worst status only after a certain amount of entities are not operational. Save the rule and proceed to create another one if you need to. The final workload status equals the worst status among all the individual group statuses. Important In this final calculation, any automatically calculated status is overridden if a static status has been set by a workload manager. A rule for remaining entities For an easier and more dynamic status configuration, you can use a roll-up type for all entities that aren’t evaluated in any other rule that you have defined before. In particular, if you don't add any other rule at all, the rule for remaining entities will take into account all the entities in the workload. When combined with the grouping by entity type option, this special rule allows you to get a general sense of how each entity type in your workload is doing, without having to configure a rule for each entity type. Therefore, we recommend that you always set a rule for all remaining entities grouped by type, and roll up their worst status to quickly detect when all entities in a layer of your workload stack are not operational. Set a static workload status If you want to communicate the status for your workload regardless of any automatic calculation based on rules, you can set a static status value for your workload from one of the available status values. This is useful during maintenance tasks to communicate to other teams that the status of your workload is disrupted, to provide further information, or to give the time you expect the workload to be operational again. Tip If you regularly need to communicate a temporary status due to your deployment or operations processes, you can automate the static status set up by integrating the API into your workflows. Important Any static status set by a workload manager always overrides any other status values calculated automatically. To set up a static workload status: Set a static status value. Optionally, write a short summary for the status, and a longer description of what’s happening to the workload. Check that the static status is enabled. Understand the status value The workload Overview shows the result of the workload status. If you click on the Status details and setup icon (or just Status details if you don’t have the workload manager role), you’ll see how the status calculation was configured, and the result of all the rules and/or static statuses that were taken into account to calculate the global workload status value. Any change that you make on the workload status configuration will become effective only once you save the changes. For your convenience, while you’re setting the automatic rules or a static status, you’ll get a preview of what the status result would be if you saved the configuration at that point.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.96472,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Workload</em> status configuration",
        "sections": "<em>Workload</em> status configuration",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " the <em>workload</em> overview. Configure the automatic <em>workload</em> status Important You must have <em>workload</em> management permissions to carry out this configuration. You can <em>use</em> the status of each <em>one</em> of the entities that belong to a <em>workload</em> in order to summarize the <em>workload</em> status into a single value. Not all"
      },
      "id": "603e8a25e7b9d268262a07c5"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What is an entity?",
        "Find and explore entities",
        "Tip",
        "Entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services",
        "Group and organize entities"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-07-09T09:08:40Z",
      "updated_at": "2021-07-09T09:08:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of the entity. An entity is anything that reports data to New Relic. This document explains: What entities are How to find entity data How to modify existing entity types or create new ones How entities are related to one another How to organize them into groups for easier analysis What is an entity? From a New Relic product perspective, entity is a broad concept. An entity is anything we can identify that has data you can monitor. \"Entity\" can refer to fundamental data-reporting components like applications, hosts, and database services, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. This conceptual definition of \"entity\" is important because New Relic's goal is to give you practical information about the status of your business-important entities (and not just give you an unhelpfully large stream of assorted metrics and data). Our focus on entities, and the relationships between them, helps us optimize monitoring and troubleshooting of complex, modern systems. Find and explore entities You'll find your entities wherever you see your data reporting in New Relic. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's unique global identifier (GUID): from any list of monitored entities in the New Relic Explorer, hover over a specific entity and click the icon to see the GUID and other metadata. An entity's GUID is reported as the attribute entityGuid. You can query for an entity using this attribute in the query builder. Use the Related Entities view in the New Relic Explorer, service maps, distributed tracing, and our relationships API in GraphQL to see connections between entities. Explore entity data using our NerdGraph GraphiQL explorer (api.newrelic.com/graphiql). Entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic which matches your definition file will be synthesized into an entity. Tip For more information on how to modify existing entity types or create new ones please refer to our Entity Synthesis documentation. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you are aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relic’s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relic’s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relic’s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a single entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related Entities in the entity's mini overview. Related Entities is a visualization of the various entities connected directly to the current entity in focus. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip You can learn more about how entities are related using our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related Entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you don’t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are “dynamic” (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod that’s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: How to tag entities Create workloads (groups of related entities)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 289.92126,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate ingested telemetry with an entity already created by <em>New</em> <em>Relic</em>. When the entity.guid attribute is sent, the value"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "New Relic feature end of life announcements July 2020",
        "Old Kubernetes integration agent versions",
        "Monitor listing page and Synthetic labels",
        "\"Rollup by\" in Synthetics",
        "Embedded charts",
        "Legacy distributed tracing UI",
        "Violations changes",
        "Connected agents page",
        "Inactive apps in New Relic One",
        "Synthetic monitor alert notifications and conditions"
      ],
      "title": "New Relic feature end of life announcements July 2020",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "1db1d6b3df6d5ac3b983f78f3264cab332cff05a",
      "image": "https://docs.newrelic.com/static/f2b139d12bd8cdc13a9907b7874a4452/0a867/nrone-embed-bb062520.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-feature-end-life-announcements-july-2020/",
      "published_at": "2021-07-09T10:18:47Z",
      "updated_at": "2021-07-09T10:18:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to improve your New Relic experience we've made some big improvements to our platform. As a result, we'll be ending support for some old features over the next few weeks. Many have already been publicly announced as \"end-of-life.\" These changes represent our commitment to improve your interactions with our platform. Our mission is one observability platform that unites your telemetry data, connects your full stack, and helps you build more perfect software. To that end we're focusing on simplifying your experience for troubleshooting, alerting, and visualizing data. Here are more details on what's changed, with some helpful links and guides on how to take advantage of new capabilities to achieve the same goals. As always, we're here to help. Please connect with us in the Explorers Hub, or contact your account team with any questions. Old Kubernetes integration agent versions To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in New Relic One. If you are already using the latest Kubernetes agent version, no action is necessary. If you are using v1.7 or older, you must update your integration in order to continue viewing Kubernetes performance data. Follow the instructions in our documentation to upgrade to the latest version of the Kubernetes integration. Action items for a successful transition: Review the Kubernetes agent deprecation notice. Follow standard procedures to upgrade your Kubernetes agent to the latest version. Learn about the Kubernetes cluster explorer UI in New Relic One. For more information, see the Explorers Hub post. Monitor listing page and Synthetic labels To improve the experience of Synthetic monitors and labels, we've moved both experiences into the New Relic One platform. If you use the REST API for Synthetic label management, you must update to the tags API moving forward. The good news: with the NerdGraph tags API, you can organize and group all your entities in a single request. For more information about any of the following, see the Explorers Hub post. Action items for a successful transition: Synthetic monitors transition Comments Monitor index list When migration is completed, no action is needed on your part to use the new Synthetics entity listing pages. The new experience will be available to you automatically after July 20, 2020. For more information, learn how the explorer in New Relic One replaces the Synthetics monitors index. Existing Synthetics labels You may have already seen an option in the UI to migrate your Synthetics monitor labels to New Relic One tags. If you did not select that option, we've got you covered. Automatic migration from labels to tags starts begins July 8, 2020. For more information, learn how tagging in New Relic One replaces labels for Synthetics monitors. REST API If you use the REST API for Synthetics label management, follow these steps to update to the tags API: Learn more about NerdGraph. Review the NerdGraph tagging API tutorial. Make sure you have a Personal API key to use NerdGraph. Follow the procedures in the Explorers Hub post (look for the How do I transition my scripts from the Synthetics API to the tag API (NerdGraph)? section), and update your existing tags with the GraphiQL explorer at api.newrelic.com/graphiql. NerdGraph is our GraphQL API, a query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time. \"Rollup by\" in Synthetics Synthetics is moving to New Relic One to provide a single platform for observability of your complex software systems. To do this we are unifying the tools you use to tag (or label) your services, applications, and monitors. The specific feature that is end-of-life is the Rollup by feature under the Search monitors dropdown menu. You can group monitors by tags in New Relic One without needing a separate Rollup by dropdown. No changes will be required to use the new Synthetic monitor listing pages. The new experiences will be available to you after July 20, 2020. Documentation: Tagging in New Relic One replaces labels for Synthetics monitors. Explorer in New Relic One replaces Synthetics monitors index. Action items for a successful transition: If you currently use Synthetics rollups: Follow the procedures in the Explorer Hub post to recreate the rollups that are being retired. Go to the Explorers Hub post about the rollups EOL. In particular, look for How can New Relic Workloads help me visualize groups of applications and monitors? in the post's FAQs section. Follow the procedures in the Explorers Hub post to recreate the rollups that are being retired. Embedded charts In order to reduce redundancy and provide a more unified experience, the embedded charts functionality will be replaced by the New Relic One Get chart. Embedded charts currently in use and hosted outside the New Relic domain will continue to function. The changes will include: The name on the chart's menu that generates them will change from Embed to Get chart link. For charts that are no longer supported, Embed will be replaced with Get chart link is not supported for this chart. The APM UI page that lists all embedded chart links will no longer be available. Documentation: Explorers Hub post New Relic One's enhanced query builder functionality replaces the EOL embed chart functionality. Action items for a successful transition: You can generate a publicly accessible link to add to internal and external websites. Users do not need to be logged in to New Relic to see the chart link. The ability to embed a chart will remain, but instead of clicking Embed (which will be removed from the UI), you will click Get chart link (which is in the same location). This gives you the ability to get links with an even broader range of chart visuals and behaviors than the one we are retiring. Here's an example of how it looks in New Relic One: To replace existing chart links you created with Embed, create new URLs with New Relic One's Get chart link, and insert them in webpages where they're used. If you have an embedded chart and get the message Get chart link is not supported for this chart, simply run a different query, select an available chart type, and then select Embed. Legacy distributed tracing UI To standardize our user experience, we will be deprecating the older distributed tracing UI, which exists within the rpm.newrelic.com domain. You can access distributed tracing through New Relic One, which provides a superior experience with all the functionality supported in the duplicate UI that is end-of-life. Documentation: Global and service-specific distributed tracing views in New Relic One Deprecated distributed tracing UI Action items for a successful transition: No action required, but you can get ready for the new UI experience. New Relic One's distributed tracing page builds on capabilities you are already familiar with. Get acquainted with the enhanced distributed tracing features in New Relic One, including search and filter capabilities with cross-account trace details, query options with the NerdGraph API, and histogram charts (which can help you quickly understand trace distribution for important values such as duration). Review the trace sampling options available with head-based sampling (standard distributed tracing) and tail-based sampling (Infinite Tracing). Violations changes In order to provide a unified experience, we're deprecating browser, mobile, and synthetics monitor violations and replacing them with the New Relic One equivalent. New Relic One users can access violations by using any of these options: Click the Alerts and AI link in New Relic One's main UI. Review the entity list activity stream. See alert details from inside a specific entity via the new indicator for Operational, Warning, and Critical violations. You will see alert details automatically when navigating to one.newrelic.com. Documentation: Applied Intelligence and alerting in New Relic One Browser alert violations (moving to New Relic One) Mobile violations (moving to New Relic One) Monitor violations (moving to New Relic One) Action items for a successful transition: No action required, but you can get ready for the new UI experience. Here's an example of the detailed information about an Alerts violation for a selected entity in New Relic One. Violation details in New Relic One Comments Holistic view From New Relic One's homepage, the entity list presents an activity stream of all entities with alert violations. You no longer need to jump around individual lists of end-user, mobile, or monitor violations. Enhanced troubleshooting tools From New Relic One's homepage, you will also see an Alerts & AI (Applied Intelligence) link. From here you can solve problems faster with anomaly detection, incident correlation, and noise reduction. Specific violation From a selected entity, you will see a new button identifying the violation as Operational, Warning, or Critical, as well as entity metadata and useful details about the incident. Connected agents page Finding your connected agents has never been easier! You can already do this via the Query your data link in New Relic One. Simply run these NrDailyUsage queries to get a list of connected agents and hosts. The old Connected agents page is end-of-life and will be removed. Documentation: Explorers Hub post NRQL query tools NrDailyUsage data definition Action items for a successful transition: To query your connected apps and hosts, you can use existing NRQL query tools, such as New Relic One's query builder or the GraphQL API. Recommendation: For best results exploring comprehensive data about your apps and hosts, use query builder in New Relic One or the NerdGraph API. For best results with Insights, run separate queries for apps and hosts. Inactive apps in New Relic One Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI. However, key metrics will continue to be available via the New Relic REST API based on subscription level. This is why the application name will remain reserved until the application is permanently deleted via the REST API Explorer. Action items for a successful transition: If you want to reuse an app name for an old app that is no longer reporting data: Use the REST API v2 or API Explorer to get summary data, including app ID, name, health status (look for gray), last reported, etc. Uninstall the agent for your app. Use the REST API or API Explorer to delete the apps. Synthetic monitor alert notifications and conditions In order to provide a unified experience, we're deprecating Synthetics monitor alert notifications and condition violations. We are replacing these pages with a new Synthetics monitor overview experience in New Relic One. This new experience provides visibility into a monitor's open violations and alert conditions with the monitor results in a single view, removing the need to open multiple tabs to view violations or alert conditions. Action items for a successful transition: No action required, but you can get ready for the new UI experience by reviewing our documentation about New Relic Applied Intelligence, which includes: The alerting functionality you are already familiar with in New Relic Alerts, and more Incident Intelligence, which reduces noise and accelerates your incident resolution process Proactive Detection, which surfaces relevant issues and provides automatic explanations to their cause",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 273.79437,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> feature end of life announcements July 2020",
        "sections": "Inactive apps in <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that <em>use</em> v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in <em>New</em> <em>Relic</em> <em>One</em>. If you are already using"
      },
      "id": "603e795364441ff1924e8872"
    }
  ],
  "/docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster": [
    {
      "sections": [
        "Workload status configuration",
        "Configure the automatic workload status",
        "Important",
        "Create custom rules",
        "A rule for remaining entities",
        "Set a static workload status",
        "Tip",
        "Understand the status value"
      ],
      "title": "Workload status configuration",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Workloads"
      ],
      "external_id": "279b7200d747d5fca3b0021cd0647de4705f0926",
      "image": "https://docs.newrelic.com/static/877d101d0e1d86f4c0b9b96c58d72885/c1b63/new-relic-workload-status-main.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/workloads/workload-status-configuration/",
      "published_at": "2021-07-09T08:52:05Z",
      "updated_at": "2021-07-09T08:52:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can obtain your workload status in two ways, automatic and static: Automatic status: it is calculated from a series of rules. Static status: it overrides any automatic calculation of your workload status. To create or edit the workload status, click the Status details and setup icon from the workload overview. Configure the automatic workload status Important You must have workload management permissions to carry out this configuration. You can use the status of each one of the entities that belong to a workload in order to summarize the workload status into a single value. Not all entities in a workload are equally important from a performance, errors, or availability perspective: You might want your workload to show as disrupted if an essential Synthetics monitor or service has got a critical violation going on. However, if your host infrastructure has a certain redundancy and resilience to outages, you might not need to change your workload status from Operational just because a single host has an alert violation going on. By default, when you create a workload the following rules to calculate its status are added: For entity types close to the digital experience (that is, synthetic monitors, browser applications, mobile applications, and services), the worst available status is propagated. For any other entity type, which are basically infrastructure entities, the best available status is propagated. Create custom rules To customize the automatic workload status, you can define your own rules. A rule consists of a group of entities and a roll up mode: Define the group of entities based on entity types, tag values, GUIDs, or a combination of all of them. Decide how to propagate the status of these entities to the group status: Roll up the best status: the group status matches the less critical status of all belonging entities. Use this option when you want the group status to be operational as long as at least one entity in the group is still operational. Roll up the worst status: the group status matches the most critical status of all belonging entities. Use this option when you want the group status to indicate a degradation or a disruption of service as soon as one entity in the group is not operational. You can also decide to roll up the worst status only after a certain amount of entities are not operational. Save the rule and proceed to create another one if you need to. The final workload status equals the worst status among all the individual group statuses. Important In this final calculation, any automatically calculated status is overridden if a static status has been set by a workload manager. A rule for remaining entities For an easier and more dynamic status configuration, you can use a roll-up type for all entities that aren’t evaluated in any other rule that you have defined before. In particular, if you don't add any other rule at all, the rule for remaining entities will take into account all the entities in the workload. When combined with the grouping by entity type option, this special rule allows you to get a general sense of how each entity type in your workload is doing, without having to configure a rule for each entity type. Therefore, we recommend that you always set a rule for all remaining entities grouped by type, and roll up their worst status to quickly detect when all entities in a layer of your workload stack are not operational. Set a static workload status If you want to communicate the status for your workload regardless of any automatic calculation based on rules, you can set a static status value for your workload from one of the available status values. This is useful during maintenance tasks to communicate to other teams that the status of your workload is disrupted, to provide further information, or to give the time you expect the workload to be operational again. Tip If you regularly need to communicate a temporary status due to your deployment or operations processes, you can automate the static status set up by integrating the API into your workflows. Important Any static status set by a workload manager always overrides any other status values calculated automatically. To set up a static workload status: Set a static status value. Optionally, write a short summary for the status, and a longer description of what’s happening to the workload. Check that the static status is enabled. Understand the status value The workload Overview shows the result of the workload status. If you click on the Status details and setup icon (or just Status details if you don’t have the workload manager role), you’ll see how the status calculation was configured, and the result of all the rules and/or static statuses that were taken into account to calculate the global workload status value. Any change that you make on the workload status configuration will become effective only once you save the changes. For your convenience, while you’re setting the automatic rules or a static status, you’ll get a preview of what the status result would be if you saved the configuration at that point.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.9645,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Workload</em> status configuration",
        "sections": "<em>Workload</em> status configuration",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " the <em>workload</em> overview. Configure the automatic <em>workload</em> status Important You must have <em>workload</em> management permissions to carry out this configuration. You can <em>use</em> the status of each <em>one</em> of the entities that belong to a <em>workload</em> in order to summarize the <em>workload</em> status into a single value. Not all"
      },
      "id": "603e8a25e7b9d268262a07c5"
    },
    {
      "sections": [
        "What is an entity in New Relic?",
        "What is an entity?",
        "Find and explore entities",
        "Tip",
        "Entity synthesis",
        "Reserved attributes for synthesized entities",
        "Entity relationships",
        "Important",
        "Which relationships are created?",
        "Source: New Relic agent",
        "Source: Infrastructure",
        "Source: Synthetics monitor",
        "Source: Kubernetes",
        "External services",
        "Group and organize entities"
      ],
      "title": "What is an entity in New Relic?",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "52a3e08bc9103c717d27b153e4fd4f547d6ecc32",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/what-entity-new-relic/",
      "published_at": "2021-07-09T09:08:40Z",
      "updated_at": "2021-07-09T09:08:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic monitoring is built around the concept of the entity. An entity is anything that reports data to New Relic. This document explains: What entities are How to find entity data How to modify existing entity types or create new ones How entities are related to one another How to organize them into groups for easier analysis What is an entity? From a New Relic product perspective, entity is a broad concept. An entity is anything we can identify that has data you can monitor. \"Entity\" can refer to fundamental data-reporting components like applications, hosts, and database services, but it can also refer to larger groupings of those components. For example, to monitor a data center, you could aggregate those hosts in New Relic to be a workload (a custom grouping of entities). That workload is, itself, also an entity. This conceptual definition of \"entity\" is important because New Relic's goal is to give you practical information about the status of your business-important entities (and not just give you an unhelpfully large stream of assorted metrics and data). Our focus on entities, and the relationships between them, helps us optimize monitoring and troubleshooting of complex, modern systems. Find and explore entities You'll find your entities wherever you see your data reporting in New Relic. Tip You can create new entity types to monitor any data source. Learn more about entity synthesis. Some tips for finding and understanding entity data: To find an entity's unique global identifier (GUID): from any list of monitored entities in the New Relic Explorer, hover over a specific entity and click the icon to see the GUID and other metadata. An entity's GUID is reported as the attribute entityGuid. You can query for an entity using this attribute in the query builder. Use the Related Entities view in the New Relic Explorer, service maps, distributed tracing, and our relationships API in GraphQL to see connections between entities. Explore entity data using our NerdGraph GraphiQL explorer (api.newrelic.com/graphiql). Entity synthesis If you have telemetry from any source that's not supported by New Relic out of the box, you can propose a mapping for it. Once approved, any telemetry received by New Relic which matches your definition file will be synthesized into an entity. Tip For more information on how to modify existing entity types or create new ones please refer to our Entity Synthesis documentation. Reserved attributes for synthesized entities These attributes are meant to be synthesized from the telemetry we receive. Do not set them unless you are aware of the implications and consequences. Attribute Description entity.guid Generally, you should not set this attribute field on your telemetry data. New Relic may add this field to ingested data to store a unique identifier for the entity associated with the data point. If telemetry arrives with the entity.guid attribute already present, then New Relic will not change the value. However, it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. One use case for passing this attribute is to associate ingested telemetry with an entity already created by New Relic. When the entity.guid attribute is sent, the value will override New Relic’s entity identification system (such as entity synthesis definitions) and instead will use the attribute as the data. entity.name This attribute shouldn't be put on ingested telemetry data unless you're trying to override the entity name that would have been selected by New Relic’s entity identification system. While New Relic won't change the value if it's already present on the data, New Relic may add the attribute to your data. Therefore invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. If this field is present on ingested telemetry, its value will be used to name the entity associated with the data point. This name will be used instead of the name selected by New Relic’s entity identification system (for example, entity synthesis definitions). Note that many entities use the name as part of their identification, so changing this field may result in the generation of a new entity. entity.type This attribute shouldn't be put on ingested telemetry data except for certain legacy cases where it's required to distinguish entity types. Passing this field may interfere with entity detection, particularly if unrecognized values are sent in this field. While New Relic won't change the value if already present on the data, the field is not guaranteed to provide unambiguous filtering of telemetry at query-time. Existing entity definitions already have overlapping values, and we recommend avoiding entity.type in favor of other fields for filtering telemetry queries. This field is used by New Relic, meaning that invalid or unexpected values may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. Entity relationships Connections between entities are automatically created by New Relic based on what we can infer from your telemetry. For example, when two services that communicate using HTTP are instrumented with New Relic, we infer a \"calls/called-by\" relationship between them. When viewing a single entity in either the New Relic Explorer, Navigator, or Lookout, you can see its Related Entities in the entity's mini overview. Related Entities is a visualization of the various entities connected directly to the current entity in focus. You can quickly view important metrics for these related entities and navigate from one entity to another, through all the connected parts of your stack. Tip You can learn more about how entities are related using our NerdGraph API. When relationships are not automatically detected, you can manually create them using the \"Add/edit related entities\" link in Related Entities. Important Currently, you can only manually create calls/called-by relationships between service entities. Tip To manage manual relationships, you need to have modify and delete capabilities on entity relationships. If you don’t see the edit relationships button, contact your account admin. Which relationships are created? These are the relationships created between entities: Source: New Relic agent Relationship source Relationship type Relationship target Why is the relationship created? Application instrumented with a New Relic agent CALLS Application instrumented with a New Relic agent Relationships between applications monitored by New Relic agents are reported using the DurationByCaller metric. The callee reports the metric. For example, the metric DurationByCaller/Mobile/100/1234/HTTP/all indicates that the caller is APPLICATION 1234 for account 100. Application instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent An application (caller) that calls a service (callee) monitored by New Relic creates a relationship that's reported by the caller using the ExternalApp metric. For example, the metric ExternalApp/dirac.vips.net/100#1234/all indicates that the callee is APPLICATION 1234 for account 100. The metric is reported if the callee successfully responds to the caller. Service instrumented with a New Relic agent CALLS Service instrumented with a New Relic agent When a New Relic agent detects that a service (caller) calls another service (callee) instrumented by New Relic, the callee reports the metric ClientApplication. For example, the metric ClientApplication/100#1234/all indicates that the caller is APPLICATION 1234 for account 100. Service instrumented with a New Relic agent CALLS A datastore instance When an application calls a datastore instance it creates a relationship reported with the DatastoreInstance metric. For example, the metric Datastore/instance/MySQL/172.16.16.3/3306 indicates the datastore instance is vendor: MySQL, host: 172.16.16.3, port: 3306. This metric also supports the legacy datastore instance format Datastore/instance/MySQL/172.16.16.3:3306. Currently we cannot determine whether the datastore instance is instrumented by New Relic and has an entity associated to it. APM agent SERVES Browser agent This relationship is created when an APM agent injects the browser agent into a page. Workload entity CONTAINS Any entity When a workload is created or updated, relationships for each of the entities that belong to the workload are created. Because some workloads are “dynamic” (defined by tags), relationships are re-created every 5 minutes. This way entities can join or leave the workload. Source: Infrastructure Relationship source Relationship type Relationship target Why is the relationship created? Infrastructure host HOSTS Application This relationship is created when an application is running in one or more hosts, and the infra agent is running in those hosts. Infrastructure host HOSTS Container This relationship is created when containers are running in one or more hosts, and the host is instrumented with the infra agent. Source: Synthetics monitor Relationship source Relationship type Relationship target Why is the relationship created? Synthetics Monitor CALLS Browser agent This relationship is created when a synthetics monitor checks a page instrumented with the browser agent. Synthetics Monitor CALLS APM application Agent events that contain the attribute nr.syntheticsMonitorId have been described as synthetics monitors (the source) interacting with an APM application (the target). If the header exists and the APM application Id exists, a relationship is created between the monitor and the app. Source: Kubernetes Relationship source Relationship type Relationship target Why is the relationship created? Cluster CONTAINS Pod This relationship is created when a pod is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Deployment This relationship is created when a deployment is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS DaemonSet This relationship is created when a DaemonSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS StatefulSet This relationship is created when a StatefulSet is created in a cluster instrumented with the New Relic Kubernetes integration. Cluster CONTAINS Host This relationship is created when a host that's part of a cluster is instrumented with the New Relic Kubernetes integration. Deployment CONTAINS Pod This relationship is created when a deployment creates a pod in a cluster instrumented with the New Relic Kubernetes integration. DaemonSet CONTAINS Pod This relationship is created when a DaemonSet is created a pod in a cluster instrumented with the New Relic Kubernetes integration. StatefulSet CONTAINS Pod This relationship is created when a StatefulSet creates a pod in a cluster instrumented with the New Relic Kubernetes integration. Pod CONTAINS Container This relationship is created when a pod creates a container in a cluster instrumented with the New Relic Kubernetes integration. Host HOSTS Pod This relationship is created when a pod is running in a host that's part of a cluster instrumented with the New Relic Kubernetes integration. Container HOSTS Application This relationship is created when an application is running in docker, and the hosts where docker is running are instrumented by the the infra agent. External services Relationship source Relationship type Relationship target Why is the relationship created? External service CALLS External service When the relationship is created, the external service reports a span with its name on the service.name attribute and the name of the service that initiates the call in the parent.service.name attribute. Application IS External service A relationship between an application and an external service is created so that users can navigate between them using the related entities component. Browser application instrumented with a New Relic agent CALLS External service A browser application reports an Ajax/HostTransaction metric when calling an external service (URL). Example metric: Ajax/HostTransaction/api.segment.io:443/CallbackTime' Cluster CONTAINS External service When the relationship is created, the external service reports a span with the attribute k8s.cluster.name, the name of the cluster. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Pod HOSTS External service When the relationship is created, the external service reports a span with the following attributes: service.name: The name of the service. k8s.cluster.name: The name of the cluster. k8s.pod.name: The name of the pod that’s running the service. k8s.namespace.name: The namespace where the pod was created. The cluster must be instrumented with the New Relic Kubernetes integration and the cluster name set for the integration must match the one reported in the span. Group and organize entities You can place entities into groups that reflect business-important relationships in your organization. For example, you might group all entities related to a specific team or department, or related to a specific service. Or you might group multiple hosts together to reflect their grouping in a data center. To group your entities, see: How to tag entities Create workloads (groups of related entities)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 289.92108,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "What is an entity in <em>New</em> <em>Relic</em>?",
        "sections": "What is an entity in <em>New</em> <em>Relic</em>?",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": ", it may cause undefined behavior such as missing entities in the UI, or telemetry not associating with the expected entities. <em>One</em> <em>use</em> case for passing this attribute is to associate ingested telemetry with an entity already created by <em>New</em> <em>Relic</em>. When the entity.guid attribute is sent, the value"
      },
      "id": "603ec160e7b9d295f72a07fc"
    },
    {
      "sections": [
        "New Relic feature end of life announcements July 2020",
        "Old Kubernetes integration agent versions",
        "Monitor listing page and Synthetic labels",
        "\"Rollup by\" in Synthetics",
        "Embedded charts",
        "Legacy distributed tracing UI",
        "Violations changes",
        "Connected agents page",
        "Inactive apps in New Relic One",
        "Synthetic monitor alert notifications and conditions"
      ],
      "title": "New Relic feature end of life announcements July 2020",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "1db1d6b3df6d5ac3b983f78f3264cab332cff05a",
      "image": "https://docs.newrelic.com/static/f2b139d12bd8cdc13a9907b7874a4452/0a867/nrone-embed-bb062520.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/new-relic-feature-end-life-announcements-july-2020/",
      "published_at": "2021-07-09T10:18:47Z",
      "updated_at": "2021-07-09T10:18:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to improve your New Relic experience we've made some big improvements to our platform. As a result, we'll be ending support for some old features over the next few weeks. Many have already been publicly announced as \"end-of-life.\" These changes represent our commitment to improve your interactions with our platform. Our mission is one observability platform that unites your telemetry data, connects your full stack, and helps you build more perfect software. To that end we're focusing on simplifying your experience for troubleshooting, alerting, and visualizing data. Here are more details on what's changed, with some helpful links and guides on how to take advantage of new capabilities to achieve the same goals. As always, we're here to help. Please connect with us in the Explorers Hub, or contact your account team with any questions. Old Kubernetes integration agent versions To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that use v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in New Relic One. If you are already using the latest Kubernetes agent version, no action is necessary. If you are using v1.7 or older, you must update your integration in order to continue viewing Kubernetes performance data. Follow the instructions in our documentation to upgrade to the latest version of the Kubernetes integration. Action items for a successful transition: Review the Kubernetes agent deprecation notice. Follow standard procedures to upgrade your Kubernetes agent to the latest version. Learn about the Kubernetes cluster explorer UI in New Relic One. For more information, see the Explorers Hub post. Monitor listing page and Synthetic labels To improve the experience of Synthetic monitors and labels, we've moved both experiences into the New Relic One platform. If you use the REST API for Synthetic label management, you must update to the tags API moving forward. The good news: with the NerdGraph tags API, you can organize and group all your entities in a single request. For more information about any of the following, see the Explorers Hub post. Action items for a successful transition: Synthetic monitors transition Comments Monitor index list When migration is completed, no action is needed on your part to use the new Synthetics entity listing pages. The new experience will be available to you automatically after July 20, 2020. For more information, learn how the explorer in New Relic One replaces the Synthetics monitors index. Existing Synthetics labels You may have already seen an option in the UI to migrate your Synthetics monitor labels to New Relic One tags. If you did not select that option, we've got you covered. Automatic migration from labels to tags starts begins July 8, 2020. For more information, learn how tagging in New Relic One replaces labels for Synthetics monitors. REST API If you use the REST API for Synthetics label management, follow these steps to update to the tags API: Learn more about NerdGraph. Review the NerdGraph tagging API tutorial. Make sure you have a Personal API key to use NerdGraph. Follow the procedures in the Explorers Hub post (look for the How do I transition my scripts from the Synthetics API to the tag API (NerdGraph)? section), and update your existing tags with the GraphiQL explorer at api.newrelic.com/graphiql. NerdGraph is our GraphQL API, a query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time. \"Rollup by\" in Synthetics Synthetics is moving to New Relic One to provide a single platform for observability of your complex software systems. To do this we are unifying the tools you use to tag (or label) your services, applications, and monitors. The specific feature that is end-of-life is the Rollup by feature under the Search monitors dropdown menu. You can group monitors by tags in New Relic One without needing a separate Rollup by dropdown. No changes will be required to use the new Synthetic monitor listing pages. The new experiences will be available to you after July 20, 2020. Documentation: Tagging in New Relic One replaces labels for Synthetics monitors. Explorer in New Relic One replaces Synthetics monitors index. Action items for a successful transition: If you currently use Synthetics rollups: Follow the procedures in the Explorer Hub post to recreate the rollups that are being retired. Go to the Explorers Hub post about the rollups EOL. In particular, look for How can New Relic Workloads help me visualize groups of applications and monitors? in the post's FAQs section. Follow the procedures in the Explorers Hub post to recreate the rollups that are being retired. Embedded charts In order to reduce redundancy and provide a more unified experience, the embedded charts functionality will be replaced by the New Relic One Get chart. Embedded charts currently in use and hosted outside the New Relic domain will continue to function. The changes will include: The name on the chart's menu that generates them will change from Embed to Get chart link. For charts that are no longer supported, Embed will be replaced with Get chart link is not supported for this chart. The APM UI page that lists all embedded chart links will no longer be available. Documentation: Explorers Hub post New Relic One's enhanced query builder functionality replaces the EOL embed chart functionality. Action items for a successful transition: You can generate a publicly accessible link to add to internal and external websites. Users do not need to be logged in to New Relic to see the chart link. The ability to embed a chart will remain, but instead of clicking Embed (which will be removed from the UI), you will click Get chart link (which is in the same location). This gives you the ability to get links with an even broader range of chart visuals and behaviors than the one we are retiring. Here's an example of how it looks in New Relic One: To replace existing chart links you created with Embed, create new URLs with New Relic One's Get chart link, and insert them in webpages where they're used. If you have an embedded chart and get the message Get chart link is not supported for this chart, simply run a different query, select an available chart type, and then select Embed. Legacy distributed tracing UI To standardize our user experience, we will be deprecating the older distributed tracing UI, which exists within the rpm.newrelic.com domain. You can access distributed tracing through New Relic One, which provides a superior experience with all the functionality supported in the duplicate UI that is end-of-life. Documentation: Global and service-specific distributed tracing views in New Relic One Deprecated distributed tracing UI Action items for a successful transition: No action required, but you can get ready for the new UI experience. New Relic One's distributed tracing page builds on capabilities you are already familiar with. Get acquainted with the enhanced distributed tracing features in New Relic One, including search and filter capabilities with cross-account trace details, query options with the NerdGraph API, and histogram charts (which can help you quickly understand trace distribution for important values such as duration). Review the trace sampling options available with head-based sampling (standard distributed tracing) and tail-based sampling (Infinite Tracing). Violations changes In order to provide a unified experience, we're deprecating browser, mobile, and synthetics monitor violations and replacing them with the New Relic One equivalent. New Relic One users can access violations by using any of these options: Click the Alerts and AI link in New Relic One's main UI. Review the entity list activity stream. See alert details from inside a specific entity via the new indicator for Operational, Warning, and Critical violations. You will see alert details automatically when navigating to one.newrelic.com. Documentation: Applied Intelligence and alerting in New Relic One Browser alert violations (moving to New Relic One) Mobile violations (moving to New Relic One) Monitor violations (moving to New Relic One) Action items for a successful transition: No action required, but you can get ready for the new UI experience. Here's an example of the detailed information about an Alerts violation for a selected entity in New Relic One. Violation details in New Relic One Comments Holistic view From New Relic One's homepage, the entity list presents an activity stream of all entities with alert violations. You no longer need to jump around individual lists of end-user, mobile, or monitor violations. Enhanced troubleshooting tools From New Relic One's homepage, you will also see an Alerts & AI (Applied Intelligence) link. From here you can solve problems faster with anomaly detection, incident correlation, and noise reduction. Specific violation From a selected entity, you will see a new button identifying the violation as Operational, Warning, or Critical, as well as entity metadata and useful details about the incident. Connected agents page Finding your connected agents has never been easier! You can already do this via the Query your data link in New Relic One. Simply run these NrDailyUsage queries to get a list of connected agents and hosts. The old Connected agents page is end-of-life and will be removed. Documentation: Explorers Hub post NRQL query tools NrDailyUsage data definition Action items for a successful transition: To query your connected apps and hosts, you can use existing NRQL query tools, such as New Relic One's query builder or the GraphQL API. Recommendation: For best results exploring comprehensive data about your apps and hosts, use query builder in New Relic One or the NerdGraph API. For best results with Insights, run separate queries for apps and hosts. Inactive apps in New Relic One Starting June 8, 2020, New Relic One will not continue to display any APM application that hasn't reported data for 93 days. To match our published APM data retention guidelines, applications that have not reported data will be available within the New Relic UI for 90 days. After 90 days, those applications will be removed from the UI. However, key metrics will continue to be available via the New Relic REST API based on subscription level. This is why the application name will remain reserved until the application is permanently deleted via the REST API Explorer. Action items for a successful transition: If you want to reuse an app name for an old app that is no longer reporting data: Use the REST API v2 or API Explorer to get summary data, including app ID, name, health status (look for gray), last reported, etc. Uninstall the agent for your app. Use the REST API or API Explorer to delete the apps. Synthetic monitor alert notifications and conditions In order to provide a unified experience, we're deprecating Synthetics monitor alert notifications and condition violations. We are replacing these pages with a new Synthetics monitor overview experience in New Relic One. This new experience provides visibility into a monitor's open violations and alert conditions with the monitor results in a single view, removing the need to open multiple tabs to view violations or alert conditions. Action items for a successful transition: No action required, but you can get ready for the new UI experience by reviewing our documentation about New Relic Applied Intelligence, which includes: The alerting functionality you are already familiar with in New Relic Alerts, and more Incident Intelligence, which reduces noise and accelerates your incident resolution process Proactive Detection, which surfaces relevant issues and provides automatic explanations to their cause",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 273.7942,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> feature end of life announcements July 2020",
        "sections": "Inactive apps in <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " To improve our unified experience, starting from Wednesday, August 12, 2020, Kubernetes integrations that <em>use</em> v1.7 or older will be deprecated. The UI experience in the infrastructure.newrelic.com domain will no longer be available; it will only be available in <em>New</em> <em>Relic</em> <em>One</em>. If you are already using"
      },
      "id": "603e795364441ff1924e8872"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/appendix/version-history": [
    {
      "sections": [
        "Partnership admin console",
        "Console components",
        "Partnership configuration settings",
        "Customer activity monitoring",
        "State-of-the-Partnership report",
        "Partner customer monitoring",
        "View an arbitrary customer",
        "Viewing detailed customer data"
      ],
      "title": "Partnership admin console",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "670e4d2e1db957100b23a7b8b0af6bf50cc8c996",
      "image": "https://docs.newrelic.com/static/43369c88523ebf526ae58fa5719d4efe/0abdd/crop-partnership-owner-account-settings.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console/",
      "published_at": "2021-07-09T08:56:36Z",
      "updated_at": "2021-07-02T15:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Partnership Admin Console is the interface for managing your customers' accounts and integration with New Relic. To access the console, sign into the partnership owner account, and go to: https://partner-admin-console.newrelic.com/accounts/ACCOUNT_ID/admin_console/ Copy You can also access the console from the New Relic UI: Go to one.newrelic.com > (account dropdown) > Account settings. From the left menu bar, select Partnerships. one.newrelic.com > (account dropdown) > Account settings > Partnerships: Partnership owners can access the Partnership Admin Console from their account settings in the New Relic UI. Console components The Partnership Admin Console has two main components: Partnership configuration settings Customer activity monitoring If multiple partnerships are associated with the New Relic parent account, the menu also includes an option to switch partnership accounts. Partnership configuration settings In developing your integration with New Relic, you must specify a number of settings. For your convenience these settings are grouped together in the partnership console, including URLs for header/footer and various redirects, SSO configuration, and keys and the ability to manipulate them. Customer activity monitoring New Relic provides you with two tools for managing your customers: State-of-the-Partnership reports and live monitoring of all deployed New Relic agents in your partnership. Both of these tools provide insight into your customers who are using New Relic. They can be used to identify up-sale opportunities or to assist your support group in proactive support. State-of-the-Partnership report The State-of-the-Partnership report provides a summary of your customers with New Relic accounts and their activities. The report is broken down by language of the agents deployed, the agent version and the language version for each account. This report is run weekly for each partner. It is available on request from your New Relic Business Development contact. This report is an excellent way to see which of your customers with New Relic accounts are in fact using the service. Partner customer monitoring The Partner customer monitoring facility provides application performance data on the New Relic enabled applications that are running on your service. This facility allows you to easily identify customers experiencing performance problems. Where the performance problems are caused by under capacity, these customers are excellent sales opportunities. Alternatively your support or services organization will find this information useful in pre-emptively identifying customer issues or as good prospects for consulting services. View an arbitrary customer To view activity of a customer that does not appear in any of the filtered views: Go to one.newrelic.com > (account dropdown) > Switch accounts > Other accounts. New Relic will list all of the reporting accounts in the partnership. You can filter or search the list. Viewing detailed customer data Under normal circumstances a partner will be able to see only the summary level data in a customer's New Relic account. Through the Partnership Admin Console, partners will be permitted to drill down to the more detailed presentation. If you want to drill down from the Partnership Admin Console, add your user (typically support@partner.com or something similar) to the account. Typically this will be done at account creation. Avoid provisioning this user as the account Owner.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.37416,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> admin console",
        "sections": "<em>Partnership</em> admin console",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "The <em>Partnership</em> Admin Console is the interface for managing your customers&#x27; accounts and <em>integration</em> with <em>New</em> <em>Relic</em>. To access the console, sign into the <em>partnership</em> owner account, and go to: https:&#x2F;&#x2F;<em>partner</em>-admin-console.newrelic.com&#x2F;accounts&#x2F;ACCOUNT_ID&#x2F;admin_console&#x2F; Copy You can also access"
      },
      "id": "603ed3e3196a6735baa83dad"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.18504,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " these customers &quot;customer <em>partnerships</em>.&quot; Use of our <em>partnership</em> account structure requires prior approval and set up by <em>New</em> <em>Relic</em> representatives. For customer <em>partnerships</em>, <em>New</em> <em>Relic</em> contacts organizations that would benefit from such a structure. <em>Partnerships</em> are identified by a numeric <em>PARTNER</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Support resources for New Relic partners",
        "Tip",
        "New Relic Support",
        "Documentation",
        "Agent documentation",
        "Agent release notes",
        "Online Technical Community"
      ],
      "title": "Support resources for New Relic partners",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "56246fb8462659d929766125f8afbbc429f42ee5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/support-resources-new-relic-partners/",
      "published_at": "2021-07-09T09:33:10Z",
      "updated_at": "2021-05-16T01:08:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for New Relic partners. After you complete your partnership integration, you will be introduced to your technical contacts at New Relic. Use these channels for non-urgent escalations. Tip If you are not a New Relic partner, see New Relic's resources for finding help or filing a support ticket. New Relic Support To obtain support for partner accounts, create a ticket at support.newrelic.com. If you need to call New Relic directly, contact your Business Development representative. Documentation Documentation from New Relic's Docs site is an important resource for your support group when providing Level 1 support to your New Relic subscribers. Posting these links on your support pages is an effective way to encourage self help and reduce your support efforts. Top level entry point for New Relic documentation: docs.newrelic.com. From here you can select information about New Relic products and features by category. Tip The Docs site includes a Partnerships category with information for New Relic partners and some partnership customers. Here are the five most commonly consulted articles on the New Relic Docs site. Providing easily found and direct links to these articles can provide many users with self-serve answers to their questions. Create your New Relic account Name your application Configure the agent Not seeing data Apdex: Measuring user satisfaction Agent documentation Here are links to New Relic documentation categories organized by APM agent languages: Go Java .NET Node.js PHP Python Ruby Agent release notes Here are links to New Relic release notes organized by agent languages: Go Java .NET Node.js PHP Python Ruby Online Technical Community The New Relic Explorers Hub brings together the expertise of New Relic employees, our Partners, and our community regarding all things New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.37445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "sections": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "This document is for <em>New</em> <em>Relic</em> partners. After you complete your <em>partnership</em> <em>integration</em>, you will be introduced to your technical contacts at <em>New</em> <em>Relic</em>. Use these channels for non-urgent escalations. Tip If you are not a <em>New</em> <em>Relic</em> <em>partner</em>, see <em>New</em> <em>Relic</em>&#x27;s resources for finding help or filing"
      },
      "id": "60450ecf28ccbc45632c6095"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/getting-started/co-branding-new-relic-partners": [
    {
      "sections": [
        "Partnership admin console",
        "Console components",
        "Partnership configuration settings",
        "Customer activity monitoring",
        "State-of-the-Partnership report",
        "Partner customer monitoring",
        "View an arbitrary customer",
        "Viewing detailed customer data"
      ],
      "title": "Partnership admin console",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "670e4d2e1db957100b23a7b8b0af6bf50cc8c996",
      "image": "https://docs.newrelic.com/static/43369c88523ebf526ae58fa5719d4efe/0abdd/crop-partnership-owner-account-settings.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console/",
      "published_at": "2021-07-09T08:56:36Z",
      "updated_at": "2021-07-02T15:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Partnership Admin Console is the interface for managing your customers' accounts and integration with New Relic. To access the console, sign into the partnership owner account, and go to: https://partner-admin-console.newrelic.com/accounts/ACCOUNT_ID/admin_console/ Copy You can also access the console from the New Relic UI: Go to one.newrelic.com > (account dropdown) > Account settings. From the left menu bar, select Partnerships. one.newrelic.com > (account dropdown) > Account settings > Partnerships: Partnership owners can access the Partnership Admin Console from their account settings in the New Relic UI. Console components The Partnership Admin Console has two main components: Partnership configuration settings Customer activity monitoring If multiple partnerships are associated with the New Relic parent account, the menu also includes an option to switch partnership accounts. Partnership configuration settings In developing your integration with New Relic, you must specify a number of settings. For your convenience these settings are grouped together in the partnership console, including URLs for header/footer and various redirects, SSO configuration, and keys and the ability to manipulate them. Customer activity monitoring New Relic provides you with two tools for managing your customers: State-of-the-Partnership reports and live monitoring of all deployed New Relic agents in your partnership. Both of these tools provide insight into your customers who are using New Relic. They can be used to identify up-sale opportunities or to assist your support group in proactive support. State-of-the-Partnership report The State-of-the-Partnership report provides a summary of your customers with New Relic accounts and their activities. The report is broken down by language of the agents deployed, the agent version and the language version for each account. This report is run weekly for each partner. It is available on request from your New Relic Business Development contact. This report is an excellent way to see which of your customers with New Relic accounts are in fact using the service. Partner customer monitoring The Partner customer monitoring facility provides application performance data on the New Relic enabled applications that are running on your service. This facility allows you to easily identify customers experiencing performance problems. Where the performance problems are caused by under capacity, these customers are excellent sales opportunities. Alternatively your support or services organization will find this information useful in pre-emptively identifying customer issues or as good prospects for consulting services. View an arbitrary customer To view activity of a customer that does not appear in any of the filtered views: Go to one.newrelic.com > (account dropdown) > Switch accounts > Other accounts. New Relic will list all of the reporting accounts in the partnership. You can filter or search the list. Viewing detailed customer data Under normal circumstances a partner will be able to see only the summary level data in a customer's New Relic account. Through the Partnership Admin Console, partners will be permitted to drill down to the more detailed presentation. If you want to drill down from the Partnership Admin Console, add your user (typically support@partner.com or something similar) to the account. Typically this will be done at account creation. Avoid provisioning this user as the account Owner.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.45969,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> admin console",
        "sections": "<em>Partnership</em> admin console",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "The <em>Partnership</em> Admin Console is the interface for managing your customers&#x27; accounts and <em>integration</em> with <em>New</em> <em>Relic</em>. To access the console, sign into the <em>partnership</em> owner account, and go to: https:&#x2F;&#x2F;<em>partner</em>-admin-console.newrelic.com&#x2F;accounts&#x2F;ACCOUNT_ID&#x2F;admin_console&#x2F; Copy You can also access"
      },
      "id": "603ed3e3196a6735baa83dad"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.18504,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " these customers &quot;customer <em>partnerships</em>.&quot; Use of our <em>partnership</em> account structure requires prior approval and set up by <em>New</em> <em>Relic</em> representatives. For customer <em>partnerships</em>, <em>New</em> <em>Relic</em> contacts organizations that would benefit from such a structure. <em>Partnerships</em> are identified by a numeric <em>PARTNER</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Support resources for New Relic partners",
        "Tip",
        "New Relic Support",
        "Documentation",
        "Agent documentation",
        "Agent release notes",
        "Online Technical Community"
      ],
      "title": "Support resources for New Relic partners",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "56246fb8462659d929766125f8afbbc429f42ee5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/support-resources-new-relic-partners/",
      "published_at": "2021-07-09T09:33:10Z",
      "updated_at": "2021-05-16T01:08:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for New Relic partners. After you complete your partnership integration, you will be introduced to your technical contacts at New Relic. Use these channels for non-urgent escalations. Tip If you are not a New Relic partner, see New Relic's resources for finding help or filing a support ticket. New Relic Support To obtain support for partner accounts, create a ticket at support.newrelic.com. If you need to call New Relic directly, contact your Business Development representative. Documentation Documentation from New Relic's Docs site is an important resource for your support group when providing Level 1 support to your New Relic subscribers. Posting these links on your support pages is an effective way to encourage self help and reduce your support efforts. Top level entry point for New Relic documentation: docs.newrelic.com. From here you can select information about New Relic products and features by category. Tip The Docs site includes a Partnerships category with information for New Relic partners and some partnership customers. Here are the five most commonly consulted articles on the New Relic Docs site. Providing easily found and direct links to these articles can provide many users with self-serve answers to their questions. Create your New Relic account Name your application Configure the agent Not seeing data Apdex: Measuring user satisfaction Agent documentation Here are links to New Relic documentation categories organized by APM agent languages: Go Java .NET Node.js PHP Python Ruby Agent release notes Here are links to New Relic release notes organized by agent languages: Go Java .NET Node.js PHP Python Ruby Online Technical Community The New Relic Explorers Hub brings together the expertise of New Relic employees, our Partners, and our community regarding all things New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.91856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "sections": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "This document is for <em>New</em> <em>Relic</em> partners. After you complete your <em>partnership</em> <em>integration</em>, you will be introduced to your technical contacts at <em>New</em> <em>Relic</em>. Use these channels for non-urgent escalations. Tip If you are not a <em>New</em> <em>Relic</em> <em>partner</em>, see <em>New</em> <em>Relic</em>&#x27;s resources for finding help or filing"
      },
      "id": "60450ecf28ccbc45632c6095"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/getting-started/partner-integration-requirements": [
    {
      "sections": [
        "Partnership admin console",
        "Console components",
        "Partnership configuration settings",
        "Customer activity monitoring",
        "State-of-the-Partnership report",
        "Partner customer monitoring",
        "View an arbitrary customer",
        "Viewing detailed customer data"
      ],
      "title": "Partnership admin console",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "670e4d2e1db957100b23a7b8b0af6bf50cc8c996",
      "image": "https://docs.newrelic.com/static/43369c88523ebf526ae58fa5719d4efe/0abdd/crop-partnership-owner-account-settings.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console/",
      "published_at": "2021-07-09T08:56:36Z",
      "updated_at": "2021-07-02T15:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Partnership Admin Console is the interface for managing your customers' accounts and integration with New Relic. To access the console, sign into the partnership owner account, and go to: https://partner-admin-console.newrelic.com/accounts/ACCOUNT_ID/admin_console/ Copy You can also access the console from the New Relic UI: Go to one.newrelic.com > (account dropdown) > Account settings. From the left menu bar, select Partnerships. one.newrelic.com > (account dropdown) > Account settings > Partnerships: Partnership owners can access the Partnership Admin Console from their account settings in the New Relic UI. Console components The Partnership Admin Console has two main components: Partnership configuration settings Customer activity monitoring If multiple partnerships are associated with the New Relic parent account, the menu also includes an option to switch partnership accounts. Partnership configuration settings In developing your integration with New Relic, you must specify a number of settings. For your convenience these settings are grouped together in the partnership console, including URLs for header/footer and various redirects, SSO configuration, and keys and the ability to manipulate them. Customer activity monitoring New Relic provides you with two tools for managing your customers: State-of-the-Partnership reports and live monitoring of all deployed New Relic agents in your partnership. Both of these tools provide insight into your customers who are using New Relic. They can be used to identify up-sale opportunities or to assist your support group in proactive support. State-of-the-Partnership report The State-of-the-Partnership report provides a summary of your customers with New Relic accounts and their activities. The report is broken down by language of the agents deployed, the agent version and the language version for each account. This report is run weekly for each partner. It is available on request from your New Relic Business Development contact. This report is an excellent way to see which of your customers with New Relic accounts are in fact using the service. Partner customer monitoring The Partner customer monitoring facility provides application performance data on the New Relic enabled applications that are running on your service. This facility allows you to easily identify customers experiencing performance problems. Where the performance problems are caused by under capacity, these customers are excellent sales opportunities. Alternatively your support or services organization will find this information useful in pre-emptively identifying customer issues or as good prospects for consulting services. View an arbitrary customer To view activity of a customer that does not appear in any of the filtered views: Go to one.newrelic.com > (account dropdown) > Switch accounts > Other accounts. New Relic will list all of the reporting accounts in the partnership. You can filter or search the list. Viewing detailed customer data Under normal circumstances a partner will be able to see only the summary level data in a customer's New Relic account. Through the Partnership Admin Console, partners will be permitted to drill down to the more detailed presentation. If you want to drill down from the Partnership Admin Console, add your user (typically support@partner.com or something similar) to the account. Typically this will be done at account creation. Avoid provisioning this user as the account Owner.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.45961,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> admin console",
        "sections": "<em>Partnership</em> admin console",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "The <em>Partnership</em> Admin Console is the interface for managing your customers&#x27; accounts and <em>integration</em> with <em>New</em> <em>Relic</em>. To access the console, sign into the <em>partnership</em> owner account, and go to: https:&#x2F;&#x2F;<em>partner</em>-admin-console.newrelic.com&#x2F;accounts&#x2F;ACCOUNT_ID&#x2F;admin_console&#x2F; Copy You can also access"
      },
      "id": "603ed3e3196a6735baa83dad"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " these customers &quot;customer <em>partnerships</em>.&quot; Use of our <em>partnership</em> account structure requires prior approval and set up by <em>New</em> <em>Relic</em> representatives. For customer <em>partnerships</em>, <em>New</em> <em>Relic</em> contacts organizations that would benefit from such a structure. <em>Partnerships</em> are identified by a numeric <em>PARTNER</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Support resources for New Relic partners",
        "Tip",
        "New Relic Support",
        "Documentation",
        "Agent documentation",
        "Agent release notes",
        "Online Technical Community"
      ],
      "title": "Support resources for New Relic partners",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "56246fb8462659d929766125f8afbbc429f42ee5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/support-resources-new-relic-partners/",
      "published_at": "2021-07-09T09:33:10Z",
      "updated_at": "2021-05-16T01:08:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for New Relic partners. After you complete your partnership integration, you will be introduced to your technical contacts at New Relic. Use these channels for non-urgent escalations. Tip If you are not a New Relic partner, see New Relic's resources for finding help or filing a support ticket. New Relic Support To obtain support for partner accounts, create a ticket at support.newrelic.com. If you need to call New Relic directly, contact your Business Development representative. Documentation Documentation from New Relic's Docs site is an important resource for your support group when providing Level 1 support to your New Relic subscribers. Posting these links on your support pages is an effective way to encourage self help and reduce your support efforts. Top level entry point for New Relic documentation: docs.newrelic.com. From here you can select information about New Relic products and features by category. Tip The Docs site includes a Partnerships category with information for New Relic partners and some partnership customers. Here are the five most commonly consulted articles on the New Relic Docs site. Providing easily found and direct links to these articles can provide many users with self-serve answers to their questions. Create your New Relic account Name your application Configure the agent Not seeing data Apdex: Measuring user satisfaction Agent documentation Here are links to New Relic documentation categories organized by APM agent languages: Go Java .NET Node.js PHP Python Ruby Agent release notes Here are links to New Relic release notes organized by agent languages: Go Java .NET Node.js PHP Python Ruby Online Technical Community The New Relic Explorers Hub brings together the expertise of New Relic employees, our Partners, and our community regarding all things New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.91856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "sections": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "This document is for <em>New</em> <em>Relic</em> partners. After you complete your <em>partnership</em> <em>integration</em>, you will be introduced to your technical contacts at <em>New</em> <em>Relic</em>. Use these channels for non-urgent escalations. Tip If you are not a <em>New</em> <em>Relic</em> <em>partner</em>, see <em>New</em> <em>Relic</em>&#x27;s resources for finding help or filing"
      },
      "id": "60450ecf28ccbc45632c6095"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/getting-started/partners-contact-new-relic": [
    {
      "sections": [
        "Partnership admin console",
        "Console components",
        "Partnership configuration settings",
        "Customer activity monitoring",
        "State-of-the-Partnership report",
        "Partner customer monitoring",
        "View an arbitrary customer",
        "Viewing detailed customer data"
      ],
      "title": "Partnership admin console",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "670e4d2e1db957100b23a7b8b0af6bf50cc8c996",
      "image": "https://docs.newrelic.com/static/43369c88523ebf526ae58fa5719d4efe/0abdd/crop-partnership-owner-account-settings.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console/",
      "published_at": "2021-07-09T08:56:36Z",
      "updated_at": "2021-07-02T15:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Partnership Admin Console is the interface for managing your customers' accounts and integration with New Relic. To access the console, sign into the partnership owner account, and go to: https://partner-admin-console.newrelic.com/accounts/ACCOUNT_ID/admin_console/ Copy You can also access the console from the New Relic UI: Go to one.newrelic.com > (account dropdown) > Account settings. From the left menu bar, select Partnerships. one.newrelic.com > (account dropdown) > Account settings > Partnerships: Partnership owners can access the Partnership Admin Console from their account settings in the New Relic UI. Console components The Partnership Admin Console has two main components: Partnership configuration settings Customer activity monitoring If multiple partnerships are associated with the New Relic parent account, the menu also includes an option to switch partnership accounts. Partnership configuration settings In developing your integration with New Relic, you must specify a number of settings. For your convenience these settings are grouped together in the partnership console, including URLs for header/footer and various redirects, SSO configuration, and keys and the ability to manipulate them. Customer activity monitoring New Relic provides you with two tools for managing your customers: State-of-the-Partnership reports and live monitoring of all deployed New Relic agents in your partnership. Both of these tools provide insight into your customers who are using New Relic. They can be used to identify up-sale opportunities or to assist your support group in proactive support. State-of-the-Partnership report The State-of-the-Partnership report provides a summary of your customers with New Relic accounts and their activities. The report is broken down by language of the agents deployed, the agent version and the language version for each account. This report is run weekly for each partner. It is available on request from your New Relic Business Development contact. This report is an excellent way to see which of your customers with New Relic accounts are in fact using the service. Partner customer monitoring The Partner customer monitoring facility provides application performance data on the New Relic enabled applications that are running on your service. This facility allows you to easily identify customers experiencing performance problems. Where the performance problems are caused by under capacity, these customers are excellent sales opportunities. Alternatively your support or services organization will find this information useful in pre-emptively identifying customer issues or as good prospects for consulting services. View an arbitrary customer To view activity of a customer that does not appear in any of the filtered views: Go to one.newrelic.com > (account dropdown) > Switch accounts > Other accounts. New Relic will list all of the reporting accounts in the partnership. You can filter or search the list. Viewing detailed customer data Under normal circumstances a partner will be able to see only the summary level data in a customer's New Relic account. Through the Partnership Admin Console, partners will be permitted to drill down to the more detailed presentation. If you want to drill down from the Partnership Admin Console, add your user (typically support@partner.com or something similar) to the account. Typically this will be done at account creation. Avoid provisioning this user as the account Owner.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.45961,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> admin console",
        "sections": "<em>Partnership</em> admin console",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "The <em>Partnership</em> Admin Console is the interface for managing your customers&#x27; accounts and <em>integration</em> with <em>New</em> <em>Relic</em>. To access the console, sign into the <em>partnership</em> owner account, and go to: https:&#x2F;&#x2F;<em>partner</em>-admin-console.newrelic.com&#x2F;accounts&#x2F;ACCOUNT_ID&#x2F;admin_console&#x2F; Copy You can also access"
      },
      "id": "603ed3e3196a6735baa83dad"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " these customers &quot;customer <em>partnerships</em>.&quot; Use of our <em>partnership</em> account structure requires prior approval and set up by <em>New</em> <em>Relic</em> representatives. For customer <em>partnerships</em>, <em>New</em> <em>Relic</em> contacts organizations that would benefit from such a structure. <em>Partnerships</em> are identified by a numeric <em>PARTNER</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Support resources for New Relic partners",
        "Tip",
        "New Relic Support",
        "Documentation",
        "Agent documentation",
        "Agent release notes",
        "Online Technical Community"
      ],
      "title": "Support resources for New Relic partners",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "56246fb8462659d929766125f8afbbc429f42ee5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/support-resources-new-relic-partners/",
      "published_at": "2021-07-09T09:33:10Z",
      "updated_at": "2021-05-16T01:08:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for New Relic partners. After you complete your partnership integration, you will be introduced to your technical contacts at New Relic. Use these channels for non-urgent escalations. Tip If you are not a New Relic partner, see New Relic's resources for finding help or filing a support ticket. New Relic Support To obtain support for partner accounts, create a ticket at support.newrelic.com. If you need to call New Relic directly, contact your Business Development representative. Documentation Documentation from New Relic's Docs site is an important resource for your support group when providing Level 1 support to your New Relic subscribers. Posting these links on your support pages is an effective way to encourage self help and reduce your support efforts. Top level entry point for New Relic documentation: docs.newrelic.com. From here you can select information about New Relic products and features by category. Tip The Docs site includes a Partnerships category with information for New Relic partners and some partnership customers. Here are the five most commonly consulted articles on the New Relic Docs site. Providing easily found and direct links to these articles can provide many users with self-serve answers to their questions. Create your New Relic account Name your application Configure the agent Not seeing data Apdex: Measuring user satisfaction Agent documentation Here are links to New Relic documentation categories organized by APM agent languages: Go Java .NET Node.js PHP Python Ruby Agent release notes Here are links to New Relic release notes organized by agent languages: Go Java .NET Node.js PHP Python Ruby Online Technical Community The New Relic Explorers Hub brings together the expertise of New Relic employees, our Partners, and our community regarding all things New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.91856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "sections": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "This document is for <em>New</em> <em>Relic</em> partners. After you complete your <em>partnership</em> <em>integration</em>, you will be introduced to your technical contacts at <em>New</em> <em>Relic</em>. Use these channels for non-urgent escalations. Tip If you are not a <em>New</em> <em>Relic</em> <em>partner</em>, see <em>New</em> <em>Relic</em>&#x27;s resources for finding help or filing"
      },
      "id": "60450ecf28ccbc45632c6095"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console": [
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.18495,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " these customers &quot;customer <em>partnerships</em>.&quot; Use of our <em>partnership</em> account structure requires prior approval and set up by <em>New</em> <em>Relic</em> representatives. For customer <em>partnerships</em>, <em>New</em> <em>Relic</em> contacts organizations that would benefit from such a structure. <em>Partnerships</em> are identified by a numeric <em>PARTNER</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Support resources for New Relic partners",
        "Tip",
        "New Relic Support",
        "Documentation",
        "Agent documentation",
        "Agent release notes",
        "Online Technical Community"
      ],
      "title": "Support resources for New Relic partners",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "56246fb8462659d929766125f8afbbc429f42ee5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/support-resources-new-relic-partners/",
      "published_at": "2021-07-09T09:33:10Z",
      "updated_at": "2021-05-16T01:08:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for New Relic partners. After you complete your partnership integration, you will be introduced to your technical contacts at New Relic. Use these channels for non-urgent escalations. Tip If you are not a New Relic partner, see New Relic's resources for finding help or filing a support ticket. New Relic Support To obtain support for partner accounts, create a ticket at support.newrelic.com. If you need to call New Relic directly, contact your Business Development representative. Documentation Documentation from New Relic's Docs site is an important resource for your support group when providing Level 1 support to your New Relic subscribers. Posting these links on your support pages is an effective way to encourage self help and reduce your support efforts. Top level entry point for New Relic documentation: docs.newrelic.com. From here you can select information about New Relic products and features by category. Tip The Docs site includes a Partnerships category with information for New Relic partners and some partnership customers. Here are the five most commonly consulted articles on the New Relic Docs site. Providing easily found and direct links to these articles can provide many users with self-serve answers to their questions. Create your New Relic account Name your application Configure the agent Not seeing data Apdex: Measuring user satisfaction Agent documentation Here are links to New Relic documentation categories organized by APM agent languages: Go Java .NET Node.js PHP Python Ruby Agent release notes Here are links to New Relic release notes organized by agent languages: Go Java .NET Node.js PHP Python Ruby Online Technical Community The New Relic Explorers Hub brings together the expertise of New Relic employees, our Partners, and our community regarding all things New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.91856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "sections": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "This document is for <em>New</em> <em>Relic</em> partners. After you complete your <em>partnership</em> <em>integration</em>, you will be introduced to your technical contacts at <em>New</em> <em>Relic</em>. Use these channels for non-urgent escalations. Tip If you are not a <em>New</em> <em>Relic</em> <em>partner</em>, see <em>New</em> <em>Relic</em>&#x27;s resources for finding help or filing"
      },
      "id": "60450ecf28ccbc45632c6095"
    },
    {
      "sections": [
        "Partners: Contact New Relic",
        "Integration assistance",
        "Technical assistance (regular priority)",
        "Emergency technical assistance",
        "Customer support"
      ],
      "title": "Partners: Contact New Relic",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "0ccf40e755893e6c718ec900144a46f9d4f31230",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partners-contact-new-relic/",
      "published_at": "2021-07-09T08:32:19Z",
      "updated_at": "2021-03-16T10:06:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are New Relic's resources for partners. If you are not a New Relic partner, follow standard procedures to find help or file a support ticket. Integration assistance For technical assistance or coordination to create your integration, contact your New Relic account representative. In addition, if you are interested in becoming a new partner, contact your New Relic account representative. Technical assistance (regular priority) Once your integration is live, follow standard procedures to find help or file a support ticket. Emergency technical assistance The New Relic partner support queue is continually monitored during business hours (Pacific time). New Relic strives to respond to partner support requests sent by email within an hour. For emergency assistance, email support @ newrelic.com, or contact your New Relic account representative. Customer support When your integration with New Relic is implemented and ready to launch, New Relic will arrange an introduction to your technical support contacts at New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.58865,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partners</em>: Contact <em>New</em> <em>Relic</em>",
        "sections": "<em>Partners</em>: Contact <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "Here are <em>New</em> <em>Relic</em>&#x27;s resources for partners. If you are not a <em>New</em> <em>Relic</em> <em>partner</em>, follow standard procedures to find help or file a support ticket. <em>Integration</em> assistance For technical assistance or coordination to create your <em>integration</em>, contact your <em>New</em> <em>Relic</em> account representative. In addition"
      },
      "id": "603ed39f64441fbe7f4e887d"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/getting-started/support-resources-new-relic-partners": [
    {
      "sections": [
        "Partnership admin console",
        "Console components",
        "Partnership configuration settings",
        "Customer activity monitoring",
        "State-of-the-Partnership report",
        "Partner customer monitoring",
        "View an arbitrary customer",
        "Viewing detailed customer data"
      ],
      "title": "Partnership admin console",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "670e4d2e1db957100b23a7b8b0af6bf50cc8c996",
      "image": "https://docs.newrelic.com/static/43369c88523ebf526ae58fa5719d4efe/0abdd/crop-partnership-owner-account-settings.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console/",
      "published_at": "2021-07-09T08:56:36Z",
      "updated_at": "2021-07-02T15:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Partnership Admin Console is the interface for managing your customers' accounts and integration with New Relic. To access the console, sign into the partnership owner account, and go to: https://partner-admin-console.newrelic.com/accounts/ACCOUNT_ID/admin_console/ Copy You can also access the console from the New Relic UI: Go to one.newrelic.com > (account dropdown) > Account settings. From the left menu bar, select Partnerships. one.newrelic.com > (account dropdown) > Account settings > Partnerships: Partnership owners can access the Partnership Admin Console from their account settings in the New Relic UI. Console components The Partnership Admin Console has two main components: Partnership configuration settings Customer activity monitoring If multiple partnerships are associated with the New Relic parent account, the menu also includes an option to switch partnership accounts. Partnership configuration settings In developing your integration with New Relic, you must specify a number of settings. For your convenience these settings are grouped together in the partnership console, including URLs for header/footer and various redirects, SSO configuration, and keys and the ability to manipulate them. Customer activity monitoring New Relic provides you with two tools for managing your customers: State-of-the-Partnership reports and live monitoring of all deployed New Relic agents in your partnership. Both of these tools provide insight into your customers who are using New Relic. They can be used to identify up-sale opportunities or to assist your support group in proactive support. State-of-the-Partnership report The State-of-the-Partnership report provides a summary of your customers with New Relic accounts and their activities. The report is broken down by language of the agents deployed, the agent version and the language version for each account. This report is run weekly for each partner. It is available on request from your New Relic Business Development contact. This report is an excellent way to see which of your customers with New Relic accounts are in fact using the service. Partner customer monitoring The Partner customer monitoring facility provides application performance data on the New Relic enabled applications that are running on your service. This facility allows you to easily identify customers experiencing performance problems. Where the performance problems are caused by under capacity, these customers are excellent sales opportunities. Alternatively your support or services organization will find this information useful in pre-emptively identifying customer issues or as good prospects for consulting services. View an arbitrary customer To view activity of a customer that does not appear in any of the filtered views: Go to one.newrelic.com > (account dropdown) > Switch accounts > Other accounts. New Relic will list all of the reporting accounts in the partnership. You can filter or search the list. Viewing detailed customer data Under normal circumstances a partner will be able to see only the summary level data in a customer's New Relic account. Through the Partnership Admin Console, partners will be permitted to drill down to the more detailed presentation. If you want to drill down from the Partnership Admin Console, add your user (typically support@partner.com or something similar) to the account. Typically this will be done at account creation. Avoid provisioning this user as the account Owner.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.45955,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> admin console",
        "sections": "<em>Partnership</em> admin console",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "The <em>Partnership</em> Admin Console is the interface for managing your customers&#x27; accounts and <em>integration</em> with <em>New</em> <em>Relic</em>. To access the console, sign into the <em>partnership</em> owner account, and go to: https:&#x2F;&#x2F;<em>partner</em>-admin-console.newrelic.com&#x2F;accounts&#x2F;ACCOUNT_ID&#x2F;admin_console&#x2F; Copy You can also access"
      },
      "id": "603ed3e3196a6735baa83dad"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.18495,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " these customers &quot;customer <em>partnerships</em>.&quot; Use of our <em>partnership</em> account structure requires prior approval and set up by <em>New</em> <em>Relic</em> representatives. For customer <em>partnerships</em>, <em>New</em> <em>Relic</em> contacts organizations that would benefit from such a structure. <em>Partnerships</em> are identified by a numeric <em>PARTNER</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Partners: Contact New Relic",
        "Integration assistance",
        "Technical assistance (regular priority)",
        "Emergency technical assistance",
        "Customer support"
      ],
      "title": "Partners: Contact New Relic",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "0ccf40e755893e6c718ec900144a46f9d4f31230",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partners-contact-new-relic/",
      "published_at": "2021-07-09T08:32:19Z",
      "updated_at": "2021-03-16T10:06:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are New Relic's resources for partners. If you are not a New Relic partner, follow standard procedures to find help or file a support ticket. Integration assistance For technical assistance or coordination to create your integration, contact your New Relic account representative. In addition, if you are interested in becoming a new partner, contact your New Relic account representative. Technical assistance (regular priority) Once your integration is live, follow standard procedures to find help or file a support ticket. Emergency technical assistance The New Relic partner support queue is continually monitored during business hours (Pacific time). New Relic strives to respond to partner support requests sent by email within an hour. For emergency assistance, email support @ newrelic.com, or contact your New Relic account representative. Customer support When your integration with New Relic is implemented and ready to launch, New Relic will arrange an introduction to your technical support contacts at New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.58865,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partners</em>: Contact <em>New</em> <em>Relic</em>",
        "sections": "<em>Partners</em>: Contact <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "Here are <em>New</em> <em>Relic</em>&#x27;s resources for partners. If you are not a <em>New</em> <em>Relic</em> <em>partner</em>, follow standard procedures to find help or file a support ticket. <em>Integration</em> assistance For technical assistance or coordination to create your <em>integration</em>, contact your <em>New</em> <em>Relic</em> account representative. In addition"
      },
      "id": "603ed39f64441fbe7f4e887d"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/getting-started/walkthrough-signoff": [
    {
      "sections": [
        "Partnership admin console",
        "Console components",
        "Partnership configuration settings",
        "Customer activity monitoring",
        "State-of-the-Partnership report",
        "Partner customer monitoring",
        "View an arbitrary customer",
        "Viewing detailed customer data"
      ],
      "title": "Partnership admin console",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "670e4d2e1db957100b23a7b8b0af6bf50cc8c996",
      "image": "https://docs.newrelic.com/static/43369c88523ebf526ae58fa5719d4efe/0abdd/crop-partnership-owner-account-settings.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console/",
      "published_at": "2021-07-09T08:56:36Z",
      "updated_at": "2021-07-02T15:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Partnership Admin Console is the interface for managing your customers' accounts and integration with New Relic. To access the console, sign into the partnership owner account, and go to: https://partner-admin-console.newrelic.com/accounts/ACCOUNT_ID/admin_console/ Copy You can also access the console from the New Relic UI: Go to one.newrelic.com > (account dropdown) > Account settings. From the left menu bar, select Partnerships. one.newrelic.com > (account dropdown) > Account settings > Partnerships: Partnership owners can access the Partnership Admin Console from their account settings in the New Relic UI. Console components The Partnership Admin Console has two main components: Partnership configuration settings Customer activity monitoring If multiple partnerships are associated with the New Relic parent account, the menu also includes an option to switch partnership accounts. Partnership configuration settings In developing your integration with New Relic, you must specify a number of settings. For your convenience these settings are grouped together in the partnership console, including URLs for header/footer and various redirects, SSO configuration, and keys and the ability to manipulate them. Customer activity monitoring New Relic provides you with two tools for managing your customers: State-of-the-Partnership reports and live monitoring of all deployed New Relic agents in your partnership. Both of these tools provide insight into your customers who are using New Relic. They can be used to identify up-sale opportunities or to assist your support group in proactive support. State-of-the-Partnership report The State-of-the-Partnership report provides a summary of your customers with New Relic accounts and their activities. The report is broken down by language of the agents deployed, the agent version and the language version for each account. This report is run weekly for each partner. It is available on request from your New Relic Business Development contact. This report is an excellent way to see which of your customers with New Relic accounts are in fact using the service. Partner customer monitoring The Partner customer monitoring facility provides application performance data on the New Relic enabled applications that are running on your service. This facility allows you to easily identify customers experiencing performance problems. Where the performance problems are caused by under capacity, these customers are excellent sales opportunities. Alternatively your support or services organization will find this information useful in pre-emptively identifying customer issues or as good prospects for consulting services. View an arbitrary customer To view activity of a customer that does not appear in any of the filtered views: Go to one.newrelic.com > (account dropdown) > Switch accounts > Other accounts. New Relic will list all of the reporting accounts in the partnership. You can filter or search the list. Viewing detailed customer data Under normal circumstances a partner will be able to see only the summary level data in a customer's New Relic account. Through the Partnership Admin Console, partners will be permitted to drill down to the more detailed presentation. If you want to drill down from the Partnership Admin Console, add your user (typically support@partner.com or something similar) to the account. Typically this will be done at account creation. Avoid provisioning this user as the account Owner.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.45949,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> admin console",
        "sections": "<em>Partnership</em> admin console",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "The <em>Partnership</em> Admin Console is the interface for managing your customers&#x27; accounts and <em>integration</em> with <em>New</em> <em>Relic</em>. To access the console, sign into the <em>partnership</em> owner account, and go to: https:&#x2F;&#x2F;<em>partner</em>-admin-console.newrelic.com&#x2F;accounts&#x2F;ACCOUNT_ID&#x2F;admin_console&#x2F; Copy You can also access"
      },
      "id": "603ed3e3196a6735baa83dad"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.1849,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " these customers &quot;customer <em>partnerships</em>.&quot; Use of our <em>partnership</em> account structure requires prior approval and set up by <em>New</em> <em>Relic</em> representatives. For customer <em>partnerships</em>, <em>New</em> <em>Relic</em> contacts organizations that would benefit from such a structure. <em>Partnerships</em> are identified by a numeric <em>PARTNER</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Support resources for New Relic partners",
        "Tip",
        "New Relic Support",
        "Documentation",
        "Agent documentation",
        "Agent release notes",
        "Online Technical Community"
      ],
      "title": "Support resources for New Relic partners",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "56246fb8462659d929766125f8afbbc429f42ee5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/support-resources-new-relic-partners/",
      "published_at": "2021-07-09T09:33:10Z",
      "updated_at": "2021-05-16T01:08:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for New Relic partners. After you complete your partnership integration, you will be introduced to your technical contacts at New Relic. Use these channels for non-urgent escalations. Tip If you are not a New Relic partner, see New Relic's resources for finding help or filing a support ticket. New Relic Support To obtain support for partner accounts, create a ticket at support.newrelic.com. If you need to call New Relic directly, contact your Business Development representative. Documentation Documentation from New Relic's Docs site is an important resource for your support group when providing Level 1 support to your New Relic subscribers. Posting these links on your support pages is an effective way to encourage self help and reduce your support efforts. Top level entry point for New Relic documentation: docs.newrelic.com. From here you can select information about New Relic products and features by category. Tip The Docs site includes a Partnerships category with information for New Relic partners and some partnership customers. Here are the five most commonly consulted articles on the New Relic Docs site. Providing easily found and direct links to these articles can provide many users with self-serve answers to their questions. Create your New Relic account Name your application Configure the agent Not seeing data Apdex: Measuring user satisfaction Agent documentation Here are links to New Relic documentation categories organized by APM agent languages: Go Java .NET Node.js PHP Python Ruby Agent release notes Here are links to New Relic release notes organized by agent languages: Go Java .NET Node.js PHP Python Ruby Online Technical Community The New Relic Explorers Hub brings together the expertise of New Relic employees, our Partners, and our community regarding all things New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.91855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "sections": "Support resources for <em>New</em> <em>Relic</em> <em>partners</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "This document is for <em>New</em> <em>Relic</em> partners. After you complete your <em>partnership</em> <em>integration</em>, you will be introduced to your technical contacts at <em>New</em> <em>Relic</em>. Use these channels for non-urgent escalations. Tip If you are not a <em>New</em> <em>Relic</em> <em>partner</em>, see <em>New</em> <em>Relic</em>&#x27;s resources for finding help or filing"
      },
      "id": "60450ecf28ccbc45632c6095"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/new-relic-products-features/other-partnership-settings": [
    {
      "sections": [
        "Partner products, pricing, and billing",
        "Important",
        "Commitment levels",
        "Customized partnership pricing",
        "Partnership billing options",
        "Cancellations",
        "Promotions",
        "Legacy products and commitment levels",
        "For more help"
      ],
      "title": "Partner products, pricing, and billing",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "New Relic products features"
      ],
      "external_id": "05d2d31e3eb7c18d7d0b13eac2d3fead6fd58bbf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/new-relic-products-features/partner-products-pricing-billing/",
      "published_at": "2021-07-09T08:56:35Z",
      "updated_at": "2021-05-16T01:10:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important This information is for New Relic partners. If you are not a New Relic partner, refer to the information about pricing and billing for New Relic accounts. Partners: For account setup procedures, see New Relic's Partner API documentation. For specific product pricing details (such as New Relic APM), visit New Relic's website, or contact your Alliance & Channels representative at New Relic. Commitment levels When customers choose a product, they also choose a monthly or annual commitment level. Existing partnerships have the option of limiting available product offerings for their customers. Reseller partners may be able to modify these subscription terms based on the contractual terms in the partner agreement with New Relic. Customized partnership pricing Partnership accounts may offer customized pricing. Customized pricing models, rates, minimums, discounts, and options vary by partnership--the actual pricing model used is subject to the contractual terms of the partner's agreement with New Relic. Contact your Alliance & Channels representative at New Relic to learn more. Partnership billing options New Relic supports the following billing options for partnerships. All subscriptions commence and expire at midnight GMT. For host-based subscriptions, fees are charged in advance for the month. Upgrade requests are honored immediately without any billing for partial use during the month. Downgrades take effect at the next payment date. To view New Relic account billing details and history from the user interface: From one.newrelic.com, select (account dropdown) > Account settings > Account > Billing. Billing option Description Credit card When partners choose credit card billing, your customers are directly charged using the credit card information provided during their New Relic subscription signup. This does not include any license fees paid directly by the partner for their customers' accounts. Invoice When partners choose invoice billing, your customers are billed directly by New Relic via invoice for their subscriptions. This option is normally provided on special request to customers with large monthly costs for which credit card billing would be impractical. Reseller For resellers, partners are billed directly for all customer accounts based on the calendar month. Partners may be responsible for accounting for customer usage, pricing, and subscriptions. Resellers have the option to implement an integration between our respective accounting systems. New Relic will invoice the partner monthly, using the Billing integration API for each of the paying accounts under the partnership. Cancellations Once a New Relic account cancellation takes effect, you must uninstall and/or delete all agents or other data-reporting integrations. For uninstallation details, see the documentation for the relevant agents and integrations. Customers may continue to access their data on New Relic until it is purged in accordance with the data retention policy corresponding to the product level. For existing accounts with paid, fixed host subscriptions, cancellations take effect at the next payment date. New Relic will continue to accept data for cancelled accounts until this date. Cancellations for accounts with free or paid based subscriptions take effect immediately. Promotions New Relic allows promotions for accounts offered through partnerships. Promotions associated with a specific partnership may only be redeemed on accounts associated with the partnership. Each promotion has a unique code. This promotion code may be applied only once per account. New Relic may impose further limits on the number of promotions that a customer may apply to an account. Promotion Description Free trials New Relic may include a free trial period for features normally available only through a paid subscription level. This option is provided for a specified number of days. The customer's subscription automatically reverts to its prior level at the conclusion of the trial. Payments for paid subscriptions are not interrupted by the redemption of a free trial promotion on the account. Single use Single use trials expire after they are used once. Discount (deprecated) A one-time percentage discount is applied to a paid subscription. This discount is applied in addition to any volume discounts and customized partner prices. The discount remains in effect until the subscription is modified or cancelled. Legacy products and commitment levels If you have questions about older New Relic products that have been converted to new pricing models, contact your Alliance & Channels representative at New Relic. For more help Additional documentation resources include: Partnership API account object (the primary JSON container object in the API) Partnership API user object (defined as an array within the account object) Partnership API subscription object (the level of service a customer purchases for one or more New Relic products) Billing integration API (functions to replace a customer's existing subscription with a new one, or to update invoice information for New Relic partner accounts)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.90321,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partner</em> <em>products</em>, pricing, and billing",
        "sections": "<em>Partner</em> <em>products</em>, pricing, and billing",
        "tags": "<em>New</em> <em>Relic</em> <em>products</em> <em>features</em>",
        "body": " API user object (defined as an array within the account object) <em>Partnership</em> API subscription object (the level of service a customer purchases for one or more <em>New</em> <em>Relic</em> <em>products</em>) Billing <em>integration</em> API (functions to replace a customer&#x27;s existing subscription with a <em>new</em> one, or to update invoice information for <em>New</em> <em>Relic</em> <em>partner</em> accounts)"
      },
      "id": "603ece55e7b9d254192a080c"
    },
    {
      "sections": [
        "Partnership accounts: Single sign on and access control",
        "Implement Single Sign On",
        "Use shared secret method",
        "SSO API",
        "Description",
        "Method",
        "URI",
        "Parameters",
        "**cURL examples**",
        "For more help"
      ],
      "title": "Partnership accounts: Single sign on and access control",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "New Relic products features"
      ],
      "external_id": "7054f72ececf6692e3abdcc1573276559be841ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/new-relic-products-features/single-sign-access-control/",
      "published_at": "2021-07-09T10:41:03Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic supports Single Sign On (SSO) as a convenience for partner customers. Partners implementing SSO also have the option to restrict access by requiring customers to access New Relic via the partner's management site or product login. Single Sign On is a convenience for your customers, eliminating the requirement of entering sign on credentials multiple times, and it creates a more unified experience for the user. In situations where this distinction is desired, SSO is recommended. Where it is desirable to maintain a distinction between the services or where technical considerations preclude implementing SSO, a fully functioning integration is still achievable. Implement Single Sign On Two methods for SSO are supported by New Relic. New Relic upgraded its single sign on system during 2011. If you implemented single sign on with New Relic prior to September 2011, you will have used the old system. That method of implementing SSO has been deprecated. All new integrations must use the new system. Existing implementations using the old system will continue to work indefinitely. However, we encourage all partners using the old system to upgrade to the new model. Use shared secret method The upgraded shared secret version of New Relic's SSO implementation offers several improvements over the old handshake version. Most important, the system is more secure. Security is enhanced by the use of passing a SHA1 digest of a shared secret, a timestamp, and request specific data in the authentication SSO request. The shared secret can be any string. Whatever shared secret is chosen, enter it in the appropriate field in the New Relic Partner console. To edit the SSO settings: Log in to the partnership owner account. From the account dropdown in the New Relic UI, select Account settings > Partnerships > Edit settings. For SSO type, select signature. For SSO data, type the shared secret. Select Save. In addition to enhanced security, the new SSO method supports a session cookie. Nav data may be stored in the session cookie to support enhanced functionality of headers and footers. The name of the cookie is specified through the Partner console. If unspecified the cookie name defaults to nav_data. To successfully use this SSO method, the SSO URI must be invoked from the user's browser. On success the browser will be automatically logged into New Relic and the redirect URL to that account returned. The SSO URI however should not be generated on the browser, as this would expose the shared secret and allow the login to be spoofed. The URI should be generated on a host and passed to the user's browser. SSO API Description SSO authentication request Method POST or GET URI https://rpm.newrelic.com/accounts/sso_access Copy Parameters Name Required Description id Yes ID of the New Relic account. email No Email address of user logging in (optional). If given, the user must already have been added to the account. By default, the account Owner role is used. Account Owners have full privileges on accounts. If some lesser degree of account privileges or a different user is desired, the email must be provided. timestamp Yes Timestamp used to generate token, in seconds since the epoch. Only timestamps within five minutes (300 seconds) of the New Relic system clock are accepted. nav-data OR nav_data No Partner navigation data. This data will be set in the session cookie using the name as specified in the partnership configuration, or nav_data by default. token Yes Signed token. The signature token is generated by applying a SHA1 hex digest on a seed string, which is composed as Account_id:secret:timestamp or Account_id:secret:timestamp:email. Each component is separated by a colon (:). Example without email: \"12345:MySecret:0987654321\" Using Ruby syntax: \"#{account_id}:#{secret}:#{timestamp}\" Example with email: \"12345:MySecret:0987654321:user@host.com\" Using Ruby syntax: \"#{account_id}:#{secret}:#{timestamp}:#{email}\" remote_url No Relative path of a New Relic page to which the users will be directed. ** cURL examples * * curl -X POST -d \"id=63790\" -d \"timestamp=1319659982\" -d \"token=a4d30d6f1f1a5b6c2872ab\" https://rpm.newrelic.com/accounts/sso_access Copy curl -X POST -d \"id=63790\" -d \"timestamp=1319659982\" -d \"token=a4d30d6f1f1a5b6c2872ab\" -d \"remote_url=/account/63790/servers\" https://rpm.newrelic.com/accounts/sso_access Copy On success returns: <html><body>You are being redirected.</body></html> Copy For more help Additional documentation resources include: SAML service providers (overview of New Relic's SSO feature, providers supported by New Relic) New Relic Partners and SAML SSO (additional options for partner accounts)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.11525,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts: Single sign on and access control",
        "sections": "<em>Partnership</em> accounts: Single sign on and access control",
        "tags": "<em>New</em> <em>Relic</em> <em>products</em> <em>features</em>",
        "body": "<em>New</em> <em>Relic</em> supports Single Sign On (SSO) as a convenience for <em>partner</em> customers. Partners implementing SSO also have the option to restrict access by requiring customers to access <em>New</em> <em>Relic</em> via the <em>partner</em>&#x27;s management site or <em>product</em> login. Single Sign On is a convenience for your customers"
      },
      "id": "6044175564441fd3fa378f1f"
    },
    {
      "sections": [
        "Partnership admin console",
        "Console components",
        "Partnership configuration settings",
        "Customer activity monitoring",
        "State-of-the-Partnership report",
        "Partner customer monitoring",
        "View an arbitrary customer",
        "Viewing detailed customer data"
      ],
      "title": "Partnership admin console",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "670e4d2e1db957100b23a7b8b0af6bf50cc8c996",
      "image": "https://docs.newrelic.com/static/43369c88523ebf526ae58fa5719d4efe/0abdd/crop-partnership-owner-account-settings.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console/",
      "published_at": "2021-07-09T08:56:36Z",
      "updated_at": "2021-07-02T15:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Partnership Admin Console is the interface for managing your customers' accounts and integration with New Relic. To access the console, sign into the partnership owner account, and go to: https://partner-admin-console.newrelic.com/accounts/ACCOUNT_ID/admin_console/ Copy You can also access the console from the New Relic UI: Go to one.newrelic.com > (account dropdown) > Account settings. From the left menu bar, select Partnerships. one.newrelic.com > (account dropdown) > Account settings > Partnerships: Partnership owners can access the Partnership Admin Console from their account settings in the New Relic UI. Console components The Partnership Admin Console has two main components: Partnership configuration settings Customer activity monitoring If multiple partnerships are associated with the New Relic parent account, the menu also includes an option to switch partnership accounts. Partnership configuration settings In developing your integration with New Relic, you must specify a number of settings. For your convenience these settings are grouped together in the partnership console, including URLs for header/footer and various redirects, SSO configuration, and keys and the ability to manipulate them. Customer activity monitoring New Relic provides you with two tools for managing your customers: State-of-the-Partnership reports and live monitoring of all deployed New Relic agents in your partnership. Both of these tools provide insight into your customers who are using New Relic. They can be used to identify up-sale opportunities or to assist your support group in proactive support. State-of-the-Partnership report The State-of-the-Partnership report provides a summary of your customers with New Relic accounts and their activities. The report is broken down by language of the agents deployed, the agent version and the language version for each account. This report is run weekly for each partner. It is available on request from your New Relic Business Development contact. This report is an excellent way to see which of your customers with New Relic accounts are in fact using the service. Partner customer monitoring The Partner customer monitoring facility provides application performance data on the New Relic enabled applications that are running on your service. This facility allows you to easily identify customers experiencing performance problems. Where the performance problems are caused by under capacity, these customers are excellent sales opportunities. Alternatively your support or services organization will find this information useful in pre-emptively identifying customer issues or as good prospects for consulting services. View an arbitrary customer To view activity of a customer that does not appear in any of the filtered views: Go to one.newrelic.com > (account dropdown) > Switch accounts > Other accounts. New Relic will list all of the reporting accounts in the partnership. You can filter or search the list. Viewing detailed customer data Under normal circumstances a partner will be able to see only the summary level data in a customer's New Relic account. Through the Partnership Admin Console, partners will be permitted to drill down to the more detailed presentation. If you want to drill down from the Partnership Admin Console, add your user (typically support@partner.com or something similar) to the account. Typically this will be done at account creation. Avoid provisioning this user as the account Owner.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.37401,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> admin console",
        "sections": "<em>Partnership</em> admin console",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "The <em>Partnership</em> Admin Console is the interface for managing your customers&#x27; accounts and <em>integration</em> with <em>New</em> <em>Relic</em>. To access the console, sign into the <em>partnership</em> owner account, and go to: https:&#x2F;&#x2F;<em>partner</em>-admin-console.newrelic.com&#x2F;accounts&#x2F;ACCOUNT_ID&#x2F;admin_console&#x2F; Copy You can also access"
      },
      "id": "603ed3e3196a6735baa83dad"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/new-relic-products-features/partner-products-pricing-billing": [
    {
      "sections": [
        "Other partnership settings",
        "Types of settings",
        "For more help"
      ],
      "title": "Other partnership settings",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "New Relic products features"
      ],
      "external_id": "df23328a14acab54c7f100c723f6feee68927c6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/new-relic-products-features/other-partnership-settings/",
      "published_at": "2021-07-09T09:34:32Z",
      "updated_at": "2021-03-16T10:07:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are a number of miscellaneous settings that are available to partners for customization of their partnership integration. Most of these settings enable or disable the presentation of New Relic features. These settings must be set by New Relic and are not configurable through the Partnership Console. Types of settings Contact your partnership technical contact to have any of these settings modified. Download links: Show agent link Show configuration file link Welcome messages: Signup message: A customized welcome message Hide or show banner welcome message Hide or show invoice message Email control: Send deploy reminders Send trial emails Billing email: This is for partnerships where the billing method is \"Reseller\" and invoices should be directed to the attention of a specific party. Feature access: Server monitoring User administration For more help Additional documentation resources include: Partnership console (overview of how to use the Partnership Console to change account settings in New Relic) The New Relic user interface (overview of how to use the UI)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.53555,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Other <em>partnership</em> settings",
        "sections": "Other <em>partnership</em> settings",
        "tags": "<em>New</em> <em>Relic</em> <em>products</em> <em>features</em>",
        "body": "There are a number of miscellaneous settings that are available to partners for customization of their <em>partnership</em> <em>integration</em>. Most of these settings enable or disable the presentation of <em>New</em> <em>Relic</em> <em>features</em>. These settings must be set by <em>New</em> <em>Relic</em> and are not configurable through the <em>Partnership</em>"
      },
      "id": "603ed42364441fb51f4e88a9"
    },
    {
      "sections": [
        "Partnership accounts: Single sign on and access control",
        "Implement Single Sign On",
        "Use shared secret method",
        "SSO API",
        "Description",
        "Method",
        "URI",
        "Parameters",
        "**cURL examples**",
        "For more help"
      ],
      "title": "Partnership accounts: Single sign on and access control",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "New Relic products features"
      ],
      "external_id": "7054f72ececf6692e3abdcc1573276559be841ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/new-relic-products-features/single-sign-access-control/",
      "published_at": "2021-07-09T10:41:03Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic supports Single Sign On (SSO) as a convenience for partner customers. Partners implementing SSO also have the option to restrict access by requiring customers to access New Relic via the partner's management site or product login. Single Sign On is a convenience for your customers, eliminating the requirement of entering sign on credentials multiple times, and it creates a more unified experience for the user. In situations where this distinction is desired, SSO is recommended. Where it is desirable to maintain a distinction between the services or where technical considerations preclude implementing SSO, a fully functioning integration is still achievable. Implement Single Sign On Two methods for SSO are supported by New Relic. New Relic upgraded its single sign on system during 2011. If you implemented single sign on with New Relic prior to September 2011, you will have used the old system. That method of implementing SSO has been deprecated. All new integrations must use the new system. Existing implementations using the old system will continue to work indefinitely. However, we encourage all partners using the old system to upgrade to the new model. Use shared secret method The upgraded shared secret version of New Relic's SSO implementation offers several improvements over the old handshake version. Most important, the system is more secure. Security is enhanced by the use of passing a SHA1 digest of a shared secret, a timestamp, and request specific data in the authentication SSO request. The shared secret can be any string. Whatever shared secret is chosen, enter it in the appropriate field in the New Relic Partner console. To edit the SSO settings: Log in to the partnership owner account. From the account dropdown in the New Relic UI, select Account settings > Partnerships > Edit settings. For SSO type, select signature. For SSO data, type the shared secret. Select Save. In addition to enhanced security, the new SSO method supports a session cookie. Nav data may be stored in the session cookie to support enhanced functionality of headers and footers. The name of the cookie is specified through the Partner console. If unspecified the cookie name defaults to nav_data. To successfully use this SSO method, the SSO URI must be invoked from the user's browser. On success the browser will be automatically logged into New Relic and the redirect URL to that account returned. The SSO URI however should not be generated on the browser, as this would expose the shared secret and allow the login to be spoofed. The URI should be generated on a host and passed to the user's browser. SSO API Description SSO authentication request Method POST or GET URI https://rpm.newrelic.com/accounts/sso_access Copy Parameters Name Required Description id Yes ID of the New Relic account. email No Email address of user logging in (optional). If given, the user must already have been added to the account. By default, the account Owner role is used. Account Owners have full privileges on accounts. If some lesser degree of account privileges or a different user is desired, the email must be provided. timestamp Yes Timestamp used to generate token, in seconds since the epoch. Only timestamps within five minutes (300 seconds) of the New Relic system clock are accepted. nav-data OR nav_data No Partner navigation data. This data will be set in the session cookie using the name as specified in the partnership configuration, or nav_data by default. token Yes Signed token. The signature token is generated by applying a SHA1 hex digest on a seed string, which is composed as Account_id:secret:timestamp or Account_id:secret:timestamp:email. Each component is separated by a colon (:). Example without email: \"12345:MySecret:0987654321\" Using Ruby syntax: \"#{account_id}:#{secret}:#{timestamp}\" Example with email: \"12345:MySecret:0987654321:user@host.com\" Using Ruby syntax: \"#{account_id}:#{secret}:#{timestamp}:#{email}\" remote_url No Relative path of a New Relic page to which the users will be directed. ** cURL examples * * curl -X POST -d \"id=63790\" -d \"timestamp=1319659982\" -d \"token=a4d30d6f1f1a5b6c2872ab\" https://rpm.newrelic.com/accounts/sso_access Copy curl -X POST -d \"id=63790\" -d \"timestamp=1319659982\" -d \"token=a4d30d6f1f1a5b6c2872ab\" -d \"remote_url=/account/63790/servers\" https://rpm.newrelic.com/accounts/sso_access Copy On success returns: <html><body>You are being redirected.</body></html> Copy For more help Additional documentation resources include: SAML service providers (overview of New Relic's SSO feature, providers supported by New Relic) New Relic Partners and SAML SSO (additional options for partner accounts)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.11525,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts: Single sign on and access control",
        "sections": "<em>Partnership</em> accounts: Single sign on and access control",
        "tags": "<em>New</em> <em>Relic</em> <em>products</em> <em>features</em>",
        "body": "<em>New</em> <em>Relic</em> supports Single Sign On (SSO) as a convenience for <em>partner</em> customers. Partners implementing SSO also have the option to restrict access by requiring customers to access <em>New</em> <em>Relic</em> via the <em>partner</em>&#x27;s management site or <em>product</em> login. Single Sign On is a convenience for your customers"
      },
      "id": "6044175564441fd3fa378f1f"
    },
    {
      "sections": [
        "Partnership admin console",
        "Console components",
        "Partnership configuration settings",
        "Customer activity monitoring",
        "State-of-the-Partnership report",
        "Partner customer monitoring",
        "View an arbitrary customer",
        "Viewing detailed customer data"
      ],
      "title": "Partnership admin console",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "670e4d2e1db957100b23a7b8b0af6bf50cc8c996",
      "image": "https://docs.newrelic.com/static/43369c88523ebf526ae58fa5719d4efe/0abdd/crop-partnership-owner-account-settings.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console/",
      "published_at": "2021-07-09T08:56:36Z",
      "updated_at": "2021-07-02T15:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Partnership Admin Console is the interface for managing your customers' accounts and integration with New Relic. To access the console, sign into the partnership owner account, and go to: https://partner-admin-console.newrelic.com/accounts/ACCOUNT_ID/admin_console/ Copy You can also access the console from the New Relic UI: Go to one.newrelic.com > (account dropdown) > Account settings. From the left menu bar, select Partnerships. one.newrelic.com > (account dropdown) > Account settings > Partnerships: Partnership owners can access the Partnership Admin Console from their account settings in the New Relic UI. Console components The Partnership Admin Console has two main components: Partnership configuration settings Customer activity monitoring If multiple partnerships are associated with the New Relic parent account, the menu also includes an option to switch partnership accounts. Partnership configuration settings In developing your integration with New Relic, you must specify a number of settings. For your convenience these settings are grouped together in the partnership console, including URLs for header/footer and various redirects, SSO configuration, and keys and the ability to manipulate them. Customer activity monitoring New Relic provides you with two tools for managing your customers: State-of-the-Partnership reports and live monitoring of all deployed New Relic agents in your partnership. Both of these tools provide insight into your customers who are using New Relic. They can be used to identify up-sale opportunities or to assist your support group in proactive support. State-of-the-Partnership report The State-of-the-Partnership report provides a summary of your customers with New Relic accounts and their activities. The report is broken down by language of the agents deployed, the agent version and the language version for each account. This report is run weekly for each partner. It is available on request from your New Relic Business Development contact. This report is an excellent way to see which of your customers with New Relic accounts are in fact using the service. Partner customer monitoring The Partner customer monitoring facility provides application performance data on the New Relic enabled applications that are running on your service. This facility allows you to easily identify customers experiencing performance problems. Where the performance problems are caused by under capacity, these customers are excellent sales opportunities. Alternatively your support or services organization will find this information useful in pre-emptively identifying customer issues or as good prospects for consulting services. View an arbitrary customer To view activity of a customer that does not appear in any of the filtered views: Go to one.newrelic.com > (account dropdown) > Switch accounts > Other accounts. New Relic will list all of the reporting accounts in the partnership. You can filter or search the list. Viewing detailed customer data Under normal circumstances a partner will be able to see only the summary level data in a customer's New Relic account. Through the Partnership Admin Console, partners will be permitted to drill down to the more detailed presentation. If you want to drill down from the Partnership Admin Console, add your user (typically support@partner.com or something similar) to the account. Typically this will be done at account creation. Avoid provisioning this user as the account Owner.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.37396,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> admin console",
        "sections": "<em>Partnership</em> admin console",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "The <em>Partnership</em> Admin Console is the interface for managing your customers&#x27; accounts and <em>integration</em> with <em>New</em> <em>Relic</em>. To access the console, sign into the <em>partnership</em> owner account, and go to: https:&#x2F;&#x2F;<em>partner</em>-admin-console.newrelic.com&#x2F;accounts&#x2F;ACCOUNT_ID&#x2F;admin_console&#x2F; Copy You can also access"
      },
      "id": "603ed3e3196a6735baa83dad"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/new-relic-products-features/single-sign-access-control": [
    {
      "sections": [
        "Partner products, pricing, and billing",
        "Important",
        "Commitment levels",
        "Customized partnership pricing",
        "Partnership billing options",
        "Cancellations",
        "Promotions",
        "Legacy products and commitment levels",
        "For more help"
      ],
      "title": "Partner products, pricing, and billing",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "New Relic products features"
      ],
      "external_id": "05d2d31e3eb7c18d7d0b13eac2d3fead6fd58bbf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/new-relic-products-features/partner-products-pricing-billing/",
      "published_at": "2021-07-09T08:56:35Z",
      "updated_at": "2021-05-16T01:10:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important This information is for New Relic partners. If you are not a New Relic partner, refer to the information about pricing and billing for New Relic accounts. Partners: For account setup procedures, see New Relic's Partner API documentation. For specific product pricing details (such as New Relic APM), visit New Relic's website, or contact your Alliance & Channels representative at New Relic. Commitment levels When customers choose a product, they also choose a monthly or annual commitment level. Existing partnerships have the option of limiting available product offerings for their customers. Reseller partners may be able to modify these subscription terms based on the contractual terms in the partner agreement with New Relic. Customized partnership pricing Partnership accounts may offer customized pricing. Customized pricing models, rates, minimums, discounts, and options vary by partnership--the actual pricing model used is subject to the contractual terms of the partner's agreement with New Relic. Contact your Alliance & Channels representative at New Relic to learn more. Partnership billing options New Relic supports the following billing options for partnerships. All subscriptions commence and expire at midnight GMT. For host-based subscriptions, fees are charged in advance for the month. Upgrade requests are honored immediately without any billing for partial use during the month. Downgrades take effect at the next payment date. To view New Relic account billing details and history from the user interface: From one.newrelic.com, select (account dropdown) > Account settings > Account > Billing. Billing option Description Credit card When partners choose credit card billing, your customers are directly charged using the credit card information provided during their New Relic subscription signup. This does not include any license fees paid directly by the partner for their customers' accounts. Invoice When partners choose invoice billing, your customers are billed directly by New Relic via invoice for their subscriptions. This option is normally provided on special request to customers with large monthly costs for which credit card billing would be impractical. Reseller For resellers, partners are billed directly for all customer accounts based on the calendar month. Partners may be responsible for accounting for customer usage, pricing, and subscriptions. Resellers have the option to implement an integration between our respective accounting systems. New Relic will invoice the partner monthly, using the Billing integration API for each of the paying accounts under the partnership. Cancellations Once a New Relic account cancellation takes effect, you must uninstall and/or delete all agents or other data-reporting integrations. For uninstallation details, see the documentation for the relevant agents and integrations. Customers may continue to access their data on New Relic until it is purged in accordance with the data retention policy corresponding to the product level. For existing accounts with paid, fixed host subscriptions, cancellations take effect at the next payment date. New Relic will continue to accept data for cancelled accounts until this date. Cancellations for accounts with free or paid based subscriptions take effect immediately. Promotions New Relic allows promotions for accounts offered through partnerships. Promotions associated with a specific partnership may only be redeemed on accounts associated with the partnership. Each promotion has a unique code. This promotion code may be applied only once per account. New Relic may impose further limits on the number of promotions that a customer may apply to an account. Promotion Description Free trials New Relic may include a free trial period for features normally available only through a paid subscription level. This option is provided for a specified number of days. The customer's subscription automatically reverts to its prior level at the conclusion of the trial. Payments for paid subscriptions are not interrupted by the redemption of a free trial promotion on the account. Single use Single use trials expire after they are used once. Discount (deprecated) A one-time percentage discount is applied to a paid subscription. This discount is applied in addition to any volume discounts and customized partner prices. The discount remains in effect until the subscription is modified or cancelled. Legacy products and commitment levels If you have questions about older New Relic products that have been converted to new pricing models, contact your Alliance & Channels representative at New Relic. For more help Additional documentation resources include: Partnership API account object (the primary JSON container object in the API) Partnership API user object (defined as an array within the account object) Partnership API subscription object (the level of service a customer purchases for one or more New Relic products) Billing integration API (functions to replace a customer's existing subscription with a new one, or to update invoice information for New Relic partner accounts)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.90321,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partner</em> <em>products</em>, pricing, and billing",
        "sections": "<em>Partner</em> <em>products</em>, pricing, and billing",
        "tags": "<em>New</em> <em>Relic</em> <em>products</em> <em>features</em>",
        "body": " API user object (defined as an array within the account object) <em>Partnership</em> API subscription object (the level of service a customer purchases for one or more <em>New</em> <em>Relic</em> <em>products</em>) Billing <em>integration</em> API (functions to replace a customer&#x27;s existing subscription with a <em>new</em> one, or to update invoice information for <em>New</em> <em>Relic</em> <em>partner</em> accounts)"
      },
      "id": "603ece55e7b9d254192a080c"
    },
    {
      "sections": [
        "Other partnership settings",
        "Types of settings",
        "For more help"
      ],
      "title": "Other partnership settings",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "New Relic products features"
      ],
      "external_id": "df23328a14acab54c7f100c723f6feee68927c6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/new-relic-products-features/other-partnership-settings/",
      "published_at": "2021-07-09T09:34:32Z",
      "updated_at": "2021-03-16T10:07:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are a number of miscellaneous settings that are available to partners for customization of their partnership integration. Most of these settings enable or disable the presentation of New Relic features. These settings must be set by New Relic and are not configurable through the Partnership Console. Types of settings Contact your partnership technical contact to have any of these settings modified. Download links: Show agent link Show configuration file link Welcome messages: Signup message: A customized welcome message Hide or show banner welcome message Hide or show invoice message Email control: Send deploy reminders Send trial emails Billing email: This is for partnerships where the billing method is \"Reseller\" and invoices should be directed to the attention of a specific party. Feature access: Server monitoring User administration For more help Additional documentation resources include: Partnership console (overview of how to use the Partnership Console to change account settings in New Relic) The New Relic user interface (overview of how to use the UI)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.53555,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Other <em>partnership</em> settings",
        "sections": "Other <em>partnership</em> settings",
        "tags": "<em>New</em> <em>Relic</em> <em>products</em> <em>features</em>",
        "body": "There are a number of miscellaneous settings that are available to partners for customization of their <em>partnership</em> <em>integration</em>. Most of these settings enable or disable the presentation of <em>New</em> <em>Relic</em> <em>features</em>. These settings must be set by <em>New</em> <em>Relic</em> and are not configurable through the <em>Partnership</em>"
      },
      "id": "603ed42364441fb51f4e88a9"
    },
    {
      "sections": [
        "Partnership admin console",
        "Console components",
        "Partnership configuration settings",
        "Customer activity monitoring",
        "State-of-the-Partnership report",
        "Partner customer monitoring",
        "View an arbitrary customer",
        "Viewing detailed customer data"
      ],
      "title": "Partnership admin console",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "670e4d2e1db957100b23a7b8b0af6bf50cc8c996",
      "image": "https://docs.newrelic.com/static/43369c88523ebf526ae58fa5719d4efe/0abdd/crop-partnership-owner-account-settings.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console/",
      "published_at": "2021-07-09T08:56:36Z",
      "updated_at": "2021-07-02T15:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Partnership Admin Console is the interface for managing your customers' accounts and integration with New Relic. To access the console, sign into the partnership owner account, and go to: https://partner-admin-console.newrelic.com/accounts/ACCOUNT_ID/admin_console/ Copy You can also access the console from the New Relic UI: Go to one.newrelic.com > (account dropdown) > Account settings. From the left menu bar, select Partnerships. one.newrelic.com > (account dropdown) > Account settings > Partnerships: Partnership owners can access the Partnership Admin Console from their account settings in the New Relic UI. Console components The Partnership Admin Console has two main components: Partnership configuration settings Customer activity monitoring If multiple partnerships are associated with the New Relic parent account, the menu also includes an option to switch partnership accounts. Partnership configuration settings In developing your integration with New Relic, you must specify a number of settings. For your convenience these settings are grouped together in the partnership console, including URLs for header/footer and various redirects, SSO configuration, and keys and the ability to manipulate them. Customer activity monitoring New Relic provides you with two tools for managing your customers: State-of-the-Partnership reports and live monitoring of all deployed New Relic agents in your partnership. Both of these tools provide insight into your customers who are using New Relic. They can be used to identify up-sale opportunities or to assist your support group in proactive support. State-of-the-Partnership report The State-of-the-Partnership report provides a summary of your customers with New Relic accounts and their activities. The report is broken down by language of the agents deployed, the agent version and the language version for each account. This report is run weekly for each partner. It is available on request from your New Relic Business Development contact. This report is an excellent way to see which of your customers with New Relic accounts are in fact using the service. Partner customer monitoring The Partner customer monitoring facility provides application performance data on the New Relic enabled applications that are running on your service. This facility allows you to easily identify customers experiencing performance problems. Where the performance problems are caused by under capacity, these customers are excellent sales opportunities. Alternatively your support or services organization will find this information useful in pre-emptively identifying customer issues or as good prospects for consulting services. View an arbitrary customer To view activity of a customer that does not appear in any of the filtered views: Go to one.newrelic.com > (account dropdown) > Switch accounts > Other accounts. New Relic will list all of the reporting accounts in the partnership. You can filter or search the list. Viewing detailed customer data Under normal circumstances a partner will be able to see only the summary level data in a customer's New Relic account. Through the Partnership Admin Console, partners will be permitted to drill down to the more detailed presentation. If you want to drill down from the Partnership Admin Console, add your user (typically support@partner.com or something similar) to the account. Typically this will be done at account creation. Avoid provisioning this user as the account Owner.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.37396,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> admin console",
        "sections": "<em>Partnership</em> admin console",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "The <em>Partnership</em> Admin Console is the interface for managing your customers&#x27; accounts and <em>integration</em> with <em>New</em> <em>Relic</em>. To access the console, sign into the <em>partnership</em> owner account, and go to: https:&#x2F;&#x2F;<em>partner</em>-admin-console.newrelic.com&#x2F;accounts&#x2F;ACCOUNT_ID&#x2F;admin_console&#x2F; Copy You can also access"
      },
      "id": "603ed3e3196a6735baa83dad"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partner-account-access-administrators": [
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.08246,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>accounts</em>, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " these customers &quot;customer <em>partnerships</em>.&quot; Use of our <em>partnership</em> <em>account</em> structure requires prior approval and set up by <em>New</em> <em>Relic</em> representatives. For customer <em>partnerships</em>, <em>New</em> <em>Relic</em> contacts organizations that would benefit from such a structure. <em>Partnerships</em> are identified by a numeric <em>PARTNER</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Intro to Partnership API",
        "Requirements",
        "Customer partnership restrictions",
        "Password requirements",
        "Things you can do",
        "Get started"
      ],
      "title": "Intro to Partnership API",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "074cf4e7c590dfa2332284a7b7f394e2f7ba45ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partner-api/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-03-29T20:10:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Partnership API allows New Relic partners, and New Relic accounts set up as customer partnerships, to manage accounts, users, and subscription-related settings. Requirements The Partnership API can be used by two types of New Relic accounts: partners (managed service providers, resellers) and customer partnerships (larger customers who have been given access to our partnership account structure). These docs are for version 2 of the Partner API. Earlier versions have been deprecated. If you have problems with an older integration, upgrade to version 2. Access to the partnership account structure and the Partnership API requires prior setup and approval by New Relic. Partnership API calls require authentication with both your partnership owner account's REST API key and your Partner ID. Accounts that are genuine New Relic partners (managed service providers, resellers) have no restrictions on using the API. Accounts set up as customer partnerships have restrictions that follow. Customer partnership restrictions If your New Relic organization is set up as a customer partnership, there are some restrictions in place if your organization is on our newer pricing plan or our newer account/user model. Details: Pricing plan. If you’re on New Relic One pricing, you can't use API calls that govern our original pricing plan. The API impacts are: You can't use the subscription object You can't use the NerdGraph Provisioning API. User model. If your New Relic account has been converted to be entirely on the New Relic One account/user model, you can no longer use API calls that create or govern users on our original user model. The API impacts are: You can't use the user object. Instead, you'd manage users with these user management docs. For the account object: you can't add users via the users field. Instead, you'd manage users with these user management docs. To determine your pricing plan or account/user model, see Overview of pricing and user model changes. Password requirements Passwords passed for account creation have these requirements: 8 to 50 characters in length Only contain letters, numbers, or special characters Cannot contain spaces Must contain at least 1 letter Must contain at least 1 number or special character Things you can do Here is an overview of the API's functionality. Account: The account object is what you use to create and update accounts. You can do the following with it: Create new Show Update Cancel Show usage Set primary admin (some accounts) Set subscription (some accounts) There is also a sub-account object for creating sub-accounts. Users: Some organizations that meet the requirements can use the user object to: Add user access to account Remove user access from account Subscription: Organizations that meet the requirements and are on our original product pricing plan can use the subscription object to configure various subscription-related traits. Get started To start using the Partnership API, see the Partner API reference docs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.1803,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>Partnership</em> API",
        "sections": "Intro to <em>Partnership</em> API",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": ") and customer <em>partnerships</em> (larger customers who have been given access to our <em>partnership</em> <em>account</em> structure). These docs are for version 2 of the <em>Partner</em> API. Earlier versions have been deprecated. If you have problems with an older <em>integration</em>, upgrade to version 2. Access to the <em>partnership</em> <em>account</em>"
      },
      "id": "603ed42328ccbcd4b3eba7ca"
    },
    {
      "sections": [
        "Tips and tricks",
        "Account creation and deletion",
        "Partnership owner account"
      ],
      "title": "Tips and tricks",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ba123e58f5acafea5b65e09350eba65abf430b2e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/tips-tricks/",
      "published_at": "2021-07-09T10:19:58Z",
      "updated_at": "2021-03-13T03:11:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some tips and tricks for creating and deleting New Relic partner accounts. Account creation and deletion When you create an account through the New Relic Partner API, the system checks the string submitted as the account name to ensure it is unique. If it is not unique, the system will append a number to the submitted string to ensure uniqueness; for example, account-name_1. When an account is canceled, it is not deleted from the New Relic database. Rather, it is made inactive by removing all subscriptions from the account. If you attempt to reinstate an account by calling the Account Creation API using the same account name, the system will check for uniqueness, determine that the name is not unique and create a new account with an appended number. This is in most cases not what is desired. To avoid this problem, as part of account creation, store the numeric account_id with the account name. When re-creating an account, check for the existence of this ID. If detected, rather than using the Account Creation API, use the Change Subscription API to add a new subscription to the account. Adding an active subscription to the account will re-activate the account. Partnership owner account The Partnership Owner Account is not part of the partnership. It owns the partnership. Attempts to treat it as if it were in the partnership will fail. This includes but is not limited to: Attempting to SSO into the partnership owner account using the partnership shared secret Expecting the partnership pricing to apply to the partnership owner account",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.93344,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Partnership</em> owner <em>account</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "Here are some tips and tricks for creating and deleting <em>New</em> <em>Relic</em> <em>partner</em> accounts. <em>Account</em> creation and deletion When you create an <em>account</em> through the <em>New</em> <em>Relic</em> <em>Partner</em> API, the system checks the string submitted as the <em>account</em> name to ensure it is unique. If it is not unique, the system"
      },
      "id": "60441785196a676aed960f46"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partner-api": [
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.08246,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>accounts</em>, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " these customers &quot;customer <em>partnerships</em>.&quot; Use of our <em>partnership</em> <em>account</em> structure requires prior approval and set up by <em>New</em> <em>Relic</em> representatives. For customer <em>partnerships</em>, <em>New</em> <em>Relic</em> contacts organizations that would benefit from such a structure. <em>Partnerships</em> are identified by a numeric <em>PARTNER</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Partner account access for administrators",
        "Guest level access",
        "Administrative level access"
      ],
      "title": "Partner account access for administrators",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "619eaa0ec75341c74c05afc0b888d2cc46d08767",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partner-account-access-administrators/",
      "published_at": "2021-07-09T10:36:01Z",
      "updated_at": "2021-03-16T10:08:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers the option for partner administrators to access their customers' accounts, subject to the contractual terms of the partnership agreement. These settings are controlled by a New Relic admin. For permissions for non-partner accounts, see Users and roles. Guest level access Guest level access allows administrators to view application data on their customers' accounts. This is particularly useful for troubleshooting customer issues related to performance. Administrative level access Administrative level access, in addition to viewing application data, allows partner administrators to modify the account and subscription terms, and add or remove users from an account. This access level is required for partners who will remotely administer customer accounts using the API or who enable Restricted access on their accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.32832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partner</em> <em>account</em> access for administrators",
        "sections": "<em>Partner</em> <em>account</em> access for administrators",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> offers the option for <em>partner</em> administrators to access their customers&#x27; accounts, subject to the contractual terms of the <em>partnership</em> agreement. These settings are controlled by a <em>New</em> <em>Relic</em> admin. For permissions for non-<em>partner</em> accounts, see Users and roles. Guest level access Guest"
      },
      "id": "603ec86ee7b9d2756c2a07c7"
    },
    {
      "sections": [
        "Tips and tricks",
        "Account creation and deletion",
        "Partnership owner account"
      ],
      "title": "Tips and tricks",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ba123e58f5acafea5b65e09350eba65abf430b2e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/tips-tricks/",
      "published_at": "2021-07-09T10:19:58Z",
      "updated_at": "2021-03-13T03:11:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some tips and tricks for creating and deleting New Relic partner accounts. Account creation and deletion When you create an account through the New Relic Partner API, the system checks the string submitted as the account name to ensure it is unique. If it is not unique, the system will append a number to the submitted string to ensure uniqueness; for example, account-name_1. When an account is canceled, it is not deleted from the New Relic database. Rather, it is made inactive by removing all subscriptions from the account. If you attempt to reinstate an account by calling the Account Creation API using the same account name, the system will check for uniqueness, determine that the name is not unique and create a new account with an appended number. This is in most cases not what is desired. To avoid this problem, as part of account creation, store the numeric account_id with the account name. When re-creating an account, check for the existence of this ID. If detected, rather than using the Account Creation API, use the Change Subscription API to add a new subscription to the account. Adding an active subscription to the account will re-activate the account. Partnership owner account The Partnership Owner Account is not part of the partnership. It owns the partnership. Attempts to treat it as if it were in the partnership will fail. This includes but is not limited to: Attempting to SSO into the partnership owner account using the partnership shared secret Expecting the partnership pricing to apply to the partnership owner account",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.93344,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Partnership</em> owner <em>account</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "Here are some tips and tricks for creating and deleting <em>New</em> <em>Relic</em> <em>partner</em> accounts. <em>Account</em> creation and deletion When you create an <em>account</em> through the <em>New</em> <em>Relic</em> <em>Partner</em> API, the system checks the string submitted as the <em>account</em> name to ensure it is unique. If it is not unique, the system"
      },
      "id": "60441785196a676aed960f46"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions": [
    {
      "sections": [
        "Intro to Partnership API",
        "Requirements",
        "Customer partnership restrictions",
        "Password requirements",
        "Things you can do",
        "Get started"
      ],
      "title": "Intro to Partnership API",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "074cf4e7c590dfa2332284a7b7f394e2f7ba45ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partner-api/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-03-29T20:10:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Partnership API allows New Relic partners, and New Relic accounts set up as customer partnerships, to manage accounts, users, and subscription-related settings. Requirements The Partnership API can be used by two types of New Relic accounts: partners (managed service providers, resellers) and customer partnerships (larger customers who have been given access to our partnership account structure). These docs are for version 2 of the Partner API. Earlier versions have been deprecated. If you have problems with an older integration, upgrade to version 2. Access to the partnership account structure and the Partnership API requires prior setup and approval by New Relic. Partnership API calls require authentication with both your partnership owner account's REST API key and your Partner ID. Accounts that are genuine New Relic partners (managed service providers, resellers) have no restrictions on using the API. Accounts set up as customer partnerships have restrictions that follow. Customer partnership restrictions If your New Relic organization is set up as a customer partnership, there are some restrictions in place if your organization is on our newer pricing plan or our newer account/user model. Details: Pricing plan. If you’re on New Relic One pricing, you can't use API calls that govern our original pricing plan. The API impacts are: You can't use the subscription object You can't use the NerdGraph Provisioning API. User model. If your New Relic account has been converted to be entirely on the New Relic One account/user model, you can no longer use API calls that create or govern users on our original user model. The API impacts are: You can't use the user object. Instead, you'd manage users with these user management docs. For the account object: you can't add users via the users field. Instead, you'd manage users with these user management docs. To determine your pricing plan or account/user model, see Overview of pricing and user model changes. Password requirements Passwords passed for account creation have these requirements: 8 to 50 characters in length Only contain letters, numbers, or special characters Cannot contain spaces Must contain at least 1 letter Must contain at least 1 number or special character Things you can do Here is an overview of the API's functionality. Account: The account object is what you use to create and update accounts. You can do the following with it: Create new Show Update Cancel Show usage Set primary admin (some accounts) Set subscription (some accounts) There is also a sub-account object for creating sub-accounts. Users: Some organizations that meet the requirements can use the user object to: Add user access to account Remove user access from account Subscription: Organizations that meet the requirements and are on our original product pricing plan can use the subscription object to configure various subscription-related traits. Get started To start using the Partnership API, see the Partner API reference docs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.1803,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>Partnership</em> API",
        "sections": "Intro to <em>Partnership</em> API",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": ") and customer <em>partnerships</em> (larger customers who have been given access to our <em>partnership</em> <em>account</em> structure). These docs are for version 2 of the <em>Partner</em> API. Earlier versions have been deprecated. If you have problems with an older <em>integration</em>, upgrade to version 2. Access to the <em>partnership</em> <em>account</em>"
      },
      "id": "603ed42328ccbcd4b3eba7ca"
    },
    {
      "sections": [
        "Partner account access for administrators",
        "Guest level access",
        "Administrative level access"
      ],
      "title": "Partner account access for administrators",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "619eaa0ec75341c74c05afc0b888d2cc46d08767",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partner-account-access-administrators/",
      "published_at": "2021-07-09T10:36:01Z",
      "updated_at": "2021-03-16T10:08:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers the option for partner administrators to access their customers' accounts, subject to the contractual terms of the partnership agreement. These settings are controlled by a New Relic admin. For permissions for non-partner accounts, see Users and roles. Guest level access Guest level access allows administrators to view application data on their customers' accounts. This is particularly useful for troubleshooting customer issues related to performance. Administrative level access Administrative level access, in addition to viewing application data, allows partner administrators to modify the account and subscription terms, and add or remove users from an account. This access level is required for partners who will remotely administer customer accounts using the API or who enable Restricted access on their accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.32832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partner</em> <em>account</em> access for administrators",
        "sections": "<em>Partner</em> <em>account</em> access for administrators",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> offers the option for <em>partner</em> administrators to access their customers&#x27; accounts, subject to the contractual terms of the <em>partnership</em> agreement. These settings are controlled by a <em>New</em> <em>Relic</em> admin. For permissions for non-<em>partner</em> accounts, see Users and roles. Guest level access Guest"
      },
      "id": "603ec86ee7b9d2756c2a07c7"
    },
    {
      "sections": [
        "Tips and tricks",
        "Account creation and deletion",
        "Partnership owner account"
      ],
      "title": "Tips and tricks",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ba123e58f5acafea5b65e09350eba65abf430b2e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/tips-tricks/",
      "published_at": "2021-07-09T10:19:58Z",
      "updated_at": "2021-03-13T03:11:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some tips and tricks for creating and deleting New Relic partner accounts. Account creation and deletion When you create an account through the New Relic Partner API, the system checks the string submitted as the account name to ensure it is unique. If it is not unique, the system will append a number to the submitted string to ensure uniqueness; for example, account-name_1. When an account is canceled, it is not deleted from the New Relic database. Rather, it is made inactive by removing all subscriptions from the account. If you attempt to reinstate an account by calling the Account Creation API using the same account name, the system will check for uniqueness, determine that the name is not unique and create a new account with an appended number. This is in most cases not what is desired. To avoid this problem, as part of account creation, store the numeric account_id with the account name. When re-creating an account, check for the existence of this ID. If detected, rather than using the Account Creation API, use the Change Subscription API to add a new subscription to the account. Adding an active subscription to the account will re-activate the account. Partnership owner account The Partnership Owner Account is not part of the partnership. It owns the partnership. Attempts to treat it as if it were in the partnership will fail. This includes but is not limited to: Attempting to SSO into the partnership owner account using the partnership shared secret Expecting the partnership pricing to apply to the partnership owner account",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.93344,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Partnership</em> owner <em>account</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "Here are some tips and tricks for creating and deleting <em>New</em> <em>Relic</em> <em>partner</em> accounts. <em>Account</em> creation and deletion When you create an <em>account</em> through the <em>New</em> <em>Relic</em> <em>Partner</em> API, the system checks the string submitted as the <em>account</em> name to ensure it is unique. If it is not unique, the system"
      },
      "id": "60441785196a676aed960f46"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/restricted-access-partnerships": [
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.0824,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>accounts</em>, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " these customers &quot;customer <em>partnerships</em>.&quot; Use of our <em>partnership</em> <em>account</em> structure requires prior approval and set up by <em>New</em> <em>Relic</em> representatives. For customer <em>partnerships</em>, <em>New</em> <em>Relic</em> contacts organizations that would benefit from such a structure. <em>Partnerships</em> are identified by a numeric <em>PARTNER</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Intro to Partnership API",
        "Requirements",
        "Customer partnership restrictions",
        "Password requirements",
        "Things you can do",
        "Get started"
      ],
      "title": "Intro to Partnership API",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "074cf4e7c590dfa2332284a7b7f394e2f7ba45ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partner-api/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-03-29T20:10:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Partnership API allows New Relic partners, and New Relic accounts set up as customer partnerships, to manage accounts, users, and subscription-related settings. Requirements The Partnership API can be used by two types of New Relic accounts: partners (managed service providers, resellers) and customer partnerships (larger customers who have been given access to our partnership account structure). These docs are for version 2 of the Partner API. Earlier versions have been deprecated. If you have problems with an older integration, upgrade to version 2. Access to the partnership account structure and the Partnership API requires prior setup and approval by New Relic. Partnership API calls require authentication with both your partnership owner account's REST API key and your Partner ID. Accounts that are genuine New Relic partners (managed service providers, resellers) have no restrictions on using the API. Accounts set up as customer partnerships have restrictions that follow. Customer partnership restrictions If your New Relic organization is set up as a customer partnership, there are some restrictions in place if your organization is on our newer pricing plan or our newer account/user model. Details: Pricing plan. If you’re on New Relic One pricing, you can't use API calls that govern our original pricing plan. The API impacts are: You can't use the subscription object You can't use the NerdGraph Provisioning API. User model. If your New Relic account has been converted to be entirely on the New Relic One account/user model, you can no longer use API calls that create or govern users on our original user model. The API impacts are: You can't use the user object. Instead, you'd manage users with these user management docs. For the account object: you can't add users via the users field. Instead, you'd manage users with these user management docs. To determine your pricing plan or account/user model, see Overview of pricing and user model changes. Password requirements Passwords passed for account creation have these requirements: 8 to 50 characters in length Only contain letters, numbers, or special characters Cannot contain spaces Must contain at least 1 letter Must contain at least 1 number or special character Things you can do Here is an overview of the API's functionality. Account: The account object is what you use to create and update accounts. You can do the following with it: Create new Show Update Cancel Show usage Set primary admin (some accounts) Set subscription (some accounts) There is also a sub-account object for creating sub-accounts. Users: Some organizations that meet the requirements can use the user object to: Add user access to account Remove user access from account Subscription: Organizations that meet the requirements and are on our original product pricing plan can use the subscription object to configure various subscription-related traits. Get started To start using the Partnership API, see the Partner API reference docs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.1803,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>Partnership</em> API",
        "sections": "Intro to <em>Partnership</em> API",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": ") and customer <em>partnerships</em> (larger customers who have been given access to our <em>partnership</em> <em>account</em> structure). These docs are for version 2 of the <em>Partner</em> API. Earlier versions have been deprecated. If you have problems with an older <em>integration</em>, upgrade to version 2. Access to the <em>partnership</em> <em>account</em>"
      },
      "id": "603ed42328ccbcd4b3eba7ca"
    },
    {
      "sections": [
        "Partner account access for administrators",
        "Guest level access",
        "Administrative level access"
      ],
      "title": "Partner account access for administrators",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "619eaa0ec75341c74c05afc0b888d2cc46d08767",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partner-account-access-administrators/",
      "published_at": "2021-07-09T10:36:01Z",
      "updated_at": "2021-03-16T10:08:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers the option for partner administrators to access their customers' accounts, subject to the contractual terms of the partnership agreement. These settings are controlled by a New Relic admin. For permissions for non-partner accounts, see Users and roles. Guest level access Guest level access allows administrators to view application data on their customers' accounts. This is particularly useful for troubleshooting customer issues related to performance. Administrative level access Administrative level access, in addition to viewing application data, allows partner administrators to modify the account and subscription terms, and add or remove users from an account. This access level is required for partners who will remotely administer customer accounts using the API or who enable Restricted access on their accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.32832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partner</em> <em>account</em> access for administrators",
        "sections": "<em>Partner</em> <em>account</em> access for administrators",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> offers the option for <em>partner</em> administrators to access their customers&#x27; accounts, subject to the contractual terms of the <em>partnership</em> agreement. These settings are controlled by a <em>New</em> <em>Relic</em> admin. For permissions for non-<em>partner</em> accounts, see Users and roles. Guest level access Guest"
      },
      "id": "603ec86ee7b9d2756c2a07c7"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/staging-production": [
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.0824,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>accounts</em>, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " these customers &quot;customer <em>partnerships</em>.&quot; Use of our <em>partnership</em> <em>account</em> structure requires prior approval and set up by <em>New</em> <em>Relic</em> representatives. For customer <em>partnerships</em>, <em>New</em> <em>Relic</em> contacts organizations that would benefit from such a structure. <em>Partnerships</em> are identified by a numeric <em>PARTNER</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Intro to Partnership API",
        "Requirements",
        "Customer partnership restrictions",
        "Password requirements",
        "Things you can do",
        "Get started"
      ],
      "title": "Intro to Partnership API",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "074cf4e7c590dfa2332284a7b7f394e2f7ba45ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partner-api/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-03-29T20:10:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Partnership API allows New Relic partners, and New Relic accounts set up as customer partnerships, to manage accounts, users, and subscription-related settings. Requirements The Partnership API can be used by two types of New Relic accounts: partners (managed service providers, resellers) and customer partnerships (larger customers who have been given access to our partnership account structure). These docs are for version 2 of the Partner API. Earlier versions have been deprecated. If you have problems with an older integration, upgrade to version 2. Access to the partnership account structure and the Partnership API requires prior setup and approval by New Relic. Partnership API calls require authentication with both your partnership owner account's REST API key and your Partner ID. Accounts that are genuine New Relic partners (managed service providers, resellers) have no restrictions on using the API. Accounts set up as customer partnerships have restrictions that follow. Customer partnership restrictions If your New Relic organization is set up as a customer partnership, there are some restrictions in place if your organization is on our newer pricing plan or our newer account/user model. Details: Pricing plan. If you’re on New Relic One pricing, you can't use API calls that govern our original pricing plan. The API impacts are: You can't use the subscription object You can't use the NerdGraph Provisioning API. User model. If your New Relic account has been converted to be entirely on the New Relic One account/user model, you can no longer use API calls that create or govern users on our original user model. The API impacts are: You can't use the user object. Instead, you'd manage users with these user management docs. For the account object: you can't add users via the users field. Instead, you'd manage users with these user management docs. To determine your pricing plan or account/user model, see Overview of pricing and user model changes. Password requirements Passwords passed for account creation have these requirements: 8 to 50 characters in length Only contain letters, numbers, or special characters Cannot contain spaces Must contain at least 1 letter Must contain at least 1 number or special character Things you can do Here is an overview of the API's functionality. Account: The account object is what you use to create and update accounts. You can do the following with it: Create new Show Update Cancel Show usage Set primary admin (some accounts) Set subscription (some accounts) There is also a sub-account object for creating sub-accounts. Users: Some organizations that meet the requirements can use the user object to: Add user access to account Remove user access from account Subscription: Organizations that meet the requirements and are on our original product pricing plan can use the subscription object to configure various subscription-related traits. Get started To start using the Partnership API, see the Partner API reference docs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.1803,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>Partnership</em> API",
        "sections": "Intro to <em>Partnership</em> API",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": ") and customer <em>partnerships</em> (larger customers who have been given access to our <em>partnership</em> <em>account</em> structure). These docs are for version 2 of the <em>Partner</em> API. Earlier versions have been deprecated. If you have problems with an older <em>integration</em>, upgrade to version 2. Access to the <em>partnership</em> <em>account</em>"
      },
      "id": "603ed42328ccbcd4b3eba7ca"
    },
    {
      "sections": [
        "Partner account access for administrators",
        "Guest level access",
        "Administrative level access"
      ],
      "title": "Partner account access for administrators",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "619eaa0ec75341c74c05afc0b888d2cc46d08767",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partner-account-access-administrators/",
      "published_at": "2021-07-09T10:36:01Z",
      "updated_at": "2021-03-16T10:08:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers the option for partner administrators to access their customers' accounts, subject to the contractual terms of the partnership agreement. These settings are controlled by a New Relic admin. For permissions for non-partner accounts, see Users and roles. Guest level access Guest level access allows administrators to view application data on their customers' accounts. This is particularly useful for troubleshooting customer issues related to performance. Administrative level access Administrative level access, in addition to viewing application data, allows partner administrators to modify the account and subscription terms, and add or remove users from an account. This access level is required for partners who will remotely administer customer accounts using the API or who enable Restricted access on their accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.32832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partner</em> <em>account</em> access for administrators",
        "sections": "<em>Partner</em> <em>account</em> access for administrators",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> offers the option for <em>partner</em> administrators to access their customers&#x27; accounts, subject to the contractual terms of the <em>partnership</em> agreement. These settings are controlled by a <em>New</em> <em>Relic</em> admin. For permissions for non-<em>partner</em> accounts, see Users and roles. Guest level access Guest"
      },
      "id": "603ec86ee7b9d2756c2a07c7"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/tips-tricks": [
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.0823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>accounts</em>, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " these customers &quot;customer <em>partnerships</em>.&quot; Use of our <em>partnership</em> <em>account</em> structure requires prior approval and set up by <em>New</em> <em>Relic</em> representatives. For customer <em>partnerships</em>, <em>New</em> <em>Relic</em> contacts organizations that would benefit from such a structure. <em>Partnerships</em> are identified by a numeric <em>PARTNER</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Intro to Partnership API",
        "Requirements",
        "Customer partnership restrictions",
        "Password requirements",
        "Things you can do",
        "Get started"
      ],
      "title": "Intro to Partnership API",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "074cf4e7c590dfa2332284a7b7f394e2f7ba45ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partner-api/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-03-29T20:10:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Partnership API allows New Relic partners, and New Relic accounts set up as customer partnerships, to manage accounts, users, and subscription-related settings. Requirements The Partnership API can be used by two types of New Relic accounts: partners (managed service providers, resellers) and customer partnerships (larger customers who have been given access to our partnership account structure). These docs are for version 2 of the Partner API. Earlier versions have been deprecated. If you have problems with an older integration, upgrade to version 2. Access to the partnership account structure and the Partnership API requires prior setup and approval by New Relic. Partnership API calls require authentication with both your partnership owner account's REST API key and your Partner ID. Accounts that are genuine New Relic partners (managed service providers, resellers) have no restrictions on using the API. Accounts set up as customer partnerships have restrictions that follow. Customer partnership restrictions If your New Relic organization is set up as a customer partnership, there are some restrictions in place if your organization is on our newer pricing plan or our newer account/user model. Details: Pricing plan. If you’re on New Relic One pricing, you can't use API calls that govern our original pricing plan. The API impacts are: You can't use the subscription object You can't use the NerdGraph Provisioning API. User model. If your New Relic account has been converted to be entirely on the New Relic One account/user model, you can no longer use API calls that create or govern users on our original user model. The API impacts are: You can't use the user object. Instead, you'd manage users with these user management docs. For the account object: you can't add users via the users field. Instead, you'd manage users with these user management docs. To determine your pricing plan or account/user model, see Overview of pricing and user model changes. Password requirements Passwords passed for account creation have these requirements: 8 to 50 characters in length Only contain letters, numbers, or special characters Cannot contain spaces Must contain at least 1 letter Must contain at least 1 number or special character Things you can do Here is an overview of the API's functionality. Account: The account object is what you use to create and update accounts. You can do the following with it: Create new Show Update Cancel Show usage Set primary admin (some accounts) Set subscription (some accounts) There is also a sub-account object for creating sub-accounts. Users: Some organizations that meet the requirements can use the user object to: Add user access to account Remove user access from account Subscription: Organizations that meet the requirements and are on our original product pricing plan can use the subscription object to configure various subscription-related traits. Get started To start using the Partnership API, see the Partner API reference docs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.18028,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>Partnership</em> API",
        "sections": "Intro to <em>Partnership</em> API",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": ") and customer <em>partnerships</em> (larger customers who have been given access to our <em>partnership</em> <em>account</em> structure). These docs are for version 2 of the <em>Partner</em> API. Earlier versions have been deprecated. If you have problems with an older <em>integration</em>, upgrade to version 2. Access to the <em>partnership</em> <em>account</em>"
      },
      "id": "603ed42328ccbcd4b3eba7ca"
    },
    {
      "sections": [
        "Partner account access for administrators",
        "Guest level access",
        "Administrative level access"
      ],
      "title": "Partner account access for administrators",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "619eaa0ec75341c74c05afc0b888d2cc46d08767",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partner-account-access-administrators/",
      "published_at": "2021-07-09T10:36:01Z",
      "updated_at": "2021-03-16T10:08:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers the option for partner administrators to access their customers' accounts, subject to the contractual terms of the partnership agreement. These settings are controlled by a New Relic admin. For permissions for non-partner accounts, see Users and roles. Guest level access Guest level access allows administrators to view application data on their customers' accounts. This is particularly useful for troubleshooting customer issues related to performance. Administrative level access Administrative level access, in addition to viewing application data, allows partner administrators to modify the account and subscription terms, and add or remove users from an account. This access level is required for partners who will remotely administer customer accounts using the API or who enable Restricted access on their accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.32832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partner</em> <em>account</em> access for administrators",
        "sections": "<em>Partner</em> <em>account</em> access for administrators",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> offers the option for <em>partner</em> administrators to access their customers&#x27; accounts, subject to the contractual terms of the <em>partnership</em> agreement. These settings are controlled by a <em>New</em> <em>Relic</em> admin. For permissions for non-<em>partner</em> accounts, see Users and roles. Guest level access Guest"
      },
      "id": "603ec86ee7b9d2756c2a07c7"
    }
  ],
  "/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/welcome-messages-partnerships": [
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.0823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>accounts</em>, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " these customers &quot;customer <em>partnerships</em>.&quot; Use of our <em>partnership</em> <em>account</em> structure requires prior approval and set up by <em>New</em> <em>Relic</em> representatives. For customer <em>partnerships</em>, <em>New</em> <em>Relic</em> contacts organizations that would benefit from such a structure. <em>Partnerships</em> are identified by a numeric <em>PARTNER</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Intro to Partnership API",
        "Requirements",
        "Customer partnership restrictions",
        "Password requirements",
        "Things you can do",
        "Get started"
      ],
      "title": "Intro to Partnership API",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "074cf4e7c590dfa2332284a7b7f394e2f7ba45ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partner-api/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-03-29T20:10:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Partnership API allows New Relic partners, and New Relic accounts set up as customer partnerships, to manage accounts, users, and subscription-related settings. Requirements The Partnership API can be used by two types of New Relic accounts: partners (managed service providers, resellers) and customer partnerships (larger customers who have been given access to our partnership account structure). These docs are for version 2 of the Partner API. Earlier versions have been deprecated. If you have problems with an older integration, upgrade to version 2. Access to the partnership account structure and the Partnership API requires prior setup and approval by New Relic. Partnership API calls require authentication with both your partnership owner account's REST API key and your Partner ID. Accounts that are genuine New Relic partners (managed service providers, resellers) have no restrictions on using the API. Accounts set up as customer partnerships have restrictions that follow. Customer partnership restrictions If your New Relic organization is set up as a customer partnership, there are some restrictions in place if your organization is on our newer pricing plan or our newer account/user model. Details: Pricing plan. If you’re on New Relic One pricing, you can't use API calls that govern our original pricing plan. The API impacts are: You can't use the subscription object You can't use the NerdGraph Provisioning API. User model. If your New Relic account has been converted to be entirely on the New Relic One account/user model, you can no longer use API calls that create or govern users on our original user model. The API impacts are: You can't use the user object. Instead, you'd manage users with these user management docs. For the account object: you can't add users via the users field. Instead, you'd manage users with these user management docs. To determine your pricing plan or account/user model, see Overview of pricing and user model changes. Password requirements Passwords passed for account creation have these requirements: 8 to 50 characters in length Only contain letters, numbers, or special characters Cannot contain spaces Must contain at least 1 letter Must contain at least 1 number or special character Things you can do Here is an overview of the API's functionality. Account: The account object is what you use to create and update accounts. You can do the following with it: Create new Show Update Cancel Show usage Set primary admin (some accounts) Set subscription (some accounts) There is also a sub-account object for creating sub-accounts. Users: Some organizations that meet the requirements can use the user object to: Add user access to account Remove user access from account Subscription: Organizations that meet the requirements and are on our original product pricing plan can use the subscription object to configure various subscription-related traits. Get started To start using the Partnership API, see the Partner API reference docs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.18028,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>Partnership</em> API",
        "sections": "Intro to <em>Partnership</em> API",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": ") and customer <em>partnerships</em> (larger customers who have been given access to our <em>partnership</em> <em>account</em> structure). These docs are for version 2 of the <em>Partner</em> API. Earlier versions have been deprecated. If you have problems with an older <em>integration</em>, upgrade to version 2. Access to the <em>partnership</em> <em>account</em>"
      },
      "id": "603ed42328ccbcd4b3eba7ca"
    },
    {
      "sections": [
        "Partner account access for administrators",
        "Guest level access",
        "Administrative level access"
      ],
      "title": "Partner account access for administrators",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "619eaa0ec75341c74c05afc0b888d2cc46d08767",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partner-account-access-administrators/",
      "published_at": "2021-07-09T10:36:01Z",
      "updated_at": "2021-03-16T10:08:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers the option for partner administrators to access their customers' accounts, subject to the contractual terms of the partnership agreement. These settings are controlled by a New Relic admin. For permissions for non-partner accounts, see Users and roles. Guest level access Guest level access allows administrators to view application data on their customers' accounts. This is particularly useful for troubleshooting customer issues related to performance. Administrative level access Administrative level access, in addition to viewing application data, allows partner administrators to modify the account and subscription terms, and add or remove users from an account. This access level is required for partners who will remotely administer customer accounts using the API or who enable Restricted access on their accounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.32832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partner</em> <em>account</em> access for administrators",
        "sections": "<em>Partner</em> <em>account</em> access for administrators",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> offers the option for <em>partner</em> administrators to access their customers&#x27; accounts, subject to the contractual terms of the <em>partnership</em> agreement. These settings are controlled by a <em>New</em> <em>Relic</em> admin. For permissions for non-<em>partner</em> accounts, see Users and roles. Guest level access Guest"
      },
      "id": "603ec86ee7b9d2756c2a07c7"
    }
  ],
  "/docs/new-relic-partnerships/partnerships/getting-started/partner-marketing": [
    {
      "sections": [
        "Partnership admin console",
        "Console components",
        "Partnership configuration settings",
        "Customer activity monitoring",
        "State-of-the-Partnership report",
        "Partner customer monitoring",
        "View an arbitrary customer",
        "Viewing detailed customer data"
      ],
      "title": "Partnership admin console",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "670e4d2e1db957100b23a7b8b0af6bf50cc8c996",
      "image": "https://docs.newrelic.com/static/43369c88523ebf526ae58fa5719d4efe/0abdd/crop-partnership-owner-account-settings.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console/",
      "published_at": "2021-07-09T08:56:36Z",
      "updated_at": "2021-07-02T15:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Partnership Admin Console is the interface for managing your customers' accounts and integration with New Relic. To access the console, sign into the partnership owner account, and go to: https://partner-admin-console.newrelic.com/accounts/ACCOUNT_ID/admin_console/ Copy You can also access the console from the New Relic UI: Go to one.newrelic.com > (account dropdown) > Account settings. From the left menu bar, select Partnerships. one.newrelic.com > (account dropdown) > Account settings > Partnerships: Partnership owners can access the Partnership Admin Console from their account settings in the New Relic UI. Console components The Partnership Admin Console has two main components: Partnership configuration settings Customer activity monitoring If multiple partnerships are associated with the New Relic parent account, the menu also includes an option to switch partnership accounts. Partnership configuration settings In developing your integration with New Relic, you must specify a number of settings. For your convenience these settings are grouped together in the partnership console, including URLs for header/footer and various redirects, SSO configuration, and keys and the ability to manipulate them. Customer activity monitoring New Relic provides you with two tools for managing your customers: State-of-the-Partnership reports and live monitoring of all deployed New Relic agents in your partnership. Both of these tools provide insight into your customers who are using New Relic. They can be used to identify up-sale opportunities or to assist your support group in proactive support. State-of-the-Partnership report The State-of-the-Partnership report provides a summary of your customers with New Relic accounts and their activities. The report is broken down by language of the agents deployed, the agent version and the language version for each account. This report is run weekly for each partner. It is available on request from your New Relic Business Development contact. This report is an excellent way to see which of your customers with New Relic accounts are in fact using the service. Partner customer monitoring The Partner customer monitoring facility provides application performance data on the New Relic enabled applications that are running on your service. This facility allows you to easily identify customers experiencing performance problems. Where the performance problems are caused by under capacity, these customers are excellent sales opportunities. Alternatively your support or services organization will find this information useful in pre-emptively identifying customer issues or as good prospects for consulting services. View an arbitrary customer To view activity of a customer that does not appear in any of the filtered views: Go to one.newrelic.com > (account dropdown) > Switch accounts > Other accounts. New Relic will list all of the reporting accounts in the partnership. You can filter or search the list. Viewing detailed customer data Under normal circumstances a partner will be able to see only the summary level data in a customer's New Relic account. Through the Partnership Admin Console, partners will be permitted to drill down to the more detailed presentation. If you want to drill down from the Partnership Admin Console, add your user (typically support@partner.com or something similar) to the account. Typically this will be done at account creation. Avoid provisioning this user as the account Owner.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.19513,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> admin console",
        "sections": "<em>Partnership</em> admin console",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " the console from the <em>New</em> <em>Relic</em> UI: Go to one.newrelic.com &gt; (account dropdown) &gt; Account settings. From the left menu bar, select <em>Partnerships</em>. one.newrelic.com &gt; (account dropdown) &gt; Account settings &gt; <em>Partnerships</em>: <em>Partnership</em> owners can access the <em>Partnership</em> Admin Console from their account settings"
      },
      "id": "603ed3e3196a6735baa83dad"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.73405,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> organizations set up as <em>partnership</em> accounts have access to an enhanced hierarchical way of organizing their account structure. <em>Partnerships</em> with <em>New</em> <em>Relic</em> There are two types of <em>New</em> <em>Relic</em> organizations that are able to use our <em>partnership</em> account structure and the <em>Partnership</em> API"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Partnership API account object",
        "Requirements",
        "Account object attributes",
        "name (REQUIRED to create an account)",
        "phone_number",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "subscriptions (REQUIRED for some accounts)",
        "Important",
        "Account API calls",
        "Status definitions",
        "JSON example",
        "Account object JSON request",
        "JSON response",
        "Account object API examples",
        "List",
        "Show",
        "Create",
        "Update",
        "Delete"
      ],
      "title": "Partnership API account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "0b1fde4800f2f9f355e0381796f55e23e61342c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-account-object/",
      "published_at": "2021-07-09T10:21:59Z",
      "updated_at": "2021-07-02T15:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage accounts. For child accounts, you'd use the child account object. Requirements You may not be able to use some aspects of this object. Before using, first read the requirements. Account object attributes Here are the Partnership API account object's attributes. name (REQUIRED to create an account) Type: String Default: (none) The account name attribute is required for new accounts. This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy phone_number Type: String Default: (none) Primary contact phone number for the account. allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you first create an account, this field is required, and only one user can be defined: the account Owner. To add additional users, use the Partnership API user object. For more on restrictions, read the Requirements. subscriptions (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of subscriptions. There are some restrictions in place dependent on the status of your account: For customer partnerships on our New Relic One pricing plan: ignore this field because it applies to the original pricing plan, not yours. If you use this, it will be ignored. For all other accounts: You are on our original product-based pricing plan. The subscriptions attribute is required for new accounts. If it is empty, default product tiers will be used. To update subscription information, use the Partnership API subscription object. Important When creating an account with this object, it can take some time for the account settings to populate. This means that the returned response may initially show aspects that are not true (for example, it may return a response showing default Lite subscriptions). To specify an empty JSON array, don't use subscriptions: [ {} ]. Instead, use this format: subscriptions: [ ] Copy The account API does not include an attribute to create a child account. Instead, to create child accounts, use the parent account's Account settings page in the New Relic UI. Account API calls Here are the URL patterns for account API functions. If using this URL pattern, send an HTTP header containing the Partner API key along with the JSON request body. For example: GET .../api/v2/partners/:PARTNER_ID/accounts/:ID x-api-key: :PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern List (index) all accounts of a partner. GET /api/v2/partners/PARTNER_ID/accounts Copy Show the attributes of an account. GET /api/v2/partners/PARTNER_ID/accounts/:ID Copy Update the attributes of an account. PUT /api/v2/partners/PARTNER_ID/accounts/:ID Copy Create an account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts Copy Cancel an account. DELETE /api/v2/partners/PARTNER_ID/accounts/:ID Copy Status definitions When an account is created or listed with an API call, the account status is included automatically. Some of these statuses don't apply to all pricing plans. Account status Definition pending Free account created, but primary admin is not yet activated. paid_pending Account created with a paid subscription, but the primary admin is not yet activated. new Free account, active primary admin, no application data has been collected. paid_new Paid subscription, active primary admin, no application data has been collected. active Free subscription, receiving application data. paid_active Paid subscription, receiving application data. upgraded Account's subscription was upgraded. downgraded Account's subscription was downgraded. cancelled The New Relic account subscription has been cancelled. suspended The New Relic account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the Partnership API account object. Note that this is just an example, and that for some accounts, the users and subscriptions attributes are unnecessary and are ignored. Account object JSON request { \"account\": { \"name\": \"Sample Account\", \"application_type\": \"ruby\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"subscriptions\": [ { \"product_id\": 4, \"quantity\": 10 }, { \"product_id\": 10, \"quantity\": 0 } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Account object API examples Partnerships with more than 1000 accounts return a paginated response. To specify a page, add the following parameter to the query: ?page= Copy Here are examples of calls using the Partnership API account object. Note that these are examples, and that for some accounts, the users and subscriptions attributes don't apply and will be ignored. List List request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts Copy Response (line breaks are for readability): { \"accounts\": [ { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": null, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } ] } Copy Show Request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": 00000, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Create Here's an example of creating an account for an organization on our original pricing plan and on our original user model. For an example call of creating an account for organizations with the newer models, see the example after this one. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample Account\", \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}],\"subscriptions\":[{\"product_id\": 4,\"quantity\": 10},{\"product_id\": 10,\"quantity\": 0}]}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Here's an example of creating an account for a customer partnership that is on our New Relic One pricing and our New Relic One account/user model. For more on restrictions on API use, see requirements. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Update You can only use the Partnership API account object to update the name, phone_number, testing and allow_API_access values. To update subscription and users values, you must use the Partnership API subscription object and Partnership API user object. Request: curl -X PUT \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account name\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Account New Name\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Delete Request: curl -X DELETE \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response: No response body.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.27686,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> API account object",
        "sections": "<em>Partnership</em> API account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " a list of users. There are some restrictions in place dependent on the status of your account: For customer <em>partnerships</em> who have switched to the <em>New</em> <em>Relic</em> One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you&#x27;d use these user"
      },
      "id": "603ebc5f196a679110a83dd5"
    }
  ],
  "/docs/new-relic-partnerships/partnerships/getting-started/using-partner-portal": [
    {
      "sections": [
        "Partnership admin console",
        "Console components",
        "Partnership configuration settings",
        "Customer activity monitoring",
        "State-of-the-Partnership report",
        "Partner customer monitoring",
        "View an arbitrary customer",
        "Viewing detailed customer data"
      ],
      "title": "Partnership admin console",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "670e4d2e1db957100b23a7b8b0af6bf50cc8c996",
      "image": "https://docs.newrelic.com/static/43369c88523ebf526ae58fa5719d4efe/0abdd/crop-partnership-owner-account-settings.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console/",
      "published_at": "2021-07-09T08:56:36Z",
      "updated_at": "2021-07-02T15:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Partnership Admin Console is the interface for managing your customers' accounts and integration with New Relic. To access the console, sign into the partnership owner account, and go to: https://partner-admin-console.newrelic.com/accounts/ACCOUNT_ID/admin_console/ Copy You can also access the console from the New Relic UI: Go to one.newrelic.com > (account dropdown) > Account settings. From the left menu bar, select Partnerships. one.newrelic.com > (account dropdown) > Account settings > Partnerships: Partnership owners can access the Partnership Admin Console from their account settings in the New Relic UI. Console components The Partnership Admin Console has two main components: Partnership configuration settings Customer activity monitoring If multiple partnerships are associated with the New Relic parent account, the menu also includes an option to switch partnership accounts. Partnership configuration settings In developing your integration with New Relic, you must specify a number of settings. For your convenience these settings are grouped together in the partnership console, including URLs for header/footer and various redirects, SSO configuration, and keys and the ability to manipulate them. Customer activity monitoring New Relic provides you with two tools for managing your customers: State-of-the-Partnership reports and live monitoring of all deployed New Relic agents in your partnership. Both of these tools provide insight into your customers who are using New Relic. They can be used to identify up-sale opportunities or to assist your support group in proactive support. State-of-the-Partnership report The State-of-the-Partnership report provides a summary of your customers with New Relic accounts and their activities. The report is broken down by language of the agents deployed, the agent version and the language version for each account. This report is run weekly for each partner. It is available on request from your New Relic Business Development contact. This report is an excellent way to see which of your customers with New Relic accounts are in fact using the service. Partner customer monitoring The Partner customer monitoring facility provides application performance data on the New Relic enabled applications that are running on your service. This facility allows you to easily identify customers experiencing performance problems. Where the performance problems are caused by under capacity, these customers are excellent sales opportunities. Alternatively your support or services organization will find this information useful in pre-emptively identifying customer issues or as good prospects for consulting services. View an arbitrary customer To view activity of a customer that does not appear in any of the filtered views: Go to one.newrelic.com > (account dropdown) > Switch accounts > Other accounts. New Relic will list all of the reporting accounts in the partnership. You can filter or search the list. Viewing detailed customer data Under normal circumstances a partner will be able to see only the summary level data in a customer's New Relic account. Through the Partnership Admin Console, partners will be permitted to drill down to the more detailed presentation. If you want to drill down from the Partnership Admin Console, add your user (typically support@partner.com or something similar) to the account. Typically this will be done at account creation. Avoid provisioning this user as the account Owner.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.19513,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> admin console",
        "sections": "<em>Partnership</em> admin console",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " the console from the <em>New</em> <em>Relic</em> UI: Go to one.newrelic.com &gt; (account dropdown) &gt; Account settings. From the left menu bar, select <em>Partnerships</em>. one.newrelic.com &gt; (account dropdown) &gt; Account settings &gt; <em>Partnerships</em>: <em>Partnership</em> owners can access the <em>Partnership</em> Admin Console from their account settings"
      },
      "id": "603ed3e3196a6735baa83dad"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.73405,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> organizations set up as <em>partnership</em> accounts have access to an enhanced hierarchical way of organizing their account structure. <em>Partnerships</em> with <em>New</em> <em>Relic</em> There are two types of <em>New</em> <em>Relic</em> organizations that are able to use our <em>partnership</em> account structure and the <em>Partnership</em> API"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Partnership API account object",
        "Requirements",
        "Account object attributes",
        "name (REQUIRED to create an account)",
        "phone_number",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "subscriptions (REQUIRED for some accounts)",
        "Important",
        "Account API calls",
        "Status definitions",
        "JSON example",
        "Account object JSON request",
        "JSON response",
        "Account object API examples",
        "List",
        "Show",
        "Create",
        "Update",
        "Delete"
      ],
      "title": "Partnership API account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "0b1fde4800f2f9f355e0381796f55e23e61342c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-account-object/",
      "published_at": "2021-07-09T10:21:59Z",
      "updated_at": "2021-07-02T15:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage accounts. For child accounts, you'd use the child account object. Requirements You may not be able to use some aspects of this object. Before using, first read the requirements. Account object attributes Here are the Partnership API account object's attributes. name (REQUIRED to create an account) Type: String Default: (none) The account name attribute is required for new accounts. This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy phone_number Type: String Default: (none) Primary contact phone number for the account. allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you first create an account, this field is required, and only one user can be defined: the account Owner. To add additional users, use the Partnership API user object. For more on restrictions, read the Requirements. subscriptions (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of subscriptions. There are some restrictions in place dependent on the status of your account: For customer partnerships on our New Relic One pricing plan: ignore this field because it applies to the original pricing plan, not yours. If you use this, it will be ignored. For all other accounts: You are on our original product-based pricing plan. The subscriptions attribute is required for new accounts. If it is empty, default product tiers will be used. To update subscription information, use the Partnership API subscription object. Important When creating an account with this object, it can take some time for the account settings to populate. This means that the returned response may initially show aspects that are not true (for example, it may return a response showing default Lite subscriptions). To specify an empty JSON array, don't use subscriptions: [ {} ]. Instead, use this format: subscriptions: [ ] Copy The account API does not include an attribute to create a child account. Instead, to create child accounts, use the parent account's Account settings page in the New Relic UI. Account API calls Here are the URL patterns for account API functions. If using this URL pattern, send an HTTP header containing the Partner API key along with the JSON request body. For example: GET .../api/v2/partners/:PARTNER_ID/accounts/:ID x-api-key: :PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern List (index) all accounts of a partner. GET /api/v2/partners/PARTNER_ID/accounts Copy Show the attributes of an account. GET /api/v2/partners/PARTNER_ID/accounts/:ID Copy Update the attributes of an account. PUT /api/v2/partners/PARTNER_ID/accounts/:ID Copy Create an account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts Copy Cancel an account. DELETE /api/v2/partners/PARTNER_ID/accounts/:ID Copy Status definitions When an account is created or listed with an API call, the account status is included automatically. Some of these statuses don't apply to all pricing plans. Account status Definition pending Free account created, but primary admin is not yet activated. paid_pending Account created with a paid subscription, but the primary admin is not yet activated. new Free account, active primary admin, no application data has been collected. paid_new Paid subscription, active primary admin, no application data has been collected. active Free subscription, receiving application data. paid_active Paid subscription, receiving application data. upgraded Account's subscription was upgraded. downgraded Account's subscription was downgraded. cancelled The New Relic account subscription has been cancelled. suspended The New Relic account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the Partnership API account object. Note that this is just an example, and that for some accounts, the users and subscriptions attributes are unnecessary and are ignored. Account object JSON request { \"account\": { \"name\": \"Sample Account\", \"application_type\": \"ruby\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"subscriptions\": [ { \"product_id\": 4, \"quantity\": 10 }, { \"product_id\": 10, \"quantity\": 0 } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Account object API examples Partnerships with more than 1000 accounts return a paginated response. To specify a page, add the following parameter to the query: ?page= Copy Here are examples of calls using the Partnership API account object. Note that these are examples, and that for some accounts, the users and subscriptions attributes don't apply and will be ignored. List List request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts Copy Response (line breaks are for readability): { \"accounts\": [ { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": null, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } ] } Copy Show Request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": 00000, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Create Here's an example of creating an account for an organization on our original pricing plan and on our original user model. For an example call of creating an account for organizations with the newer models, see the example after this one. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample Account\", \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}],\"subscriptions\":[{\"product_id\": 4,\"quantity\": 10},{\"product_id\": 10,\"quantity\": 0}]}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Here's an example of creating an account for a customer partnership that is on our New Relic One pricing and our New Relic One account/user model. For more on restrictions on API use, see requirements. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Update You can only use the Partnership API account object to update the name, phone_number, testing and allow_API_access values. To update subscription and users values, you must use the Partnership API subscription object and Partnership API user object. Request: curl -X PUT \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account name\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Account New Name\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Delete Request: curl -X DELETE \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response: No response body.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.27686,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> API account object",
        "sections": "<em>Partnership</em> API account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " a list of users. There are some restrictions in place dependent on the status of your account: For customer <em>partnerships</em> who have switched to the <em>New</em> <em>Relic</em> One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you&#x27;d use these user"
      },
      "id": "603ebc5f196a679110a83dd5"
    }
  ],
  "/docs/new-relic-partnerships/partnerships/partner-api/partner-api-reference": [
    {
      "sections": [
        "Partnership API account object",
        "Requirements",
        "Account object attributes",
        "name (REQUIRED to create an account)",
        "phone_number",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "subscriptions (REQUIRED for some accounts)",
        "Important",
        "Account API calls",
        "Status definitions",
        "JSON example",
        "Account object JSON request",
        "JSON response",
        "Account object API examples",
        "List",
        "Show",
        "Create",
        "Update",
        "Delete"
      ],
      "title": "Partnership API account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "0b1fde4800f2f9f355e0381796f55e23e61342c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-account-object/",
      "published_at": "2021-07-09T10:21:59Z",
      "updated_at": "2021-07-02T15:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage accounts. For child accounts, you'd use the child account object. Requirements You may not be able to use some aspects of this object. Before using, first read the requirements. Account object attributes Here are the Partnership API account object's attributes. name (REQUIRED to create an account) Type: String Default: (none) The account name attribute is required for new accounts. This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy phone_number Type: String Default: (none) Primary contact phone number for the account. allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you first create an account, this field is required, and only one user can be defined: the account Owner. To add additional users, use the Partnership API user object. For more on restrictions, read the Requirements. subscriptions (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of subscriptions. There are some restrictions in place dependent on the status of your account: For customer partnerships on our New Relic One pricing plan: ignore this field because it applies to the original pricing plan, not yours. If you use this, it will be ignored. For all other accounts: You are on our original product-based pricing plan. The subscriptions attribute is required for new accounts. If it is empty, default product tiers will be used. To update subscription information, use the Partnership API subscription object. Important When creating an account with this object, it can take some time for the account settings to populate. This means that the returned response may initially show aspects that are not true (for example, it may return a response showing default Lite subscriptions). To specify an empty JSON array, don't use subscriptions: [ {} ]. Instead, use this format: subscriptions: [ ] Copy The account API does not include an attribute to create a child account. Instead, to create child accounts, use the parent account's Account settings page in the New Relic UI. Account API calls Here are the URL patterns for account API functions. If using this URL pattern, send an HTTP header containing the Partner API key along with the JSON request body. For example: GET .../api/v2/partners/:PARTNER_ID/accounts/:ID x-api-key: :PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern List (index) all accounts of a partner. GET /api/v2/partners/PARTNER_ID/accounts Copy Show the attributes of an account. GET /api/v2/partners/PARTNER_ID/accounts/:ID Copy Update the attributes of an account. PUT /api/v2/partners/PARTNER_ID/accounts/:ID Copy Create an account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts Copy Cancel an account. DELETE /api/v2/partners/PARTNER_ID/accounts/:ID Copy Status definitions When an account is created or listed with an API call, the account status is included automatically. Some of these statuses don't apply to all pricing plans. Account status Definition pending Free account created, but primary admin is not yet activated. paid_pending Account created with a paid subscription, but the primary admin is not yet activated. new Free account, active primary admin, no application data has been collected. paid_new Paid subscription, active primary admin, no application data has been collected. active Free subscription, receiving application data. paid_active Paid subscription, receiving application data. upgraded Account's subscription was upgraded. downgraded Account's subscription was downgraded. cancelled The New Relic account subscription has been cancelled. suspended The New Relic account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the Partnership API account object. Note that this is just an example, and that for some accounts, the users and subscriptions attributes are unnecessary and are ignored. Account object JSON request { \"account\": { \"name\": \"Sample Account\", \"application_type\": \"ruby\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"subscriptions\": [ { \"product_id\": 4, \"quantity\": 10 }, { \"product_id\": 10, \"quantity\": 0 } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Account object API examples Partnerships with more than 1000 accounts return a paginated response. To specify a page, add the following parameter to the query: ?page= Copy Here are examples of calls using the Partnership API account object. Note that these are examples, and that for some accounts, the users and subscriptions attributes don't apply and will be ignored. List List request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts Copy Response (line breaks are for readability): { \"accounts\": [ { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": null, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } ] } Copy Show Request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": 00000, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Create Here's an example of creating an account for an organization on our original pricing plan and on our original user model. For an example call of creating an account for organizations with the newer models, see the example after this one. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample Account\", \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}],\"subscriptions\":[{\"product_id\": 4,\"quantity\": 10},{\"product_id\": 10,\"quantity\": 0}]}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Here's an example of creating an account for a customer partnership that is on our New Relic One pricing and our New Relic One account/user model. For more on restrictions on API use, see requirements. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Update You can only use the Partnership API account object to update the name, phone_number, testing and allow_API_access values. To update subscription and users values, you must use the Partnership API subscription object and Partnership API user object. Request: curl -X PUT \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account name\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Account New Name\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Delete Request: curl -X DELETE \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response: No response body.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.97488,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> account object",
        "sections": "<em>Partnership</em> <em>API</em> account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "&#x27;s subscription was downgraded. cancelled The <em>New</em> <em>Relic</em> account subscription has been cancelled. suspended The <em>New</em> <em>Relic</em> account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ebc5f196a679110a83dd5"
    },
    {
      "sections": [
        "Partnership API child account object",
        "Requirements",
        "Introduction to using child accounts",
        "Child account object attributes",
        "name (REQUIRED)",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "password (REQUIRED)",
        "Child account API calls",
        "JSON example",
        "Child account object JSON request",
        "JSON response",
        "Child account object API examples",
        "Create"
      ],
      "title": "Partnership API child account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "7fb13302d892a5f89c6c9371f35a60bf1ed9f6a5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-sub-account-object/",
      "published_at": "2021-07-09T10:22:56Z",
      "updated_at": "2021-07-02T13:14:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage child accounts. For accounts, you'd use the child account object. Requirements You may not have access to using this object. Before using the Partnership API, first read the requirements. Introduction to using child accounts Some notes about using the child account object: To manage existing parent accounts or child accounts, use the Partnership API account object. A parent account may have more than one associated child account, but every chld account must correspond to one and only one parent account. Every child account must have at least a primary_admin user. You cannot create a child account without connecting it to an existing parent account and adding at least one user. Child account object attributes Before using the Partnership API, first read the requirements. Here are the Partnership API child account object's attributes: name (REQUIRED) Type: String Default: (none) This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you create the child account, you can define only one user: the account Owner. To add additional users, use the Partnership API user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user's current password. For some New Relic organizations, child accounts can also be created via the parent account's Account settings page in the New Relic UI. Child account API calls Here is the URL pattern to create child accounts. Notice that the Parent Account ID must be specified. If using this URL pattern, send the JSON object along with an HTTP header containing the Partner API key. For example: POST .../api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts​ x-api-key:PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern Create a child account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy JSON example Here is an example of a JSON request and response using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Child account object JSON request { \"account\": { \"name\": \"Sample child account\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Child account object API examples Here is an example of an API call using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Create Request: curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"sub_account\":{\"name\":\"Sample child account\"}, \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}]}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample child account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": false, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.5021,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> child account object",
        "sections": "<em>Partnership</em> <em>API</em> child account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " additional users, use the <em>Partnership</em> <em>API</em> user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user&#x27;s current password. For some <em>New</em> <em>Relic</em>"
      },
      "id": "603eba3ae7b9d2b8e32a07b5"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.22879,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> organizations set up as <em>partnership</em> accounts have access to an enhanced hierarchical way of organizing their account structure. <em>Partnerships</em> with <em>New</em> <em>Relic</em> There are two types of <em>New</em> <em>Relic</em> organizations that are able to use our <em>partnership</em> account structure and the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    }
  ],
  "/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-account-object": [
    {
      "sections": [
        "Partnership API child account object",
        "Requirements",
        "Introduction to using child accounts",
        "Child account object attributes",
        "name (REQUIRED)",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "password (REQUIRED)",
        "Child account API calls",
        "JSON example",
        "Child account object JSON request",
        "JSON response",
        "Child account object API examples",
        "Create"
      ],
      "title": "Partnership API child account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "7fb13302d892a5f89c6c9371f35a60bf1ed9f6a5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-sub-account-object/",
      "published_at": "2021-07-09T10:22:56Z",
      "updated_at": "2021-07-02T13:14:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage child accounts. For accounts, you'd use the child account object. Requirements You may not have access to using this object. Before using the Partnership API, first read the requirements. Introduction to using child accounts Some notes about using the child account object: To manage existing parent accounts or child accounts, use the Partnership API account object. A parent account may have more than one associated child account, but every chld account must correspond to one and only one parent account. Every child account must have at least a primary_admin user. You cannot create a child account without connecting it to an existing parent account and adding at least one user. Child account object attributes Before using the Partnership API, first read the requirements. Here are the Partnership API child account object's attributes: name (REQUIRED) Type: String Default: (none) This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you create the child account, you can define only one user: the account Owner. To add additional users, use the Partnership API user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user's current password. For some New Relic organizations, child accounts can also be created via the parent account's Account settings page in the New Relic UI. Child account API calls Here is the URL pattern to create child accounts. Notice that the Parent Account ID must be specified. If using this URL pattern, send the JSON object along with an HTTP header containing the Partner API key. For example: POST .../api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts​ x-api-key:PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern Create a child account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy JSON example Here is an example of a JSON request and response using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Child account object JSON request { \"account\": { \"name\": \"Sample child account\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Child account object API examples Here is an example of an API call using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Create Request: curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"sub_account\":{\"name\":\"Sample child account\"}, \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}]}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample child account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": false, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.5021,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> child account object",
        "sections": "<em>Partnership</em> <em>API</em> child account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " additional users, use the <em>Partnership</em> <em>API</em> user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user&#x27;s current password. For some <em>New</em> <em>Relic</em>"
      },
      "id": "603eba3ae7b9d2b8e32a07b5"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.22879,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> organizations set up as <em>partnership</em> accounts have access to an enhanced hierarchical way of organizing their account structure. <em>Partnerships</em> with <em>New</em> <em>Relic</em> There are two types of <em>New</em> <em>Relic</em> organizations that are able to use our <em>partnership</em> account structure and the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Partnership billing integration API",
        "Requirements",
        "Communication endpoint",
        "Billing API",
        "Customer subscription notification API",
        "Invoice notification API"
      ],
      "title": "Partnership billing integration API",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "73da7e096ce56bb45e39bb95a1c2e0a0011be597",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-billing-integration-api/",
      "published_at": "2021-07-09T10:18:47Z",
      "updated_at": "2021-03-30T21:12:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Partnership API includes functionality for partners to replace a customer's existing subscription with a new one, or to update invoice information for New Relic partner accounts. This is particularly useful for partners acting as resellers or managed service providers of New Relic accounts. For example, when customers of a New Relic reseller partner purchase a higher subscription level from New Relic's Sales team, New Relic replaces the old subscription with a new subscription. New Relic then uses the API to communicate this information to the partner. Requirements Before using this object, please read the Partnership API requirements. Communication endpoint Partners must implement a billing communication endpoint that identifies the partner's URL and PARTNER_ID. New Relic uses this endpoint to notify the partner that New Relic has made a change to a partner account's subscription or invoice information. The endpoint must support HTTPS. The partner-specified portion of the URL is identified from the Settings tab of New Relic's Partner Portal. The PARTNER_ID is the partner's external ID for this account. This value must be passed when the account is created by using the partner_external_identifier parameter. Billing API Supported functionality for the Partnership billing API includes: Customer subscription notification Invoice information notification Customer subscription notification API To communicate changes to a partner about a customer's subscription, New Relic uses the POST method with this URI: https://partner-specified/partner-specified/PARTNER_ID.json Copy Authentication is done via headers with the partner's REST API key or Admin user's API key. The Partnership API returns the results as JSON. Parameters: Name Type Description id String The customer's New Relic account ID subscription_id Integer Subscription's numeric ID subscription_string String Description of subscription for display price Integer Monthly price of subscription in cents number_of_hosts Integer Number of hosts starts Date Subscription's start date (yyyymmdd) expires Date Subscription's end date (yyyymmdd) Return codes: 200: Successfully updated. 404: Account not found. 422: Missing or invalid parameters. Authentication failed. Invoice notification API New Relic uses this endpoint to notify the partner of changes to a partner account's subscription level and invoice information. New Relic uses the PUT method with this URI: https://partner-specified/partner-specified/PARTNER_ID.json Copy OR https://partner-specified/partner-specified/PARTNER_ID.xml Copy The Partnership API returns the results as JSON or XML. Parameters: Name Type Description id string The customer's New Relic account ID subscription_id integer Subscription's numeric ID subscription_string string Description of subscription for display price integer Monthly price of subscription in cents Return codes: 200: Successfully updated. 404: Account not found. 422: Missing or invalid parameters. Authentication failed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.83978,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> billing integration <em>API</em>",
        "sections": "<em>Partnership</em> billing integration <em>API</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>Partnership</em> <em>API</em> includes functionality for partners to replace a customer&#x27;s existing subscription with a <em>new</em> one, or to update invoice information for <em>New</em> <em>Relic</em> <em>partner</em> accounts. This is particularly useful for partners acting as resellers or managed service providers of <em>New</em> <em>Relic</em>"
      },
      "id": "603ec86e64441f09e44e8871"
    }
  ],
  "/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-keys": [
    {
      "sections": [
        "Partnership API account object",
        "Requirements",
        "Account object attributes",
        "name (REQUIRED to create an account)",
        "phone_number",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "subscriptions (REQUIRED for some accounts)",
        "Important",
        "Account API calls",
        "Status definitions",
        "JSON example",
        "Account object JSON request",
        "JSON response",
        "Account object API examples",
        "List",
        "Show",
        "Create",
        "Update",
        "Delete"
      ],
      "title": "Partnership API account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "0b1fde4800f2f9f355e0381796f55e23e61342c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-account-object/",
      "published_at": "2021-07-09T10:21:59Z",
      "updated_at": "2021-07-02T15:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage accounts. For child accounts, you'd use the child account object. Requirements You may not be able to use some aspects of this object. Before using, first read the requirements. Account object attributes Here are the Partnership API account object's attributes. name (REQUIRED to create an account) Type: String Default: (none) The account name attribute is required for new accounts. This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy phone_number Type: String Default: (none) Primary contact phone number for the account. allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you first create an account, this field is required, and only one user can be defined: the account Owner. To add additional users, use the Partnership API user object. For more on restrictions, read the Requirements. subscriptions (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of subscriptions. There are some restrictions in place dependent on the status of your account: For customer partnerships on our New Relic One pricing plan: ignore this field because it applies to the original pricing plan, not yours. If you use this, it will be ignored. For all other accounts: You are on our original product-based pricing plan. The subscriptions attribute is required for new accounts. If it is empty, default product tiers will be used. To update subscription information, use the Partnership API subscription object. Important When creating an account with this object, it can take some time for the account settings to populate. This means that the returned response may initially show aspects that are not true (for example, it may return a response showing default Lite subscriptions). To specify an empty JSON array, don't use subscriptions: [ {} ]. Instead, use this format: subscriptions: [ ] Copy The account API does not include an attribute to create a child account. Instead, to create child accounts, use the parent account's Account settings page in the New Relic UI. Account API calls Here are the URL patterns for account API functions. If using this URL pattern, send an HTTP header containing the Partner API key along with the JSON request body. For example: GET .../api/v2/partners/:PARTNER_ID/accounts/:ID x-api-key: :PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern List (index) all accounts of a partner. GET /api/v2/partners/PARTNER_ID/accounts Copy Show the attributes of an account. GET /api/v2/partners/PARTNER_ID/accounts/:ID Copy Update the attributes of an account. PUT /api/v2/partners/PARTNER_ID/accounts/:ID Copy Create an account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts Copy Cancel an account. DELETE /api/v2/partners/PARTNER_ID/accounts/:ID Copy Status definitions When an account is created or listed with an API call, the account status is included automatically. Some of these statuses don't apply to all pricing plans. Account status Definition pending Free account created, but primary admin is not yet activated. paid_pending Account created with a paid subscription, but the primary admin is not yet activated. new Free account, active primary admin, no application data has been collected. paid_new Paid subscription, active primary admin, no application data has been collected. active Free subscription, receiving application data. paid_active Paid subscription, receiving application data. upgraded Account's subscription was upgraded. downgraded Account's subscription was downgraded. cancelled The New Relic account subscription has been cancelled. suspended The New Relic account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the Partnership API account object. Note that this is just an example, and that for some accounts, the users and subscriptions attributes are unnecessary and are ignored. Account object JSON request { \"account\": { \"name\": \"Sample Account\", \"application_type\": \"ruby\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"subscriptions\": [ { \"product_id\": 4, \"quantity\": 10 }, { \"product_id\": 10, \"quantity\": 0 } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Account object API examples Partnerships with more than 1000 accounts return a paginated response. To specify a page, add the following parameter to the query: ?page= Copy Here are examples of calls using the Partnership API account object. Note that these are examples, and that for some accounts, the users and subscriptions attributes don't apply and will be ignored. List List request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts Copy Response (line breaks are for readability): { \"accounts\": [ { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": null, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } ] } Copy Show Request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": 00000, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Create Here's an example of creating an account for an organization on our original pricing plan and on our original user model. For an example call of creating an account for organizations with the newer models, see the example after this one. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample Account\", \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}],\"subscriptions\":[{\"product_id\": 4,\"quantity\": 10},{\"product_id\": 10,\"quantity\": 0}]}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Here's an example of creating an account for a customer partnership that is on our New Relic One pricing and our New Relic One account/user model. For more on restrictions on API use, see requirements. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Update You can only use the Partnership API account object to update the name, phone_number, testing and allow_API_access values. To update subscription and users values, you must use the Partnership API subscription object and Partnership API user object. Request: curl -X PUT \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account name\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Account New Name\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Delete Request: curl -X DELETE \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response: No response body.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.97482,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> account object",
        "sections": "<em>Partnership</em> <em>API</em> account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "&#x27;s subscription was downgraded. cancelled The <em>New</em> <em>Relic</em> account subscription has been cancelled. suspended The <em>New</em> <em>Relic</em> account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ebc5f196a679110a83dd5"
    },
    {
      "sections": [
        "Partnership API child account object",
        "Requirements",
        "Introduction to using child accounts",
        "Child account object attributes",
        "name (REQUIRED)",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "password (REQUIRED)",
        "Child account API calls",
        "JSON example",
        "Child account object JSON request",
        "JSON response",
        "Child account object API examples",
        "Create"
      ],
      "title": "Partnership API child account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "7fb13302d892a5f89c6c9371f35a60bf1ed9f6a5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-sub-account-object/",
      "published_at": "2021-07-09T10:22:56Z",
      "updated_at": "2021-07-02T13:14:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage child accounts. For accounts, you'd use the child account object. Requirements You may not have access to using this object. Before using the Partnership API, first read the requirements. Introduction to using child accounts Some notes about using the child account object: To manage existing parent accounts or child accounts, use the Partnership API account object. A parent account may have more than one associated child account, but every chld account must correspond to one and only one parent account. Every child account must have at least a primary_admin user. You cannot create a child account without connecting it to an existing parent account and adding at least one user. Child account object attributes Before using the Partnership API, first read the requirements. Here are the Partnership API child account object's attributes: name (REQUIRED) Type: String Default: (none) This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you create the child account, you can define only one user: the account Owner. To add additional users, use the Partnership API user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user's current password. For some New Relic organizations, child accounts can also be created via the parent account's Account settings page in the New Relic UI. Child account API calls Here is the URL pattern to create child accounts. Notice that the Parent Account ID must be specified. If using this URL pattern, send the JSON object along with an HTTP header containing the Partner API key. For example: POST .../api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts​ x-api-key:PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern Create a child account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy JSON example Here is an example of a JSON request and response using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Child account object JSON request { \"account\": { \"name\": \"Sample child account\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Child account object API examples Here is an example of an API call using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Create Request: curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"sub_account\":{\"name\":\"Sample child account\"}, \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}]}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample child account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": false, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.50204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> child account object",
        "sections": "<em>Partnership</em> <em>API</em> child account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " additional users, use the <em>Partnership</em> <em>API</em> user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user&#x27;s current password. For some <em>New</em> <em>Relic</em>"
      },
      "id": "603eba3ae7b9d2b8e32a07b5"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.22874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> organizations set up as <em>partnership</em> accounts have access to an enhanced hierarchical way of organizing their account structure. <em>Partnerships</em> with <em>New</em> <em>Relic</em> There are two types of <em>New</em> <em>Relic</em> organizations that are able to use our <em>partnership</em> account structure and the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    }
  ],
  "/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-sub-account-object": [
    {
      "sections": [
        "Partnership API account object",
        "Requirements",
        "Account object attributes",
        "name (REQUIRED to create an account)",
        "phone_number",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "subscriptions (REQUIRED for some accounts)",
        "Important",
        "Account API calls",
        "Status definitions",
        "JSON example",
        "Account object JSON request",
        "JSON response",
        "Account object API examples",
        "List",
        "Show",
        "Create",
        "Update",
        "Delete"
      ],
      "title": "Partnership API account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "0b1fde4800f2f9f355e0381796f55e23e61342c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-account-object/",
      "published_at": "2021-07-09T10:21:59Z",
      "updated_at": "2021-07-02T15:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage accounts. For child accounts, you'd use the child account object. Requirements You may not be able to use some aspects of this object. Before using, first read the requirements. Account object attributes Here are the Partnership API account object's attributes. name (REQUIRED to create an account) Type: String Default: (none) The account name attribute is required for new accounts. This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy phone_number Type: String Default: (none) Primary contact phone number for the account. allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you first create an account, this field is required, and only one user can be defined: the account Owner. To add additional users, use the Partnership API user object. For more on restrictions, read the Requirements. subscriptions (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of subscriptions. There are some restrictions in place dependent on the status of your account: For customer partnerships on our New Relic One pricing plan: ignore this field because it applies to the original pricing plan, not yours. If you use this, it will be ignored. For all other accounts: You are on our original product-based pricing plan. The subscriptions attribute is required for new accounts. If it is empty, default product tiers will be used. To update subscription information, use the Partnership API subscription object. Important When creating an account with this object, it can take some time for the account settings to populate. This means that the returned response may initially show aspects that are not true (for example, it may return a response showing default Lite subscriptions). To specify an empty JSON array, don't use subscriptions: [ {} ]. Instead, use this format: subscriptions: [ ] Copy The account API does not include an attribute to create a child account. Instead, to create child accounts, use the parent account's Account settings page in the New Relic UI. Account API calls Here are the URL patterns for account API functions. If using this URL pattern, send an HTTP header containing the Partner API key along with the JSON request body. For example: GET .../api/v2/partners/:PARTNER_ID/accounts/:ID x-api-key: :PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern List (index) all accounts of a partner. GET /api/v2/partners/PARTNER_ID/accounts Copy Show the attributes of an account. GET /api/v2/partners/PARTNER_ID/accounts/:ID Copy Update the attributes of an account. PUT /api/v2/partners/PARTNER_ID/accounts/:ID Copy Create an account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts Copy Cancel an account. DELETE /api/v2/partners/PARTNER_ID/accounts/:ID Copy Status definitions When an account is created or listed with an API call, the account status is included automatically. Some of these statuses don't apply to all pricing plans. Account status Definition pending Free account created, but primary admin is not yet activated. paid_pending Account created with a paid subscription, but the primary admin is not yet activated. new Free account, active primary admin, no application data has been collected. paid_new Paid subscription, active primary admin, no application data has been collected. active Free subscription, receiving application data. paid_active Paid subscription, receiving application data. upgraded Account's subscription was upgraded. downgraded Account's subscription was downgraded. cancelled The New Relic account subscription has been cancelled. suspended The New Relic account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the Partnership API account object. Note that this is just an example, and that for some accounts, the users and subscriptions attributes are unnecessary and are ignored. Account object JSON request { \"account\": { \"name\": \"Sample Account\", \"application_type\": \"ruby\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"subscriptions\": [ { \"product_id\": 4, \"quantity\": 10 }, { \"product_id\": 10, \"quantity\": 0 } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Account object API examples Partnerships with more than 1000 accounts return a paginated response. To specify a page, add the following parameter to the query: ?page= Copy Here are examples of calls using the Partnership API account object. Note that these are examples, and that for some accounts, the users and subscriptions attributes don't apply and will be ignored. List List request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts Copy Response (line breaks are for readability): { \"accounts\": [ { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": null, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } ] } Copy Show Request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": 00000, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Create Here's an example of creating an account for an organization on our original pricing plan and on our original user model. For an example call of creating an account for organizations with the newer models, see the example after this one. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample Account\", \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}],\"subscriptions\":[{\"product_id\": 4,\"quantity\": 10},{\"product_id\": 10,\"quantity\": 0}]}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Here's an example of creating an account for a customer partnership that is on our New Relic One pricing and our New Relic One account/user model. For more on restrictions on API use, see requirements. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Update You can only use the Partnership API account object to update the name, phone_number, testing and allow_API_access values. To update subscription and users values, you must use the Partnership API subscription object and Partnership API user object. Request: curl -X PUT \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account name\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Account New Name\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Delete Request: curl -X DELETE \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response: No response body.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.97482,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> account object",
        "sections": "<em>Partnership</em> <em>API</em> account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "&#x27;s subscription was downgraded. cancelled The <em>New</em> <em>Relic</em> account subscription has been cancelled. suspended The <em>New</em> <em>Relic</em> account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ebc5f196a679110a83dd5"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.22874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> organizations set up as <em>partnership</em> accounts have access to an enhanced hierarchical way of organizing their account structure. <em>Partnerships</em> with <em>New</em> <em>Relic</em> There are two types of <em>New</em> <em>Relic</em> organizations that are able to use our <em>partnership</em> account structure and the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Partnership billing integration API",
        "Requirements",
        "Communication endpoint",
        "Billing API",
        "Customer subscription notification API",
        "Invoice notification API"
      ],
      "title": "Partnership billing integration API",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "73da7e096ce56bb45e39bb95a1c2e0a0011be597",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-billing-integration-api/",
      "published_at": "2021-07-09T10:18:47Z",
      "updated_at": "2021-03-30T21:12:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Partnership API includes functionality for partners to replace a customer's existing subscription with a new one, or to update invoice information for New Relic partner accounts. This is particularly useful for partners acting as resellers or managed service providers of New Relic accounts. For example, when customers of a New Relic reseller partner purchase a higher subscription level from New Relic's Sales team, New Relic replaces the old subscription with a new subscription. New Relic then uses the API to communicate this information to the partner. Requirements Before using this object, please read the Partnership API requirements. Communication endpoint Partners must implement a billing communication endpoint that identifies the partner's URL and PARTNER_ID. New Relic uses this endpoint to notify the partner that New Relic has made a change to a partner account's subscription or invoice information. The endpoint must support HTTPS. The partner-specified portion of the URL is identified from the Settings tab of New Relic's Partner Portal. The PARTNER_ID is the partner's external ID for this account. This value must be passed when the account is created by using the partner_external_identifier parameter. Billing API Supported functionality for the Partnership billing API includes: Customer subscription notification Invoice information notification Customer subscription notification API To communicate changes to a partner about a customer's subscription, New Relic uses the POST method with this URI: https://partner-specified/partner-specified/PARTNER_ID.json Copy Authentication is done via headers with the partner's REST API key or Admin user's API key. The Partnership API returns the results as JSON. Parameters: Name Type Description id String The customer's New Relic account ID subscription_id Integer Subscription's numeric ID subscription_string String Description of subscription for display price Integer Monthly price of subscription in cents number_of_hosts Integer Number of hosts starts Date Subscription's start date (yyyymmdd) expires Date Subscription's end date (yyyymmdd) Return codes: 200: Successfully updated. 404: Account not found. 422: Missing or invalid parameters. Authentication failed. Invoice notification API New Relic uses this endpoint to notify the partner of changes to a partner account's subscription level and invoice information. New Relic uses the PUT method with this URI: https://partner-specified/partner-specified/PARTNER_ID.json Copy OR https://partner-specified/partner-specified/PARTNER_ID.xml Copy The Partnership API returns the results as JSON or XML. Parameters: Name Type Description id string The customer's New Relic account ID subscription_id integer Subscription's numeric ID subscription_string string Description of subscription for display price integer Monthly price of subscription in cents Return codes: 200: Successfully updated. 404: Account not found. 422: Missing or invalid parameters. Authentication failed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.83978,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> billing integration <em>API</em>",
        "sections": "<em>Partnership</em> billing integration <em>API</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em>&#x27;s <em>Partnership</em> <em>API</em> includes functionality for partners to replace a customer&#x27;s existing subscription with a <em>new</em> one, or to update invoice information for <em>New</em> <em>Relic</em> <em>partner</em> accounts. This is particularly useful for partners acting as resellers or managed service providers of <em>New</em> <em>Relic</em>"
      },
      "id": "603ec86e64441f09e44e8871"
    }
  ],
  "/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-subscription-object": [
    {
      "sections": [
        "Partnership API account object",
        "Requirements",
        "Account object attributes",
        "name (REQUIRED to create an account)",
        "phone_number",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "subscriptions (REQUIRED for some accounts)",
        "Important",
        "Account API calls",
        "Status definitions",
        "JSON example",
        "Account object JSON request",
        "JSON response",
        "Account object API examples",
        "List",
        "Show",
        "Create",
        "Update",
        "Delete"
      ],
      "title": "Partnership API account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "0b1fde4800f2f9f355e0381796f55e23e61342c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-account-object/",
      "published_at": "2021-07-09T10:21:59Z",
      "updated_at": "2021-07-02T15:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage accounts. For child accounts, you'd use the child account object. Requirements You may not be able to use some aspects of this object. Before using, first read the requirements. Account object attributes Here are the Partnership API account object's attributes. name (REQUIRED to create an account) Type: String Default: (none) The account name attribute is required for new accounts. This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy phone_number Type: String Default: (none) Primary contact phone number for the account. allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you first create an account, this field is required, and only one user can be defined: the account Owner. To add additional users, use the Partnership API user object. For more on restrictions, read the Requirements. subscriptions (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of subscriptions. There are some restrictions in place dependent on the status of your account: For customer partnerships on our New Relic One pricing plan: ignore this field because it applies to the original pricing plan, not yours. If you use this, it will be ignored. For all other accounts: You are on our original product-based pricing plan. The subscriptions attribute is required for new accounts. If it is empty, default product tiers will be used. To update subscription information, use the Partnership API subscription object. Important When creating an account with this object, it can take some time for the account settings to populate. This means that the returned response may initially show aspects that are not true (for example, it may return a response showing default Lite subscriptions). To specify an empty JSON array, don't use subscriptions: [ {} ]. Instead, use this format: subscriptions: [ ] Copy The account API does not include an attribute to create a child account. Instead, to create child accounts, use the parent account's Account settings page in the New Relic UI. Account API calls Here are the URL patterns for account API functions. If using this URL pattern, send an HTTP header containing the Partner API key along with the JSON request body. For example: GET .../api/v2/partners/:PARTNER_ID/accounts/:ID x-api-key: :PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern List (index) all accounts of a partner. GET /api/v2/partners/PARTNER_ID/accounts Copy Show the attributes of an account. GET /api/v2/partners/PARTNER_ID/accounts/:ID Copy Update the attributes of an account. PUT /api/v2/partners/PARTNER_ID/accounts/:ID Copy Create an account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts Copy Cancel an account. DELETE /api/v2/partners/PARTNER_ID/accounts/:ID Copy Status definitions When an account is created or listed with an API call, the account status is included automatically. Some of these statuses don't apply to all pricing plans. Account status Definition pending Free account created, but primary admin is not yet activated. paid_pending Account created with a paid subscription, but the primary admin is not yet activated. new Free account, active primary admin, no application data has been collected. paid_new Paid subscription, active primary admin, no application data has been collected. active Free subscription, receiving application data. paid_active Paid subscription, receiving application data. upgraded Account's subscription was upgraded. downgraded Account's subscription was downgraded. cancelled The New Relic account subscription has been cancelled. suspended The New Relic account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the Partnership API account object. Note that this is just an example, and that for some accounts, the users and subscriptions attributes are unnecessary and are ignored. Account object JSON request { \"account\": { \"name\": \"Sample Account\", \"application_type\": \"ruby\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"subscriptions\": [ { \"product_id\": 4, \"quantity\": 10 }, { \"product_id\": 10, \"quantity\": 0 } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Account object API examples Partnerships with more than 1000 accounts return a paginated response. To specify a page, add the following parameter to the query: ?page= Copy Here are examples of calls using the Partnership API account object. Note that these are examples, and that for some accounts, the users and subscriptions attributes don't apply and will be ignored. List List request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts Copy Response (line breaks are for readability): { \"accounts\": [ { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": null, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } ] } Copy Show Request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": 00000, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Create Here's an example of creating an account for an organization on our original pricing plan and on our original user model. For an example call of creating an account for organizations with the newer models, see the example after this one. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample Account\", \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}],\"subscriptions\":[{\"product_id\": 4,\"quantity\": 10},{\"product_id\": 10,\"quantity\": 0}]}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Here's an example of creating an account for a customer partnership that is on our New Relic One pricing and our New Relic One account/user model. For more on restrictions on API use, see requirements. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Update You can only use the Partnership API account object to update the name, phone_number, testing and allow_API_access values. To update subscription and users values, you must use the Partnership API subscription object and Partnership API user object. Request: curl -X PUT \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account name\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Account New Name\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Delete Request: curl -X DELETE \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response: No response body.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.97482,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> account object",
        "sections": "<em>Partnership</em> <em>API</em> account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "&#x27;s subscription was downgraded. cancelled The <em>New</em> <em>Relic</em> account subscription has been cancelled. suspended The <em>New</em> <em>Relic</em> account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ebc5f196a679110a83dd5"
    },
    {
      "sections": [
        "Partnership API child account object",
        "Requirements",
        "Introduction to using child accounts",
        "Child account object attributes",
        "name (REQUIRED)",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "password (REQUIRED)",
        "Child account API calls",
        "JSON example",
        "Child account object JSON request",
        "JSON response",
        "Child account object API examples",
        "Create"
      ],
      "title": "Partnership API child account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "7fb13302d892a5f89c6c9371f35a60bf1ed9f6a5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-sub-account-object/",
      "published_at": "2021-07-09T10:22:56Z",
      "updated_at": "2021-07-02T13:14:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage child accounts. For accounts, you'd use the child account object. Requirements You may not have access to using this object. Before using the Partnership API, first read the requirements. Introduction to using child accounts Some notes about using the child account object: To manage existing parent accounts or child accounts, use the Partnership API account object. A parent account may have more than one associated child account, but every chld account must correspond to one and only one parent account. Every child account must have at least a primary_admin user. You cannot create a child account without connecting it to an existing parent account and adding at least one user. Child account object attributes Before using the Partnership API, first read the requirements. Here are the Partnership API child account object's attributes: name (REQUIRED) Type: String Default: (none) This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you create the child account, you can define only one user: the account Owner. To add additional users, use the Partnership API user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user's current password. For some New Relic organizations, child accounts can also be created via the parent account's Account settings page in the New Relic UI. Child account API calls Here is the URL pattern to create child accounts. Notice that the Parent Account ID must be specified. If using this URL pattern, send the JSON object along with an HTTP header containing the Partner API key. For example: POST .../api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts​ x-api-key:PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern Create a child account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy JSON example Here is an example of a JSON request and response using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Child account object JSON request { \"account\": { \"name\": \"Sample child account\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Child account object API examples Here is an example of an API call using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Create Request: curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"sub_account\":{\"name\":\"Sample child account\"}, \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}]}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample child account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": false, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.50204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> child account object",
        "sections": "<em>Partnership</em> <em>API</em> child account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " additional users, use the <em>Partnership</em> <em>API</em> user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user&#x27;s current password. For some <em>New</em> <em>Relic</em>"
      },
      "id": "603eba3ae7b9d2b8e32a07b5"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.22874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> organizations set up as <em>partnership</em> accounts have access to an enhanced hierarchical way of organizing their account structure. <em>Partnerships</em> with <em>New</em> <em>Relic</em> There are two types of <em>New</em> <em>Relic</em> organizations that are able to use our <em>partnership</em> account structure and the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    }
  ],
  "/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-user-object": [
    {
      "sections": [
        "Partnership API account object",
        "Requirements",
        "Account object attributes",
        "name (REQUIRED to create an account)",
        "phone_number",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "subscriptions (REQUIRED for some accounts)",
        "Important",
        "Account API calls",
        "Status definitions",
        "JSON example",
        "Account object JSON request",
        "JSON response",
        "Account object API examples",
        "List",
        "Show",
        "Create",
        "Update",
        "Delete"
      ],
      "title": "Partnership API account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "0b1fde4800f2f9f355e0381796f55e23e61342c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-account-object/",
      "published_at": "2021-07-09T10:21:59Z",
      "updated_at": "2021-07-02T15:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage accounts. For child accounts, you'd use the child account object. Requirements You may not be able to use some aspects of this object. Before using, first read the requirements. Account object attributes Here are the Partnership API account object's attributes. name (REQUIRED to create an account) Type: String Default: (none) The account name attribute is required for new accounts. This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy phone_number Type: String Default: (none) Primary contact phone number for the account. allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you first create an account, this field is required, and only one user can be defined: the account Owner. To add additional users, use the Partnership API user object. For more on restrictions, read the Requirements. subscriptions (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of subscriptions. There are some restrictions in place dependent on the status of your account: For customer partnerships on our New Relic One pricing plan: ignore this field because it applies to the original pricing plan, not yours. If you use this, it will be ignored. For all other accounts: You are on our original product-based pricing plan. The subscriptions attribute is required for new accounts. If it is empty, default product tiers will be used. To update subscription information, use the Partnership API subscription object. Important When creating an account with this object, it can take some time for the account settings to populate. This means that the returned response may initially show aspects that are not true (for example, it may return a response showing default Lite subscriptions). To specify an empty JSON array, don't use subscriptions: [ {} ]. Instead, use this format: subscriptions: [ ] Copy The account API does not include an attribute to create a child account. Instead, to create child accounts, use the parent account's Account settings page in the New Relic UI. Account API calls Here are the URL patterns for account API functions. If using this URL pattern, send an HTTP header containing the Partner API key along with the JSON request body. For example: GET .../api/v2/partners/:PARTNER_ID/accounts/:ID x-api-key: :PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern List (index) all accounts of a partner. GET /api/v2/partners/PARTNER_ID/accounts Copy Show the attributes of an account. GET /api/v2/partners/PARTNER_ID/accounts/:ID Copy Update the attributes of an account. PUT /api/v2/partners/PARTNER_ID/accounts/:ID Copy Create an account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts Copy Cancel an account. DELETE /api/v2/partners/PARTNER_ID/accounts/:ID Copy Status definitions When an account is created or listed with an API call, the account status is included automatically. Some of these statuses don't apply to all pricing plans. Account status Definition pending Free account created, but primary admin is not yet activated. paid_pending Account created with a paid subscription, but the primary admin is not yet activated. new Free account, active primary admin, no application data has been collected. paid_new Paid subscription, active primary admin, no application data has been collected. active Free subscription, receiving application data. paid_active Paid subscription, receiving application data. upgraded Account's subscription was upgraded. downgraded Account's subscription was downgraded. cancelled The New Relic account subscription has been cancelled. suspended The New Relic account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the Partnership API account object. Note that this is just an example, and that for some accounts, the users and subscriptions attributes are unnecessary and are ignored. Account object JSON request { \"account\": { \"name\": \"Sample Account\", \"application_type\": \"ruby\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"subscriptions\": [ { \"product_id\": 4, \"quantity\": 10 }, { \"product_id\": 10, \"quantity\": 0 } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Account object API examples Partnerships with more than 1000 accounts return a paginated response. To specify a page, add the following parameter to the query: ?page= Copy Here are examples of calls using the Partnership API account object. Note that these are examples, and that for some accounts, the users and subscriptions attributes don't apply and will be ignored. List List request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts Copy Response (line breaks are for readability): { \"accounts\": [ { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": null, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } ] } Copy Show Request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": 00000, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Create Here's an example of creating an account for an organization on our original pricing plan and on our original user model. For an example call of creating an account for organizations with the newer models, see the example after this one. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample Account\", \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}],\"subscriptions\":[{\"product_id\": 4,\"quantity\": 10},{\"product_id\": 10,\"quantity\": 0}]}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Here's an example of creating an account for a customer partnership that is on our New Relic One pricing and our New Relic One account/user model. For more on restrictions on API use, see requirements. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Update You can only use the Partnership API account object to update the name, phone_number, testing and allow_API_access values. To update subscription and users values, you must use the Partnership API subscription object and Partnership API user object. Request: curl -X PUT \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account name\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Account New Name\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Delete Request: curl -X DELETE \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response: No response body.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.97476,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> account object",
        "sections": "<em>Partnership</em> <em>API</em> account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "&#x27;s subscription was downgraded. cancelled The <em>New</em> <em>Relic</em> account subscription has been cancelled. suspended The <em>New</em> <em>Relic</em> account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ebc5f196a679110a83dd5"
    },
    {
      "sections": [
        "Partnership API child account object",
        "Requirements",
        "Introduction to using child accounts",
        "Child account object attributes",
        "name (REQUIRED)",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "password (REQUIRED)",
        "Child account API calls",
        "JSON example",
        "Child account object JSON request",
        "JSON response",
        "Child account object API examples",
        "Create"
      ],
      "title": "Partnership API child account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "7fb13302d892a5f89c6c9371f35a60bf1ed9f6a5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-sub-account-object/",
      "published_at": "2021-07-09T10:22:56Z",
      "updated_at": "2021-07-02T13:14:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage child accounts. For accounts, you'd use the child account object. Requirements You may not have access to using this object. Before using the Partnership API, first read the requirements. Introduction to using child accounts Some notes about using the child account object: To manage existing parent accounts or child accounts, use the Partnership API account object. A parent account may have more than one associated child account, but every chld account must correspond to one and only one parent account. Every child account must have at least a primary_admin user. You cannot create a child account without connecting it to an existing parent account and adding at least one user. Child account object attributes Before using the Partnership API, first read the requirements. Here are the Partnership API child account object's attributes: name (REQUIRED) Type: String Default: (none) This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you create the child account, you can define only one user: the account Owner. To add additional users, use the Partnership API user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user's current password. For some New Relic organizations, child accounts can also be created via the parent account's Account settings page in the New Relic UI. Child account API calls Here is the URL pattern to create child accounts. Notice that the Parent Account ID must be specified. If using this URL pattern, send the JSON object along with an HTTP header containing the Partner API key. For example: POST .../api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts​ x-api-key:PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern Create a child account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy JSON example Here is an example of a JSON request and response using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Child account object JSON request { \"account\": { \"name\": \"Sample child account\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Child account object API examples Here is an example of an API call using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Create Request: curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"sub_account\":{\"name\":\"Sample child account\"}, \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}]}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample child account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": false, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.50198,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> child account object",
        "sections": "<em>Partnership</em> <em>API</em> child account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " additional users, use the <em>Partnership</em> <em>API</em> user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user&#x27;s current password. For some <em>New</em> <em>Relic</em>"
      },
      "id": "603eba3ae7b9d2b8e32a07b5"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.2287,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> organizations set up as <em>partnership</em> accounts have access to an enhanced hierarchical way of organizing their account structure. <em>Partnerships</em> with <em>New</em> <em>Relic</em> There are two types of <em>New</em> <em>Relic</em> organizations that are able to use our <em>partnership</em> account structure and the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    }
  ],
  "/docs/new-relic-partnerships/partnerships/partner-api/partnership-billing-integration-api": [
    {
      "sections": [
        "Partnership API account object",
        "Requirements",
        "Account object attributes",
        "name (REQUIRED to create an account)",
        "phone_number",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "subscriptions (REQUIRED for some accounts)",
        "Important",
        "Account API calls",
        "Status definitions",
        "JSON example",
        "Account object JSON request",
        "JSON response",
        "Account object API examples",
        "List",
        "Show",
        "Create",
        "Update",
        "Delete"
      ],
      "title": "Partnership API account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "0b1fde4800f2f9f355e0381796f55e23e61342c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-account-object/",
      "published_at": "2021-07-09T10:21:59Z",
      "updated_at": "2021-07-02T15:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage accounts. For child accounts, you'd use the child account object. Requirements You may not be able to use some aspects of this object. Before using, first read the requirements. Account object attributes Here are the Partnership API account object's attributes. name (REQUIRED to create an account) Type: String Default: (none) The account name attribute is required for new accounts. This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy phone_number Type: String Default: (none) Primary contact phone number for the account. allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you first create an account, this field is required, and only one user can be defined: the account Owner. To add additional users, use the Partnership API user object. For more on restrictions, read the Requirements. subscriptions (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of subscriptions. There are some restrictions in place dependent on the status of your account: For customer partnerships on our New Relic One pricing plan: ignore this field because it applies to the original pricing plan, not yours. If you use this, it will be ignored. For all other accounts: You are on our original product-based pricing plan. The subscriptions attribute is required for new accounts. If it is empty, default product tiers will be used. To update subscription information, use the Partnership API subscription object. Important When creating an account with this object, it can take some time for the account settings to populate. This means that the returned response may initially show aspects that are not true (for example, it may return a response showing default Lite subscriptions). To specify an empty JSON array, don't use subscriptions: [ {} ]. Instead, use this format: subscriptions: [ ] Copy The account API does not include an attribute to create a child account. Instead, to create child accounts, use the parent account's Account settings page in the New Relic UI. Account API calls Here are the URL patterns for account API functions. If using this URL pattern, send an HTTP header containing the Partner API key along with the JSON request body. For example: GET .../api/v2/partners/:PARTNER_ID/accounts/:ID x-api-key: :PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern List (index) all accounts of a partner. GET /api/v2/partners/PARTNER_ID/accounts Copy Show the attributes of an account. GET /api/v2/partners/PARTNER_ID/accounts/:ID Copy Update the attributes of an account. PUT /api/v2/partners/PARTNER_ID/accounts/:ID Copy Create an account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts Copy Cancel an account. DELETE /api/v2/partners/PARTNER_ID/accounts/:ID Copy Status definitions When an account is created or listed with an API call, the account status is included automatically. Some of these statuses don't apply to all pricing plans. Account status Definition pending Free account created, but primary admin is not yet activated. paid_pending Account created with a paid subscription, but the primary admin is not yet activated. new Free account, active primary admin, no application data has been collected. paid_new Paid subscription, active primary admin, no application data has been collected. active Free subscription, receiving application data. paid_active Paid subscription, receiving application data. upgraded Account's subscription was upgraded. downgraded Account's subscription was downgraded. cancelled The New Relic account subscription has been cancelled. suspended The New Relic account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the Partnership API account object. Note that this is just an example, and that for some accounts, the users and subscriptions attributes are unnecessary and are ignored. Account object JSON request { \"account\": { \"name\": \"Sample Account\", \"application_type\": \"ruby\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"subscriptions\": [ { \"product_id\": 4, \"quantity\": 10 }, { \"product_id\": 10, \"quantity\": 0 } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Account object API examples Partnerships with more than 1000 accounts return a paginated response. To specify a page, add the following parameter to the query: ?page= Copy Here are examples of calls using the Partnership API account object. Note that these are examples, and that for some accounts, the users and subscriptions attributes don't apply and will be ignored. List List request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts Copy Response (line breaks are for readability): { \"accounts\": [ { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": null, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } ] } Copy Show Request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": 00000, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Create Here's an example of creating an account for an organization on our original pricing plan and on our original user model. For an example call of creating an account for organizations with the newer models, see the example after this one. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample Account\", \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}],\"subscriptions\":[{\"product_id\": 4,\"quantity\": 10},{\"product_id\": 10,\"quantity\": 0}]}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Here's an example of creating an account for a customer partnership that is on our New Relic One pricing and our New Relic One account/user model. For more on restrictions on API use, see requirements. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Update You can only use the Partnership API account object to update the name, phone_number, testing and allow_API_access values. To update subscription and users values, you must use the Partnership API subscription object and Partnership API user object. Request: curl -X PUT \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account name\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Account New Name\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Delete Request: curl -X DELETE \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response: No response body.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.97476,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> account object",
        "sections": "<em>Partnership</em> <em>API</em> account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "&#x27;s subscription was downgraded. cancelled The <em>New</em> <em>Relic</em> account subscription has been cancelled. suspended The <em>New</em> <em>Relic</em> account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ebc5f196a679110a83dd5"
    },
    {
      "sections": [
        "Partnership API child account object",
        "Requirements",
        "Introduction to using child accounts",
        "Child account object attributes",
        "name (REQUIRED)",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "password (REQUIRED)",
        "Child account API calls",
        "JSON example",
        "Child account object JSON request",
        "JSON response",
        "Child account object API examples",
        "Create"
      ],
      "title": "Partnership API child account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "7fb13302d892a5f89c6c9371f35a60bf1ed9f6a5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-sub-account-object/",
      "published_at": "2021-07-09T10:22:56Z",
      "updated_at": "2021-07-02T13:14:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage child accounts. For accounts, you'd use the child account object. Requirements You may not have access to using this object. Before using the Partnership API, first read the requirements. Introduction to using child accounts Some notes about using the child account object: To manage existing parent accounts or child accounts, use the Partnership API account object. A parent account may have more than one associated child account, but every chld account must correspond to one and only one parent account. Every child account must have at least a primary_admin user. You cannot create a child account without connecting it to an existing parent account and adding at least one user. Child account object attributes Before using the Partnership API, first read the requirements. Here are the Partnership API child account object's attributes: name (REQUIRED) Type: String Default: (none) This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you create the child account, you can define only one user: the account Owner. To add additional users, use the Partnership API user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user's current password. For some New Relic organizations, child accounts can also be created via the parent account's Account settings page in the New Relic UI. Child account API calls Here is the URL pattern to create child accounts. Notice that the Parent Account ID must be specified. If using this URL pattern, send the JSON object along with an HTTP header containing the Partner API key. For example: POST .../api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts​ x-api-key:PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern Create a child account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy JSON example Here is an example of a JSON request and response using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Child account object JSON request { \"account\": { \"name\": \"Sample child account\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Child account object API examples Here is an example of an API call using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Create Request: curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"sub_account\":{\"name\":\"Sample child account\"}, \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}]}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample child account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": false, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.50198,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> child account object",
        "sections": "<em>Partnership</em> <em>API</em> child account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " additional users, use the <em>Partnership</em> <em>API</em> user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user&#x27;s current password. For some <em>New</em> <em>Relic</em>"
      },
      "id": "603eba3ae7b9d2b8e32a07b5"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.2287,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> organizations set up as <em>partnership</em> accounts have access to an enhanced hierarchical way of organizing their account structure. <em>Partnerships</em> with <em>New</em> <em>Relic</em> There are two types of <em>New</em> <em>Relic</em> organizations that are able to use our <em>partnership</em> account structure and the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    }
  ],
  "/docs/new-relic-partnerships/partnerships/partner-api/product-buckets": [
    {
      "sections": [
        "Partnership API account object",
        "Requirements",
        "Account object attributes",
        "name (REQUIRED to create an account)",
        "phone_number",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "subscriptions (REQUIRED for some accounts)",
        "Important",
        "Account API calls",
        "Status definitions",
        "JSON example",
        "Account object JSON request",
        "JSON response",
        "Account object API examples",
        "List",
        "Show",
        "Create",
        "Update",
        "Delete"
      ],
      "title": "Partnership API account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "0b1fde4800f2f9f355e0381796f55e23e61342c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-account-object/",
      "published_at": "2021-07-09T10:21:59Z",
      "updated_at": "2021-07-02T15:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage accounts. For child accounts, you'd use the child account object. Requirements You may not be able to use some aspects of this object. Before using, first read the requirements. Account object attributes Here are the Partnership API account object's attributes. name (REQUIRED to create an account) Type: String Default: (none) The account name attribute is required for new accounts. This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy phone_number Type: String Default: (none) Primary contact phone number for the account. allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you first create an account, this field is required, and only one user can be defined: the account Owner. To add additional users, use the Partnership API user object. For more on restrictions, read the Requirements. subscriptions (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of subscriptions. There are some restrictions in place dependent on the status of your account: For customer partnerships on our New Relic One pricing plan: ignore this field because it applies to the original pricing plan, not yours. If you use this, it will be ignored. For all other accounts: You are on our original product-based pricing plan. The subscriptions attribute is required for new accounts. If it is empty, default product tiers will be used. To update subscription information, use the Partnership API subscription object. Important When creating an account with this object, it can take some time for the account settings to populate. This means that the returned response may initially show aspects that are not true (for example, it may return a response showing default Lite subscriptions). To specify an empty JSON array, don't use subscriptions: [ {} ]. Instead, use this format: subscriptions: [ ] Copy The account API does not include an attribute to create a child account. Instead, to create child accounts, use the parent account's Account settings page in the New Relic UI. Account API calls Here are the URL patterns for account API functions. If using this URL pattern, send an HTTP header containing the Partner API key along with the JSON request body. For example: GET .../api/v2/partners/:PARTNER_ID/accounts/:ID x-api-key: :PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern List (index) all accounts of a partner. GET /api/v2/partners/PARTNER_ID/accounts Copy Show the attributes of an account. GET /api/v2/partners/PARTNER_ID/accounts/:ID Copy Update the attributes of an account. PUT /api/v2/partners/PARTNER_ID/accounts/:ID Copy Create an account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts Copy Cancel an account. DELETE /api/v2/partners/PARTNER_ID/accounts/:ID Copy Status definitions When an account is created or listed with an API call, the account status is included automatically. Some of these statuses don't apply to all pricing plans. Account status Definition pending Free account created, but primary admin is not yet activated. paid_pending Account created with a paid subscription, but the primary admin is not yet activated. new Free account, active primary admin, no application data has been collected. paid_new Paid subscription, active primary admin, no application data has been collected. active Free subscription, receiving application data. paid_active Paid subscription, receiving application data. upgraded Account's subscription was upgraded. downgraded Account's subscription was downgraded. cancelled The New Relic account subscription has been cancelled. suspended The New Relic account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the Partnership API account object. Note that this is just an example, and that for some accounts, the users and subscriptions attributes are unnecessary and are ignored. Account object JSON request { \"account\": { \"name\": \"Sample Account\", \"application_type\": \"ruby\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"subscriptions\": [ { \"product_id\": 4, \"quantity\": 10 }, { \"product_id\": 10, \"quantity\": 0 } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Account object API examples Partnerships with more than 1000 accounts return a paginated response. To specify a page, add the following parameter to the query: ?page= Copy Here are examples of calls using the Partnership API account object. Note that these are examples, and that for some accounts, the users and subscriptions attributes don't apply and will be ignored. List List request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts Copy Response (line breaks are for readability): { \"accounts\": [ { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": null, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } ] } Copy Show Request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": 00000, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Create Here's an example of creating an account for an organization on our original pricing plan and on our original user model. For an example call of creating an account for organizations with the newer models, see the example after this one. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample Account\", \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}],\"subscriptions\":[{\"product_id\": 4,\"quantity\": 10},{\"product_id\": 10,\"quantity\": 0}]}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Here's an example of creating an account for a customer partnership that is on our New Relic One pricing and our New Relic One account/user model. For more on restrictions on API use, see requirements. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Update You can only use the Partnership API account object to update the name, phone_number, testing and allow_API_access values. To update subscription and users values, you must use the Partnership API subscription object and Partnership API user object. Request: curl -X PUT \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account name\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Account New Name\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Delete Request: curl -X DELETE \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response: No response body.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.9747,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> account object",
        "sections": "<em>Partnership</em> <em>API</em> account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "&#x27;s subscription was downgraded. cancelled The <em>New</em> <em>Relic</em> account subscription has been cancelled. suspended The <em>New</em> <em>Relic</em> account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ebc5f196a679110a83dd5"
    },
    {
      "sections": [
        "Partnership API child account object",
        "Requirements",
        "Introduction to using child accounts",
        "Child account object attributes",
        "name (REQUIRED)",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "password (REQUIRED)",
        "Child account API calls",
        "JSON example",
        "Child account object JSON request",
        "JSON response",
        "Child account object API examples",
        "Create"
      ],
      "title": "Partnership API child account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "7fb13302d892a5f89c6c9371f35a60bf1ed9f6a5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-sub-account-object/",
      "published_at": "2021-07-09T10:22:56Z",
      "updated_at": "2021-07-02T13:14:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage child accounts. For accounts, you'd use the child account object. Requirements You may not have access to using this object. Before using the Partnership API, first read the requirements. Introduction to using child accounts Some notes about using the child account object: To manage existing parent accounts or child accounts, use the Partnership API account object. A parent account may have more than one associated child account, but every chld account must correspond to one and only one parent account. Every child account must have at least a primary_admin user. You cannot create a child account without connecting it to an existing parent account and adding at least one user. Child account object attributes Before using the Partnership API, first read the requirements. Here are the Partnership API child account object's attributes: name (REQUIRED) Type: String Default: (none) This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you create the child account, you can define only one user: the account Owner. To add additional users, use the Partnership API user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user's current password. For some New Relic organizations, child accounts can also be created via the parent account's Account settings page in the New Relic UI. Child account API calls Here is the URL pattern to create child accounts. Notice that the Parent Account ID must be specified. If using this URL pattern, send the JSON object along with an HTTP header containing the Partner API key. For example: POST .../api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts​ x-api-key:PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern Create a child account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy JSON example Here is an example of a JSON request and response using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Child account object JSON request { \"account\": { \"name\": \"Sample child account\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Child account object API examples Here is an example of an API call using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Create Request: curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"sub_account\":{\"name\":\"Sample child account\"}, \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}]}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample child account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": false, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.50192,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> child account object",
        "sections": "<em>Partnership</em> <em>API</em> child account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " additional users, use the <em>Partnership</em> <em>API</em> user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user&#x27;s current password. For some <em>New</em> <em>Relic</em>"
      },
      "id": "603eba3ae7b9d2b8e32a07b5"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.22865,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> organizations set up as <em>partnership</em> accounts have access to an enhanced hierarchical way of organizing their account structure. <em>Partnerships</em> with <em>New</em> <em>Relic</em> There are two types of <em>New</em> <em>Relic</em> organizations that are able to use our <em>partnership</em> account structure and the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    }
  ],
  "/docs/new-relic-partnerships/partnerships/partner-api/typical-integration-example": [
    {
      "sections": [
        "Partnership API account object",
        "Requirements",
        "Account object attributes",
        "name (REQUIRED to create an account)",
        "phone_number",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "subscriptions (REQUIRED for some accounts)",
        "Important",
        "Account API calls",
        "Status definitions",
        "JSON example",
        "Account object JSON request",
        "JSON response",
        "Account object API examples",
        "List",
        "Show",
        "Create",
        "Update",
        "Delete"
      ],
      "title": "Partnership API account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "0b1fde4800f2f9f355e0381796f55e23e61342c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-account-object/",
      "published_at": "2021-07-09T10:21:59Z",
      "updated_at": "2021-07-02T15:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage accounts. For child accounts, you'd use the child account object. Requirements You may not be able to use some aspects of this object. Before using, first read the requirements. Account object attributes Here are the Partnership API account object's attributes. name (REQUIRED to create an account) Type: String Default: (none) The account name attribute is required for new accounts. This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy phone_number Type: String Default: (none) Primary contact phone number for the account. allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you first create an account, this field is required, and only one user can be defined: the account Owner. To add additional users, use the Partnership API user object. For more on restrictions, read the Requirements. subscriptions (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of subscriptions. There are some restrictions in place dependent on the status of your account: For customer partnerships on our New Relic One pricing plan: ignore this field because it applies to the original pricing plan, not yours. If you use this, it will be ignored. For all other accounts: You are on our original product-based pricing plan. The subscriptions attribute is required for new accounts. If it is empty, default product tiers will be used. To update subscription information, use the Partnership API subscription object. Important When creating an account with this object, it can take some time for the account settings to populate. This means that the returned response may initially show aspects that are not true (for example, it may return a response showing default Lite subscriptions). To specify an empty JSON array, don't use subscriptions: [ {} ]. Instead, use this format: subscriptions: [ ] Copy The account API does not include an attribute to create a child account. Instead, to create child accounts, use the parent account's Account settings page in the New Relic UI. Account API calls Here are the URL patterns for account API functions. If using this URL pattern, send an HTTP header containing the Partner API key along with the JSON request body. For example: GET .../api/v2/partners/:PARTNER_ID/accounts/:ID x-api-key: :PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern List (index) all accounts of a partner. GET /api/v2/partners/PARTNER_ID/accounts Copy Show the attributes of an account. GET /api/v2/partners/PARTNER_ID/accounts/:ID Copy Update the attributes of an account. PUT /api/v2/partners/PARTNER_ID/accounts/:ID Copy Create an account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts Copy Cancel an account. DELETE /api/v2/partners/PARTNER_ID/accounts/:ID Copy Status definitions When an account is created or listed with an API call, the account status is included automatically. Some of these statuses don't apply to all pricing plans. Account status Definition pending Free account created, but primary admin is not yet activated. paid_pending Account created with a paid subscription, but the primary admin is not yet activated. new Free account, active primary admin, no application data has been collected. paid_new Paid subscription, active primary admin, no application data has been collected. active Free subscription, receiving application data. paid_active Paid subscription, receiving application data. upgraded Account's subscription was upgraded. downgraded Account's subscription was downgraded. cancelled The New Relic account subscription has been cancelled. suspended The New Relic account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the Partnership API account object. Note that this is just an example, and that for some accounts, the users and subscriptions attributes are unnecessary and are ignored. Account object JSON request { \"account\": { \"name\": \"Sample Account\", \"application_type\": \"ruby\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"subscriptions\": [ { \"product_id\": 4, \"quantity\": 10 }, { \"product_id\": 10, \"quantity\": 0 } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Account object API examples Partnerships with more than 1000 accounts return a paginated response. To specify a page, add the following parameter to the query: ?page= Copy Here are examples of calls using the Partnership API account object. Note that these are examples, and that for some accounts, the users and subscriptions attributes don't apply and will be ignored. List List request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts Copy Response (line breaks are for readability): { \"accounts\": [ { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": null, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } ] } Copy Show Request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": 00000, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Create Here's an example of creating an account for an organization on our original pricing plan and on our original user model. For an example call of creating an account for organizations with the newer models, see the example after this one. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample Account\", \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}],\"subscriptions\":[{\"product_id\": 4,\"quantity\": 10},{\"product_id\": 10,\"quantity\": 0}]}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Here's an example of creating an account for a customer partnership that is on our New Relic One pricing and our New Relic One account/user model. For more on restrictions on API use, see requirements. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Update You can only use the Partnership API account object to update the name, phone_number, testing and allow_API_access values. To update subscription and users values, you must use the Partnership API subscription object and Partnership API user object. Request: curl -X PUT \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account name\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Account New Name\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Delete Request: curl -X DELETE \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response: No response body.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.9747,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> account object",
        "sections": "<em>Partnership</em> <em>API</em> account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "&#x27;s subscription was downgraded. cancelled The <em>New</em> <em>Relic</em> account subscription has been cancelled. suspended The <em>New</em> <em>Relic</em> account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ebc5f196a679110a83dd5"
    },
    {
      "sections": [
        "Partnership API child account object",
        "Requirements",
        "Introduction to using child accounts",
        "Child account object attributes",
        "name (REQUIRED)",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "password (REQUIRED)",
        "Child account API calls",
        "JSON example",
        "Child account object JSON request",
        "JSON response",
        "Child account object API examples",
        "Create"
      ],
      "title": "Partnership API child account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "7fb13302d892a5f89c6c9371f35a60bf1ed9f6a5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-sub-account-object/",
      "published_at": "2021-07-09T10:22:56Z",
      "updated_at": "2021-07-02T13:14:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage child accounts. For accounts, you'd use the child account object. Requirements You may not have access to using this object. Before using the Partnership API, first read the requirements. Introduction to using child accounts Some notes about using the child account object: To manage existing parent accounts or child accounts, use the Partnership API account object. A parent account may have more than one associated child account, but every chld account must correspond to one and only one parent account. Every child account must have at least a primary_admin user. You cannot create a child account without connecting it to an existing parent account and adding at least one user. Child account object attributes Before using the Partnership API, first read the requirements. Here are the Partnership API child account object's attributes: name (REQUIRED) Type: String Default: (none) This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you create the child account, you can define only one user: the account Owner. To add additional users, use the Partnership API user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user's current password. For some New Relic organizations, child accounts can also be created via the parent account's Account settings page in the New Relic UI. Child account API calls Here is the URL pattern to create child accounts. Notice that the Parent Account ID must be specified. If using this URL pattern, send the JSON object along with an HTTP header containing the Partner API key. For example: POST .../api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts​ x-api-key:PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern Create a child account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy JSON example Here is an example of a JSON request and response using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Child account object JSON request { \"account\": { \"name\": \"Sample child account\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Child account object API examples Here is an example of an API call using the Partnership API child account object. Note that this is just an example, and that for some accounts, the users attribute is unnecessary and will be ignored. Create Request: curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"sub_account\":{\"name\":\"Sample child account\"}, \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}]}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/PARENT_ACCOUNT_ID/sub_accounts Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample child account\", \"status\": \"pending\", \"license_key\": \"XXXXXX\", \"api_key\": \"XXXXXX\", \"browser_monitoring_key\": \"XXXXXX\", \"allow_api_access\": false, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"parent_account_id\":XXXXXX, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.50192,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> <em>API</em> child account object",
        "sections": "<em>Partnership</em> <em>API</em> child account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " additional users, use the <em>Partnership</em> <em>API</em> user object. For more about restrictions, read the Requirements. password (REQUIRED) Type: String Default: (none) If you are creating a child account with an existing user as the account Owner, the password must match the user&#x27;s current password. For some <em>New</em> <em>Relic</em>"
      },
      "id": "603eba3ae7b9d2b8e32a07b5"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-09T10:37:13Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.22865,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> organizations set up as <em>partnership</em> accounts have access to an enhanced hierarchical way of organizing their account structure. <em>Partnerships</em> with <em>New</em> <em>Relic</em> There are two types of <em>New</em> <em>Relic</em> organizations that are able to use our <em>partnership</em> account structure and the <em>Partnership</em> <em>API</em>"
      },
      "id": "603ece55e7b9d273782a0804"
    }
  ],
  "/docs/new-relic-solutions/best-practices-guides/alerts-applied-intelligence/alerts-best-practices": [
    {
      "sections": [
        "Alert quality management tutorial",
        "The Problem",
        "Desired Outcome",
        "Overview",
        "Key Performance Metrics",
        "Incident Volume",
        "Summary",
        "Volume - Incident Count",
        "Volume - Accumulated Incident Duration",
        "Volume - Mean-Time-To-Close (MTTC)",
        "Volume - Percent Under Five Minutes",
        "User Engagement",
        "User Engagement - Percentage Incidents Acknowledged",
        "User Engagement - Mean Time to Investigate",
        "Required Knowledge",
        "Establishing Current State",
        "Install and configure incident event webhook.",
        "Install the AQM Dashboard",
        "Perform Initial AQM Orientation / Enablement",
        "Accumulate AQM Data",
        "Perform Second Enablement Session",
        "Improvement Process",
        "Value Realization",
        "KPI Reference",
        "Volume - Incidents Duration",
        "Volume - Mean-Time-to-Close",
        "Incident Engagement"
      ],
      "title": "Alert quality management tutorial",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Tutorials",
        "Alerts and Applied Intelligence"
      ],
      "external_id": "f6197aa3a2ce7e8bad779c94fea9c36ee4bcdf22",
      "image": "https://docs.newrelic.com/static/0670e81749bd4d12599dec1868e2f4f7/5b481/aqm-tutorial-webhook.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/alerts-applied-intelligence/alert-quality-management-tutorial/",
      "published_at": "2021-07-09T08:38:58Z",
      "updated_at": "2021-06-25T12:03:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Problem Teams suffer from alert fatigue when they are subject to high alert volumes and alerts that are not aligned to business impact. This situation will condition responders to believe that most alerts are false, will cause them to prioritize easy to resolve alerts over others, and may drive them to close unresolved incidents so they can stay within their SLA targets. Overall, these behaviors will result in slower incident response, which will magnify issue scope and severity when true business impacting issues occur. Alert Quality Management (AQM) focuses on reducing the number of nuisance incidents so that only alerts with true business impact are asserted. This reduces alert fatigue and ensures that attention is focused on the right places at the right times. You are a good candidate for AQM if any of the following are true: You have too many alerts. You have alerts that are asserted for long time periods. Your alerts are not relevant. You perceive that customers discover your issues before your monitoring tools do. You can’t see the value of your observability tool(s). Desired Outcome Overview An alert strategy based on measuring business impact will result in faster response times and greater proactive awareness of critical events. An improved alert signal to noise ratio reduces confusion and improves rapid identification and problem isolation. AQM’s overall goal is to ensure that fewer, more valuable, incidents are created, resulting in increased uptime and availability and reduced MTTR. As you move towards this goal, alert volume will decrease and alerts that are not valuable will be identified and either made valuable or removed. The AQM process described in this guide will generate the key performance metrics that you will use to measure progress towards these goals. Those KPIs will be used to drive a continuous improvement process that identifies and reduces nuisance alerts and increases user engagement in incident investigation. Those business metrics are measured in real time in the AQM dashboard. AQM is intended to improve the value of existing alert configurations and to detect known or expected modes of failure. It does not encompass anomaly detection or AIOps, which are designed to detect unknown or unexpected modes of failure. The two practices (AQM and ML/AI) work hand in hand, they are not mutually exclusive. Key Performance Metrics AQM measures the following KPIs: Incident volume: Incident Count Accumulated incident time Mean Time to Close (MTTC) Percent Under 5 Minutes User Engagement: Mean Time to Investigate (MTTI) % of Incidents Investigated Detailed information on each metric follows. Incident Volume Summary Incidents (with or without alerts) should be treated like a queue of tasks and, just like a queue, the number of alerts should spend time near zero. For each incident, an action should be taken to resolve the condition. If an alert does not result in action, then the value of the alert condition should be questioned. If you see a constant rate of incidents or specific incidents that are “always-on”, you should question why. Are you in a constant state of business impact, or do you simply have a large volume of noise? The alert volume KPIs help you to answer those questions and to measure progress towards a healthy state of high quality alerting. Volume - Incident Count Description Incident Count is the number of incidents generated over a period of time. Typically you should compare the current and previous weeks. Goal Reduce the number of low value / nuisance incidents. Best Practices Ensure condition settings are intended to detect real business impact. See “Service Level Objectives” [link tbd] . Ensure condition settings are detecting abnormal behavior. Communicate that the incident details “Acknowledge” feature helps measure meaningful and actionable alerts. See “Percent Investigated KPI” [link tbd] . Report AQM KPIs to all stakeholders. Volume - Accumulated Incident Duration Description Accumulated incident duration is the total sum of minutes that all the incidents accumulated over a period of time. Typically you should compare the current and previous weeks. Goal Reduce the total accumulated minutes of incidents. Best Practices Do not manually close incidents. Manual closure will skew the real duration of incident length. Eliminate alerts that do not result in any remediation actions from the recipients. Improve percent investigated and mean-time-to-investigate KPIs (below) by communicating their importance in improving detection and response time. Report AQM KPIs to all stakeholders. Volume - Mean-Time-To-Close (MTTC) Description Average duration of incidents within the period of time measured. Goal Reduce MTTC. Best Practices Do not manually close incidents. Manual closure will skew the real duration of incident length. Improve Reliability Engineering skills [link tbd] . Report AQM KPIs to all stakeholders. Volume - Percent Under Five Minutes Description Percentage of incidents where the duration of the incident is under five minutes. This can be an indicator of incident flapping. Goal Minimize percentage of incidents with short durations. Best Practices Ensure that conditions are detecting legitimate deviations from expected behavior. See Baselining and Service Level Management [links tbd] . Ensure that conditions are detecting legitimate deviations that correlate to business impact or impending business impact. User Engagement Summary The value of an incident is measured by whether or not it engages the attention of the relevant incident response team(s). Engagement in this context is measured by whether or not an incident has been acknowledged. The amount of engagement an individual alert receives is a direct measurement of its value. More engagement implies a valuable alert, less (or zero) engagement implies a nuisance alert that should be modified or disabled. It is important to understand that there is a significant difference between measuring the moment of incident awareness vs. acknowledging the moment resolution activity begins. If you are using an integration with New Relic Alerting, be sure that the “acknowledge” event that is sent to New Relic is triggered when resolution activity begins, not when the incident is sent to the external incident management tool. For more information regarding the standard Incident Management process, see Incident Management Process: 5 Steps to Effective Resolution Posted on August 31, 2020 by OnPage Corporation. -- in reference to ITIL4. User Engagement - Percentage Incidents Acknowledged Description Incidents acknowledged identifies the percentage of incidents that had their acknowledged property set to true. Typically you should compare the current and previous weeks. Goal Increase the percentage of users engaging incident details. Best Practices Educate the DevOps team on when it is appropriate to acknowledge an incident alert. Gamify alert acknowledgement to drive usage. Discourage mass acknowledgement exercises. User Engagement - Mean Time to Investigate Description Mean time to investigate identifies the average time it takes for an incident to be triaged. Typically you should compare the current and previous weeks. Goal Reduce the mean time to investigate. Best Practices Work at building incident responder’s confidence in alerts. Ensure that valuable alerts are acknowledged. Incentivize response teams to respond quickly to alerts. Required Knowledge Implementers of this use case should have basic knowledge of the topics itemized below. NR1 Alert Policy and Conditions configuration NR1 Incident Notification Channel Webhook configuration NR1 NRQL NR1 Alerting Best Practices NR1 APM & Infrastructure How to baseline data in order to determine anomalies vs. normal behavior. NOTE: It’s highly recommended that all attendees complete the New Relic University (NRU) Overview Course or have equivalent experience. Establishing Current State As with any continuous improvement process, the first step of AQM is to establish the current state of your KPIs. To do so, perform the following tasks: Install and configure incident event webhook. In this task, you should do the following: Identify your primary production account and each of your accounts that you will be analyzing with the AQM process. Install the Incident Event webhook into each account that will participate in the AQM process and configure the webhook to report nrAQMIncident events to your primary production account. Assign the webhook as a notification channel to every alert policy in each account. This example shows a webhook notification for each account. The webhook will create New Relic events corresponding to each incident as it proceeds through its lifecycle (open, acknowledge, close). It is critical that this webhook be associated as a notification channel for each and every alert policy. Failure to do so will reduce or eliminate the value of the AQM process. NOTE: AQM requires the use of incident, not violation data. The out of box NrAiIncident event provides violation data only and must not be used to drive this process. As of December 2020, the NR Detection Team has not yet integrated acknowledged events into NrAiIncident. It’s anticipated that the NrAiIssue event type will contain this required event at some point in 2021. In the meantime, we must still manually establish a webhook to send the required data to New Relic. Full webhook instructions can be found at: https://source.datanerd.us/amazzarellafaria/observability-maturity (VPN Required). Install the AQM Dashboard Install the AQM dashboard into the primary production account you identified in the task above. The AQM dashboard is the primary asset that drives the AQM process. To achieve this, do the following: Download the dashboard definition JSON file. Import the definition into your primary production account. For more details on importing dashboards, see the New Relic documentation at this link. Perform Initial AQM Orientation / Enablement During this phase, your incident management team(s) and other stakeholders will learn the goals of the AQM process and the scope of their involvement in it. The most critical portion of this task is that your team is properly educated on the importance of acknowledging incident alerts, since that is how the alert’s value is determined. In general, they should be instructed to follow these guidelines: If you look at an alert and decide to take any sort of further investigative action, it should be acknowledged. If there are alerts that you normally close without doing anything else, they should NOT be acknowledged Do not start closing or acknowledging incident alerts that are “always-on”. For further details, see Second Enablement Session below. Training materials can be found at this link. Accumulate AQM Data The overall process requires at least two weeks of data before it can proceed. You should periodically check the following items: Confirm that incident alert event data is accumulating. Confirm that the webhook is attached to every alert policy. Ensure that DevOps teams are following the alert acknowledgement guidelines. Perform Second Enablement Session During this phase, you will introduce incident management teams and other stakeholders to the initial AQM data and the ongoing continuous improvement process you’ll be following. The process consists of four activities: Review AQM Dashboard and KPI Trending - Here you and the stakeholders will look at the AQM KPIs and identify their week over week trends. The team should identify areas where KPIs are not improving and develop strategies to drive improvement. Identify Achievements, Challenges, and Opportunities - Here you and the stakeholders will map the current state of alert quality to business impact, identifying areas where improvement has resulted in better business outcomes and areas where problems are impacting business outcomes Incident Policy Review - Using the AQM dashboard, you and the stakeholders will identify the noisiest incident policies. Once identified, those policies should be evaluated as detailed in step 4 below. Recommendations - In this step, you and the stakeholders will review the noisiest policies using the following criteria: a. Do the alerts have any business impact? b. Are the policies properly configured? i. Are they telling us something about the resource that needs to be fixed? ii. Are the policies necessary? (i.e. do they have business impact) iii. Are the thresholds set properly? c. Have any technical issues been discovered? i. Are there application / system problems for engineering to review? ii. Are there poorly constructed policies that need to be fixed? iii. Are there instrumentation gaps? Further enablement for this step can be found.... Improvement Process This is the ongoing phase of the continuous improvement process where the AQM data is reviewed as outlined above and adjustments are made to alert policies. The KPIs should be reported each week to upper management to ensure that the stakeholder teams are appropriately prioritizing the work and to show that progress towards the promised business outcomes are being reached. Weekly KPIs should be recorded and retained over periods of months to years to establish a baseline and to show the rate of improvement. Value Realization At the end of the AQM process, you should see significant reductions in the volume of alerts while reliability and stability remain the same or improve. In addition, alerts that are asserted should have a clear and unambiguous business impact. The AQM KPIs should bear out these improvements. Once you are firmly on the path to AQM’s goals, you should consider moving to other OMA workflows within the UPR value stream (such as Service Level Management) or to new OMA value streams, such as Customer Experience. KPI Reference Following are the descriptions of each KPI as well as sample NRQL queries that will extract them from the New Relic platform. Incident Volume Volume - Incident Count Description Incident Count is the number of incidents generated over a period of time. By default we look at one week compared with the previous week. NRQL FROM nrAQMIncident SELECT count(*) AS 'Incident Count' WHERE current_state='open' AND severity='CRITICAL' SINCE 1 WEEK AGO COMPARE WITH 1 WEEK AGO Copy Volume - Incidents Duration Description Incident Duration is the total sum of minutes that all the incidents accumulated over a period of time. The default is one week compared with the previous week. NRQL FROM nrAQMIncident SELECT sum(duration)/(1000*60) AS 'Incident Minutes' WHERE current_state='closed' AND severity='CRITICAL' SINCE 1 WEEK AGO COMPARE WITH 1 WEEK AGO Copy Volume - Mean-Time-to-Close Description Average duration of incidents within the period of time measured. NRQL FROM nrAQMIncident SELECT sum(duration)/(1000*60) AS 'Incident Minutes' WHERE current_state='closed' AND severity='CRITICAL' SINCE 1 WEEK AGO COMPARE WITH 1 WEEK AGO Copy Volume - Percent Under Five Minutes Description Percentage of incidents where the duration of the incident is under five minutes. This can be an indicator of incident flapping. NRQL FROM nrAQMIncident SELECT sum(duration)/(1000*60) AS 'Incident Minutes' WHERE current_state='closed' AND severity='CRITICAL' SINCE 1 WEEK AGO COMPARE WITH 1 WEEK AGO Copy Incident Engagement User Engagement - Percentage Incidents Acknowledged Description Incidents acknowledged identifies the percentage of incidents that had their acknowledged property set to true. Typically you should compare the current and previous weeks. NRQL FROM nrAQMIncident SELECT filter(count(*), WHERE current_state='acknowledged')/filter(count(*), WHERE current_state='open')*100 AS '% Investigated' WHERE severity='CRITICAL' SINCE 1 WEEK AGO COMPARE WITH 1 WEEK AGO Copy User Engagement - Mean Time to Investigate Description Mean time to investigate identifies the average time it takes for an incident to be triaged. Typically you should compare the current and previous weeks. NRQL FROM nrAQMIncident SELECT average(duration/(1000*60)) AS 'Incident MTTI (minutes)' WHERE current_state='acknowledged' AND severity='CRITICAL' SINCE 1 WEEK AGO COMPARE WITH 1 WEEK AGO Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 253.03488,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> quality management tutorial",
        "sections": "<em>Alert</em> quality management tutorial",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " accumulated minutes of incidents. <em>Best</em> <em>Practices</em> Do not manually close incidents. Manual closure will skew the real duration of incident length. Eliminate <em>alerts</em> that do not result in any remediation actions from the recipients. Improve percent investigated and mean-time-to-investigate KPIs (below"
      },
      "id": "60d5c61c28ccbcb90171b43b"
    },
    {
      "sections": [
        "Browser monitoring best practices guide",
        "1. Use browser SPA agent",
        "How to do it",
        "2. Use APM auto-instrumentation",
        "Tip",
        "3. Customize Apdex",
        "4. Create alerts",
        "5. Use baseline alerts",
        "6. Add alerts to workflows",
        "7. Create dashboards",
        "8. Group your data",
        "9. Get the right data",
        "10. Break down performance data",
        "Want more user tips?"
      ],
      "title": "Browser monitoring best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "65e00c29691e851341248bcadf7302e955718ca8",
      "image": "https://docs.newrelic.com/static/bcbac83ecd75ee65ad36bbf8299ad89f/c1b63/best01_spapro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/browser-monitoring-best-practices-guide/",
      "published_at": "2021-07-09T09:17:17Z",
      "updated_at": "2021-07-09T09:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring tips & tricks that every user should know Get more out of browser monitoring, with deeper visibility into your websites and your users. Here are 10 best practices to help you find problems faster and deliver a better experience to your customers with real user monitoring. 1. Use browser SPA agent Use the browser SPA agent for deeper visibility Modern websites are complex, with dynamic content and sophisticated logic. See deeper into your user interactions, enable the single-page application (SPA) agent for browser and gain visibility into your user actions and the underlying webpage events behind them. This framework-agnostic agent is not only for single-page application frameworks like React, Angular, Ember, or Backbone, but also for custom frameworks and any other pages with dynamic content. Advanced timing analytics provide more granularity into Navigation Timing Specification API sub-timings beyond page rendering or DOM processing, with detailed performance data filtering useful for understanding all page lifecycles. How to do it From the browser app list, select an app, then select Settings > Application Settings. Select Pro + SPA. Click Save application settings Change your browser monitoring settings to switch to SPA. 2. Use APM auto-instrumentation Use APM automatic instrumentation over copy/paste If you’re also a APM customer, we recommend enabling automatic instrumentation where possible, as this will automatically inject the browser monitoring JavaScript agent into your frontend for you. Not only will the browser agent remain automatically up to date with this approach, using these products together helps unify frontend to backend visibility. For example, you’d be able to link frontend AJAX calls to their corresponding backend transaction, and to align your frontend and backend data together in an Insights dashboard. Tip Depending on your backend framework or CDN strategy, a copy/paste approach may be the better strategy. Just remember that it’ll require periodic updating. How to do it Select Settings > Application Settings. Select Enable via New Relic APM. Select Pro + SPA agent. Click Save application settings. one.newrelic.com > Browser > Settings > Application Settings 3. Customize Apdex Customize your Apdex threshold New Relic uses Apdex, an industry-standard metric, to measure users’ satisfaction with the response time of your applications. Apdex converts many measurements into one number on a uniform scale of 0 to 1 (0 = no users satisfied, 1 = all users satisfied). Apdex T is the central value for Apdex—it is the response time below which a transaction is considered “Satisfactory.” You can define Apdex T values for each application, with separate values for app server and end-user browser performance. (Note that many modern websites are bottlenecked primarily in the frontend browser, accounting for 90% or more of pageload times.) While a suggested T-value threshold is 5 seconds, we encourage you to customize your Apdex T value to fit the needs of your users and application. For example, an ecommerce site may want to have a lower T value to reduce bounce rates from potential buyers frustrated by a slow experience, compared to an internal employee application. However, the goal is to continually lower T-values over time to improve your digital customer experience. How to do it From the browser app list, select an app, then select Settings > Application settings. Set the Apdex T value (in seconds) for this application. Click Save application settings. one.newrelic.com > Browser > Settings > Application 4. Create alerts Create and evaluate alert policies What happens if your Apdex score exceeds your threshold? You want to be alerted whenever this happens, so that you can investigate what is causing the issue before you lose any customers. New Relic provides unified alerting across all our products, including browser monitoring, so that you’ll always be in the know. We recommend setting up alerts to monitor your Apdex score, along with these sample alerts to get you started: Apdex score: Alert if score is below 0.8 for 5 minutes. (If the Apdex score is below 0.8, that means 20% or more of your users are not “satisfied” with their experience on your website.) Page load time: Alert if median page load time is above 10 seconds for 5 minutes. (If the median page load time begins to spike, that suggest that something may be wrong with your web page causing it to significantly slow down. This complements alerting on your Apdex score.) JS errors: Alert if error rate is above 5% for 5 minutes. (If your frontend error rate starts spiking, particularly after a deployment, you may have introduced bad JavaScript into your frontend that should be fixed.) How to do it From Alerts & AI, select Go to Alerts, and click on Policies on the left column. Select (+) New alert policy to create a new alert policy, and give it a meaningful name. Click on Create a condition to create your first condition, then select Browser for your product and the Metric for the condition (which should be the default). Then click Next, select entities. Click the checkbox for the applications you want to alert on, and click Next, define thresholds. Pick the metrics of interest and their thresholds that determine when to trigger an alert. one.newrelic.com > Alerts & AI > Policies > New alert policy 5. Use baseline alerts Alert on anomalous behaviors and events While some metrics can be easily tracked against specific thresholds, other types of data can be more cyclical or have variable ranges for what’s considered healthy. Traffic throughput is a good example of this; it can have significantly cycles, but large traffic drops or spikes may be important indicators of a breakage preventing user traffic or a DDoS attack spiking traffic. Baseline alerts can be helpful for creating an expected \"band\" of normal activity to create more signal to noise in your alerting. How to do it From Alerts & AI, select Go to Alerts, and click on Policies on the left column. Select (+) New alert policy to create a new alert policy, and give it a meaningful name. Click on Create a condition to create your first condition, select Browser for your product and the Metric Baseline for the condition (which should be the default). Then click Next, select entities. Click the checkbox for the applications you want to alert on, and click Next, define thresholds. Pick the Page view throughput and use the slider to define the normal range you want to trigger the alert. one.newrelic.com > Alerts & AI > Policies > New alert policy 6. Add alerts to workflows Integrate your alerts into your workflows With the different alerting policies that you’re setting up, you’ll want to make sure to take advantage of the different alert notification channels available so that they’re integrated into team workflows. After all, what good are alerts if no one knows about them? You can route alerts through Slack, PagerDuty, webhooks, email, and more. You also have the opportunity to align alert notifications with your response processes, such as integrating with ChatOps or linking runbooks to your alerts. Be sure to evaluate alert policies on a regular basis to ensure that they are always valid. How to do it From Alerts & AI, click on Notification channels. Set up different notification channels, which can then be used within different alerting policies. 7. Create dashboards Create your own dashboards using New Relic Insights Browser automatically provides a curated experience to quickly triage issues, but you can also create bespoke dashboards with your frontend data with the query builder. Build unique real-time overviews of what’s going on in your frontend, and see how it fits with the rest of your technology stack. For example, you can: Create a browser-specific breakdown of percentiles, durations, and page views: SELECT average(duration),percentile(duration,50,75,95) as 'Percentile', count(*) as 'Pageviews' FROM PageView WHERE userAgentName='Chrome' SINCE 1 week ago Copy Break down route change performance into percentiles: SELECT count(*) as 'Route Change', average(duration) as 'Avg PageLoad',percentile(duration,50,75) as '%' ,average(jsDuration) as 'JS Duration' FROM BrowserInteraction FACET targetUrl where category = 'Route change' SINCE 1 day ago Copy Compare frontend performance to backend performance in APM: SELECT average(duration) as 'Avg Frontend Duration', average(backendDuration) FROM PageView SINCE 2 minutes ago UNTIL 10 seconds ago TIMESERIES Copy These individual widgets can be added together to create a team dashboard that’s shared across different engineering teams and the company. You can bring together web and mobile application data, backend data, infrastructure data, synthetic monitoring data, and more, all on a single custom dashboard across New Relic One. one.newrelic.com > Dashboards How to do it Go to one.newrelic.com, then click Query your data to access the query builder. In the NRQL tab of the query builder, paste the query into the NRQL> query bar and click Run. Type in a widget title, and add to either an existing or a new dashboard. Go to Dashboards to see your new dashboard. For more information, see our docs on data querying and dashboards. 8. Group your data Group your data into meaningful categories Different websites have different URL architectures, which can vary depending on content structure, technology framework, or SEO strategy. For example: website.com/product/widget-name website.com/gallery?product=109832 website.com/gallery/housewares/lamps/widget-name website.com/product#widget-name URL structure possibilities are endless, so browser includes an automatic grouping algorithm to set categories for that data into different URL groups. We recommend using URL grouping allowed lists to customize how your data is grouped together, which makes the corresponding performance information more useful and aligned to your website architecture. If the data generated by this default grouping is too high level, creating a URL grouping will disaggregate the data and give you greater granularity to make it more useful. For example, you could group by: Different page types: product pages vs. search pages Different forms, APIs, or user groupings Mobile vs. non-mobile Authenticated vs. non-authenticated Different content delivery networks (CDNs) How to do it In the browser monitoring UI, select Settings > Segment allow lists. In the Allow listed segments section, click on the + icon. Type in the URL segments you want to appear in groupings on the page views and AJAX pages. one.newrelic.com > Browser > Settings > Segment allow lists. 9. Get the right data Make sure you get data only from the right sources Browser data is generated from wherever your JavaScript agent is instrumented, though copies of your agent might become duplicated, such as through development, staging, or other environments, resulting in additional data being included from these sources that you would not want mixed with your production data. You can use domain conditions to allow or deny data from the different website domains you want monitored. How to do it In the browser monitoring UI, select Settings > Domain conditions. If there are no domain conditions in place, select Enable domain conditions. If conditions exist, select Next, Choose your setting. Select Deny only or Allow only to identify the data you want collected from the domains you want monitored. Then select Next, Create conditions. Enter the domain string conditions that you want to deny or allow data collection (maximum 10 conditions). Review and confirm your domain condition settings. one.newrelic.com > Browser > Settings > Domain conditions. 10. Break down performance data Break down performance across your users, business, and more By leveraging New Relic APIs, you can add vital context to your performance data as it relates to your technology, users, and your business. All our monitoring tools send their data to New Relic One, which enables plenty of customization and extensibility in your dashboarding. Just be sure to standardize naming for custom events and attributes across different data sources (such as between browser and mobile) for omnichannel engagement. Here are some examples of what you can measure: Build id: Pass in a build number to A/B test differences between versions User id: Manage your VIP customers and track their experience Cart value: Understand how much revenue is at risk when errors occur during checkout Content type: Track the type of content your users are viewing Video playback: See how users are consuming your media content The possibilities are endless. And as you can see, this type of reporting creates context around how your application performance impacts the rest of the business. How to do it Use our APIs to pass custom data about people, things, money, and more into New Relic One. Visit one.newrelic.com, and query on the custom data that is now available. For more information, see our docs on data querying and dashboards. one.newrelic.com > Dashboards > (selected dashboard). Want more user tips? View training videos at New Relic University. Read the Browser documentation. Check out our Tutorials page. Ask a question in the New Relic Community Forum.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.28476,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "sections": "Browser monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": " &gt; Application 4. Create <em>alerts</em> Create and evaluate <em>alert</em> policies What happens if your Apdex score exceeds your threshold? You want to be alerted whenever this happens, so that you can investigate what is causing the issue before you lose any customers. <em>New</em> <em>Relic</em> provides unified alerting across all our"
      },
      "id": "60441b4a28ccbc584a2c6095"
    },
    {
      "sections": [
        "Browser monitoring best practices in Java",
        "Ensure you are using the Apache Jasper compiler.",
        "Place meta tags immediately after the initial head tag.",
        "Avoid if ... else statements in the head section.",
        "Avoid expressions with the less than sign in the head section."
      ],
      "title": "Browser monitoring best practices in Java",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "536c56c90f1dcd9dee65692a229ffde9762f177e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/browser-monitoring-best-practices-java/",
      "published_at": "2021-07-09T09:17:17Z",
      "updated_at": "2021-07-09T09:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring with APM for Java to measure end-user load times. This document explains best practices for setting up browser monitoring. For information on how to set up browser monitoring for your Java app, see Browser monitoring and the Java agent. Ensure you are using the Apache Jasper compiler. The New Relic Java agent only auto-instruments pages compiled with the Apache Jasper compiler. The following application servers use the Jasper compiler by default: Tomcat Jetty Glassfish JBoss 4 Place meta tags immediately after the initial head tag. Recommendation: Place all <meta> tags immediately after the initial <head> tag. Some meta tags have requirements on how close they need to be to the beginning of an HTML document. The character encoding must be declared within the first 512 bytes of the HTML document. If the New Relic header is placed before the character encoding, it is possible for the character encoding to then be outside that 512 byte limit. Placing the character encoding meta tag immediately after the <head> tag will ensure that the New Relic header is positioned after the character encoding. <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> . . . </head> Copy The X-UA-Compatible meta tag should be within the meta tags immediately after the <head> tag. This tag allows page authors to set the document mode used for rending the page in Internet Explorer. This tag should be placed before any script tags. If the New Relic header is positioned before the X-UA-Compatible meta tag, the page might display incorrectly in Internet Explorer. <!DOCTYPE html> <html> <head> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=9\"> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> . . . </head> Copy Avoid if ... else statements in the head section. The auto instrumentation script does not recognize if ... else statements within a JSP page. If you have an if ... else block before your first non-meta, non-title tag, the New Relic header might be placed in the incorrect position in the page. For example, this code could potentially cause the auto instrumentation script to be inserted before the meta tags: if (expression) { <nonmeta tag> } <meta tag> <meta tag> Copy Avoid expressions with the less than sign in the head section. The New Relic Java agent looks for the open angle bracket < to mark the beginning of an HTML tag. This means if you have an expression using a less than sign, then you will either need to change your expression to use a greater than sign or use manual instrumentation. For example: <head> <% for (i = 0; i < variable; i++) . . . %> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.28476,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring <em>best</em> <em>practices</em> in Java",
        "sections": "Browser monitoring <em>best</em> <em>practices</em> in Java",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "You can use browser monitoring with APM for Java to measure end-user load times. This document explains <em>best</em> <em>practices</em> for setting up browser monitoring. For information on how to set up browser monitoring for your Java app, see Browser monitoring and the Java agent. Ensure you are using the Apache"
      },
      "id": "60441afc64441f7f65378f02"
    }
  ],
  "/docs/new-relic-solutions/best-practices-guides/full-stack-observability/apm-best-practices-guide": [
    {
      "sections": [
        "Browser monitoring best practices guide",
        "1. Use browser SPA agent",
        "How to do it",
        "2. Use APM auto-instrumentation",
        "Tip",
        "3. Customize Apdex",
        "4. Create alerts",
        "5. Use baseline alerts",
        "6. Add alerts to workflows",
        "7. Create dashboards",
        "8. Group your data",
        "9. Get the right data",
        "10. Break down performance data",
        "Want more user tips?"
      ],
      "title": "Browser monitoring best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "65e00c29691e851341248bcadf7302e955718ca8",
      "image": "https://docs.newrelic.com/static/bcbac83ecd75ee65ad36bbf8299ad89f/c1b63/best01_spapro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/browser-monitoring-best-practices-guide/",
      "published_at": "2021-07-09T09:17:17Z",
      "updated_at": "2021-07-09T09:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring tips & tricks that every user should know Get more out of browser monitoring, with deeper visibility into your websites and your users. Here are 10 best practices to help you find problems faster and deliver a better experience to your customers with real user monitoring. 1. Use browser SPA agent Use the browser SPA agent for deeper visibility Modern websites are complex, with dynamic content and sophisticated logic. See deeper into your user interactions, enable the single-page application (SPA) agent for browser and gain visibility into your user actions and the underlying webpage events behind them. This framework-agnostic agent is not only for single-page application frameworks like React, Angular, Ember, or Backbone, but also for custom frameworks and any other pages with dynamic content. Advanced timing analytics provide more granularity into Navigation Timing Specification API sub-timings beyond page rendering or DOM processing, with detailed performance data filtering useful for understanding all page lifecycles. How to do it From the browser app list, select an app, then select Settings > Application Settings. Select Pro + SPA. Click Save application settings Change your browser monitoring settings to switch to SPA. 2. Use APM auto-instrumentation Use APM automatic instrumentation over copy/paste If you’re also a APM customer, we recommend enabling automatic instrumentation where possible, as this will automatically inject the browser monitoring JavaScript agent into your frontend for you. Not only will the browser agent remain automatically up to date with this approach, using these products together helps unify frontend to backend visibility. For example, you’d be able to link frontend AJAX calls to their corresponding backend transaction, and to align your frontend and backend data together in an Insights dashboard. Tip Depending on your backend framework or CDN strategy, a copy/paste approach may be the better strategy. Just remember that it’ll require periodic updating. How to do it Select Settings > Application Settings. Select Enable via New Relic APM. Select Pro + SPA agent. Click Save application settings. one.newrelic.com > Browser > Settings > Application Settings 3. Customize Apdex Customize your Apdex threshold New Relic uses Apdex, an industry-standard metric, to measure users’ satisfaction with the response time of your applications. Apdex converts many measurements into one number on a uniform scale of 0 to 1 (0 = no users satisfied, 1 = all users satisfied). Apdex T is the central value for Apdex—it is the response time below which a transaction is considered “Satisfactory.” You can define Apdex T values for each application, with separate values for app server and end-user browser performance. (Note that many modern websites are bottlenecked primarily in the frontend browser, accounting for 90% or more of pageload times.) While a suggested T-value threshold is 5 seconds, we encourage you to customize your Apdex T value to fit the needs of your users and application. For example, an ecommerce site may want to have a lower T value to reduce bounce rates from potential buyers frustrated by a slow experience, compared to an internal employee application. However, the goal is to continually lower T-values over time to improve your digital customer experience. How to do it From the browser app list, select an app, then select Settings > Application settings. Set the Apdex T value (in seconds) for this application. Click Save application settings. one.newrelic.com > Browser > Settings > Application 4. Create alerts Create and evaluate alert policies What happens if your Apdex score exceeds your threshold? You want to be alerted whenever this happens, so that you can investigate what is causing the issue before you lose any customers. New Relic provides unified alerting across all our products, including browser monitoring, so that you’ll always be in the know. We recommend setting up alerts to monitor your Apdex score, along with these sample alerts to get you started: Apdex score: Alert if score is below 0.8 for 5 minutes. (If the Apdex score is below 0.8, that means 20% or more of your users are not “satisfied” with their experience on your website.) Page load time: Alert if median page load time is above 10 seconds for 5 minutes. (If the median page load time begins to spike, that suggest that something may be wrong with your web page causing it to significantly slow down. This complements alerting on your Apdex score.) JS errors: Alert if error rate is above 5% for 5 minutes. (If your frontend error rate starts spiking, particularly after a deployment, you may have introduced bad JavaScript into your frontend that should be fixed.) How to do it From Alerts & AI, select Go to Alerts, and click on Policies on the left column. Select (+) New alert policy to create a new alert policy, and give it a meaningful name. Click on Create a condition to create your first condition, then select Browser for your product and the Metric for the condition (which should be the default). Then click Next, select entities. Click the checkbox for the applications you want to alert on, and click Next, define thresholds. Pick the metrics of interest and their thresholds that determine when to trigger an alert. one.newrelic.com > Alerts & AI > Policies > New alert policy 5. Use baseline alerts Alert on anomalous behaviors and events While some metrics can be easily tracked against specific thresholds, other types of data can be more cyclical or have variable ranges for what’s considered healthy. Traffic throughput is a good example of this; it can have significantly cycles, but large traffic drops or spikes may be important indicators of a breakage preventing user traffic or a DDoS attack spiking traffic. Baseline alerts can be helpful for creating an expected \"band\" of normal activity to create more signal to noise in your alerting. How to do it From Alerts & AI, select Go to Alerts, and click on Policies on the left column. Select (+) New alert policy to create a new alert policy, and give it a meaningful name. Click on Create a condition to create your first condition, select Browser for your product and the Metric Baseline for the condition (which should be the default). Then click Next, select entities. Click the checkbox for the applications you want to alert on, and click Next, define thresholds. Pick the Page view throughput and use the slider to define the normal range you want to trigger the alert. one.newrelic.com > Alerts & AI > Policies > New alert policy 6. Add alerts to workflows Integrate your alerts into your workflows With the different alerting policies that you’re setting up, you’ll want to make sure to take advantage of the different alert notification channels available so that they’re integrated into team workflows. After all, what good are alerts if no one knows about them? You can route alerts through Slack, PagerDuty, webhooks, email, and more. You also have the opportunity to align alert notifications with your response processes, such as integrating with ChatOps or linking runbooks to your alerts. Be sure to evaluate alert policies on a regular basis to ensure that they are always valid. How to do it From Alerts & AI, click on Notification channels. Set up different notification channels, which can then be used within different alerting policies. 7. Create dashboards Create your own dashboards using New Relic Insights Browser automatically provides a curated experience to quickly triage issues, but you can also create bespoke dashboards with your frontend data with the query builder. Build unique real-time overviews of what’s going on in your frontend, and see how it fits with the rest of your technology stack. For example, you can: Create a browser-specific breakdown of percentiles, durations, and page views: SELECT average(duration),percentile(duration,50,75,95) as 'Percentile', count(*) as 'Pageviews' FROM PageView WHERE userAgentName='Chrome' SINCE 1 week ago Copy Break down route change performance into percentiles: SELECT count(*) as 'Route Change', average(duration) as 'Avg PageLoad',percentile(duration,50,75) as '%' ,average(jsDuration) as 'JS Duration' FROM BrowserInteraction FACET targetUrl where category = 'Route change' SINCE 1 day ago Copy Compare frontend performance to backend performance in APM: SELECT average(duration) as 'Avg Frontend Duration', average(backendDuration) FROM PageView SINCE 2 minutes ago UNTIL 10 seconds ago TIMESERIES Copy These individual widgets can be added together to create a team dashboard that’s shared across different engineering teams and the company. You can bring together web and mobile application data, backend data, infrastructure data, synthetic monitoring data, and more, all on a single custom dashboard across New Relic One. one.newrelic.com > Dashboards How to do it Go to one.newrelic.com, then click Query your data to access the query builder. In the NRQL tab of the query builder, paste the query into the NRQL> query bar and click Run. Type in a widget title, and add to either an existing or a new dashboard. Go to Dashboards to see your new dashboard. For more information, see our docs on data querying and dashboards. 8. Group your data Group your data into meaningful categories Different websites have different URL architectures, which can vary depending on content structure, technology framework, or SEO strategy. For example: website.com/product/widget-name website.com/gallery?product=109832 website.com/gallery/housewares/lamps/widget-name website.com/product#widget-name URL structure possibilities are endless, so browser includes an automatic grouping algorithm to set categories for that data into different URL groups. We recommend using URL grouping allowed lists to customize how your data is grouped together, which makes the corresponding performance information more useful and aligned to your website architecture. If the data generated by this default grouping is too high level, creating a URL grouping will disaggregate the data and give you greater granularity to make it more useful. For example, you could group by: Different page types: product pages vs. search pages Different forms, APIs, or user groupings Mobile vs. non-mobile Authenticated vs. non-authenticated Different content delivery networks (CDNs) How to do it In the browser monitoring UI, select Settings > Segment allow lists. In the Allow listed segments section, click on the + icon. Type in the URL segments you want to appear in groupings on the page views and AJAX pages. one.newrelic.com > Browser > Settings > Segment allow lists. 9. Get the right data Make sure you get data only from the right sources Browser data is generated from wherever your JavaScript agent is instrumented, though copies of your agent might become duplicated, such as through development, staging, or other environments, resulting in additional data being included from these sources that you would not want mixed with your production data. You can use domain conditions to allow or deny data from the different website domains you want monitored. How to do it In the browser monitoring UI, select Settings > Domain conditions. If there are no domain conditions in place, select Enable domain conditions. If conditions exist, select Next, Choose your setting. Select Deny only or Allow only to identify the data you want collected from the domains you want monitored. Then select Next, Create conditions. Enter the domain string conditions that you want to deny or allow data collection (maximum 10 conditions). Review and confirm your domain condition settings. one.newrelic.com > Browser > Settings > Domain conditions. 10. Break down performance data Break down performance across your users, business, and more By leveraging New Relic APIs, you can add vital context to your performance data as it relates to your technology, users, and your business. All our monitoring tools send their data to New Relic One, which enables plenty of customization and extensibility in your dashboarding. Just be sure to standardize naming for custom events and attributes across different data sources (such as between browser and mobile) for omnichannel engagement. Here are some examples of what you can measure: Build id: Pass in a build number to A/B test differences between versions User id: Manage your VIP customers and track their experience Cart value: Understand how much revenue is at risk when errors occur during checkout Content type: Track the type of content your users are viewing Video playback: See how users are consuming your media content The possibilities are endless. And as you can see, this type of reporting creates context around how your application performance impacts the rest of the business. How to do it Use our APIs to pass custom data about people, things, money, and more into New Relic One. Visit one.newrelic.com, and query on the custom data that is now available. For more information, see our docs on data querying and dashboards. one.newrelic.com > Dashboards > (selected dashboard). Want more user tips? View training videos at New Relic University. Read the Browser documentation. Check out our Tutorials page. Ask a question in the New Relic Community Forum.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.46768,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "sections": "Browser monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "Browser monitoring tips &amp; tricks that every user should know Get more out of browser monitoring, with deeper visibility into your websites and your users. Here are 10 <em>best</em> <em>practices</em> to help you find problems faster and deliver a better experience to your customers with real user monitoring. 1. Use"
      },
      "id": "60441b4a28ccbc584a2c6095"
    },
    {
      "sections": [
        "Browser monitoring best practices in Java",
        "Ensure you are using the Apache Jasper compiler.",
        "Place meta tags immediately after the initial head tag.",
        "Avoid if ... else statements in the head section.",
        "Avoid expressions with the less than sign in the head section."
      ],
      "title": "Browser monitoring best practices in Java",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "536c56c90f1dcd9dee65692a229ffde9762f177e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/browser-monitoring-best-practices-java/",
      "published_at": "2021-07-09T09:17:17Z",
      "updated_at": "2021-07-09T09:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring with APM for Java to measure end-user load times. This document explains best practices for setting up browser monitoring. For information on how to set up browser monitoring for your Java app, see Browser monitoring and the Java agent. Ensure you are using the Apache Jasper compiler. The New Relic Java agent only auto-instruments pages compiled with the Apache Jasper compiler. The following application servers use the Jasper compiler by default: Tomcat Jetty Glassfish JBoss 4 Place meta tags immediately after the initial head tag. Recommendation: Place all <meta> tags immediately after the initial <head> tag. Some meta tags have requirements on how close they need to be to the beginning of an HTML document. The character encoding must be declared within the first 512 bytes of the HTML document. If the New Relic header is placed before the character encoding, it is possible for the character encoding to then be outside that 512 byte limit. Placing the character encoding meta tag immediately after the <head> tag will ensure that the New Relic header is positioned after the character encoding. <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> . . . </head> Copy The X-UA-Compatible meta tag should be within the meta tags immediately after the <head> tag. This tag allows page authors to set the document mode used for rending the page in Internet Explorer. This tag should be placed before any script tags. If the New Relic header is positioned before the X-UA-Compatible meta tag, the page might display incorrectly in Internet Explorer. <!DOCTYPE html> <html> <head> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=9\"> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> . . . </head> Copy Avoid if ... else statements in the head section. The auto instrumentation script does not recognize if ... else statements within a JSP page. If you have an if ... else block before your first non-meta, non-title tag, the New Relic header might be placed in the incorrect position in the page. For example, this code could potentially cause the auto instrumentation script to be inserted before the meta tags: if (expression) { <nonmeta tag> } <meta tag> <meta tag> Copy Avoid expressions with the less than sign in the head section. The New Relic Java agent looks for the open angle bracket < to mark the beginning of an HTML tag. This means if you have an expression using a less than sign, then you will either need to change your expression to use a greater than sign or use manual instrumentation. For example: <head> <% for (i = 0; i < variable; i++) . . . %> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.46768,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring <em>best</em> <em>practices</em> in Java",
        "sections": "Browser monitoring <em>best</em> <em>practices</em> in Java",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "You can use browser monitoring with APM for Java to measure end-user load times. This document explains <em>best</em> <em>practices</em> for setting up browser monitoring. For information on how to set up browser monitoring for your Java app, see Browser monitoring and the Java agent. Ensure you are using the Apache"
      },
      "id": "60441afc64441f7f65378f02"
    },
    {
      "sections": [
        "Mobile monitoring best practices guide",
        "1. Start collecting data",
        "How to do it",
        "Add your mobile app to New Relic",
        "Install and configure our mobile SDK",
        "2. Explore your data",
        "Analyze, resolve, and prevent crashes",
        "Monitor your key workflows",
        "Get actionable session data",
        "3. Take preventive steps",
        "Metric-based alerts",
        "Event-based alerts",
        "4. Dig deeper into crashes",
        "Crash analysis",
        "Breadcrumbs",
        "Custom attributes",
        "5. Focus on KPIs",
        "Track and query feature use",
        "Measure page load times",
        "Examine data about webpage interactions"
      ],
      "title": "Mobile monitoring best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "32f5d3919c54c90173721a2cda556d8fd57744f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/mobile-monitoring-best-practices-guide/",
      "published_at": "2021-07-09T08:59:56Z",
      "updated_at": "2021-07-09T08:59:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "By eliminating crashes and increasing speed across the stack, you can build better performance into every mobile app release. Here are some best practices to take full advantage of mobile monitoring with New Relic. 1. Start collecting data Start collecting data in production. You'll see immediate value by adding our mobile monitoring SDK to your app for its next release to the app store. We recommend installing the iOS or Android agent to your production release even if you're simply testing New Relic's capabilities. This will ensure you'll get an adequate amount of data to really understand all of our mobile monitoring capabilities and your end users' experience. How to do it Add your mobile app to New Relic First, add a new app in New Relic's user interface (full steps): Go to one.newrelic.com and click Mobile. From the list of monitored apps, select Add more. Select the relevant platform. Type a name for your mobile app, and select Continue. Use one app and the associated app token for the development releases of your iOS app, another app and its associated app token for the production releases of that iOS app, and another pair of app tokens for development and production releases of your Android app. You'll be able to compare data from across the four app tokens using our query builder. Install and configure our mobile SDK Next, install and configure the mobile agent: Download the latest version of New Relic's SDK for iOS or Android, and add it to your mobile app. (Full steps for iOS and Android) Configure your installation as needed. For example: Enable the feature flag to capture MobileRequest events to use our full network analysis capabilities for iOS or Android. Automate dSYM uploads for your production builds. To avoid surprises, follow the standard pattern of where you start our mobile agent. In addition, start our agent before you initiate any other SDKs. For more information, see our documentation for Android installation and configuration and for iOS installation and configuration. Deploy a new release of your application. 2. Explore your data Immediately be able to explore your data. As soon as New Relic starts reporting data, take the time to explore the wealth of information about your mobile apps. To get started, go to one.newrelic.com and select Mobile. How to do it Analyze, resolve, and prevent crashes Find the cause of crashes so you can fix them. Then, uncover trends behind crashes so you can prevent them: From the summary UI page for a monitored mobile app, click Crash analysis. Analyze crash data so you can see and fix the most impactful crashes. Follow the breadcrumbs in the crash event trail to fix crashes and resolve critical errors more easily: From your mobile app's Crash analysis page in the UI, select a Crash type. From the crash type's Summary page, select the Crash trail tab. For more information, see our blog post about crash analysis. Monitor your key workflows Create custom breadcrumbs to monitor key workflows (such as your app's login or checkout process), track user clicks, optimize timing, and identify crash locations for faster MTTR. Get actionable session data Borrow from our example queries to: See how much of your user base has upgraded to your latest app version. Track adoption over time. Get a count of new installs as compared to upgrades from an earlier version. See the distribution of usage across geographical locations, carriers, ASN owners (wi-fi providers), devices, connection types, and more. 3. Take preventive steps Use alert notifications to help uncover the causes behind crashes and errors. Once you are running our mobile monitoring capabilities in production and have explored some of the key features, you can use New Relic to uncover critical issues with your mobile application. In particular, focus on crashes and errors. Use metric-based alerts as a starting point to gain high-level visibility into problems. Then, as new services or functionalities are added, use New Relic’s more targeted, event-based (NRQL) alerts to make sure that the most critical issues are handled swiftly. Use these alerts to determine whether a crash is impacting a large number of users. If it is, the relevant people (for example, both the mobile app team’s on-call member and the owner of the related back-end service) will be alerted. Make sure that your team knows how to respond to changes in crash rate (crashes per sessions) and the percentage of users impacted by crashes of your mobile app. How to do it Metric-based alerts Use our metric-based alerts and mobile monitoring UI: Ensure that key members of your mobile team have opted in to receive emails for new crashes. These emails will take you to the crash type in the UI page for your mobile app. Create an alert for your crash rate threshold that key members of your team can view in Slack or any other Alerts notification channel you choose. Your alert notification will include a link to our UI, where you can examine a chart with the exceeded threshold. From there, a link will take you to the relevant mobile monitoring page, where you can get additional details. Event-based alerts Combine the metric-based workflow with event-based alerts and dashboards specific to your mobile app and system. Create your NRQL alert that focuses on crashes of your most recently released production version. Create an additional NRQL alert that focuses on the percentage of users impacted by crashes in your latest app version (to check the overall impact on your user base). 4. Dig deeper into crashes Take your crash reporting to the next level. Now it’s time to tackle some of those harder-to-reproduce crashes by: Applying additional instrumentation to your application. Leveraging crash event trails, NRQL queries, and dashboards to visualize your data. How to do it Crash analysis Crashes are an inevitable part of running mobile applications at scale. We provide tools to help you understand your highest-impact crashes. Use the Crash analysis UI to see which crashes are occurring most often, the percentage of crash-free users, which files and methods are associated with perhaps 80 percent of your crashes, which crashes a particular user just experienced, and more. Go after high-impact crashes with crash analysis: Add custom attributes to categorize the highest-value customers, and then use them to segment crashes according to your most valuable audiences. Add breadcrumbs and custom events to produce a detailed trail of events leading up to every crash occurrence (over the last 90 days). Then, view this crash event trail in our mobile monitoring UI. Use our mobile monitoring's Versions trends page to make sure you’re improving the crash rate over subsequent releases and avoiding regressions. Breadcrumbs Use breadcrumbs and custom attributes to better reproduce and debug crashes. For example, use our recordBreadrumb API for Android or iOS to track mid-session changes in state that can help debug crashes, such as: Change of connection type Change of orientation CPU and memory state at key points in the app code Custom attributes Add custom attributes to existing events, so you can ask even more precise questions of your mobile app. Add dimensions such as: User ID: Use to react to specific user concerns and to better understand which customers and segments are most impacted. Store ID: Use to address problems with out-of-date devices, bad wi-fi, and so on. User segments: Use to better understand which customers and segments are most impacted; for example, logged in vs. non-logged in. Money in the cart at session end Origin or attribution of entry into the app Standardize custom attribute names across your mobile apps, and align with your website (if you're using our browser monitoring), so that you can compare and contrast performance across end-user channels. The mobile agents track the last interaction of crashed and non-crashed sessions to provide visibility into what the user viewed before exiting your app (either intentionally or due to a crash). 5. Focus on KPIs Bring your key performance indicators to life. Create custom interactions and events to hone in on the most important signals, including user activity for the business-critical aspects of your app. Using these powerful APIs, you can add custom instrumentation to just about anything. The following are some example use cases. How to do it Track and query feature use Use custom events to track feature use. For example: Use custom events to track user flow between app and website. Use custom events or mobile breadcrumbs to optimize the performance of key user flows (log in, shopping cart, etc.). use custom events to provide faster, contextualized support experiences for your digital customers. Use the recordCustomEvent API. Then compare the use of different features using: SELECT count(*) FROM MyNewMobileEventType FACET name Copy Measure page load times Use custom events to measure page load time: Create an app-launch timer to measure the time that elapses between a user-tap to launch your app and the point in your app code where the first screen is available. Record the timer value in New Relic using something like the following: recordCustomEvent(<myMobileTimers>, <appLaunch>, {attributes}) Copy Define start and stop timers to measure spinner durations, and then record this time in New Relic using something like the following: recordCustomEvent(<myMobileTimers>, <spinnerOnScreenA>, {attributes}) Copy Track specific user actions or funnel steps in the app (like \"add to cart\"), and include the price as an attribute on that event. Measure flows through the application by viewing the related funnel steps with custom events in Insights. For example, create a timer to track the start and end times of a subflow or an entire flow across multiple funnel steps to understand how long it took users to get through the process. Examine data about webpage interactions Use custom interactions to see traces associated with the same webpages. Use the agent API to disable default interactions, and focus on custom interactions so that you can review the page loads that are most crucial to your primary funnel. Define the start and stop times of these custom interactions to trace activities associated with individual steps of that funnel (for example, a specific user action or a page load). Track the last interactions of crashed and non-crashed sessions so that you can see what the user viewed before exiting your app (either intentionally or from a crash). Example query for non-crashed sessions: SELECT count(*) FROM Mobile WHERE sessionCrashed is null FACET lastInteraction SINCE 90 days ago Copy Example query for crashed sessions: SELECT count(*) FROM Mobile WHERE sessionCrashed is true FACET lastInteraction SINCE 90 days ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.1969,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Mobile monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "sections": "Mobile monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "By eliminating crashes and increasing speed across the <em>stack</em>, you can build better performance into every mobile app release. Here are some <em>best</em> <em>practices</em> to take <em>full</em> advantage of mobile monitoring with <em>New</em> <em>Relic</em>. 1. Start collecting data Start collecting data in production. You&#x27;ll see immediate"
      },
      "id": "6044151e28ccbc19ab2c60d8"
    }
  ],
  "/docs/new-relic-solutions/best-practices-guides/full-stack-observability/browser-monitoring-best-practices-guide": [
    {
      "sections": [
        "Browser monitoring best practices in Java",
        "Ensure you are using the Apache Jasper compiler.",
        "Place meta tags immediately after the initial head tag.",
        "Avoid if ... else statements in the head section.",
        "Avoid expressions with the less than sign in the head section."
      ],
      "title": "Browser monitoring best practices in Java",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "536c56c90f1dcd9dee65692a229ffde9762f177e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/browser-monitoring-best-practices-java/",
      "published_at": "2021-07-09T09:17:17Z",
      "updated_at": "2021-07-09T09:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring with APM for Java to measure end-user load times. This document explains best practices for setting up browser monitoring. For information on how to set up browser monitoring for your Java app, see Browser monitoring and the Java agent. Ensure you are using the Apache Jasper compiler. The New Relic Java agent only auto-instruments pages compiled with the Apache Jasper compiler. The following application servers use the Jasper compiler by default: Tomcat Jetty Glassfish JBoss 4 Place meta tags immediately after the initial head tag. Recommendation: Place all <meta> tags immediately after the initial <head> tag. Some meta tags have requirements on how close they need to be to the beginning of an HTML document. The character encoding must be declared within the first 512 bytes of the HTML document. If the New Relic header is placed before the character encoding, it is possible for the character encoding to then be outside that 512 byte limit. Placing the character encoding meta tag immediately after the <head> tag will ensure that the New Relic header is positioned after the character encoding. <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> . . . </head> Copy The X-UA-Compatible meta tag should be within the meta tags immediately after the <head> tag. This tag allows page authors to set the document mode used for rending the page in Internet Explorer. This tag should be placed before any script tags. If the New Relic header is positioned before the X-UA-Compatible meta tag, the page might display incorrectly in Internet Explorer. <!DOCTYPE html> <html> <head> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=9\"> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> . . . </head> Copy Avoid if ... else statements in the head section. The auto instrumentation script does not recognize if ... else statements within a JSP page. If you have an if ... else block before your first non-meta, non-title tag, the New Relic header might be placed in the incorrect position in the page. For example, this code could potentially cause the auto instrumentation script to be inserted before the meta tags: if (expression) { <nonmeta tag> } <meta tag> <meta tag> Copy Avoid expressions with the less than sign in the head section. The New Relic Java agent looks for the open angle bracket < to mark the beginning of an HTML tag. This means if you have an expression using a less than sign, then you will either need to change your expression to use a greater than sign or use manual instrumentation. For example: <head> <% for (i = 0; i < variable; i++) . . . %> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.4674,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring <em>best</em> <em>practices</em> in Java",
        "sections": "Browser monitoring <em>best</em> <em>practices</em> in Java",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "You can use browser monitoring with APM for Java to measure end-user load times. This document explains <em>best</em> <em>practices</em> for setting up browser monitoring. For information on how to set up browser monitoring for your Java app, see Browser monitoring and the Java agent. Ensure you are using the Apache"
      },
      "id": "60441afc64441f7f65378f02"
    },
    {
      "sections": [
        "APM best practices guide",
        "Tip",
        "1. Standardize application names",
        "How to do it",
        "2. Add tags to your applications",
        "Caution",
        "3. Create and evaluate alert policies",
        "4. Identify and set up key transactions",
        "5. Track deployment history",
        "6. Review APM reports",
        "7. Review your environment with service maps",
        "8. Keep current",
        "9. Manage user access",
        "Important"
      ],
      "title": "APM best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "368a1a5688384d5bebf128604a9b8f190d335524",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/apm-best-practices-guide/",
      "published_at": "2021-07-09T09:16:17Z",
      "updated_at": "2021-07-09T09:16:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Application Monitoring Tips You Need To Know It's one thing to know how to use APM, but it's another thing to know how to use New Relic's application performance monitoring software well. Here are some best practices designed to help you become an APM master—and a key asset to your team! Tip To get a high-level overview of all your applications and services, use the New Relic Explorer in New Relic One. 1. Standardize application names Most New Relic agents provide a default application name, such as \"My Application\" or \"PHP Application,\" if you don't specify one in your New Relic configuration file. You don't want to end up with 20 identically named applications, be sure to select a descriptive identifier for your apps as soon you deploy them. To keep things consistent and easy to navigate, New Relic recommends standardizing your application naming (for example, all apps in Staging append [ Staging] or the like at the end of their names). Ideally, you want your new Java applications to be named automatically to reduce the chances of typographical errors and misnaming. How to do it For Java applications, automatic application naming can come from the following sources: Request attribute Servlet init parameter Filter init parameter Web app context parameter Web app context name (display name) Web app context path Choose the method that fits best your needs and follow these steps. For non-Java applications, there are no automatic naming methods, so refer to the documentation for your APM agent. 2. Add tags to your applications When several different applications use the same account, and each application spans multiple environments (for example, development, test, pre-production, production), it can be hard to find a specific application in your overview dashboard. That's why we recommend adding tags to your apps so that you can segment them into logical groups. The two most common tags that mature APM customers use are application name and environment. So, for example, if you wanted to view the billing application in Test, you could simply filter by \"billing app\" (name tag) and \"test\" (environment tag). Caution In the APM agent configuration settings files, use the labels field to add tags to your data. For example, see this description of the Python labels setting. APM is designed so that apps can roll up into an unlimited number of meaningful tag categories. How to do it Learn about tags. Learn how to add tags.. Learn how to query tags. 3. Create and evaluate alert policies When key performance indicators spike or drop, individuals and teams in your organization need to be notified. Alerting in New Relic provides a set of tools including dynamic baselines that allow you to detect problems before they impact your end users. Alert policies can be set up in two primary ways: Static threshold alerts are great when you already know the nature of an application and its normal behaviors aren't likely to change anytime soon. Apdex score, response time, error rate, throughput are some of the static thresholds you can create alert policies on. Dynamic baseline alerts make it easy to determine and set dynamic alert thresholds for applications with varying seasonal patterns and growth trends (which make it difficult to set thresholds that define normal behavior). These alerts use baselines modeled from your application’s historical metric data. Each alert policy can contain as many conditions as you need, and each alert condition includes three components: Type of condition (metric, external service, and so on) Entities that the policy targets (for example, APM apps, browser monitoring apps, or hosts) Thresholds that escalate into alerting situations with increasing severity Once you have your alerting set up, you then want to make sure you're taking advantage of all viable notification channels. After all, what good are alerts if no one knows about them? You can manage alerts by creating specific user groups and by leveraging New Relic's integrated alert channels, including Slack, PagerDuty, webhooks, and email. Be sure to evaluate alert policies on a regular basis to ensure that they are always valid. How to do it See the detailed documentation: To set up dynamic baseline alerts and choose an application, follow standard procedures. You will see a preview of the metric with the predicted baseline You can select a metric for that application and see the corresponding baseline. Then, using the threshold sliders, you can set how closely you want your threshold to follow the baseline prediction. To set up static threshold alerts for your Apdex settings, follow standard procedures. To set up your alert notification channels, follow standard procedures. 4. Identify and set up key transactions Depending on the nature of your application, some transactions may be more important to you than others. New Relic's key transactions feature is designed to help you closely monitor what you consider to be your app's most business-critical transactions, whether that's end-user or app response time, call counts, error rates, or something else. You can also set alert threshold levels for notifications when your key transactions are performing poorly. How to do it In the menu bar, select More > Key transactions, and then select Add more. Then select the app and web transaction or, from the selected transaction, select Track as key transaction. Type a name for the key transaction, and select Track key transaction. Optional: If the agent for the selected app supports custom alerting, use the default values that New Relic automatically fills, or select Edit key alert transaction policy to set the Apdex and alert threshold values. To view the key transactions dashboard details, select View new key transaction. 5. Track deployment history When development teams are pushing new code out as frequently as possible, it can be hard to measure the impact that each deployment is having on performance. One way to stay in tune with how these changes are affecting your application is with deployment reports. These reports list recent deployments and their impact on end-users and app servers' Apdex scores, along with response times, throughput, and errors. You can also view and drill down into the details to catch errors related to recent deployments, or file a ticket and share details with your team. How to do it From the New Relic menu bar, select APM > (selected app) > Events > Deployments. To view performance after a deployment, go to the selected app's Overview dashboard in the Recent events section. A blue vertical bar on a chart indicates a deployment. To view summary information about the deployment, point to the blue bar. 6. Review APM reports From SLA, deployment, and capacity to scalability, host usage reports, and more, New Relic APM offers a variety of downloadable reporting tools surfacing historical trends—all great ways to report to senior executive teams or customers. Take a look at the full list of reports and use them to your advantage. How to do it From the New Relic APM menu bar, select Applications > (selected app) > Reports. Select the report you'd like to see. If you want to save or export a report to share, select Download this report as .csv, which will create a report with comma-separated values. 7. Review your environment with service maps Use New Relic service maps, a feature included in APM, to understand how apps and services in your architecture connect and talk to each other. Service maps are visual, customizable representations of your application architecture. Maps automatically show you your app's connections and dependencies, including databases and external services. Health indicators and performance metrics show you the current operational status for every part of your architecture. How to do it Go to one.newrelic.com > More > service maps. To get started, read the instructions in Introduction to service maps. 8. Keep current With New Relic’s SaaS platform, getting new features is as easy as updating your agent. Most likely your organization already has a set of scripts for deploying application upgrades into your environment. In a similar fashion, you can also automate your New Relic agent deployment to ensure that your systems are up to date. Both Puppet and Chef scripts are great examples of deployment frameworks that make life easier by allowing you to automate your entire deployment and management process. How to do it Regularly review which version of the agent you're using so that you know when an update is needed. If the latest agent release contains a needed fix or added functionality, download it. To deploy the agent automatically (preferred as a method to avoid errors): Use existing deployment scripts, provided they can be adapted to handle the deployment. OR Create and maintain a script that specifically deploys and configures the New Relic agent. Ideally, the script would pull the agent files from a repository where the files are versioned (for rollback purposes). Once the script has been created, shut down the application (unless script handles this). Run the deployment script. Start the application (unless script handles this). If problems arise, run the script to roll back to the previous version. To deploy the agent manually: Back up the current agent directory. Deploy the updated agent into the existing agent directory. Modify configuration files by comparing new files with existing files. In particular, make sure things like license key and custom extensions are copied over to the new configuration. Restart the application. If problems arise, restore the old agent using the backup and restart. 9. Manage user access Important This is available only for accounts on our original product-based pricing plan. Enable role-based access control (RBAC) and single sign-on (SSO) New Relic allows authorized individuals to access the broadest possible amount of data, regardless of their assigned role. As an Owner or Administrator of your New Relic account, you can control the permissions of individual users or entire roles with RBAC. To find out what is possible and how to make changes, see Users and roles. Security is no doubt of utmost concern to your organization. To simplify password management for your employees and strengthen security, you may already be using SSO with your other systems. You should do the same with New Relic. Using New Relic's SSO integration feature, account administrators will be able to enforce strong passwords and restrict login via a corporate authentication mechanism. This way, New Relic users who have already authenticated using a corporate SSO system will be able to bypass the New Relic login prompt. How to do it Log in to New Relic as an admin and go to the SSO configuration page. From the New Relic title bar, select (your account name) > Account Settings > Integrations > Single Sign On. From the SAML Single Sign On page, review your New Relic SAML Service Provider details. To upload your SAML Identity Provider certificate, select Choose File, and then follow standard procedures to select and save the file. Copy and paste in (or type) the Remove login URL that your users will use for Single Sign-On. If your organization’s SAML integration provides a redirect URL for logout, copy and paste in (or type) the Logout landing URL; otherwise leave blank. Save, test, and enable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.45154,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>best</em> <em>practices</em> <em>guide</em>",
        "sections": "APM <em>best</em> <em>practices</em> <em>guide</em>",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "Application Monitoring Tips You Need To Know It&#x27;s one thing to know how to use APM, but it&#x27;s another thing to know how to use <em>New</em> <em>Relic</em>&#x27;s application performance monitoring software well. Here are some <em>best</em> <em>practices</em> designed to help you become an APM master—and a key asset to your team! Tip To get"
      },
      "id": "6044186564441f1f94378ecc"
    },
    {
      "sections": [
        "Mobile monitoring best practices guide",
        "1. Start collecting data",
        "How to do it",
        "Add your mobile app to New Relic",
        "Install and configure our mobile SDK",
        "2. Explore your data",
        "Analyze, resolve, and prevent crashes",
        "Monitor your key workflows",
        "Get actionable session data",
        "3. Take preventive steps",
        "Metric-based alerts",
        "Event-based alerts",
        "4. Dig deeper into crashes",
        "Crash analysis",
        "Breadcrumbs",
        "Custom attributes",
        "5. Focus on KPIs",
        "Track and query feature use",
        "Measure page load times",
        "Examine data about webpage interactions"
      ],
      "title": "Mobile monitoring best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "32f5d3919c54c90173721a2cda556d8fd57744f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/mobile-monitoring-best-practices-guide/",
      "published_at": "2021-07-09T08:59:56Z",
      "updated_at": "2021-07-09T08:59:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "By eliminating crashes and increasing speed across the stack, you can build better performance into every mobile app release. Here are some best practices to take full advantage of mobile monitoring with New Relic. 1. Start collecting data Start collecting data in production. You'll see immediate value by adding our mobile monitoring SDK to your app for its next release to the app store. We recommend installing the iOS or Android agent to your production release even if you're simply testing New Relic's capabilities. This will ensure you'll get an adequate amount of data to really understand all of our mobile monitoring capabilities and your end users' experience. How to do it Add your mobile app to New Relic First, add a new app in New Relic's user interface (full steps): Go to one.newrelic.com and click Mobile. From the list of monitored apps, select Add more. Select the relevant platform. Type a name for your mobile app, and select Continue. Use one app and the associated app token for the development releases of your iOS app, another app and its associated app token for the production releases of that iOS app, and another pair of app tokens for development and production releases of your Android app. You'll be able to compare data from across the four app tokens using our query builder. Install and configure our mobile SDK Next, install and configure the mobile agent: Download the latest version of New Relic's SDK for iOS or Android, and add it to your mobile app. (Full steps for iOS and Android) Configure your installation as needed. For example: Enable the feature flag to capture MobileRequest events to use our full network analysis capabilities for iOS or Android. Automate dSYM uploads for your production builds. To avoid surprises, follow the standard pattern of where you start our mobile agent. In addition, start our agent before you initiate any other SDKs. For more information, see our documentation for Android installation and configuration and for iOS installation and configuration. Deploy a new release of your application. 2. Explore your data Immediately be able to explore your data. As soon as New Relic starts reporting data, take the time to explore the wealth of information about your mobile apps. To get started, go to one.newrelic.com and select Mobile. How to do it Analyze, resolve, and prevent crashes Find the cause of crashes so you can fix them. Then, uncover trends behind crashes so you can prevent them: From the summary UI page for a monitored mobile app, click Crash analysis. Analyze crash data so you can see and fix the most impactful crashes. Follow the breadcrumbs in the crash event trail to fix crashes and resolve critical errors more easily: From your mobile app's Crash analysis page in the UI, select a Crash type. From the crash type's Summary page, select the Crash trail tab. For more information, see our blog post about crash analysis. Monitor your key workflows Create custom breadcrumbs to monitor key workflows (such as your app's login or checkout process), track user clicks, optimize timing, and identify crash locations for faster MTTR. Get actionable session data Borrow from our example queries to: See how much of your user base has upgraded to your latest app version. Track adoption over time. Get a count of new installs as compared to upgrades from an earlier version. See the distribution of usage across geographical locations, carriers, ASN owners (wi-fi providers), devices, connection types, and more. 3. Take preventive steps Use alert notifications to help uncover the causes behind crashes and errors. Once you are running our mobile monitoring capabilities in production and have explored some of the key features, you can use New Relic to uncover critical issues with your mobile application. In particular, focus on crashes and errors. Use metric-based alerts as a starting point to gain high-level visibility into problems. Then, as new services or functionalities are added, use New Relic’s more targeted, event-based (NRQL) alerts to make sure that the most critical issues are handled swiftly. Use these alerts to determine whether a crash is impacting a large number of users. If it is, the relevant people (for example, both the mobile app team’s on-call member and the owner of the related back-end service) will be alerted. Make sure that your team knows how to respond to changes in crash rate (crashes per sessions) and the percentage of users impacted by crashes of your mobile app. How to do it Metric-based alerts Use our metric-based alerts and mobile monitoring UI: Ensure that key members of your mobile team have opted in to receive emails for new crashes. These emails will take you to the crash type in the UI page for your mobile app. Create an alert for your crash rate threshold that key members of your team can view in Slack or any other Alerts notification channel you choose. Your alert notification will include a link to our UI, where you can examine a chart with the exceeded threshold. From there, a link will take you to the relevant mobile monitoring page, where you can get additional details. Event-based alerts Combine the metric-based workflow with event-based alerts and dashboards specific to your mobile app and system. Create your NRQL alert that focuses on crashes of your most recently released production version. Create an additional NRQL alert that focuses on the percentage of users impacted by crashes in your latest app version (to check the overall impact on your user base). 4. Dig deeper into crashes Take your crash reporting to the next level. Now it’s time to tackle some of those harder-to-reproduce crashes by: Applying additional instrumentation to your application. Leveraging crash event trails, NRQL queries, and dashboards to visualize your data. How to do it Crash analysis Crashes are an inevitable part of running mobile applications at scale. We provide tools to help you understand your highest-impact crashes. Use the Crash analysis UI to see which crashes are occurring most often, the percentage of crash-free users, which files and methods are associated with perhaps 80 percent of your crashes, which crashes a particular user just experienced, and more. Go after high-impact crashes with crash analysis: Add custom attributes to categorize the highest-value customers, and then use them to segment crashes according to your most valuable audiences. Add breadcrumbs and custom events to produce a detailed trail of events leading up to every crash occurrence (over the last 90 days). Then, view this crash event trail in our mobile monitoring UI. Use our mobile monitoring's Versions trends page to make sure you’re improving the crash rate over subsequent releases and avoiding regressions. Breadcrumbs Use breadcrumbs and custom attributes to better reproduce and debug crashes. For example, use our recordBreadrumb API for Android or iOS to track mid-session changes in state that can help debug crashes, such as: Change of connection type Change of orientation CPU and memory state at key points in the app code Custom attributes Add custom attributes to existing events, so you can ask even more precise questions of your mobile app. Add dimensions such as: User ID: Use to react to specific user concerns and to better understand which customers and segments are most impacted. Store ID: Use to address problems with out-of-date devices, bad wi-fi, and so on. User segments: Use to better understand which customers and segments are most impacted; for example, logged in vs. non-logged in. Money in the cart at session end Origin or attribution of entry into the app Standardize custom attribute names across your mobile apps, and align with your website (if you're using our browser monitoring), so that you can compare and contrast performance across end-user channels. The mobile agents track the last interaction of crashed and non-crashed sessions to provide visibility into what the user viewed before exiting your app (either intentionally or due to a crash). 5. Focus on KPIs Bring your key performance indicators to life. Create custom interactions and events to hone in on the most important signals, including user activity for the business-critical aspects of your app. Using these powerful APIs, you can add custom instrumentation to just about anything. The following are some example use cases. How to do it Track and query feature use Use custom events to track feature use. For example: Use custom events to track user flow between app and website. Use custom events or mobile breadcrumbs to optimize the performance of key user flows (log in, shopping cart, etc.). use custom events to provide faster, contextualized support experiences for your digital customers. Use the recordCustomEvent API. Then compare the use of different features using: SELECT count(*) FROM MyNewMobileEventType FACET name Copy Measure page load times Use custom events to measure page load time: Create an app-launch timer to measure the time that elapses between a user-tap to launch your app and the point in your app code where the first screen is available. Record the timer value in New Relic using something like the following: recordCustomEvent(<myMobileTimers>, <appLaunch>, {attributes}) Copy Define start and stop timers to measure spinner durations, and then record this time in New Relic using something like the following: recordCustomEvent(<myMobileTimers>, <spinnerOnScreenA>, {attributes}) Copy Track specific user actions or funnel steps in the app (like \"add to cart\"), and include the price as an attribute on that event. Measure flows through the application by viewing the related funnel steps with custom events in Insights. For example, create a timer to track the start and end times of a subflow or an entire flow across multiple funnel steps to understand how long it took users to get through the process. Examine data about webpage interactions Use custom interactions to see traces associated with the same webpages. Use the agent API to disable default interactions, and focus on custom interactions so that you can review the page loads that are most crucial to your primary funnel. Define the start and stop times of these custom interactions to trace activities associated with individual steps of that funnel (for example, a specific user action or a page load). Track the last interactions of crashed and non-crashed sessions so that you can see what the user viewed before exiting your app (either intentionally or from a crash). Example query for non-crashed sessions: SELECT count(*) FROM Mobile WHERE sessionCrashed is null FACET lastInteraction SINCE 90 days ago Copy Example query for crashed sessions: SELECT count(*) FROM Mobile WHERE sessionCrashed is true FACET lastInteraction SINCE 90 days ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.19662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Mobile monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "sections": "Mobile monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "By eliminating crashes and increasing speed across the <em>stack</em>, you can build better performance into every mobile app release. Here are some <em>best</em> <em>practices</em> to take <em>full</em> advantage of mobile monitoring with <em>New</em> <em>Relic</em>. 1. Start collecting data Start collecting data in production. You&#x27;ll see immediate"
      },
      "id": "6044151e28ccbc19ab2c60d8"
    }
  ],
  "/docs/new-relic-solutions/best-practices-guides/full-stack-observability/browser-monitoring-best-practices-java": [
    {
      "sections": [
        "Browser monitoring best practices guide",
        "1. Use browser SPA agent",
        "How to do it",
        "2. Use APM auto-instrumentation",
        "Tip",
        "3. Customize Apdex",
        "4. Create alerts",
        "5. Use baseline alerts",
        "6. Add alerts to workflows",
        "7. Create dashboards",
        "8. Group your data",
        "9. Get the right data",
        "10. Break down performance data",
        "Want more user tips?"
      ],
      "title": "Browser monitoring best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "65e00c29691e851341248bcadf7302e955718ca8",
      "image": "https://docs.newrelic.com/static/bcbac83ecd75ee65ad36bbf8299ad89f/c1b63/best01_spapro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/browser-monitoring-best-practices-guide/",
      "published_at": "2021-07-09T09:17:17Z",
      "updated_at": "2021-07-09T09:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring tips & tricks that every user should know Get more out of browser monitoring, with deeper visibility into your websites and your users. Here are 10 best practices to help you find problems faster and deliver a better experience to your customers with real user monitoring. 1. Use browser SPA agent Use the browser SPA agent for deeper visibility Modern websites are complex, with dynamic content and sophisticated logic. See deeper into your user interactions, enable the single-page application (SPA) agent for browser and gain visibility into your user actions and the underlying webpage events behind them. This framework-agnostic agent is not only for single-page application frameworks like React, Angular, Ember, or Backbone, but also for custom frameworks and any other pages with dynamic content. Advanced timing analytics provide more granularity into Navigation Timing Specification API sub-timings beyond page rendering or DOM processing, with detailed performance data filtering useful for understanding all page lifecycles. How to do it From the browser app list, select an app, then select Settings > Application Settings. Select Pro + SPA. Click Save application settings Change your browser monitoring settings to switch to SPA. 2. Use APM auto-instrumentation Use APM automatic instrumentation over copy/paste If you’re also a APM customer, we recommend enabling automatic instrumentation where possible, as this will automatically inject the browser monitoring JavaScript agent into your frontend for you. Not only will the browser agent remain automatically up to date with this approach, using these products together helps unify frontend to backend visibility. For example, you’d be able to link frontend AJAX calls to their corresponding backend transaction, and to align your frontend and backend data together in an Insights dashboard. Tip Depending on your backend framework or CDN strategy, a copy/paste approach may be the better strategy. Just remember that it’ll require periodic updating. How to do it Select Settings > Application Settings. Select Enable via New Relic APM. Select Pro + SPA agent. Click Save application settings. one.newrelic.com > Browser > Settings > Application Settings 3. Customize Apdex Customize your Apdex threshold New Relic uses Apdex, an industry-standard metric, to measure users’ satisfaction with the response time of your applications. Apdex converts many measurements into one number on a uniform scale of 0 to 1 (0 = no users satisfied, 1 = all users satisfied). Apdex T is the central value for Apdex—it is the response time below which a transaction is considered “Satisfactory.” You can define Apdex T values for each application, with separate values for app server and end-user browser performance. (Note that many modern websites are bottlenecked primarily in the frontend browser, accounting for 90% or more of pageload times.) While a suggested T-value threshold is 5 seconds, we encourage you to customize your Apdex T value to fit the needs of your users and application. For example, an ecommerce site may want to have a lower T value to reduce bounce rates from potential buyers frustrated by a slow experience, compared to an internal employee application. However, the goal is to continually lower T-values over time to improve your digital customer experience. How to do it From the browser app list, select an app, then select Settings > Application settings. Set the Apdex T value (in seconds) for this application. Click Save application settings. one.newrelic.com > Browser > Settings > Application 4. Create alerts Create and evaluate alert policies What happens if your Apdex score exceeds your threshold? You want to be alerted whenever this happens, so that you can investigate what is causing the issue before you lose any customers. New Relic provides unified alerting across all our products, including browser monitoring, so that you’ll always be in the know. We recommend setting up alerts to monitor your Apdex score, along with these sample alerts to get you started: Apdex score: Alert if score is below 0.8 for 5 minutes. (If the Apdex score is below 0.8, that means 20% or more of your users are not “satisfied” with their experience on your website.) Page load time: Alert if median page load time is above 10 seconds for 5 minutes. (If the median page load time begins to spike, that suggest that something may be wrong with your web page causing it to significantly slow down. This complements alerting on your Apdex score.) JS errors: Alert if error rate is above 5% for 5 minutes. (If your frontend error rate starts spiking, particularly after a deployment, you may have introduced bad JavaScript into your frontend that should be fixed.) How to do it From Alerts & AI, select Go to Alerts, and click on Policies on the left column. Select (+) New alert policy to create a new alert policy, and give it a meaningful name. Click on Create a condition to create your first condition, then select Browser for your product and the Metric for the condition (which should be the default). Then click Next, select entities. Click the checkbox for the applications you want to alert on, and click Next, define thresholds. Pick the metrics of interest and their thresholds that determine when to trigger an alert. one.newrelic.com > Alerts & AI > Policies > New alert policy 5. Use baseline alerts Alert on anomalous behaviors and events While some metrics can be easily tracked against specific thresholds, other types of data can be more cyclical or have variable ranges for what’s considered healthy. Traffic throughput is a good example of this; it can have significantly cycles, but large traffic drops or spikes may be important indicators of a breakage preventing user traffic or a DDoS attack spiking traffic. Baseline alerts can be helpful for creating an expected \"band\" of normal activity to create more signal to noise in your alerting. How to do it From Alerts & AI, select Go to Alerts, and click on Policies on the left column. Select (+) New alert policy to create a new alert policy, and give it a meaningful name. Click on Create a condition to create your first condition, select Browser for your product and the Metric Baseline for the condition (which should be the default). Then click Next, select entities. Click the checkbox for the applications you want to alert on, and click Next, define thresholds. Pick the Page view throughput and use the slider to define the normal range you want to trigger the alert. one.newrelic.com > Alerts & AI > Policies > New alert policy 6. Add alerts to workflows Integrate your alerts into your workflows With the different alerting policies that you’re setting up, you’ll want to make sure to take advantage of the different alert notification channels available so that they’re integrated into team workflows. After all, what good are alerts if no one knows about them? You can route alerts through Slack, PagerDuty, webhooks, email, and more. You also have the opportunity to align alert notifications with your response processes, such as integrating with ChatOps or linking runbooks to your alerts. Be sure to evaluate alert policies on a regular basis to ensure that they are always valid. How to do it From Alerts & AI, click on Notification channels. Set up different notification channels, which can then be used within different alerting policies. 7. Create dashboards Create your own dashboards using New Relic Insights Browser automatically provides a curated experience to quickly triage issues, but you can also create bespoke dashboards with your frontend data with the query builder. Build unique real-time overviews of what’s going on in your frontend, and see how it fits with the rest of your technology stack. For example, you can: Create a browser-specific breakdown of percentiles, durations, and page views: SELECT average(duration),percentile(duration,50,75,95) as 'Percentile', count(*) as 'Pageviews' FROM PageView WHERE userAgentName='Chrome' SINCE 1 week ago Copy Break down route change performance into percentiles: SELECT count(*) as 'Route Change', average(duration) as 'Avg PageLoad',percentile(duration,50,75) as '%' ,average(jsDuration) as 'JS Duration' FROM BrowserInteraction FACET targetUrl where category = 'Route change' SINCE 1 day ago Copy Compare frontend performance to backend performance in APM: SELECT average(duration) as 'Avg Frontend Duration', average(backendDuration) FROM PageView SINCE 2 minutes ago UNTIL 10 seconds ago TIMESERIES Copy These individual widgets can be added together to create a team dashboard that’s shared across different engineering teams and the company. You can bring together web and mobile application data, backend data, infrastructure data, synthetic monitoring data, and more, all on a single custom dashboard across New Relic One. one.newrelic.com > Dashboards How to do it Go to one.newrelic.com, then click Query your data to access the query builder. In the NRQL tab of the query builder, paste the query into the NRQL> query bar and click Run. Type in a widget title, and add to either an existing or a new dashboard. Go to Dashboards to see your new dashboard. For more information, see our docs on data querying and dashboards. 8. Group your data Group your data into meaningful categories Different websites have different URL architectures, which can vary depending on content structure, technology framework, or SEO strategy. For example: website.com/product/widget-name website.com/gallery?product=109832 website.com/gallery/housewares/lamps/widget-name website.com/product#widget-name URL structure possibilities are endless, so browser includes an automatic grouping algorithm to set categories for that data into different URL groups. We recommend using URL grouping allowed lists to customize how your data is grouped together, which makes the corresponding performance information more useful and aligned to your website architecture. If the data generated by this default grouping is too high level, creating a URL grouping will disaggregate the data and give you greater granularity to make it more useful. For example, you could group by: Different page types: product pages vs. search pages Different forms, APIs, or user groupings Mobile vs. non-mobile Authenticated vs. non-authenticated Different content delivery networks (CDNs) How to do it In the browser monitoring UI, select Settings > Segment allow lists. In the Allow listed segments section, click on the + icon. Type in the URL segments you want to appear in groupings on the page views and AJAX pages. one.newrelic.com > Browser > Settings > Segment allow lists. 9. Get the right data Make sure you get data only from the right sources Browser data is generated from wherever your JavaScript agent is instrumented, though copies of your agent might become duplicated, such as through development, staging, or other environments, resulting in additional data being included from these sources that you would not want mixed with your production data. You can use domain conditions to allow or deny data from the different website domains you want monitored. How to do it In the browser monitoring UI, select Settings > Domain conditions. If there are no domain conditions in place, select Enable domain conditions. If conditions exist, select Next, Choose your setting. Select Deny only or Allow only to identify the data you want collected from the domains you want monitored. Then select Next, Create conditions. Enter the domain string conditions that you want to deny or allow data collection (maximum 10 conditions). Review and confirm your domain condition settings. one.newrelic.com > Browser > Settings > Domain conditions. 10. Break down performance data Break down performance across your users, business, and more By leveraging New Relic APIs, you can add vital context to your performance data as it relates to your technology, users, and your business. All our monitoring tools send their data to New Relic One, which enables plenty of customization and extensibility in your dashboarding. Just be sure to standardize naming for custom events and attributes across different data sources (such as between browser and mobile) for omnichannel engagement. Here are some examples of what you can measure: Build id: Pass in a build number to A/B test differences between versions User id: Manage your VIP customers and track their experience Cart value: Understand how much revenue is at risk when errors occur during checkout Content type: Track the type of content your users are viewing Video playback: See how users are consuming your media content The possibilities are endless. And as you can see, this type of reporting creates context around how your application performance impacts the rest of the business. How to do it Use our APIs to pass custom data about people, things, money, and more into New Relic One. Visit one.newrelic.com, and query on the custom data that is now available. For more information, see our docs on data querying and dashboards. one.newrelic.com > Dashboards > (selected dashboard). Want more user tips? View training videos at New Relic University. Read the Browser documentation. Check out our Tutorials page. Ask a question in the New Relic Community Forum.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.4674,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "sections": "Browser monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "Browser monitoring tips &amp; tricks that every user should know Get more out of browser monitoring, with deeper visibility into your websites and your users. Here are 10 <em>best</em> <em>practices</em> to help you find problems faster and deliver a better experience to your customers with real user monitoring. 1. Use"
      },
      "id": "60441b4a28ccbc584a2c6095"
    },
    {
      "sections": [
        "APM best practices guide",
        "Tip",
        "1. Standardize application names",
        "How to do it",
        "2. Add tags to your applications",
        "Caution",
        "3. Create and evaluate alert policies",
        "4. Identify and set up key transactions",
        "5. Track deployment history",
        "6. Review APM reports",
        "7. Review your environment with service maps",
        "8. Keep current",
        "9. Manage user access",
        "Important"
      ],
      "title": "APM best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "368a1a5688384d5bebf128604a9b8f190d335524",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/apm-best-practices-guide/",
      "published_at": "2021-07-09T09:16:17Z",
      "updated_at": "2021-07-09T09:16:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Application Monitoring Tips You Need To Know It's one thing to know how to use APM, but it's another thing to know how to use New Relic's application performance monitoring software well. Here are some best practices designed to help you become an APM master—and a key asset to your team! Tip To get a high-level overview of all your applications and services, use the New Relic Explorer in New Relic One. 1. Standardize application names Most New Relic agents provide a default application name, such as \"My Application\" or \"PHP Application,\" if you don't specify one in your New Relic configuration file. You don't want to end up with 20 identically named applications, be sure to select a descriptive identifier for your apps as soon you deploy them. To keep things consistent and easy to navigate, New Relic recommends standardizing your application naming (for example, all apps in Staging append [ Staging] or the like at the end of their names). Ideally, you want your new Java applications to be named automatically to reduce the chances of typographical errors and misnaming. How to do it For Java applications, automatic application naming can come from the following sources: Request attribute Servlet init parameter Filter init parameter Web app context parameter Web app context name (display name) Web app context path Choose the method that fits best your needs and follow these steps. For non-Java applications, there are no automatic naming methods, so refer to the documentation for your APM agent. 2. Add tags to your applications When several different applications use the same account, and each application spans multiple environments (for example, development, test, pre-production, production), it can be hard to find a specific application in your overview dashboard. That's why we recommend adding tags to your apps so that you can segment them into logical groups. The two most common tags that mature APM customers use are application name and environment. So, for example, if you wanted to view the billing application in Test, you could simply filter by \"billing app\" (name tag) and \"test\" (environment tag). Caution In the APM agent configuration settings files, use the labels field to add tags to your data. For example, see this description of the Python labels setting. APM is designed so that apps can roll up into an unlimited number of meaningful tag categories. How to do it Learn about tags. Learn how to add tags.. Learn how to query tags. 3. Create and evaluate alert policies When key performance indicators spike or drop, individuals and teams in your organization need to be notified. Alerting in New Relic provides a set of tools including dynamic baselines that allow you to detect problems before they impact your end users. Alert policies can be set up in two primary ways: Static threshold alerts are great when you already know the nature of an application and its normal behaviors aren't likely to change anytime soon. Apdex score, response time, error rate, throughput are some of the static thresholds you can create alert policies on. Dynamic baseline alerts make it easy to determine and set dynamic alert thresholds for applications with varying seasonal patterns and growth trends (which make it difficult to set thresholds that define normal behavior). These alerts use baselines modeled from your application’s historical metric data. Each alert policy can contain as many conditions as you need, and each alert condition includes three components: Type of condition (metric, external service, and so on) Entities that the policy targets (for example, APM apps, browser monitoring apps, or hosts) Thresholds that escalate into alerting situations with increasing severity Once you have your alerting set up, you then want to make sure you're taking advantage of all viable notification channels. After all, what good are alerts if no one knows about them? You can manage alerts by creating specific user groups and by leveraging New Relic's integrated alert channels, including Slack, PagerDuty, webhooks, and email. Be sure to evaluate alert policies on a regular basis to ensure that they are always valid. How to do it See the detailed documentation: To set up dynamic baseline alerts and choose an application, follow standard procedures. You will see a preview of the metric with the predicted baseline You can select a metric for that application and see the corresponding baseline. Then, using the threshold sliders, you can set how closely you want your threshold to follow the baseline prediction. To set up static threshold alerts for your Apdex settings, follow standard procedures. To set up your alert notification channels, follow standard procedures. 4. Identify and set up key transactions Depending on the nature of your application, some transactions may be more important to you than others. New Relic's key transactions feature is designed to help you closely monitor what you consider to be your app's most business-critical transactions, whether that's end-user or app response time, call counts, error rates, or something else. You can also set alert threshold levels for notifications when your key transactions are performing poorly. How to do it In the menu bar, select More > Key transactions, and then select Add more. Then select the app and web transaction or, from the selected transaction, select Track as key transaction. Type a name for the key transaction, and select Track key transaction. Optional: If the agent for the selected app supports custom alerting, use the default values that New Relic automatically fills, or select Edit key alert transaction policy to set the Apdex and alert threshold values. To view the key transactions dashboard details, select View new key transaction. 5. Track deployment history When development teams are pushing new code out as frequently as possible, it can be hard to measure the impact that each deployment is having on performance. One way to stay in tune with how these changes are affecting your application is with deployment reports. These reports list recent deployments and their impact on end-users and app servers' Apdex scores, along with response times, throughput, and errors. You can also view and drill down into the details to catch errors related to recent deployments, or file a ticket and share details with your team. How to do it From the New Relic menu bar, select APM > (selected app) > Events > Deployments. To view performance after a deployment, go to the selected app's Overview dashboard in the Recent events section. A blue vertical bar on a chart indicates a deployment. To view summary information about the deployment, point to the blue bar. 6. Review APM reports From SLA, deployment, and capacity to scalability, host usage reports, and more, New Relic APM offers a variety of downloadable reporting tools surfacing historical trends—all great ways to report to senior executive teams or customers. Take a look at the full list of reports and use them to your advantage. How to do it From the New Relic APM menu bar, select Applications > (selected app) > Reports. Select the report you'd like to see. If you want to save or export a report to share, select Download this report as .csv, which will create a report with comma-separated values. 7. Review your environment with service maps Use New Relic service maps, a feature included in APM, to understand how apps and services in your architecture connect and talk to each other. Service maps are visual, customizable representations of your application architecture. Maps automatically show you your app's connections and dependencies, including databases and external services. Health indicators and performance metrics show you the current operational status for every part of your architecture. How to do it Go to one.newrelic.com > More > service maps. To get started, read the instructions in Introduction to service maps. 8. Keep current With New Relic’s SaaS platform, getting new features is as easy as updating your agent. Most likely your organization already has a set of scripts for deploying application upgrades into your environment. In a similar fashion, you can also automate your New Relic agent deployment to ensure that your systems are up to date. Both Puppet and Chef scripts are great examples of deployment frameworks that make life easier by allowing you to automate your entire deployment and management process. How to do it Regularly review which version of the agent you're using so that you know when an update is needed. If the latest agent release contains a needed fix or added functionality, download it. To deploy the agent automatically (preferred as a method to avoid errors): Use existing deployment scripts, provided they can be adapted to handle the deployment. OR Create and maintain a script that specifically deploys and configures the New Relic agent. Ideally, the script would pull the agent files from a repository where the files are versioned (for rollback purposes). Once the script has been created, shut down the application (unless script handles this). Run the deployment script. Start the application (unless script handles this). If problems arise, run the script to roll back to the previous version. To deploy the agent manually: Back up the current agent directory. Deploy the updated agent into the existing agent directory. Modify configuration files by comparing new files with existing files. In particular, make sure things like license key and custom extensions are copied over to the new configuration. Restart the application. If problems arise, restore the old agent using the backup and restart. 9. Manage user access Important This is available only for accounts on our original product-based pricing plan. Enable role-based access control (RBAC) and single sign-on (SSO) New Relic allows authorized individuals to access the broadest possible amount of data, regardless of their assigned role. As an Owner or Administrator of your New Relic account, you can control the permissions of individual users or entire roles with RBAC. To find out what is possible and how to make changes, see Users and roles. Security is no doubt of utmost concern to your organization. To simplify password management for your employees and strengthen security, you may already be using SSO with your other systems. You should do the same with New Relic. Using New Relic's SSO integration feature, account administrators will be able to enforce strong passwords and restrict login via a corporate authentication mechanism. This way, New Relic users who have already authenticated using a corporate SSO system will be able to bypass the New Relic login prompt. How to do it Log in to New Relic as an admin and go to the SSO configuration page. From the New Relic title bar, select (your account name) > Account Settings > Integrations > Single Sign On. From the SAML Single Sign On page, review your New Relic SAML Service Provider details. To upload your SAML Identity Provider certificate, select Choose File, and then follow standard procedures to select and save the file. Copy and paste in (or type) the Remove login URL that your users will use for Single Sign-On. If your organization’s SAML integration provides a redirect URL for logout, copy and paste in (or type) the Logout landing URL; otherwise leave blank. Save, test, and enable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.45154,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>best</em> <em>practices</em> <em>guide</em>",
        "sections": "APM <em>best</em> <em>practices</em> <em>guide</em>",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "Application Monitoring Tips You Need To Know It&#x27;s one thing to know how to use APM, but it&#x27;s another thing to know how to use <em>New</em> <em>Relic</em>&#x27;s application performance monitoring software well. Here are some <em>best</em> <em>practices</em> designed to help you become an APM master—and a key asset to your team! Tip To get"
      },
      "id": "6044186564441f1f94378ecc"
    },
    {
      "sections": [
        "Mobile monitoring best practices guide",
        "1. Start collecting data",
        "How to do it",
        "Add your mobile app to New Relic",
        "Install and configure our mobile SDK",
        "2. Explore your data",
        "Analyze, resolve, and prevent crashes",
        "Monitor your key workflows",
        "Get actionable session data",
        "3. Take preventive steps",
        "Metric-based alerts",
        "Event-based alerts",
        "4. Dig deeper into crashes",
        "Crash analysis",
        "Breadcrumbs",
        "Custom attributes",
        "5. Focus on KPIs",
        "Track and query feature use",
        "Measure page load times",
        "Examine data about webpage interactions"
      ],
      "title": "Mobile monitoring best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "32f5d3919c54c90173721a2cda556d8fd57744f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/mobile-monitoring-best-practices-guide/",
      "published_at": "2021-07-09T08:59:56Z",
      "updated_at": "2021-07-09T08:59:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "By eliminating crashes and increasing speed across the stack, you can build better performance into every mobile app release. Here are some best practices to take full advantage of mobile monitoring with New Relic. 1. Start collecting data Start collecting data in production. You'll see immediate value by adding our mobile monitoring SDK to your app for its next release to the app store. We recommend installing the iOS or Android agent to your production release even if you're simply testing New Relic's capabilities. This will ensure you'll get an adequate amount of data to really understand all of our mobile monitoring capabilities and your end users' experience. How to do it Add your mobile app to New Relic First, add a new app in New Relic's user interface (full steps): Go to one.newrelic.com and click Mobile. From the list of monitored apps, select Add more. Select the relevant platform. Type a name for your mobile app, and select Continue. Use one app and the associated app token for the development releases of your iOS app, another app and its associated app token for the production releases of that iOS app, and another pair of app tokens for development and production releases of your Android app. You'll be able to compare data from across the four app tokens using our query builder. Install and configure our mobile SDK Next, install and configure the mobile agent: Download the latest version of New Relic's SDK for iOS or Android, and add it to your mobile app. (Full steps for iOS and Android) Configure your installation as needed. For example: Enable the feature flag to capture MobileRequest events to use our full network analysis capabilities for iOS or Android. Automate dSYM uploads for your production builds. To avoid surprises, follow the standard pattern of where you start our mobile agent. In addition, start our agent before you initiate any other SDKs. For more information, see our documentation for Android installation and configuration and for iOS installation and configuration. Deploy a new release of your application. 2. Explore your data Immediately be able to explore your data. As soon as New Relic starts reporting data, take the time to explore the wealth of information about your mobile apps. To get started, go to one.newrelic.com and select Mobile. How to do it Analyze, resolve, and prevent crashes Find the cause of crashes so you can fix them. Then, uncover trends behind crashes so you can prevent them: From the summary UI page for a monitored mobile app, click Crash analysis. Analyze crash data so you can see and fix the most impactful crashes. Follow the breadcrumbs in the crash event trail to fix crashes and resolve critical errors more easily: From your mobile app's Crash analysis page in the UI, select a Crash type. From the crash type's Summary page, select the Crash trail tab. For more information, see our blog post about crash analysis. Monitor your key workflows Create custom breadcrumbs to monitor key workflows (such as your app's login or checkout process), track user clicks, optimize timing, and identify crash locations for faster MTTR. Get actionable session data Borrow from our example queries to: See how much of your user base has upgraded to your latest app version. Track adoption over time. Get a count of new installs as compared to upgrades from an earlier version. See the distribution of usage across geographical locations, carriers, ASN owners (wi-fi providers), devices, connection types, and more. 3. Take preventive steps Use alert notifications to help uncover the causes behind crashes and errors. Once you are running our mobile monitoring capabilities in production and have explored some of the key features, you can use New Relic to uncover critical issues with your mobile application. In particular, focus on crashes and errors. Use metric-based alerts as a starting point to gain high-level visibility into problems. Then, as new services or functionalities are added, use New Relic’s more targeted, event-based (NRQL) alerts to make sure that the most critical issues are handled swiftly. Use these alerts to determine whether a crash is impacting a large number of users. If it is, the relevant people (for example, both the mobile app team’s on-call member and the owner of the related back-end service) will be alerted. Make sure that your team knows how to respond to changes in crash rate (crashes per sessions) and the percentage of users impacted by crashes of your mobile app. How to do it Metric-based alerts Use our metric-based alerts and mobile monitoring UI: Ensure that key members of your mobile team have opted in to receive emails for new crashes. These emails will take you to the crash type in the UI page for your mobile app. Create an alert for your crash rate threshold that key members of your team can view in Slack or any other Alerts notification channel you choose. Your alert notification will include a link to our UI, where you can examine a chart with the exceeded threshold. From there, a link will take you to the relevant mobile monitoring page, where you can get additional details. Event-based alerts Combine the metric-based workflow with event-based alerts and dashboards specific to your mobile app and system. Create your NRQL alert that focuses on crashes of your most recently released production version. Create an additional NRQL alert that focuses on the percentage of users impacted by crashes in your latest app version (to check the overall impact on your user base). 4. Dig deeper into crashes Take your crash reporting to the next level. Now it’s time to tackle some of those harder-to-reproduce crashes by: Applying additional instrumentation to your application. Leveraging crash event trails, NRQL queries, and dashboards to visualize your data. How to do it Crash analysis Crashes are an inevitable part of running mobile applications at scale. We provide tools to help you understand your highest-impact crashes. Use the Crash analysis UI to see which crashes are occurring most often, the percentage of crash-free users, which files and methods are associated with perhaps 80 percent of your crashes, which crashes a particular user just experienced, and more. Go after high-impact crashes with crash analysis: Add custom attributes to categorize the highest-value customers, and then use them to segment crashes according to your most valuable audiences. Add breadcrumbs and custom events to produce a detailed trail of events leading up to every crash occurrence (over the last 90 days). Then, view this crash event trail in our mobile monitoring UI. Use our mobile monitoring's Versions trends page to make sure you’re improving the crash rate over subsequent releases and avoiding regressions. Breadcrumbs Use breadcrumbs and custom attributes to better reproduce and debug crashes. For example, use our recordBreadrumb API for Android or iOS to track mid-session changes in state that can help debug crashes, such as: Change of connection type Change of orientation CPU and memory state at key points in the app code Custom attributes Add custom attributes to existing events, so you can ask even more precise questions of your mobile app. Add dimensions such as: User ID: Use to react to specific user concerns and to better understand which customers and segments are most impacted. Store ID: Use to address problems with out-of-date devices, bad wi-fi, and so on. User segments: Use to better understand which customers and segments are most impacted; for example, logged in vs. non-logged in. Money in the cart at session end Origin or attribution of entry into the app Standardize custom attribute names across your mobile apps, and align with your website (if you're using our browser monitoring), so that you can compare and contrast performance across end-user channels. The mobile agents track the last interaction of crashed and non-crashed sessions to provide visibility into what the user viewed before exiting your app (either intentionally or due to a crash). 5. Focus on KPIs Bring your key performance indicators to life. Create custom interactions and events to hone in on the most important signals, including user activity for the business-critical aspects of your app. Using these powerful APIs, you can add custom instrumentation to just about anything. The following are some example use cases. How to do it Track and query feature use Use custom events to track feature use. For example: Use custom events to track user flow between app and website. Use custom events or mobile breadcrumbs to optimize the performance of key user flows (log in, shopping cart, etc.). use custom events to provide faster, contextualized support experiences for your digital customers. Use the recordCustomEvent API. Then compare the use of different features using: SELECT count(*) FROM MyNewMobileEventType FACET name Copy Measure page load times Use custom events to measure page load time: Create an app-launch timer to measure the time that elapses between a user-tap to launch your app and the point in your app code where the first screen is available. Record the timer value in New Relic using something like the following: recordCustomEvent(<myMobileTimers>, <appLaunch>, {attributes}) Copy Define start and stop timers to measure spinner durations, and then record this time in New Relic using something like the following: recordCustomEvent(<myMobileTimers>, <spinnerOnScreenA>, {attributes}) Copy Track specific user actions or funnel steps in the app (like \"add to cart\"), and include the price as an attribute on that event. Measure flows through the application by viewing the related funnel steps with custom events in Insights. For example, create a timer to track the start and end times of a subflow or an entire flow across multiple funnel steps to understand how long it took users to get through the process. Examine data about webpage interactions Use custom interactions to see traces associated with the same webpages. Use the agent API to disable default interactions, and focus on custom interactions so that you can review the page loads that are most crucial to your primary funnel. Define the start and stop times of these custom interactions to trace activities associated with individual steps of that funnel (for example, a specific user action or a page load). Track the last interactions of crashed and non-crashed sessions so that you can see what the user viewed before exiting your app (either intentionally or from a crash). Example query for non-crashed sessions: SELECT count(*) FROM Mobile WHERE sessionCrashed is null FACET lastInteraction SINCE 90 days ago Copy Example query for crashed sessions: SELECT count(*) FROM Mobile WHERE sessionCrashed is true FACET lastInteraction SINCE 90 days ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.19662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Mobile monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "sections": "Mobile monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "By eliminating crashes and increasing speed across the <em>stack</em>, you can build better performance into every mobile app release. Here are some <em>best</em> <em>practices</em> to take <em>full</em> advantage of mobile monitoring with <em>New</em> <em>Relic</em>. 1. Start collecting data Start collecting data in production. You&#x27;ll see immediate"
      },
      "id": "6044151e28ccbc19ab2c60d8"
    }
  ],
  "/docs/new-relic-solutions/best-practices-guides/full-stack-observability/infrastructure-monitoring-best-practices-guide": [
    {
      "sections": [
        "Browser monitoring best practices guide",
        "1. Use browser SPA agent",
        "How to do it",
        "2. Use APM auto-instrumentation",
        "Tip",
        "3. Customize Apdex",
        "4. Create alerts",
        "5. Use baseline alerts",
        "6. Add alerts to workflows",
        "7. Create dashboards",
        "8. Group your data",
        "9. Get the right data",
        "10. Break down performance data",
        "Want more user tips?"
      ],
      "title": "Browser monitoring best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "65e00c29691e851341248bcadf7302e955718ca8",
      "image": "https://docs.newrelic.com/static/bcbac83ecd75ee65ad36bbf8299ad89f/c1b63/best01_spapro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/browser-monitoring-best-practices-guide/",
      "published_at": "2021-07-09T09:17:17Z",
      "updated_at": "2021-07-09T09:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring tips & tricks that every user should know Get more out of browser monitoring, with deeper visibility into your websites and your users. Here are 10 best practices to help you find problems faster and deliver a better experience to your customers with real user monitoring. 1. Use browser SPA agent Use the browser SPA agent for deeper visibility Modern websites are complex, with dynamic content and sophisticated logic. See deeper into your user interactions, enable the single-page application (SPA) agent for browser and gain visibility into your user actions and the underlying webpage events behind them. This framework-agnostic agent is not only for single-page application frameworks like React, Angular, Ember, or Backbone, but also for custom frameworks and any other pages with dynamic content. Advanced timing analytics provide more granularity into Navigation Timing Specification API sub-timings beyond page rendering or DOM processing, with detailed performance data filtering useful for understanding all page lifecycles. How to do it From the browser app list, select an app, then select Settings > Application Settings. Select Pro + SPA. Click Save application settings Change your browser monitoring settings to switch to SPA. 2. Use APM auto-instrumentation Use APM automatic instrumentation over copy/paste If you’re also a APM customer, we recommend enabling automatic instrumentation where possible, as this will automatically inject the browser monitoring JavaScript agent into your frontend for you. Not only will the browser agent remain automatically up to date with this approach, using these products together helps unify frontend to backend visibility. For example, you’d be able to link frontend AJAX calls to their corresponding backend transaction, and to align your frontend and backend data together in an Insights dashboard. Tip Depending on your backend framework or CDN strategy, a copy/paste approach may be the better strategy. Just remember that it’ll require periodic updating. How to do it Select Settings > Application Settings. Select Enable via New Relic APM. Select Pro + SPA agent. Click Save application settings. one.newrelic.com > Browser > Settings > Application Settings 3. Customize Apdex Customize your Apdex threshold New Relic uses Apdex, an industry-standard metric, to measure users’ satisfaction with the response time of your applications. Apdex converts many measurements into one number on a uniform scale of 0 to 1 (0 = no users satisfied, 1 = all users satisfied). Apdex T is the central value for Apdex—it is the response time below which a transaction is considered “Satisfactory.” You can define Apdex T values for each application, with separate values for app server and end-user browser performance. (Note that many modern websites are bottlenecked primarily in the frontend browser, accounting for 90% or more of pageload times.) While a suggested T-value threshold is 5 seconds, we encourage you to customize your Apdex T value to fit the needs of your users and application. For example, an ecommerce site may want to have a lower T value to reduce bounce rates from potential buyers frustrated by a slow experience, compared to an internal employee application. However, the goal is to continually lower T-values over time to improve your digital customer experience. How to do it From the browser app list, select an app, then select Settings > Application settings. Set the Apdex T value (in seconds) for this application. Click Save application settings. one.newrelic.com > Browser > Settings > Application 4. Create alerts Create and evaluate alert policies What happens if your Apdex score exceeds your threshold? You want to be alerted whenever this happens, so that you can investigate what is causing the issue before you lose any customers. New Relic provides unified alerting across all our products, including browser monitoring, so that you’ll always be in the know. We recommend setting up alerts to monitor your Apdex score, along with these sample alerts to get you started: Apdex score: Alert if score is below 0.8 for 5 minutes. (If the Apdex score is below 0.8, that means 20% or more of your users are not “satisfied” with their experience on your website.) Page load time: Alert if median page load time is above 10 seconds for 5 minutes. (If the median page load time begins to spike, that suggest that something may be wrong with your web page causing it to significantly slow down. This complements alerting on your Apdex score.) JS errors: Alert if error rate is above 5% for 5 minutes. (If your frontend error rate starts spiking, particularly after a deployment, you may have introduced bad JavaScript into your frontend that should be fixed.) How to do it From Alerts & AI, select Go to Alerts, and click on Policies on the left column. Select (+) New alert policy to create a new alert policy, and give it a meaningful name. Click on Create a condition to create your first condition, then select Browser for your product and the Metric for the condition (which should be the default). Then click Next, select entities. Click the checkbox for the applications you want to alert on, and click Next, define thresholds. Pick the metrics of interest and their thresholds that determine when to trigger an alert. one.newrelic.com > Alerts & AI > Policies > New alert policy 5. Use baseline alerts Alert on anomalous behaviors and events While some metrics can be easily tracked against specific thresholds, other types of data can be more cyclical or have variable ranges for what’s considered healthy. Traffic throughput is a good example of this; it can have significantly cycles, but large traffic drops or spikes may be important indicators of a breakage preventing user traffic or a DDoS attack spiking traffic. Baseline alerts can be helpful for creating an expected \"band\" of normal activity to create more signal to noise in your alerting. How to do it From Alerts & AI, select Go to Alerts, and click on Policies on the left column. Select (+) New alert policy to create a new alert policy, and give it a meaningful name. Click on Create a condition to create your first condition, select Browser for your product and the Metric Baseline for the condition (which should be the default). Then click Next, select entities. Click the checkbox for the applications you want to alert on, and click Next, define thresholds. Pick the Page view throughput and use the slider to define the normal range you want to trigger the alert. one.newrelic.com > Alerts & AI > Policies > New alert policy 6. Add alerts to workflows Integrate your alerts into your workflows With the different alerting policies that you’re setting up, you’ll want to make sure to take advantage of the different alert notification channels available so that they’re integrated into team workflows. After all, what good are alerts if no one knows about them? You can route alerts through Slack, PagerDuty, webhooks, email, and more. You also have the opportunity to align alert notifications with your response processes, such as integrating with ChatOps or linking runbooks to your alerts. Be sure to evaluate alert policies on a regular basis to ensure that they are always valid. How to do it From Alerts & AI, click on Notification channels. Set up different notification channels, which can then be used within different alerting policies. 7. Create dashboards Create your own dashboards using New Relic Insights Browser automatically provides a curated experience to quickly triage issues, but you can also create bespoke dashboards with your frontend data with the query builder. Build unique real-time overviews of what’s going on in your frontend, and see how it fits with the rest of your technology stack. For example, you can: Create a browser-specific breakdown of percentiles, durations, and page views: SELECT average(duration),percentile(duration,50,75,95) as 'Percentile', count(*) as 'Pageviews' FROM PageView WHERE userAgentName='Chrome' SINCE 1 week ago Copy Break down route change performance into percentiles: SELECT count(*) as 'Route Change', average(duration) as 'Avg PageLoad',percentile(duration,50,75) as '%' ,average(jsDuration) as 'JS Duration' FROM BrowserInteraction FACET targetUrl where category = 'Route change' SINCE 1 day ago Copy Compare frontend performance to backend performance in APM: SELECT average(duration) as 'Avg Frontend Duration', average(backendDuration) FROM PageView SINCE 2 minutes ago UNTIL 10 seconds ago TIMESERIES Copy These individual widgets can be added together to create a team dashboard that’s shared across different engineering teams and the company. You can bring together web and mobile application data, backend data, infrastructure data, synthetic monitoring data, and more, all on a single custom dashboard across New Relic One. one.newrelic.com > Dashboards How to do it Go to one.newrelic.com, then click Query your data to access the query builder. In the NRQL tab of the query builder, paste the query into the NRQL> query bar and click Run. Type in a widget title, and add to either an existing or a new dashboard. Go to Dashboards to see your new dashboard. For more information, see our docs on data querying and dashboards. 8. Group your data Group your data into meaningful categories Different websites have different URL architectures, which can vary depending on content structure, technology framework, or SEO strategy. For example: website.com/product/widget-name website.com/gallery?product=109832 website.com/gallery/housewares/lamps/widget-name website.com/product#widget-name URL structure possibilities are endless, so browser includes an automatic grouping algorithm to set categories for that data into different URL groups. We recommend using URL grouping allowed lists to customize how your data is grouped together, which makes the corresponding performance information more useful and aligned to your website architecture. If the data generated by this default grouping is too high level, creating a URL grouping will disaggregate the data and give you greater granularity to make it more useful. For example, you could group by: Different page types: product pages vs. search pages Different forms, APIs, or user groupings Mobile vs. non-mobile Authenticated vs. non-authenticated Different content delivery networks (CDNs) How to do it In the browser monitoring UI, select Settings > Segment allow lists. In the Allow listed segments section, click on the + icon. Type in the URL segments you want to appear in groupings on the page views and AJAX pages. one.newrelic.com > Browser > Settings > Segment allow lists. 9. Get the right data Make sure you get data only from the right sources Browser data is generated from wherever your JavaScript agent is instrumented, though copies of your agent might become duplicated, such as through development, staging, or other environments, resulting in additional data being included from these sources that you would not want mixed with your production data. You can use domain conditions to allow or deny data from the different website domains you want monitored. How to do it In the browser monitoring UI, select Settings > Domain conditions. If there are no domain conditions in place, select Enable domain conditions. If conditions exist, select Next, Choose your setting. Select Deny only or Allow only to identify the data you want collected from the domains you want monitored. Then select Next, Create conditions. Enter the domain string conditions that you want to deny or allow data collection (maximum 10 conditions). Review and confirm your domain condition settings. one.newrelic.com > Browser > Settings > Domain conditions. 10. Break down performance data Break down performance across your users, business, and more By leveraging New Relic APIs, you can add vital context to your performance data as it relates to your technology, users, and your business. All our monitoring tools send their data to New Relic One, which enables plenty of customization and extensibility in your dashboarding. Just be sure to standardize naming for custom events and attributes across different data sources (such as between browser and mobile) for omnichannel engagement. Here are some examples of what you can measure: Build id: Pass in a build number to A/B test differences between versions User id: Manage your VIP customers and track their experience Cart value: Understand how much revenue is at risk when errors occur during checkout Content type: Track the type of content your users are viewing Video playback: See how users are consuming your media content The possibilities are endless. And as you can see, this type of reporting creates context around how your application performance impacts the rest of the business. How to do it Use our APIs to pass custom data about people, things, money, and more into New Relic One. Visit one.newrelic.com, and query on the custom data that is now available. For more information, see our docs on data querying and dashboards. one.newrelic.com > Dashboards > (selected dashboard). Want more user tips? View training videos at New Relic University. Read the Browser documentation. Check out our Tutorials page. Ask a question in the New Relic Community Forum.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.46716,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "sections": "Browser monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "Browser monitoring tips &amp; tricks that every user should know Get more out of browser monitoring, with deeper visibility into your websites and your users. Here are 10 <em>best</em> <em>practices</em> to help you find problems faster and deliver a better experience to your customers with real user monitoring. 1. Use"
      },
      "id": "60441b4a28ccbc584a2c6095"
    },
    {
      "sections": [
        "Browser monitoring best practices in Java",
        "Ensure you are using the Apache Jasper compiler.",
        "Place meta tags immediately after the initial head tag.",
        "Avoid if ... else statements in the head section.",
        "Avoid expressions with the less than sign in the head section."
      ],
      "title": "Browser monitoring best practices in Java",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "536c56c90f1dcd9dee65692a229ffde9762f177e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/browser-monitoring-best-practices-java/",
      "published_at": "2021-07-09T09:17:17Z",
      "updated_at": "2021-07-09T09:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring with APM for Java to measure end-user load times. This document explains best practices for setting up browser monitoring. For information on how to set up browser monitoring for your Java app, see Browser monitoring and the Java agent. Ensure you are using the Apache Jasper compiler. The New Relic Java agent only auto-instruments pages compiled with the Apache Jasper compiler. The following application servers use the Jasper compiler by default: Tomcat Jetty Glassfish JBoss 4 Place meta tags immediately after the initial head tag. Recommendation: Place all <meta> tags immediately after the initial <head> tag. Some meta tags have requirements on how close they need to be to the beginning of an HTML document. The character encoding must be declared within the first 512 bytes of the HTML document. If the New Relic header is placed before the character encoding, it is possible for the character encoding to then be outside that 512 byte limit. Placing the character encoding meta tag immediately after the <head> tag will ensure that the New Relic header is positioned after the character encoding. <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> . . . </head> Copy The X-UA-Compatible meta tag should be within the meta tags immediately after the <head> tag. This tag allows page authors to set the document mode used for rending the page in Internet Explorer. This tag should be placed before any script tags. If the New Relic header is positioned before the X-UA-Compatible meta tag, the page might display incorrectly in Internet Explorer. <!DOCTYPE html> <html> <head> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=9\"> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> . . . </head> Copy Avoid if ... else statements in the head section. The auto instrumentation script does not recognize if ... else statements within a JSP page. If you have an if ... else block before your first non-meta, non-title tag, the New Relic header might be placed in the incorrect position in the page. For example, this code could potentially cause the auto instrumentation script to be inserted before the meta tags: if (expression) { <nonmeta tag> } <meta tag> <meta tag> Copy Avoid expressions with the less than sign in the head section. The New Relic Java agent looks for the open angle bracket < to mark the beginning of an HTML tag. This means if you have an expression using a less than sign, then you will either need to change your expression to use a greater than sign or use manual instrumentation. For example: <head> <% for (i = 0; i < variable; i++) . . . %> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.46716,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring <em>best</em> <em>practices</em> in Java",
        "sections": "Browser monitoring <em>best</em> <em>practices</em> in Java",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "You can use browser monitoring with APM for Java to measure end-user load times. This document explains <em>best</em> <em>practices</em> for setting up browser monitoring. For information on how to set up browser monitoring for your Java app, see Browser monitoring and the Java agent. Ensure you are using the Apache"
      },
      "id": "60441afc64441f7f65378f02"
    },
    {
      "sections": [
        "APM best practices guide",
        "Tip",
        "1. Standardize application names",
        "How to do it",
        "2. Add tags to your applications",
        "Caution",
        "3. Create and evaluate alert policies",
        "4. Identify and set up key transactions",
        "5. Track deployment history",
        "6. Review APM reports",
        "7. Review your environment with service maps",
        "8. Keep current",
        "9. Manage user access",
        "Important"
      ],
      "title": "APM best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "368a1a5688384d5bebf128604a9b8f190d335524",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/apm-best-practices-guide/",
      "published_at": "2021-07-09T09:16:17Z",
      "updated_at": "2021-07-09T09:16:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Application Monitoring Tips You Need To Know It's one thing to know how to use APM, but it's another thing to know how to use New Relic's application performance monitoring software well. Here are some best practices designed to help you become an APM master—and a key asset to your team! Tip To get a high-level overview of all your applications and services, use the New Relic Explorer in New Relic One. 1. Standardize application names Most New Relic agents provide a default application name, such as \"My Application\" or \"PHP Application,\" if you don't specify one in your New Relic configuration file. You don't want to end up with 20 identically named applications, be sure to select a descriptive identifier for your apps as soon you deploy them. To keep things consistent and easy to navigate, New Relic recommends standardizing your application naming (for example, all apps in Staging append [ Staging] or the like at the end of their names). Ideally, you want your new Java applications to be named automatically to reduce the chances of typographical errors and misnaming. How to do it For Java applications, automatic application naming can come from the following sources: Request attribute Servlet init parameter Filter init parameter Web app context parameter Web app context name (display name) Web app context path Choose the method that fits best your needs and follow these steps. For non-Java applications, there are no automatic naming methods, so refer to the documentation for your APM agent. 2. Add tags to your applications When several different applications use the same account, and each application spans multiple environments (for example, development, test, pre-production, production), it can be hard to find a specific application in your overview dashboard. That's why we recommend adding tags to your apps so that you can segment them into logical groups. The two most common tags that mature APM customers use are application name and environment. So, for example, if you wanted to view the billing application in Test, you could simply filter by \"billing app\" (name tag) and \"test\" (environment tag). Caution In the APM agent configuration settings files, use the labels field to add tags to your data. For example, see this description of the Python labels setting. APM is designed so that apps can roll up into an unlimited number of meaningful tag categories. How to do it Learn about tags. Learn how to add tags.. Learn how to query tags. 3. Create and evaluate alert policies When key performance indicators spike or drop, individuals and teams in your organization need to be notified. Alerting in New Relic provides a set of tools including dynamic baselines that allow you to detect problems before they impact your end users. Alert policies can be set up in two primary ways: Static threshold alerts are great when you already know the nature of an application and its normal behaviors aren't likely to change anytime soon. Apdex score, response time, error rate, throughput are some of the static thresholds you can create alert policies on. Dynamic baseline alerts make it easy to determine and set dynamic alert thresholds for applications with varying seasonal patterns and growth trends (which make it difficult to set thresholds that define normal behavior). These alerts use baselines modeled from your application’s historical metric data. Each alert policy can contain as many conditions as you need, and each alert condition includes three components: Type of condition (metric, external service, and so on) Entities that the policy targets (for example, APM apps, browser monitoring apps, or hosts) Thresholds that escalate into alerting situations with increasing severity Once you have your alerting set up, you then want to make sure you're taking advantage of all viable notification channels. After all, what good are alerts if no one knows about them? You can manage alerts by creating specific user groups and by leveraging New Relic's integrated alert channels, including Slack, PagerDuty, webhooks, and email. Be sure to evaluate alert policies on a regular basis to ensure that they are always valid. How to do it See the detailed documentation: To set up dynamic baseline alerts and choose an application, follow standard procedures. You will see a preview of the metric with the predicted baseline You can select a metric for that application and see the corresponding baseline. Then, using the threshold sliders, you can set how closely you want your threshold to follow the baseline prediction. To set up static threshold alerts for your Apdex settings, follow standard procedures. To set up your alert notification channels, follow standard procedures. 4. Identify and set up key transactions Depending on the nature of your application, some transactions may be more important to you than others. New Relic's key transactions feature is designed to help you closely monitor what you consider to be your app's most business-critical transactions, whether that's end-user or app response time, call counts, error rates, or something else. You can also set alert threshold levels for notifications when your key transactions are performing poorly. How to do it In the menu bar, select More > Key transactions, and then select Add more. Then select the app and web transaction or, from the selected transaction, select Track as key transaction. Type a name for the key transaction, and select Track key transaction. Optional: If the agent for the selected app supports custom alerting, use the default values that New Relic automatically fills, or select Edit key alert transaction policy to set the Apdex and alert threshold values. To view the key transactions dashboard details, select View new key transaction. 5. Track deployment history When development teams are pushing new code out as frequently as possible, it can be hard to measure the impact that each deployment is having on performance. One way to stay in tune with how these changes are affecting your application is with deployment reports. These reports list recent deployments and their impact on end-users and app servers' Apdex scores, along with response times, throughput, and errors. You can also view and drill down into the details to catch errors related to recent deployments, or file a ticket and share details with your team. How to do it From the New Relic menu bar, select APM > (selected app) > Events > Deployments. To view performance after a deployment, go to the selected app's Overview dashboard in the Recent events section. A blue vertical bar on a chart indicates a deployment. To view summary information about the deployment, point to the blue bar. 6. Review APM reports From SLA, deployment, and capacity to scalability, host usage reports, and more, New Relic APM offers a variety of downloadable reporting tools surfacing historical trends—all great ways to report to senior executive teams or customers. Take a look at the full list of reports and use them to your advantage. How to do it From the New Relic APM menu bar, select Applications > (selected app) > Reports. Select the report you'd like to see. If you want to save or export a report to share, select Download this report as .csv, which will create a report with comma-separated values. 7. Review your environment with service maps Use New Relic service maps, a feature included in APM, to understand how apps and services in your architecture connect and talk to each other. Service maps are visual, customizable representations of your application architecture. Maps automatically show you your app's connections and dependencies, including databases and external services. Health indicators and performance metrics show you the current operational status for every part of your architecture. How to do it Go to one.newrelic.com > More > service maps. To get started, read the instructions in Introduction to service maps. 8. Keep current With New Relic’s SaaS platform, getting new features is as easy as updating your agent. Most likely your organization already has a set of scripts for deploying application upgrades into your environment. In a similar fashion, you can also automate your New Relic agent deployment to ensure that your systems are up to date. Both Puppet and Chef scripts are great examples of deployment frameworks that make life easier by allowing you to automate your entire deployment and management process. How to do it Regularly review which version of the agent you're using so that you know when an update is needed. If the latest agent release contains a needed fix or added functionality, download it. To deploy the agent automatically (preferred as a method to avoid errors): Use existing deployment scripts, provided they can be adapted to handle the deployment. OR Create and maintain a script that specifically deploys and configures the New Relic agent. Ideally, the script would pull the agent files from a repository where the files are versioned (for rollback purposes). Once the script has been created, shut down the application (unless script handles this). Run the deployment script. Start the application (unless script handles this). If problems arise, run the script to roll back to the previous version. To deploy the agent manually: Back up the current agent directory. Deploy the updated agent into the existing agent directory. Modify configuration files by comparing new files with existing files. In particular, make sure things like license key and custom extensions are copied over to the new configuration. Restart the application. If problems arise, restore the old agent using the backup and restart. 9. Manage user access Important This is available only for accounts on our original product-based pricing plan. Enable role-based access control (RBAC) and single sign-on (SSO) New Relic allows authorized individuals to access the broadest possible amount of data, regardless of their assigned role. As an Owner or Administrator of your New Relic account, you can control the permissions of individual users or entire roles with RBAC. To find out what is possible and how to make changes, see Users and roles. Security is no doubt of utmost concern to your organization. To simplify password management for your employees and strengthen security, you may already be using SSO with your other systems. You should do the same with New Relic. Using New Relic's SSO integration feature, account administrators will be able to enforce strong passwords and restrict login via a corporate authentication mechanism. This way, New Relic users who have already authenticated using a corporate SSO system will be able to bypass the New Relic login prompt. How to do it Log in to New Relic as an admin and go to the SSO configuration page. From the New Relic title bar, select (your account name) > Account Settings > Integrations > Single Sign On. From the SAML Single Sign On page, review your New Relic SAML Service Provider details. To upload your SAML Identity Provider certificate, select Choose File, and then follow standard procedures to select and save the file. Copy and paste in (or type) the Remove login URL that your users will use for Single Sign-On. If your organization’s SAML integration provides a redirect URL for logout, copy and paste in (or type) the Logout landing URL; otherwise leave blank. Save, test, and enable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.4513,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>best</em> <em>practices</em> <em>guide</em>",
        "sections": "APM <em>best</em> <em>practices</em> <em>guide</em>",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "Application Monitoring Tips You Need To Know It&#x27;s one thing to know how to use APM, but it&#x27;s another thing to know how to use <em>New</em> <em>Relic</em>&#x27;s application performance monitoring software well. Here are some <em>best</em> <em>practices</em> designed to help you become an APM master—and a key asset to your team! Tip To get"
      },
      "id": "6044186564441f1f94378ecc"
    }
  ],
  "/docs/new-relic-solutions/best-practices-guides/full-stack-observability/mobile-monitoring-best-practices-guide": [
    {
      "sections": [
        "Browser monitoring best practices guide",
        "1. Use browser SPA agent",
        "How to do it",
        "2. Use APM auto-instrumentation",
        "Tip",
        "3. Customize Apdex",
        "4. Create alerts",
        "5. Use baseline alerts",
        "6. Add alerts to workflows",
        "7. Create dashboards",
        "8. Group your data",
        "9. Get the right data",
        "10. Break down performance data",
        "Want more user tips?"
      ],
      "title": "Browser monitoring best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "65e00c29691e851341248bcadf7302e955718ca8",
      "image": "https://docs.newrelic.com/static/bcbac83ecd75ee65ad36bbf8299ad89f/c1b63/best01_spapro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/browser-monitoring-best-practices-guide/",
      "published_at": "2021-07-09T09:17:17Z",
      "updated_at": "2021-07-09T09:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring tips & tricks that every user should know Get more out of browser monitoring, with deeper visibility into your websites and your users. Here are 10 best practices to help you find problems faster and deliver a better experience to your customers with real user monitoring. 1. Use browser SPA agent Use the browser SPA agent for deeper visibility Modern websites are complex, with dynamic content and sophisticated logic. See deeper into your user interactions, enable the single-page application (SPA) agent for browser and gain visibility into your user actions and the underlying webpage events behind them. This framework-agnostic agent is not only for single-page application frameworks like React, Angular, Ember, or Backbone, but also for custom frameworks and any other pages with dynamic content. Advanced timing analytics provide more granularity into Navigation Timing Specification API sub-timings beyond page rendering or DOM processing, with detailed performance data filtering useful for understanding all page lifecycles. How to do it From the browser app list, select an app, then select Settings > Application Settings. Select Pro + SPA. Click Save application settings Change your browser monitoring settings to switch to SPA. 2. Use APM auto-instrumentation Use APM automatic instrumentation over copy/paste If you’re also a APM customer, we recommend enabling automatic instrumentation where possible, as this will automatically inject the browser monitoring JavaScript agent into your frontend for you. Not only will the browser agent remain automatically up to date with this approach, using these products together helps unify frontend to backend visibility. For example, you’d be able to link frontend AJAX calls to their corresponding backend transaction, and to align your frontend and backend data together in an Insights dashboard. Tip Depending on your backend framework or CDN strategy, a copy/paste approach may be the better strategy. Just remember that it’ll require periodic updating. How to do it Select Settings > Application Settings. Select Enable via New Relic APM. Select Pro + SPA agent. Click Save application settings. one.newrelic.com > Browser > Settings > Application Settings 3. Customize Apdex Customize your Apdex threshold New Relic uses Apdex, an industry-standard metric, to measure users’ satisfaction with the response time of your applications. Apdex converts many measurements into one number on a uniform scale of 0 to 1 (0 = no users satisfied, 1 = all users satisfied). Apdex T is the central value for Apdex—it is the response time below which a transaction is considered “Satisfactory.” You can define Apdex T values for each application, with separate values for app server and end-user browser performance. (Note that many modern websites are bottlenecked primarily in the frontend browser, accounting for 90% or more of pageload times.) While a suggested T-value threshold is 5 seconds, we encourage you to customize your Apdex T value to fit the needs of your users and application. For example, an ecommerce site may want to have a lower T value to reduce bounce rates from potential buyers frustrated by a slow experience, compared to an internal employee application. However, the goal is to continually lower T-values over time to improve your digital customer experience. How to do it From the browser app list, select an app, then select Settings > Application settings. Set the Apdex T value (in seconds) for this application. Click Save application settings. one.newrelic.com > Browser > Settings > Application 4. Create alerts Create and evaluate alert policies What happens if your Apdex score exceeds your threshold? You want to be alerted whenever this happens, so that you can investigate what is causing the issue before you lose any customers. New Relic provides unified alerting across all our products, including browser monitoring, so that you’ll always be in the know. We recommend setting up alerts to monitor your Apdex score, along with these sample alerts to get you started: Apdex score: Alert if score is below 0.8 for 5 minutes. (If the Apdex score is below 0.8, that means 20% or more of your users are not “satisfied” with their experience on your website.) Page load time: Alert if median page load time is above 10 seconds for 5 minutes. (If the median page load time begins to spike, that suggest that something may be wrong with your web page causing it to significantly slow down. This complements alerting on your Apdex score.) JS errors: Alert if error rate is above 5% for 5 minutes. (If your frontend error rate starts spiking, particularly after a deployment, you may have introduced bad JavaScript into your frontend that should be fixed.) How to do it From Alerts & AI, select Go to Alerts, and click on Policies on the left column. Select (+) New alert policy to create a new alert policy, and give it a meaningful name. Click on Create a condition to create your first condition, then select Browser for your product and the Metric for the condition (which should be the default). Then click Next, select entities. Click the checkbox for the applications you want to alert on, and click Next, define thresholds. Pick the metrics of interest and their thresholds that determine when to trigger an alert. one.newrelic.com > Alerts & AI > Policies > New alert policy 5. Use baseline alerts Alert on anomalous behaviors and events While some metrics can be easily tracked against specific thresholds, other types of data can be more cyclical or have variable ranges for what’s considered healthy. Traffic throughput is a good example of this; it can have significantly cycles, but large traffic drops or spikes may be important indicators of a breakage preventing user traffic or a DDoS attack spiking traffic. Baseline alerts can be helpful for creating an expected \"band\" of normal activity to create more signal to noise in your alerting. How to do it From Alerts & AI, select Go to Alerts, and click on Policies on the left column. Select (+) New alert policy to create a new alert policy, and give it a meaningful name. Click on Create a condition to create your first condition, select Browser for your product and the Metric Baseline for the condition (which should be the default). Then click Next, select entities. Click the checkbox for the applications you want to alert on, and click Next, define thresholds. Pick the Page view throughput and use the slider to define the normal range you want to trigger the alert. one.newrelic.com > Alerts & AI > Policies > New alert policy 6. Add alerts to workflows Integrate your alerts into your workflows With the different alerting policies that you’re setting up, you’ll want to make sure to take advantage of the different alert notification channels available so that they’re integrated into team workflows. After all, what good are alerts if no one knows about them? You can route alerts through Slack, PagerDuty, webhooks, email, and more. You also have the opportunity to align alert notifications with your response processes, such as integrating with ChatOps or linking runbooks to your alerts. Be sure to evaluate alert policies on a regular basis to ensure that they are always valid. How to do it From Alerts & AI, click on Notification channels. Set up different notification channels, which can then be used within different alerting policies. 7. Create dashboards Create your own dashboards using New Relic Insights Browser automatically provides a curated experience to quickly triage issues, but you can also create bespoke dashboards with your frontend data with the query builder. Build unique real-time overviews of what’s going on in your frontend, and see how it fits with the rest of your technology stack. For example, you can: Create a browser-specific breakdown of percentiles, durations, and page views: SELECT average(duration),percentile(duration,50,75,95) as 'Percentile', count(*) as 'Pageviews' FROM PageView WHERE userAgentName='Chrome' SINCE 1 week ago Copy Break down route change performance into percentiles: SELECT count(*) as 'Route Change', average(duration) as 'Avg PageLoad',percentile(duration,50,75) as '%' ,average(jsDuration) as 'JS Duration' FROM BrowserInteraction FACET targetUrl where category = 'Route change' SINCE 1 day ago Copy Compare frontend performance to backend performance in APM: SELECT average(duration) as 'Avg Frontend Duration', average(backendDuration) FROM PageView SINCE 2 minutes ago UNTIL 10 seconds ago TIMESERIES Copy These individual widgets can be added together to create a team dashboard that’s shared across different engineering teams and the company. You can bring together web and mobile application data, backend data, infrastructure data, synthetic monitoring data, and more, all on a single custom dashboard across New Relic One. one.newrelic.com > Dashboards How to do it Go to one.newrelic.com, then click Query your data to access the query builder. In the NRQL tab of the query builder, paste the query into the NRQL> query bar and click Run. Type in a widget title, and add to either an existing or a new dashboard. Go to Dashboards to see your new dashboard. For more information, see our docs on data querying and dashboards. 8. Group your data Group your data into meaningful categories Different websites have different URL architectures, which can vary depending on content structure, technology framework, or SEO strategy. For example: website.com/product/widget-name website.com/gallery?product=109832 website.com/gallery/housewares/lamps/widget-name website.com/product#widget-name URL structure possibilities are endless, so browser includes an automatic grouping algorithm to set categories for that data into different URL groups. We recommend using URL grouping allowed lists to customize how your data is grouped together, which makes the corresponding performance information more useful and aligned to your website architecture. If the data generated by this default grouping is too high level, creating a URL grouping will disaggregate the data and give you greater granularity to make it more useful. For example, you could group by: Different page types: product pages vs. search pages Different forms, APIs, or user groupings Mobile vs. non-mobile Authenticated vs. non-authenticated Different content delivery networks (CDNs) How to do it In the browser monitoring UI, select Settings > Segment allow lists. In the Allow listed segments section, click on the + icon. Type in the URL segments you want to appear in groupings on the page views and AJAX pages. one.newrelic.com > Browser > Settings > Segment allow lists. 9. Get the right data Make sure you get data only from the right sources Browser data is generated from wherever your JavaScript agent is instrumented, though copies of your agent might become duplicated, such as through development, staging, or other environments, resulting in additional data being included from these sources that you would not want mixed with your production data. You can use domain conditions to allow or deny data from the different website domains you want monitored. How to do it In the browser monitoring UI, select Settings > Domain conditions. If there are no domain conditions in place, select Enable domain conditions. If conditions exist, select Next, Choose your setting. Select Deny only or Allow only to identify the data you want collected from the domains you want monitored. Then select Next, Create conditions. Enter the domain string conditions that you want to deny or allow data collection (maximum 10 conditions). Review and confirm your domain condition settings. one.newrelic.com > Browser > Settings > Domain conditions. 10. Break down performance data Break down performance across your users, business, and more By leveraging New Relic APIs, you can add vital context to your performance data as it relates to your technology, users, and your business. All our monitoring tools send their data to New Relic One, which enables plenty of customization and extensibility in your dashboarding. Just be sure to standardize naming for custom events and attributes across different data sources (such as between browser and mobile) for omnichannel engagement. Here are some examples of what you can measure: Build id: Pass in a build number to A/B test differences between versions User id: Manage your VIP customers and track their experience Cart value: Understand how much revenue is at risk when errors occur during checkout Content type: Track the type of content your users are viewing Video playback: See how users are consuming your media content The possibilities are endless. And as you can see, this type of reporting creates context around how your application performance impacts the rest of the business. How to do it Use our APIs to pass custom data about people, things, money, and more into New Relic One. Visit one.newrelic.com, and query on the custom data that is now available. For more information, see our docs on data querying and dashboards. one.newrelic.com > Dashboards > (selected dashboard). Want more user tips? View training videos at New Relic University. Read the Browser documentation. Check out our Tutorials page. Ask a question in the New Relic Community Forum.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.46716,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "sections": "Browser monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "Browser monitoring tips &amp; tricks that every user should know Get more out of browser monitoring, with deeper visibility into your websites and your users. Here are 10 <em>best</em> <em>practices</em> to help you find problems faster and deliver a better experience to your customers with real user monitoring. 1. Use"
      },
      "id": "60441b4a28ccbc584a2c6095"
    },
    {
      "sections": [
        "Browser monitoring best practices in Java",
        "Ensure you are using the Apache Jasper compiler.",
        "Place meta tags immediately after the initial head tag.",
        "Avoid if ... else statements in the head section.",
        "Avoid expressions with the less than sign in the head section."
      ],
      "title": "Browser monitoring best practices in Java",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "536c56c90f1dcd9dee65692a229ffde9762f177e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/browser-monitoring-best-practices-java/",
      "published_at": "2021-07-09T09:17:17Z",
      "updated_at": "2021-07-09T09:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring with APM for Java to measure end-user load times. This document explains best practices for setting up browser monitoring. For information on how to set up browser monitoring for your Java app, see Browser monitoring and the Java agent. Ensure you are using the Apache Jasper compiler. The New Relic Java agent only auto-instruments pages compiled with the Apache Jasper compiler. The following application servers use the Jasper compiler by default: Tomcat Jetty Glassfish JBoss 4 Place meta tags immediately after the initial head tag. Recommendation: Place all <meta> tags immediately after the initial <head> tag. Some meta tags have requirements on how close they need to be to the beginning of an HTML document. The character encoding must be declared within the first 512 bytes of the HTML document. If the New Relic header is placed before the character encoding, it is possible for the character encoding to then be outside that 512 byte limit. Placing the character encoding meta tag immediately after the <head> tag will ensure that the New Relic header is positioned after the character encoding. <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> . . . </head> Copy The X-UA-Compatible meta tag should be within the meta tags immediately after the <head> tag. This tag allows page authors to set the document mode used for rending the page in Internet Explorer. This tag should be placed before any script tags. If the New Relic header is positioned before the X-UA-Compatible meta tag, the page might display incorrectly in Internet Explorer. <!DOCTYPE html> <html> <head> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=9\"> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> . . . </head> Copy Avoid if ... else statements in the head section. The auto instrumentation script does not recognize if ... else statements within a JSP page. If you have an if ... else block before your first non-meta, non-title tag, the New Relic header might be placed in the incorrect position in the page. For example, this code could potentially cause the auto instrumentation script to be inserted before the meta tags: if (expression) { <nonmeta tag> } <meta tag> <meta tag> Copy Avoid expressions with the less than sign in the head section. The New Relic Java agent looks for the open angle bracket < to mark the beginning of an HTML tag. This means if you have an expression using a less than sign, then you will either need to change your expression to use a greater than sign or use manual instrumentation. For example: <head> <% for (i = 0; i < variable; i++) . . . %> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.46716,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring <em>best</em> <em>practices</em> in Java",
        "sections": "Browser monitoring <em>best</em> <em>practices</em> in Java",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "You can use browser monitoring with APM for Java to measure end-user load times. This document explains <em>best</em> <em>practices</em> for setting up browser monitoring. For information on how to set up browser monitoring for your Java app, see Browser monitoring and the Java agent. Ensure you are using the Apache"
      },
      "id": "60441afc64441f7f65378f02"
    },
    {
      "sections": [
        "APM best practices guide",
        "Tip",
        "1. Standardize application names",
        "How to do it",
        "2. Add tags to your applications",
        "Caution",
        "3. Create and evaluate alert policies",
        "4. Identify and set up key transactions",
        "5. Track deployment history",
        "6. Review APM reports",
        "7. Review your environment with service maps",
        "8. Keep current",
        "9. Manage user access",
        "Important"
      ],
      "title": "APM best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "368a1a5688384d5bebf128604a9b8f190d335524",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/apm-best-practices-guide/",
      "published_at": "2021-07-09T09:16:17Z",
      "updated_at": "2021-07-09T09:16:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Application Monitoring Tips You Need To Know It's one thing to know how to use APM, but it's another thing to know how to use New Relic's application performance monitoring software well. Here are some best practices designed to help you become an APM master—and a key asset to your team! Tip To get a high-level overview of all your applications and services, use the New Relic Explorer in New Relic One. 1. Standardize application names Most New Relic agents provide a default application name, such as \"My Application\" or \"PHP Application,\" if you don't specify one in your New Relic configuration file. You don't want to end up with 20 identically named applications, be sure to select a descriptive identifier for your apps as soon you deploy them. To keep things consistent and easy to navigate, New Relic recommends standardizing your application naming (for example, all apps in Staging append [ Staging] or the like at the end of their names). Ideally, you want your new Java applications to be named automatically to reduce the chances of typographical errors and misnaming. How to do it For Java applications, automatic application naming can come from the following sources: Request attribute Servlet init parameter Filter init parameter Web app context parameter Web app context name (display name) Web app context path Choose the method that fits best your needs and follow these steps. For non-Java applications, there are no automatic naming methods, so refer to the documentation for your APM agent. 2. Add tags to your applications When several different applications use the same account, and each application spans multiple environments (for example, development, test, pre-production, production), it can be hard to find a specific application in your overview dashboard. That's why we recommend adding tags to your apps so that you can segment them into logical groups. The two most common tags that mature APM customers use are application name and environment. So, for example, if you wanted to view the billing application in Test, you could simply filter by \"billing app\" (name tag) and \"test\" (environment tag). Caution In the APM agent configuration settings files, use the labels field to add tags to your data. For example, see this description of the Python labels setting. APM is designed so that apps can roll up into an unlimited number of meaningful tag categories. How to do it Learn about tags. Learn how to add tags.. Learn how to query tags. 3. Create and evaluate alert policies When key performance indicators spike or drop, individuals and teams in your organization need to be notified. Alerting in New Relic provides a set of tools including dynamic baselines that allow you to detect problems before they impact your end users. Alert policies can be set up in two primary ways: Static threshold alerts are great when you already know the nature of an application and its normal behaviors aren't likely to change anytime soon. Apdex score, response time, error rate, throughput are some of the static thresholds you can create alert policies on. Dynamic baseline alerts make it easy to determine and set dynamic alert thresholds for applications with varying seasonal patterns and growth trends (which make it difficult to set thresholds that define normal behavior). These alerts use baselines modeled from your application’s historical metric data. Each alert policy can contain as many conditions as you need, and each alert condition includes three components: Type of condition (metric, external service, and so on) Entities that the policy targets (for example, APM apps, browser monitoring apps, or hosts) Thresholds that escalate into alerting situations with increasing severity Once you have your alerting set up, you then want to make sure you're taking advantage of all viable notification channels. After all, what good are alerts if no one knows about them? You can manage alerts by creating specific user groups and by leveraging New Relic's integrated alert channels, including Slack, PagerDuty, webhooks, and email. Be sure to evaluate alert policies on a regular basis to ensure that they are always valid. How to do it See the detailed documentation: To set up dynamic baseline alerts and choose an application, follow standard procedures. You will see a preview of the metric with the predicted baseline You can select a metric for that application and see the corresponding baseline. Then, using the threshold sliders, you can set how closely you want your threshold to follow the baseline prediction. To set up static threshold alerts for your Apdex settings, follow standard procedures. To set up your alert notification channels, follow standard procedures. 4. Identify and set up key transactions Depending on the nature of your application, some transactions may be more important to you than others. New Relic's key transactions feature is designed to help you closely monitor what you consider to be your app's most business-critical transactions, whether that's end-user or app response time, call counts, error rates, or something else. You can also set alert threshold levels for notifications when your key transactions are performing poorly. How to do it In the menu bar, select More > Key transactions, and then select Add more. Then select the app and web transaction or, from the selected transaction, select Track as key transaction. Type a name for the key transaction, and select Track key transaction. Optional: If the agent for the selected app supports custom alerting, use the default values that New Relic automatically fills, or select Edit key alert transaction policy to set the Apdex and alert threshold values. To view the key transactions dashboard details, select View new key transaction. 5. Track deployment history When development teams are pushing new code out as frequently as possible, it can be hard to measure the impact that each deployment is having on performance. One way to stay in tune with how these changes are affecting your application is with deployment reports. These reports list recent deployments and their impact on end-users and app servers' Apdex scores, along with response times, throughput, and errors. You can also view and drill down into the details to catch errors related to recent deployments, or file a ticket and share details with your team. How to do it From the New Relic menu bar, select APM > (selected app) > Events > Deployments. To view performance after a deployment, go to the selected app's Overview dashboard in the Recent events section. A blue vertical bar on a chart indicates a deployment. To view summary information about the deployment, point to the blue bar. 6. Review APM reports From SLA, deployment, and capacity to scalability, host usage reports, and more, New Relic APM offers a variety of downloadable reporting tools surfacing historical trends—all great ways to report to senior executive teams or customers. Take a look at the full list of reports and use them to your advantage. How to do it From the New Relic APM menu bar, select Applications > (selected app) > Reports. Select the report you'd like to see. If you want to save or export a report to share, select Download this report as .csv, which will create a report with comma-separated values. 7. Review your environment with service maps Use New Relic service maps, a feature included in APM, to understand how apps and services in your architecture connect and talk to each other. Service maps are visual, customizable representations of your application architecture. Maps automatically show you your app's connections and dependencies, including databases and external services. Health indicators and performance metrics show you the current operational status for every part of your architecture. How to do it Go to one.newrelic.com > More > service maps. To get started, read the instructions in Introduction to service maps. 8. Keep current With New Relic’s SaaS platform, getting new features is as easy as updating your agent. Most likely your organization already has a set of scripts for deploying application upgrades into your environment. In a similar fashion, you can also automate your New Relic agent deployment to ensure that your systems are up to date. Both Puppet and Chef scripts are great examples of deployment frameworks that make life easier by allowing you to automate your entire deployment and management process. How to do it Regularly review which version of the agent you're using so that you know when an update is needed. If the latest agent release contains a needed fix or added functionality, download it. To deploy the agent automatically (preferred as a method to avoid errors): Use existing deployment scripts, provided they can be adapted to handle the deployment. OR Create and maintain a script that specifically deploys and configures the New Relic agent. Ideally, the script would pull the agent files from a repository where the files are versioned (for rollback purposes). Once the script has been created, shut down the application (unless script handles this). Run the deployment script. Start the application (unless script handles this). If problems arise, run the script to roll back to the previous version. To deploy the agent manually: Back up the current agent directory. Deploy the updated agent into the existing agent directory. Modify configuration files by comparing new files with existing files. In particular, make sure things like license key and custom extensions are copied over to the new configuration. Restart the application. If problems arise, restore the old agent using the backup and restart. 9. Manage user access Important This is available only for accounts on our original product-based pricing plan. Enable role-based access control (RBAC) and single sign-on (SSO) New Relic allows authorized individuals to access the broadest possible amount of data, regardless of their assigned role. As an Owner or Administrator of your New Relic account, you can control the permissions of individual users or entire roles with RBAC. To find out what is possible and how to make changes, see Users and roles. Security is no doubt of utmost concern to your organization. To simplify password management for your employees and strengthen security, you may already be using SSO with your other systems. You should do the same with New Relic. Using New Relic's SSO integration feature, account administrators will be able to enforce strong passwords and restrict login via a corporate authentication mechanism. This way, New Relic users who have already authenticated using a corporate SSO system will be able to bypass the New Relic login prompt. How to do it Log in to New Relic as an admin and go to the SSO configuration page. From the New Relic title bar, select (your account name) > Account Settings > Integrations > Single Sign On. From the SAML Single Sign On page, review your New Relic SAML Service Provider details. To upload your SAML Identity Provider certificate, select Choose File, and then follow standard procedures to select and save the file. Copy and paste in (or type) the Remove login URL that your users will use for Single Sign-On. If your organization’s SAML integration provides a redirect URL for logout, copy and paste in (or type) the Logout landing URL; otherwise leave blank. Save, test, and enable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.4513,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>best</em> <em>practices</em> <em>guide</em>",
        "sections": "APM <em>best</em> <em>practices</em> <em>guide</em>",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "Application Monitoring Tips You Need To Know It&#x27;s one thing to know how to use APM, but it&#x27;s another thing to know how to use <em>New</em> <em>Relic</em>&#x27;s application performance monitoring software well. Here are some <em>best</em> <em>practices</em> designed to help you become an APM master—and a key asset to your team! Tip To get"
      },
      "id": "6044186564441f1f94378ecc"
    }
  ],
  "/docs/new-relic-solutions/best-practices-guides/full-stack-observability/synthetic-monitoring-best-practices-guide": [
    {
      "sections": [
        "Browser monitoring best practices guide",
        "1. Use browser SPA agent",
        "How to do it",
        "2. Use APM auto-instrumentation",
        "Tip",
        "3. Customize Apdex",
        "4. Create alerts",
        "5. Use baseline alerts",
        "6. Add alerts to workflows",
        "7. Create dashboards",
        "8. Group your data",
        "9. Get the right data",
        "10. Break down performance data",
        "Want more user tips?"
      ],
      "title": "Browser monitoring best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "65e00c29691e851341248bcadf7302e955718ca8",
      "image": "https://docs.newrelic.com/static/bcbac83ecd75ee65ad36bbf8299ad89f/c1b63/best01_spapro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/browser-monitoring-best-practices-guide/",
      "published_at": "2021-07-09T09:17:17Z",
      "updated_at": "2021-07-09T09:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring tips & tricks that every user should know Get more out of browser monitoring, with deeper visibility into your websites and your users. Here are 10 best practices to help you find problems faster and deliver a better experience to your customers with real user monitoring. 1. Use browser SPA agent Use the browser SPA agent for deeper visibility Modern websites are complex, with dynamic content and sophisticated logic. See deeper into your user interactions, enable the single-page application (SPA) agent for browser and gain visibility into your user actions and the underlying webpage events behind them. This framework-agnostic agent is not only for single-page application frameworks like React, Angular, Ember, or Backbone, but also for custom frameworks and any other pages with dynamic content. Advanced timing analytics provide more granularity into Navigation Timing Specification API sub-timings beyond page rendering or DOM processing, with detailed performance data filtering useful for understanding all page lifecycles. How to do it From the browser app list, select an app, then select Settings > Application Settings. Select Pro + SPA. Click Save application settings Change your browser monitoring settings to switch to SPA. 2. Use APM auto-instrumentation Use APM automatic instrumentation over copy/paste If you’re also a APM customer, we recommend enabling automatic instrumentation where possible, as this will automatically inject the browser monitoring JavaScript agent into your frontend for you. Not only will the browser agent remain automatically up to date with this approach, using these products together helps unify frontend to backend visibility. For example, you’d be able to link frontend AJAX calls to their corresponding backend transaction, and to align your frontend and backend data together in an Insights dashboard. Tip Depending on your backend framework or CDN strategy, a copy/paste approach may be the better strategy. Just remember that it’ll require periodic updating. How to do it Select Settings > Application Settings. Select Enable via New Relic APM. Select Pro + SPA agent. Click Save application settings. one.newrelic.com > Browser > Settings > Application Settings 3. Customize Apdex Customize your Apdex threshold New Relic uses Apdex, an industry-standard metric, to measure users’ satisfaction with the response time of your applications. Apdex converts many measurements into one number on a uniform scale of 0 to 1 (0 = no users satisfied, 1 = all users satisfied). Apdex T is the central value for Apdex—it is the response time below which a transaction is considered “Satisfactory.” You can define Apdex T values for each application, with separate values for app server and end-user browser performance. (Note that many modern websites are bottlenecked primarily in the frontend browser, accounting for 90% or more of pageload times.) While a suggested T-value threshold is 5 seconds, we encourage you to customize your Apdex T value to fit the needs of your users and application. For example, an ecommerce site may want to have a lower T value to reduce bounce rates from potential buyers frustrated by a slow experience, compared to an internal employee application. However, the goal is to continually lower T-values over time to improve your digital customer experience. How to do it From the browser app list, select an app, then select Settings > Application settings. Set the Apdex T value (in seconds) for this application. Click Save application settings. one.newrelic.com > Browser > Settings > Application 4. Create alerts Create and evaluate alert policies What happens if your Apdex score exceeds your threshold? You want to be alerted whenever this happens, so that you can investigate what is causing the issue before you lose any customers. New Relic provides unified alerting across all our products, including browser monitoring, so that you’ll always be in the know. We recommend setting up alerts to monitor your Apdex score, along with these sample alerts to get you started: Apdex score: Alert if score is below 0.8 for 5 minutes. (If the Apdex score is below 0.8, that means 20% or more of your users are not “satisfied” with their experience on your website.) Page load time: Alert if median page load time is above 10 seconds for 5 minutes. (If the median page load time begins to spike, that suggest that something may be wrong with your web page causing it to significantly slow down. This complements alerting on your Apdex score.) JS errors: Alert if error rate is above 5% for 5 minutes. (If your frontend error rate starts spiking, particularly after a deployment, you may have introduced bad JavaScript into your frontend that should be fixed.) How to do it From Alerts & AI, select Go to Alerts, and click on Policies on the left column. Select (+) New alert policy to create a new alert policy, and give it a meaningful name. Click on Create a condition to create your first condition, then select Browser for your product and the Metric for the condition (which should be the default). Then click Next, select entities. Click the checkbox for the applications you want to alert on, and click Next, define thresholds. Pick the metrics of interest and their thresholds that determine when to trigger an alert. one.newrelic.com > Alerts & AI > Policies > New alert policy 5. Use baseline alerts Alert on anomalous behaviors and events While some metrics can be easily tracked against specific thresholds, other types of data can be more cyclical or have variable ranges for what’s considered healthy. Traffic throughput is a good example of this; it can have significantly cycles, but large traffic drops or spikes may be important indicators of a breakage preventing user traffic or a DDoS attack spiking traffic. Baseline alerts can be helpful for creating an expected \"band\" of normal activity to create more signal to noise in your alerting. How to do it From Alerts & AI, select Go to Alerts, and click on Policies on the left column. Select (+) New alert policy to create a new alert policy, and give it a meaningful name. Click on Create a condition to create your first condition, select Browser for your product and the Metric Baseline for the condition (which should be the default). Then click Next, select entities. Click the checkbox for the applications you want to alert on, and click Next, define thresholds. Pick the Page view throughput and use the slider to define the normal range you want to trigger the alert. one.newrelic.com > Alerts & AI > Policies > New alert policy 6. Add alerts to workflows Integrate your alerts into your workflows With the different alerting policies that you’re setting up, you’ll want to make sure to take advantage of the different alert notification channels available so that they’re integrated into team workflows. After all, what good are alerts if no one knows about them? You can route alerts through Slack, PagerDuty, webhooks, email, and more. You also have the opportunity to align alert notifications with your response processes, such as integrating with ChatOps or linking runbooks to your alerts. Be sure to evaluate alert policies on a regular basis to ensure that they are always valid. How to do it From Alerts & AI, click on Notification channels. Set up different notification channels, which can then be used within different alerting policies. 7. Create dashboards Create your own dashboards using New Relic Insights Browser automatically provides a curated experience to quickly triage issues, but you can also create bespoke dashboards with your frontend data with the query builder. Build unique real-time overviews of what’s going on in your frontend, and see how it fits with the rest of your technology stack. For example, you can: Create a browser-specific breakdown of percentiles, durations, and page views: SELECT average(duration),percentile(duration,50,75,95) as 'Percentile', count(*) as 'Pageviews' FROM PageView WHERE userAgentName='Chrome' SINCE 1 week ago Copy Break down route change performance into percentiles: SELECT count(*) as 'Route Change', average(duration) as 'Avg PageLoad',percentile(duration,50,75) as '%' ,average(jsDuration) as 'JS Duration' FROM BrowserInteraction FACET targetUrl where category = 'Route change' SINCE 1 day ago Copy Compare frontend performance to backend performance in APM: SELECT average(duration) as 'Avg Frontend Duration', average(backendDuration) FROM PageView SINCE 2 minutes ago UNTIL 10 seconds ago TIMESERIES Copy These individual widgets can be added together to create a team dashboard that’s shared across different engineering teams and the company. You can bring together web and mobile application data, backend data, infrastructure data, synthetic monitoring data, and more, all on a single custom dashboard across New Relic One. one.newrelic.com > Dashboards How to do it Go to one.newrelic.com, then click Query your data to access the query builder. In the NRQL tab of the query builder, paste the query into the NRQL> query bar and click Run. Type in a widget title, and add to either an existing or a new dashboard. Go to Dashboards to see your new dashboard. For more information, see our docs on data querying and dashboards. 8. Group your data Group your data into meaningful categories Different websites have different URL architectures, which can vary depending on content structure, technology framework, or SEO strategy. For example: website.com/product/widget-name website.com/gallery?product=109832 website.com/gallery/housewares/lamps/widget-name website.com/product#widget-name URL structure possibilities are endless, so browser includes an automatic grouping algorithm to set categories for that data into different URL groups. We recommend using URL grouping allowed lists to customize how your data is grouped together, which makes the corresponding performance information more useful and aligned to your website architecture. If the data generated by this default grouping is too high level, creating a URL grouping will disaggregate the data and give you greater granularity to make it more useful. For example, you could group by: Different page types: product pages vs. search pages Different forms, APIs, or user groupings Mobile vs. non-mobile Authenticated vs. non-authenticated Different content delivery networks (CDNs) How to do it In the browser monitoring UI, select Settings > Segment allow lists. In the Allow listed segments section, click on the + icon. Type in the URL segments you want to appear in groupings on the page views and AJAX pages. one.newrelic.com > Browser > Settings > Segment allow lists. 9. Get the right data Make sure you get data only from the right sources Browser data is generated from wherever your JavaScript agent is instrumented, though copies of your agent might become duplicated, such as through development, staging, or other environments, resulting in additional data being included from these sources that you would not want mixed with your production data. You can use domain conditions to allow or deny data from the different website domains you want monitored. How to do it In the browser monitoring UI, select Settings > Domain conditions. If there are no domain conditions in place, select Enable domain conditions. If conditions exist, select Next, Choose your setting. Select Deny only or Allow only to identify the data you want collected from the domains you want monitored. Then select Next, Create conditions. Enter the domain string conditions that you want to deny or allow data collection (maximum 10 conditions). Review and confirm your domain condition settings. one.newrelic.com > Browser > Settings > Domain conditions. 10. Break down performance data Break down performance across your users, business, and more By leveraging New Relic APIs, you can add vital context to your performance data as it relates to your technology, users, and your business. All our monitoring tools send their data to New Relic One, which enables plenty of customization and extensibility in your dashboarding. Just be sure to standardize naming for custom events and attributes across different data sources (such as between browser and mobile) for omnichannel engagement. Here are some examples of what you can measure: Build id: Pass in a build number to A/B test differences between versions User id: Manage your VIP customers and track their experience Cart value: Understand how much revenue is at risk when errors occur during checkout Content type: Track the type of content your users are viewing Video playback: See how users are consuming your media content The possibilities are endless. And as you can see, this type of reporting creates context around how your application performance impacts the rest of the business. How to do it Use our APIs to pass custom data about people, things, money, and more into New Relic One. Visit one.newrelic.com, and query on the custom data that is now available. For more information, see our docs on data querying and dashboards. one.newrelic.com > Dashboards > (selected dashboard). Want more user tips? View training videos at New Relic University. Read the Browser documentation. Check out our Tutorials page. Ask a question in the New Relic Community Forum.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.46692,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "sections": "Browser monitoring <em>best</em> <em>practices</em> <em>guide</em>",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "Browser monitoring tips &amp; tricks that every user should know Get more out of browser monitoring, with deeper visibility into your websites and your users. Here are 10 <em>best</em> <em>practices</em> to help you find problems faster and deliver a better experience to your customers with real user monitoring. 1. Use"
      },
      "id": "60441b4a28ccbc584a2c6095"
    },
    {
      "sections": [
        "Browser monitoring best practices in Java",
        "Ensure you are using the Apache Jasper compiler.",
        "Place meta tags immediately after the initial head tag.",
        "Avoid if ... else statements in the head section.",
        "Avoid expressions with the less than sign in the head section."
      ],
      "title": "Browser monitoring best practices in Java",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "536c56c90f1dcd9dee65692a229ffde9762f177e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/browser-monitoring-best-practices-java/",
      "published_at": "2021-07-09T09:17:17Z",
      "updated_at": "2021-07-09T09:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring with APM for Java to measure end-user load times. This document explains best practices for setting up browser monitoring. For information on how to set up browser monitoring for your Java app, see Browser monitoring and the Java agent. Ensure you are using the Apache Jasper compiler. The New Relic Java agent only auto-instruments pages compiled with the Apache Jasper compiler. The following application servers use the Jasper compiler by default: Tomcat Jetty Glassfish JBoss 4 Place meta tags immediately after the initial head tag. Recommendation: Place all <meta> tags immediately after the initial <head> tag. Some meta tags have requirements on how close they need to be to the beginning of an HTML document. The character encoding must be declared within the first 512 bytes of the HTML document. If the New Relic header is placed before the character encoding, it is possible for the character encoding to then be outside that 512 byte limit. Placing the character encoding meta tag immediately after the <head> tag will ensure that the New Relic header is positioned after the character encoding. <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> . . . </head> Copy The X-UA-Compatible meta tag should be within the meta tags immediately after the <head> tag. This tag allows page authors to set the document mode used for rending the page in Internet Explorer. This tag should be placed before any script tags. If the New Relic header is positioned before the X-UA-Compatible meta tag, the page might display incorrectly in Internet Explorer. <!DOCTYPE html> <html> <head> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=9\"> <%= com.newrelic.api.agent.NewRelic.getBrowserTimingHeader() %> . . . </head> Copy Avoid if ... else statements in the head section. The auto instrumentation script does not recognize if ... else statements within a JSP page. If you have an if ... else block before your first non-meta, non-title tag, the New Relic header might be placed in the incorrect position in the page. For example, this code could potentially cause the auto instrumentation script to be inserted before the meta tags: if (expression) { <nonmeta tag> } <meta tag> <meta tag> Copy Avoid expressions with the less than sign in the head section. The New Relic Java agent looks for the open angle bracket < to mark the beginning of an HTML tag. This means if you have an expression using a less than sign, then you will either need to change your expression to use a greater than sign or use manual instrumentation. For example: <head> <% for (i = 0; i < variable; i++) . . . %> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.46692,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring <em>best</em> <em>practices</em> in Java",
        "sections": "Browser monitoring <em>best</em> <em>practices</em> in Java",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "You can use browser monitoring with APM for Java to measure end-user load times. This document explains <em>best</em> <em>practices</em> for setting up browser monitoring. For information on how to set up browser monitoring for your Java app, see Browser monitoring and the Java agent. Ensure you are using the Apache"
      },
      "id": "60441afc64441f7f65378f02"
    },
    {
      "sections": [
        "APM best practices guide",
        "Tip",
        "1. Standardize application names",
        "How to do it",
        "2. Add tags to your applications",
        "Caution",
        "3. Create and evaluate alert policies",
        "4. Identify and set up key transactions",
        "5. Track deployment history",
        "6. Review APM reports",
        "7. Review your environment with service maps",
        "8. Keep current",
        "9. Manage user access",
        "Important"
      ],
      "title": "APM best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides",
        "Full-stack observability"
      ],
      "external_id": "368a1a5688384d5bebf128604a9b8f190d335524",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/apm-best-practices-guide/",
      "published_at": "2021-07-09T09:16:17Z",
      "updated_at": "2021-07-09T09:16:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Application Monitoring Tips You Need To Know It's one thing to know how to use APM, but it's another thing to know how to use New Relic's application performance monitoring software well. Here are some best practices designed to help you become an APM master—and a key asset to your team! Tip To get a high-level overview of all your applications and services, use the New Relic Explorer in New Relic One. 1. Standardize application names Most New Relic agents provide a default application name, such as \"My Application\" or \"PHP Application,\" if you don't specify one in your New Relic configuration file. You don't want to end up with 20 identically named applications, be sure to select a descriptive identifier for your apps as soon you deploy them. To keep things consistent and easy to navigate, New Relic recommends standardizing your application naming (for example, all apps in Staging append [ Staging] or the like at the end of their names). Ideally, you want your new Java applications to be named automatically to reduce the chances of typographical errors and misnaming. How to do it For Java applications, automatic application naming can come from the following sources: Request attribute Servlet init parameter Filter init parameter Web app context parameter Web app context name (display name) Web app context path Choose the method that fits best your needs and follow these steps. For non-Java applications, there are no automatic naming methods, so refer to the documentation for your APM agent. 2. Add tags to your applications When several different applications use the same account, and each application spans multiple environments (for example, development, test, pre-production, production), it can be hard to find a specific application in your overview dashboard. That's why we recommend adding tags to your apps so that you can segment them into logical groups. The two most common tags that mature APM customers use are application name and environment. So, for example, if you wanted to view the billing application in Test, you could simply filter by \"billing app\" (name tag) and \"test\" (environment tag). Caution In the APM agent configuration settings files, use the labels field to add tags to your data. For example, see this description of the Python labels setting. APM is designed so that apps can roll up into an unlimited number of meaningful tag categories. How to do it Learn about tags. Learn how to add tags.. Learn how to query tags. 3. Create and evaluate alert policies When key performance indicators spike or drop, individuals and teams in your organization need to be notified. Alerting in New Relic provides a set of tools including dynamic baselines that allow you to detect problems before they impact your end users. Alert policies can be set up in two primary ways: Static threshold alerts are great when you already know the nature of an application and its normal behaviors aren't likely to change anytime soon. Apdex score, response time, error rate, throughput are some of the static thresholds you can create alert policies on. Dynamic baseline alerts make it easy to determine and set dynamic alert thresholds for applications with varying seasonal patterns and growth trends (which make it difficult to set thresholds that define normal behavior). These alerts use baselines modeled from your application’s historical metric data. Each alert policy can contain as many conditions as you need, and each alert condition includes three components: Type of condition (metric, external service, and so on) Entities that the policy targets (for example, APM apps, browser monitoring apps, or hosts) Thresholds that escalate into alerting situations with increasing severity Once you have your alerting set up, you then want to make sure you're taking advantage of all viable notification channels. After all, what good are alerts if no one knows about them? You can manage alerts by creating specific user groups and by leveraging New Relic's integrated alert channels, including Slack, PagerDuty, webhooks, and email. Be sure to evaluate alert policies on a regular basis to ensure that they are always valid. How to do it See the detailed documentation: To set up dynamic baseline alerts and choose an application, follow standard procedures. You will see a preview of the metric with the predicted baseline You can select a metric for that application and see the corresponding baseline. Then, using the threshold sliders, you can set how closely you want your threshold to follow the baseline prediction. To set up static threshold alerts for your Apdex settings, follow standard procedures. To set up your alert notification channels, follow standard procedures. 4. Identify and set up key transactions Depending on the nature of your application, some transactions may be more important to you than others. New Relic's key transactions feature is designed to help you closely monitor what you consider to be your app's most business-critical transactions, whether that's end-user or app response time, call counts, error rates, or something else. You can also set alert threshold levels for notifications when your key transactions are performing poorly. How to do it In the menu bar, select More > Key transactions, and then select Add more. Then select the app and web transaction or, from the selected transaction, select Track as key transaction. Type a name for the key transaction, and select Track key transaction. Optional: If the agent for the selected app supports custom alerting, use the default values that New Relic automatically fills, or select Edit key alert transaction policy to set the Apdex and alert threshold values. To view the key transactions dashboard details, select View new key transaction. 5. Track deployment history When development teams are pushing new code out as frequently as possible, it can be hard to measure the impact that each deployment is having on performance. One way to stay in tune with how these changes are affecting your application is with deployment reports. These reports list recent deployments and their impact on end-users and app servers' Apdex scores, along with response times, throughput, and errors. You can also view and drill down into the details to catch errors related to recent deployments, or file a ticket and share details with your team. How to do it From the New Relic menu bar, select APM > (selected app) > Events > Deployments. To view performance after a deployment, go to the selected app's Overview dashboard in the Recent events section. A blue vertical bar on a chart indicates a deployment. To view summary information about the deployment, point to the blue bar. 6. Review APM reports From SLA, deployment, and capacity to scalability, host usage reports, and more, New Relic APM offers a variety of downloadable reporting tools surfacing historical trends—all great ways to report to senior executive teams or customers. Take a look at the full list of reports and use them to your advantage. How to do it From the New Relic APM menu bar, select Applications > (selected app) > Reports. Select the report you'd like to see. If you want to save or export a report to share, select Download this report as .csv, which will create a report with comma-separated values. 7. Review your environment with service maps Use New Relic service maps, a feature included in APM, to understand how apps and services in your architecture connect and talk to each other. Service maps are visual, customizable representations of your application architecture. Maps automatically show you your app's connections and dependencies, including databases and external services. Health indicators and performance metrics show you the current operational status for every part of your architecture. How to do it Go to one.newrelic.com > More > service maps. To get started, read the instructions in Introduction to service maps. 8. Keep current With New Relic’s SaaS platform, getting new features is as easy as updating your agent. Most likely your organization already has a set of scripts for deploying application upgrades into your environment. In a similar fashion, you can also automate your New Relic agent deployment to ensure that your systems are up to date. Both Puppet and Chef scripts are great examples of deployment frameworks that make life easier by allowing you to automate your entire deployment and management process. How to do it Regularly review which version of the agent you're using so that you know when an update is needed. If the latest agent release contains a needed fix or added functionality, download it. To deploy the agent automatically (preferred as a method to avoid errors): Use existing deployment scripts, provided they can be adapted to handle the deployment. OR Create and maintain a script that specifically deploys and configures the New Relic agent. Ideally, the script would pull the agent files from a repository where the files are versioned (for rollback purposes). Once the script has been created, shut down the application (unless script handles this). Run the deployment script. Start the application (unless script handles this). If problems arise, run the script to roll back to the previous version. To deploy the agent manually: Back up the current agent directory. Deploy the updated agent into the existing agent directory. Modify configuration files by comparing new files with existing files. In particular, make sure things like license key and custom extensions are copied over to the new configuration. Restart the application. If problems arise, restore the old agent using the backup and restart. 9. Manage user access Important This is available only for accounts on our original product-based pricing plan. Enable role-based access control (RBAC) and single sign-on (SSO) New Relic allows authorized individuals to access the broadest possible amount of data, regardless of their assigned role. As an Owner or Administrator of your New Relic account, you can control the permissions of individual users or entire roles with RBAC. To find out what is possible and how to make changes, see Users and roles. Security is no doubt of utmost concern to your organization. To simplify password management for your employees and strengthen security, you may already be using SSO with your other systems. You should do the same with New Relic. Using New Relic's SSO integration feature, account administrators will be able to enforce strong passwords and restrict login via a corporate authentication mechanism. This way, New Relic users who have already authenticated using a corporate SSO system will be able to bypass the New Relic login prompt. How to do it Log in to New Relic as an admin and go to the SSO configuration page. From the New Relic title bar, select (your account name) > Account Settings > Integrations > Single Sign On. From the SAML Single Sign On page, review your New Relic SAML Service Provider details. To upload your SAML Identity Provider certificate, select Choose File, and then follow standard procedures to select and save the file. Copy and paste in (or type) the Remove login URL that your users will use for Single Sign-On. If your organization’s SAML integration provides a redirect URL for logout, copy and paste in (or type) the Logout landing URL; otherwise leave blank. Save, test, and enable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 426.45102,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>best</em> <em>practices</em> <em>guide</em>",
        "sections": "APM <em>best</em> <em>practices</em> <em>guide</em>",
        "tags": "<em>Best</em> <em>practices</em> <em>guides</em>",
        "body": "Application Monitoring Tips You Need To Know It&#x27;s one thing to know how to use APM, but it&#x27;s another thing to know how to use <em>New</em> <em>Relic</em>&#x27;s application performance monitoring software well. Here are some <em>best</em> <em>practices</em> designed to help you become an APM master—and a key asset to your team! Tip To get"
      },
      "id": "6044186564441f1f94378ecc"
    }
  ],
  "/docs/new-relic-solutions/index": [
    {
      "sections": [
        "Resolve dependency risk: identify and analyze potential issues",
        "Prerequisites",
        "1. Analyze dependencies with service maps",
        "2. Identify back-end application dependency risks",
        "Tip",
        "3. Identify front-end dependency risk",
        "4. Identify Microservice Dependencies",
        "5. Create an action plan for risk mitigation"
      ],
      "title": "Resolve dependency risk: identify and analyze potential issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "4911ddf0c6fca572b52e22fbe464f21f0c6f338f",
      "image": "https://docs.newrelic.com/static/d1d4cf78d193ae770219cfdb9f6f792f/c1b63/distributed-trace_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/resolve-dependency-risk-identify-analyze-potential-issues/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Successfully scaling DevOps requires a robust understanding of dependencies across application teams and related services. Use New Relics service maps to discover and mitigate risky dependencies from upstream and downstream services. Prerequisites This tutorial assumes you’ve completed the previous DevOps procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. New Relic recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com > Service Maps > App/Service list This initial view shows all applications that are configured in your account. Applications that have violated a warning threshold are shown in yellow, and those with an active alert are shown in red. Healthy applications appear in green. New Relic uses a bold line to map applications to the services (such as databases) they connect to. Familiarize yourself with these maps to see how applications and their services fit together. Take note of which applications have the most dependencies and which rely on the same dependency, such as an API. Click an application to see high level metrics about that app, including throughput, response time, Apdex score, and error rate for the last 30 minutes. Tracking throughput is a good way to determine which of your applications are serving the most traffic. After looking at the architecture as a whole, review the applications that have the most dependencies. Select the App/Services list to see a full list of your applications. one.newrelic.com > Service Maps > App/Service list In this example, we’ve chosen Tower-Chicago from the App/Services list. All of the traffic being sent to Tower-Chicago is coming from Proxy-East. In this case, Tower-Chicago is showing 48.3 requests per minute, or 11.3% of the 426 requests per minute flowing through Proxy-East. one.newrelic.com > Service Maps > App/Service list In most cases, the separate applications and services represented in service maps are created and maintained by separate teams. This exercise of walking through the dependencies of your architecture should involve representatives from each of those teams. Teams should work together to ask questions such as: How critical is this particular dependency? What would happen if it were to go down? What happened last time it went down? Was there a revenue loss? 2. Identify back-end application dependency risks Once you’ve analyzed your applications’ dependencies, you’ll want to examine the quality of dependency execution. For example, is the dependency stable and predictable for each application or transaction you’ve identified? To do this, you’ll first need to gather as much information as you can about the applications from New Relic Insights, which helps you analyze data that is collected about the applications in more detail. Here is an example NRQL query to further analyze back-end service performance: SELECT count(appName)/30 as 'Throughput', apdex(duration), average(duration), stddev(duration), max(duration), count(error_type), uniquecount(host) FROM Transaction FACET appName SINCE 30 MINUTES AGO Copy This query shows you each application’s request per minute (throughput), Apdex score, and an overview of how the application is performing overall (through the standard deviation calculation, in which lower numbers are generally better). It also shows errors for the time period and the number of hosts on which the application is running. insights.newrelic.com > query results Next, gather information on incidents and events related to the services from New Relic Alerts: Click Alerts > Incidents > All Incidents. alerts.newrelic.com > Incidents > All Incidents Click Alerts > Events > All Events. alerts.newrelic.com > Incidents > All Events Tip Using webhooks to send alert events to New Relic Insights, allows you to supplement your dashboards with Alerts data. The process is outlined in this community discussion post. Here is a simplified example of the results of this exercise: Application Number of dependencies RPM Hosts APDEX (avg) Last outage TTR (hrs) Routing Service 10 983 4 .93 2/19/18 .75 Tower Austin 1 58 1 .95 10/11/17 1.5 Proxy-East 11 498 4 .92 1/4/18 .25 Proxy-West 11 495 4 .97 12/3/17 .25 WebPortal 7 396 8 .98 4/1/18 2.5 Supplement this data with the data that your teams know about your service and that you gathered from the dependency exercise in step 1, and use that data to develop hypotheses about the highest risk areas in your services that should be mitigated. 3. Identify front-end dependency risk Once you’ve analyzed back-end dependencies, explore front-end dependencies. This is a critical step because as you walk higher up the stack and closer to the user, you will likely have more dependencies and abstractions. Service maps seamlessly integrate data from browser monitoring and mobile monitoring to help you understand the dependencies from front-end user interfaces to back-end services. one.newrelic.com > Service Maps Use the service map view to drill into front-end dependencies, and execute a similar exercise to the one you executed for back-end dependencies. This exercise will again expose data to help you identify risk areas you should address and optimize. We recommend that you conduct the analysis with user interface (UI) teams so that you can also gather a complementary qualitative understanding of what the UI teams consider critical based on their experience. A ranking from the UI teams of the most critical dependency is a useful output of this work. 4. Identify Microservice Dependencies If you are using microservices, you can have dozens, if not hundreds, of services that are calling each other. Use Distributed Tracing to see how all those services connect together and how your requests flow through those different services. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. A distributed trace is composed of multiple \"spans,\" which represent time spent in services or resources of those services. Click on the Distributed tracing menu in New Relic APM left nav. You can see “trace listing” view where you’ll be able to quickly identify slow traces and traces with errors. The scatter plot lets you easily see outliers. Below that are the trace summaries, click on a trace to see details. Dive into distributed traces to see how long each span takes. Click into each span to see historical performance charts and associated attributes that layer in the context you need to understand and troubleshoot issues. one.newrelic.com > APM > (select an app) > Distributed tracing This rounds out your list of dependencies. 5. Create an action plan for risk mitigation Once you’ve analyzed the dependencies across your application from both front-end and back-end services, create an action plan to reduce dependency risks and achieve your service level objectives (SLO). As you prioritize these next steps, we recommend you keep these four principles in mind: Understand your risk tolerance. It’s helpful to have a clear picture of your tolerance for risk, which ideally should be informed by your service level objectives (refer to the Establish Objectives and Baselines tutorial for more information). Set an alert policy to monitor dependencies that you’ve determined have a high relationship to SLO achievement. Minimize dependencies. The simpler you keep your code, the less functions you'll have referring to other modules. Removing unnecessary complexity is an important way to ensure you have a maintainable system that meets your customers’ expectations. Localize dependencies. For the code you write, package together functions that depend on each other whenever possible. Stabilize dependencies. When dependencies are unavoidable, mitigate risks by ensuring these dependencies point to modules that are the least likely to change or are easier to substitute. When your action plan is complete, monitor the results of the efforts. The efficacy of your actions to resolve dependency risks should ultimately be measured by your SLOs",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1265.8881,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": " DevOps procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. <em>New</em> <em>Relic</em> recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com &gt; Service Maps"
      },
      "id": "60440f13e7b9d2ec025799f0"
    },
    {
      "sections": [
        "Set proactive alerting: understand and respond to performance issues",
        "Prerequisites",
        "1. Define required alerting policies based on Service Level Objectives",
        "2. Set specific alerts for performance, correctness, throughput, availability, and dependencies",
        "3. Identify groups to alert, and set broadcasting methods",
        "4. Leverage AI to fine-tune alerts and seek anomalies",
        "5. Create an alerts dashboard",
        "Conclusion",
        "For more help"
      ],
      "title": "Set proactive alerting: understand and respond to performance issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c8da73787dbeba3d1f2af43fbce84fb26e4d7852",
      "image": "https://docs.newrelic.com/static/49cfe6b2c2181499588c35b9720a1e4f/c1b63/new-relic-recent-anomalies-view.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues/",
      "published_at": "2021-07-09T15:47:11Z",
      "updated_at": "2021-07-09T15:47:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term \"alerting\" often carries some negative connotations; for too many developers, alerting correlates too closely with errors, mistakes, and ongoing issues. However, for developers who are proactive about alerting, they know they don’t have to stare at their dashboards all day, because effective alerts will tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Alerts can become overwhelming, so tune alerts and leverage AI so you get alerted on what matters. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, “95% of requests completed within 250 ms AND availability is 99.99%”), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it’s meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature DevOps customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic DevOps customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use Synthetic monitoring pings to determine if the site is up and scripted checks to determine that the most important capabilities (such as a checkout cart) are working. How's our underlying infrastructure? Set KPIs for key hardware, virtual hosts, containers, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site’s availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don’t yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we’ve set both a warning and a violation for throughput: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier -- this can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic approximately evenly across five different servers. You can set an alert based on a NRQL query, and notification to be sent if any server starts getting significantly more or less traffic than the other servers. Here’s the graph: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds And here’s a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups to alert, and set broadcasting methods Alerting without the proper broadcasting methods leaves you vulnerable. Your alerts strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the the types of alerts that warrant waking someone up. 4. Leverage AI to fine-tune alerts and seek anomalies To ensure you aren't training your teams to turn off or ignore notifications, keep your alerts valid and fresh. As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. To keep alerts to a minimum, leverage New Relic Applied Intelligence features, such as Incident Intelligence, which correlates related alerts into one actionable issue combining machine learning and manual input. Check to make sure alerts are correlated correctly and train your system to obtain the most accurate incident correlation. An additional way to reduce alert noise is by flapping detection and suppression. When an issue is \"flapping,\" it is cycling between an open and resolved state, creating a new alert every time it cycles. Effectively handling these can reduce the number of total alerts sent to your team. Finally, when you have maintenance scheduled, take advantage of alert muting rules to suppress those alerts you don't need. Now that you have tuned your alerts to valid notifications, you can proactively go after anomalies so you can fix issues before they become incidents. Enable Proactive Detection of anomalies and set some level of notification for them. 5. Create an alerts dashboard Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use NRQL to create your dashboards. For detailed instructions, check out Sending alerts data to Insights (Insights is no longer our querying interface but the same concepts apply). The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you’re using. For a more extensive discussion on notification channels, refer to the incident orchestration tutorial. Conclusion Establishing a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or infrastructure. With proactive alerting, you will decrease user-reported incidents, and allow your teams to spend less time firefighting and more time deploying significant changes to your product. For more help For more tips and best practices for alerting, see the following documentation: Tame application monitoring with dynamic targeting in New Relic Alerts Best practices for alert policies New Relic infrastructure monitoring best practices guide Infrastructure alerting examples",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1265.002,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": ". Prerequisites This tutorial assumes you have: Instrumented your applications in <em>New</em> <em>Relic</em>. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level"
      },
      "id": "60445b8764441fe7fd378ee5"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-07-09T15:09:24Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1263.1829,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With <em>New</em> <em>Relic</em> you can measure the success of your DevOps initiatives and learn how"
      },
      "id": "60440e5364441fb0c6378ef6"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/cloud-adoption/modern-cloud-services": [
    {
      "sections": [
        "Validate cloud improvements",
        "1. Identify KPIs",
        "2. Deploy monitoring tools",
        "Install New Relic APM",
        "Install New Relic Infrastructure",
        "Tip",
        "Install New Relic Infrastructure integrations",
        "3. Gather custom data",
        "4. Create baselines",
        "5. Validate improvements with Dashboards"
      ],
      "title": "Validate cloud improvements",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "e8083557674f0bd9a67aadade85517b9f5a517df",
      "image": "https://docs.newrelic.com/static/bd6f185deecee0d1735e167f1831d877/c1b63/KPIs-validate-improvement_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/validate-cloud-improvements/",
      "published_at": "2021-07-09T12:54:07Z",
      "updated_at": "2021-07-09T12:54:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you migrate your applications to the cloud and integrate cloud services, use New Relic to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the New Relic platform to measure KPIs helps you eliminate blind spots and see the connections between entities—from your application code to your cloud infrastructure (including containers running in highly distributed microservices), to your customer experience. Your goal is to create a collection of metrics in several categories that you can visualize in dashboards in New Relic Dashboards. To validate cloud improvements, group KPIs in the following categories, from least to most strong: Application and infrastructure performance End-user experience, including website and mobile application performance Audience and content trends DevOps productivity Application revenue analytics Future business goals 2. Deploy monitoring tools To start monitoring your KPIs, verify that the applications that you want to migrate are compatible with the requirements for the New Relic products you want to use. Then, install the New Relic agents: Install New Relic APM Review the compatibility and requirements and then install APM agents on your application stack. After installing the APM agents, review the architecture of the applications you instrumented with an APM agent. Take note of all hosts that are part of each tier of the application stack (database, application, web server, etc.), so you can install New Relic Infrastructure agents on each of those hosts. Install New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, install the Infrastructure agent on the hosts that you identified so you can start to gather data for your KPIs. Tip If you use Ansible, Chef, or Puppet for automation, you can use those tools to deploy Infrastructure agents to your hosts. Install New Relic Infrastructure integrations You can also monitor and report data about services that your code depends on using New Relic integrations. New Relic offers cloud integrations for Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform as well as on-host integrations. Tip If you are using AWS as a cloud provider, take advantage of New Relic’s AWS billing integrations to stay on top of your budget and prove the success of your migration. 3. Gather custom data To manage, search for, and filter resources, assign metadata to your cloud resources in the form of tags. Tags are labels that consist of key-value pairs that you use to annotate your Infrastructure data. Tag formats are different between AWS, Azure, and Google. Google, for example, has the shortest allowable lengths for keys and values. In addition, they all have different requirements for case sensitivity and allowable characters. To make sure that your tags are usable across most cloud providers: Use only lowercase letters, numbers, underscores, and dashes. Keep keys and values under 63 characters. New Relic reports data contained in specific events to your account as part of its “out-of-the-box” functionality. You can add additional data to those events by using custom attributes. If you determine that you need to collect custom data, review custom data requirements, and report custom event data. For more detailed information about sending custom data, check out these New Relic University tutorials: APM custom data overview Adding custom events using the API 4. Create baselines In order to validate the value of moving to the cloud, you need to get baselines for your applications before you move to the cloud. Define pre-migration baselines for applications and their underlying infrastructures that you have designated for cloud service improvements based on your KPIs. To stay on top of your KPIs as you are moving, create baseline alerts for applications monitored by APM and browser and use NRQL alerts to get notified on any spikes or drops in your KPIs. The following dashboard tracks key performance indicators for applications designated to move to the cloud: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs. After you migrate applications to the cloud, apply the same criteria to post-migration baselines so you can compare your results from before and after your migration. 5. Validate improvements with Dashboards Dashboards is a single location to view all the data that New Relic products gather. Use New Relic Dashboards to visualize your KPIs before and after your move: Transaction and TransactionError event types with APM PageView and PageAction event types with browser Default Infrastructure events and attributes for your systems, processes, events, storage, and network, Infrastructure integrations, and custom attributes Mobile event types with Mobile SyntheticCheck, SyntheticRequest, and SyntheticPrivateMinion event types with Synthetics The following dashboard shows KPI data used to validate cloud improvements: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs pre- and post-migration. Use dashboards to validate the value of adopting a new cloud service and to answer key questions about application performance and customer experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.69208,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Validate <em>cloud</em> improvements",
        "sections": "Install <em>New</em> <em>Relic</em> APM",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "After you migrate your applications to the <em>cloud</em> and integrate <em>cloud</em> services, use <em>New</em> <em>Relic</em> to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key"
      },
      "id": "60445c48e7b9d2052c5799d4"
    },
    {
      "sections": [
        "Refactor your applications",
        "1. Deploy monitoring",
        "Cloud-based integrations",
        "2. Set deployment markers",
        "3. Establish baselines",
        "4. Refactor your applications",
        "5. Create dashboards to track refactoring your applications",
        "6. Create comparison dashboards"
      ],
      "title": "Refactor your applications",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "fcea859e043f6ff33898803636b9a7a6de04508a",
      "image": "https://docs.newrelic.com/static/fc360bb9af89fe16ea8351e90b16ec09/c1b63/screen-deployments-page.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/refactor-your-applications/",
      "published_at": "2021-07-09T11:32:22Z",
      "updated_at": "2021-07-09T11:32:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At each step of your cloud adoption process, New Relic plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage cloud costs. New Relic can also help you refactor, or re-architect, your software and services when you migrate them to the cloud. One key aspect of refactoring your software is splitting out your components into different services available from your cloud provider. For example, you might move your database component away from a traditional MySQL database to a cloud-hosted solution, like Amazon Relational Database (RDS) services such as DynamoDB or Aurora. If you move to the Azure cloud, you might adopt Azure SQL or Cosmos DB. When you move to solutions like those, you increase your database redundancy and resiliency. If you evaluate your overall ROI properly, you should start to see the cost/benefit ratio taking effect once you complete your refactoring. 1. Deploy monitoring New Relic is a true multi-tenant SaaS solution, meaning New Relic designed the agents to work at every layer of your application stack. To get started, deploy the agents: APM to collect application-tier performance metrics Browser monitoring to collect front-end web metrics Mobile monitoring to collect front-end mobile app metrics Infrastructure to collect host/server metrics Cloud-based integrations As you refactor your application and integrate new cloud services, you can also use New Relic to monitor and report data about your cloud services, offering you a comprehensive view of your entire architecture in one place. Cloud-based integrations available through New Relic include Amazon Web Services (AWS) and Microsoft Azure. This tutorial describes a database migration and focuses on APM and Infrastructure. 2. Set deployment markers With New Relic, you can track deployments by setting deployment markers. Deployment tracking lets you quickly see how deployments affect your application’s performance and gauge its performance before and after you refactor. You can view deployments on the Deployments page in APM: rpm.newrelic.com/apm > (selected app) > Events > Deployments: Here is an example of the Deployments page and details about a selected deployment. 3. Establish baselines When you install the APM agent at the application layer, New Relic immediately starts collecting and displaying metrics. Use these metrics to set your pre-migration application baseline. APM agents collect performance metrics about outbound calls to databases. In the Monitoring section of the APM UI, click Databases to see a view of your database metrics. The following shows a database running on MySQL that will be refactored to use DynamoDB after migrating to AWS: one.newrelic.com > APM > (select an app) > Monitoring > Databases: Use this page to view and sort detailed information about database performance. 4. Refactor your applications To take advantage of the cloud, research what services are available from your cloud provider, and then re-architect and uncouple your applications. 5. Create dashboards to track refactoring your applications Apply your KPIs to your baseline measurements to validate cloud improvements, and, ideally, start seeing the impact of moving to the cloud. New Relic’s reporting for database interactions goes much deeper than high-level performance metrics about calls to the database layer in APM. You get access to metrics about slow queries so you can filter by database vendor and cache type. You can also see host and instance details for databases visually within Service Maps and within the context of transaction traces. Because all of your performance metrics are available in New Relic Insights, it is easy to build dashboards to show the performance of your database calls before, during, and after your refactoring in a single unified view. Here is an example of an Insights dashboard for an application that uses DynamoDB and was migrated to AWS: insights.newrelic.com: Build a dashboard that shows the performance of your database calls. 6. Create comparison dashboards To compare both the pre- and post-refactor baselines, create an Insights dashboard that displays the KPIs you baselined. The following dashboard shows the MySQL request query latency as compared with all of the operations for DynamoDB. You can see that, for this example, the request query latency for DynamoDB is too small to even register on the graph. Performance is clearly optimized with this cloud-based database. insights.newrelic.com: Use Insights dashboards to visualize pre- and post-refactor baselines. With APM agents and the integrations New Relic provides, you can measure the effectiveness of refactoring your applications using a broad spectrum of metrics.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.59363,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Cloud</em>-based integrations",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "At each step of your <em>cloud</em> <em>adoption</em> process, <em>New</em> <em>Relic</em> plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage <em>cloud</em> costs. <em>New</em> <em>Relic</em> can also help you refactor, or re-architect, your software and services when you migrate them"
      },
      "id": "60445da6e7b9d2bf265799ee"
    },
    {
      "sections": [
        "Optimize customer experience",
        "1. Identify applications scoped for improvement",
        "2. Deploy monitoring: Browser, mobile, and synthetics",
        "Deploy browser to monitor your front-end data",
        "Deploy mobile monitoring, if your company has a mobile app",
        "Tip",
        "Synthetics—it’s already there!",
        "3. Identify your relevant metrics",
        "KPIs for business performance",
        "KPIs that are specific to your company",
        "KPIs for application and infrastructure teams",
        "4. Create dashboards showing KPIs from before and after your migration"
      ],
      "title": "Optimize customer experience",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "2d4df116b6dedf8a3d0911b0ad0e7bbd11b991d9",
      "image": "https://docs.newrelic.com/static/b84aceb32c77eb0a35e93a26ea700075/c1b63/optimize_exp.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-customer-experience/",
      "published_at": "2021-07-09T10:50:42Z",
      "updated_at": "2021-07-09T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You have been running in the cloud for awhile now, or you just completed your migration from on-premise to the cloud. You have gone through your planning stages, identified your dependencies, tested your assumptions, and everything is looking great. But there are still some big questions: How are your customers experiencing your service? Did the performance of your front-end applications improve, or did performance stay the same? Or did it worsen in ways you did not expect? New Relic provides a suite of front-end monitoring—browser, mobile, and synthetic—to help you monitor and improve your front-end applications. With dashboards, you can bring together information from each one of these product to give you an overall view of what your customer is experiencing. Follow the steps in this doc to optimize your customer experience after you migrate to the cloud. 1. Identify applications scoped for improvement When you identify applications that you want to improve, start with applications where you have some clearly defined KPIs (Key Performance Indicators) that are relevant to the overall performance of your business. Selecting an application that tells a complete story of your performance, regarding key performance indicators, builds trust that you are doing the right level of monitoring and gathering the right metrics. When measuring front-end application performance, most companies think about these common KPIs: Availability percentage Average duration Page load time Throughput Apdex Response time Use those common KPIs as a guideline when identifying applications. Take each one of the metrics and consider it from the perspective of your company's CEO and business team. What is the actual impact on your company's business if your application becomes unavailable? How many users will your site lose if your page loads start to take over four seconds? How many dollars are lost if your applications are not able to handle throughput spikes and some users get no response during those spikes? These are serious questions to answer, and, if you are only measuring metrics on the server/application side, you are very likely not seeing what your customers are seeing on the frontend of the application. That is why browser, mobile, and synthetics are key to understanding the complete picture of your application performance. With dashboards, you bring all of these metrics together and give your company a single place to see every metric that is crucial to your success. 2. Deploy monitoring: Browser, mobile, and synthetics To start monitoring, you need to deploy browser, mobile, and synthetics agents. With browser, you gain deep insight into how your users are interacting with your application or website. Mobile monitoring allows you to monitor and manage the performance of your iOS and Android applications. Synthetics is a suite of automated, scriptable tools to monitor your websites and API endpoints. Just like with all of New Relic's agents, browser, mobile, and synthetics are quick to deploy. Here is a quick overview of each and links to documentation to help you get going: Deploy browser to monitor your front-end data In a nutshell, browser monitoring is a snippet of JavaScript that needs to appear in all of your application's webpages. It has no dependencies on other libraries, so it does not cause additional delays when bringing jQuery or other frameworks into the webpage. There are three ways to install the browser agent: Method When to use this method Enable via APM Typically, the quickest path is to let the APM agent dynamically inject the snippet into your pages on the server side. This works for many common web technologies, such as .NET, JSP, and other Java solutions. The documentation provides a complete reference for the languages and frameworks that allow this option. Copy/paste method If you are using an unsupported framework or are in an environment where you can instrument only the webpages but cannot install APM on the back-end, use the copy/paste method. New Relic presents a snippet directly in the UI, and you copy it and paste it into a global page template on your end. Just pick one that is used by all of your webpages and put it there, and then the snippet appears on all pages. Enable via the API You can perform a manual instrumentation, in which your developers can add instrumentation to your webpages using a server-side API. New Relic supports this for many server-side languages. Refer to the documentation for an example of how to do this in Java. Whichever method you choose, you quickly have front-end performance data from your web pages. Just like with APM and other New Relic products, the overview tells you the “big picture” story of your performance data—in this case, your front-end data: one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the browser apps index, the Summary page shows a summary of browser performance for that app. Set alert conditions on metrics like Page view load time and Throughput, as well as JS Errors and Ajax response time. This is not just about seeing a slowdown and fixing it—this is about real users having a frustrating experience and potentially walking away from your application, costing your company potential profits. If you do not already have SLAs defined for these kinds of metrics, now is the time to define them. If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your cloud metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with New Relic products. Deploy mobile monitoring, if your company has a mobile app If your company has a mobile application, install Mobile monitoring. Tip Monitoring performance metrics about your webpages as they work in mobile browsers is handled by the browser agent. If you do not have a native mobile application, you can skip this section. The mobile monitoring agents support most common devices running on iOS and Android. The install process for iOS and Android requires you to include the mobile SDK in your applications. The SDK is as low impact as possible in terms of resource consumption (CPU and memory) while simultaneously providing you a broad and deep spectrum of performance data about your mobile applications. Slow performance on your mobile apps can be just as impactful to your business as slow performance in webpages. Think of top-level metrics like crash occurrences, HTTP errors/network failures, and HTTP response times in terms of your business KPIs. What happens to your business objectives when your mobile app starts spiking in terms of crash rate? Do users get frustrated and give up when the app takes forever to pull down data from your back-end systems or from third-party resources? The mobile monitoring overview page pulls together a set of metrics that you should be setting SLAs and alert conditions on: one.newrelic.com > Mobile > (select an app) > Summary: Quickly view crash occurrences, app launches, and more with mobile monitoring. Once you get to know these top level metrics, you can quickly start using your mobile metrics to find root causes, so you can add new alert conditions on lower-level metrics and discover any regression problems down the road. You can also monitor the back-end systems and cloud services that support your mobile apps. Improving the back-end systems and cloud services has a direct result in their improvement. Check out Monitor your cloud services to gain more insight. Synthetics—it’s already there! With Synthetics, there is nothing to install—the agents are already installed at many global locations and are just waiting for you to start using them. Synthetics lets you quickly define monitors, which run on a schedule you pick and make automated calls from those global locations back into your systems. There are four different types of monitors, and they have the following functions: Type of monitor What this monitor can do for you Ping Point a ping monitor at one of your webpages, and New Relic tells you if that page is responding as expected. Think of Ping as a simple “up/down” test but with a few extra features that you will quickly get to know. Simple browser The job of a simple browser is to simulate all of the work that a real browser would do to build out one of your webpages. Where are the slow points? How can you quickly see a waterfall view of the page buildout? Simple browser quickly gets you all this data. Scripted browser This monitor lets you define a key workflow in your webpages (for example, registering, searching, or purchasing a product) as a script that the monitor runs for you on the frequency you select. If any step in the script fails, New Relic notifies you, with full details about where the failure happened and what it was. API test Testing your API endpoints is just as important as testing your webpages—if one of them stops working as expected, the downstream effects on your systems can be bad news for you and your customers. Define a script that pulls back data from one of your endpoints, tests what it gets back, and alerts you when it encounters a problem. Here are a few things to remember about Synthetics: You can alert on every metric recorded by the monitors, from “is it up/down?” to “what came back from my API endpoint?” All of your performance data from Synthetics can be quickly viewed in terms of SLAs and KPIs. Just like with the other areas of your instrumentation, it helps your entire team to start defining your SLAs for your KPIs. The metrics from Synthetics help you prove out the value of having moved to cloud-hosted services. For any test that you want to run on a resource inside your firewall, there are private minions that you can quickly and securely stand up in your own environment. They are available in the list of locations for your monitors, just like the the rest of the default global locations. 3. Identify your relevant metrics It is vital to identify which metrics are the most important to your business and use these metrics to define your KPIs. Answer the following questions to begin identifying the relevant metrics: What are your KPIs? Are you setting SLAs for them? Here is a look at some examples of KPIs: KPIs for business performance Here are some examples of KPIs that companies in many industries consider to be key to business performance: General DOM readiness Page render Apdex Mobile crash rate Web Session count Session duration Page views DOM readiness Page render Error % Apdex Mobile App launches User counts Load time Response time Crash rates Crash locations Error rates (HTTP, network) API errors Session duration Video Video play count Video play duration Video bit rate Video buffering time Video success rate Errors (video, advertisement) Trends Active users Product views Session duration Sales/Retail Cart value Abandon rate Funnels Click-throughs Revenue (made, loss) KPIs that are specific to your company You might start with KPIs from the business performance list and then build them out to be more specific to your own company’s performance: Geography Business unit Product Product name Device type Store/location Mobile platform Carrier Website name Page name Browser type Error type Application name Cloud provider Success/fail reason KPIs for application and infrastructure teams Here are some KPI ideas for your application and infrastructure teams for the server side: Application/Infrastructure Apdex Availability Throughput App/API/DB response times Error % Memory footprint CPU workload Disk workload Network throughput DevOps Builds Commits Deploys Errors Support incidents MTTR With New Relic products in place across your ecosystem, you can collect a large number of these metrics right out of the box. Once you have all of the data flowing, dashboards is the place where you start creating dashboards from before and after your migration to show your teams the value of moving to the cloud. 4. Create dashboards showing KPIs from before and after your migration So, what might a starter dashboard look like for this part of your migration project? Consider this example: one.newrelic.com > Dashboards: Create customizable dashboards to monitor performance and business data. The rows represent the “before” and “after” perspectives. The widgets in these rows get you answers to the key questions behind your KPIs: What is my site's availability? Which global locations are experiencing the slowest performance? How can I use Apdex scoring to measure customer satisfaction levels with my application's performance? How many are satisfied? How many are OK (tolerating)? How many are frustrated with my site? With just a few setup steps, you can get your monitors running, and then head over to New Relic dashboards and design your widgets. Check out the Introduction to New Relic One dashboards which shows you many examples of these kinds of queries, using data from your own account. You can quickly get a feel for how to start building queries, widgets, and dashboards. After you identify your SLAs and KPIs, browser and mobile monitoring let you quickly start collecting data from your webpages and mobile apps, and Synthetics lets you schedule the monitors you need so that you can find out about problems before your customers start telling you about them. Bringing it all together in dashboards, you can start building the before/after perspective you need to prove the value of moving to the cloud and gain information that will help you optimize your customer’s experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.03854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": ". If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your <em>cloud</em> metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with <em>New</em> <em>Relic</em> products. Deploy mobile monitoring, if your company has"
      },
      "id": "60445c0064441f4b53378f00"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/app-remediation-gather-performance-statistics": [
    {
      "sections": [
        "Resolve dependency risk: identify and analyze potential issues",
        "Prerequisites",
        "1. Analyze dependencies with service maps",
        "2. Identify back-end application dependency risks",
        "Tip",
        "3. Identify front-end dependency risk",
        "4. Identify Microservice Dependencies",
        "5. Create an action plan for risk mitigation"
      ],
      "title": "Resolve dependency risk: identify and analyze potential issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "4911ddf0c6fca572b52e22fbe464f21f0c6f338f",
      "image": "https://docs.newrelic.com/static/d1d4cf78d193ae770219cfdb9f6f792f/c1b63/distributed-trace_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/resolve-dependency-risk-identify-analyze-potential-issues/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Successfully scaling DevOps requires a robust understanding of dependencies across application teams and related services. Use New Relics service maps to discover and mitigate risky dependencies from upstream and downstream services. Prerequisites This tutorial assumes you’ve completed the previous DevOps procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. New Relic recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com > Service Maps > App/Service list This initial view shows all applications that are configured in your account. Applications that have violated a warning threshold are shown in yellow, and those with an active alert are shown in red. Healthy applications appear in green. New Relic uses a bold line to map applications to the services (such as databases) they connect to. Familiarize yourself with these maps to see how applications and their services fit together. Take note of which applications have the most dependencies and which rely on the same dependency, such as an API. Click an application to see high level metrics about that app, including throughput, response time, Apdex score, and error rate for the last 30 minutes. Tracking throughput is a good way to determine which of your applications are serving the most traffic. After looking at the architecture as a whole, review the applications that have the most dependencies. Select the App/Services list to see a full list of your applications. one.newrelic.com > Service Maps > App/Service list In this example, we’ve chosen Tower-Chicago from the App/Services list. All of the traffic being sent to Tower-Chicago is coming from Proxy-East. In this case, Tower-Chicago is showing 48.3 requests per minute, or 11.3% of the 426 requests per minute flowing through Proxy-East. one.newrelic.com > Service Maps > App/Service list In most cases, the separate applications and services represented in service maps are created and maintained by separate teams. This exercise of walking through the dependencies of your architecture should involve representatives from each of those teams. Teams should work together to ask questions such as: How critical is this particular dependency? What would happen if it were to go down? What happened last time it went down? Was there a revenue loss? 2. Identify back-end application dependency risks Once you’ve analyzed your applications’ dependencies, you’ll want to examine the quality of dependency execution. For example, is the dependency stable and predictable for each application or transaction you’ve identified? To do this, you’ll first need to gather as much information as you can about the applications from New Relic Insights, which helps you analyze data that is collected about the applications in more detail. Here is an example NRQL query to further analyze back-end service performance: SELECT count(appName)/30 as 'Throughput', apdex(duration), average(duration), stddev(duration), max(duration), count(error_type), uniquecount(host) FROM Transaction FACET appName SINCE 30 MINUTES AGO Copy This query shows you each application’s request per minute (throughput), Apdex score, and an overview of how the application is performing overall (through the standard deviation calculation, in which lower numbers are generally better). It also shows errors for the time period and the number of hosts on which the application is running. insights.newrelic.com > query results Next, gather information on incidents and events related to the services from New Relic Alerts: Click Alerts > Incidents > All Incidents. alerts.newrelic.com > Incidents > All Incidents Click Alerts > Events > All Events. alerts.newrelic.com > Incidents > All Events Tip Using webhooks to send alert events to New Relic Insights, allows you to supplement your dashboards with Alerts data. The process is outlined in this community discussion post. Here is a simplified example of the results of this exercise: Application Number of dependencies RPM Hosts APDEX (avg) Last outage TTR (hrs) Routing Service 10 983 4 .93 2/19/18 .75 Tower Austin 1 58 1 .95 10/11/17 1.5 Proxy-East 11 498 4 .92 1/4/18 .25 Proxy-West 11 495 4 .97 12/3/17 .25 WebPortal 7 396 8 .98 4/1/18 2.5 Supplement this data with the data that your teams know about your service and that you gathered from the dependency exercise in step 1, and use that data to develop hypotheses about the highest risk areas in your services that should be mitigated. 3. Identify front-end dependency risk Once you’ve analyzed back-end dependencies, explore front-end dependencies. This is a critical step because as you walk higher up the stack and closer to the user, you will likely have more dependencies and abstractions. Service maps seamlessly integrate data from browser monitoring and mobile monitoring to help you understand the dependencies from front-end user interfaces to back-end services. one.newrelic.com > Service Maps Use the service map view to drill into front-end dependencies, and execute a similar exercise to the one you executed for back-end dependencies. This exercise will again expose data to help you identify risk areas you should address and optimize. We recommend that you conduct the analysis with user interface (UI) teams so that you can also gather a complementary qualitative understanding of what the UI teams consider critical based on their experience. A ranking from the UI teams of the most critical dependency is a useful output of this work. 4. Identify Microservice Dependencies If you are using microservices, you can have dozens, if not hundreds, of services that are calling each other. Use Distributed Tracing to see how all those services connect together and how your requests flow through those different services. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. A distributed trace is composed of multiple \"spans,\" which represent time spent in services or resources of those services. Click on the Distributed tracing menu in New Relic APM left nav. You can see “trace listing” view where you’ll be able to quickly identify slow traces and traces with errors. The scatter plot lets you easily see outliers. Below that are the trace summaries, click on a trace to see details. Dive into distributed traces to see how long each span takes. Click into each span to see historical performance charts and associated attributes that layer in the context you need to understand and troubleshoot issues. one.newrelic.com > APM > (select an app) > Distributed tracing This rounds out your list of dependencies. 5. Create an action plan for risk mitigation Once you’ve analyzed the dependencies across your application from both front-end and back-end services, create an action plan to reduce dependency risks and achieve your service level objectives (SLO). As you prioritize these next steps, we recommend you keep these four principles in mind: Understand your risk tolerance. It’s helpful to have a clear picture of your tolerance for risk, which ideally should be informed by your service level objectives (refer to the Establish Objectives and Baselines tutorial for more information). Set an alert policy to monitor dependencies that you’ve determined have a high relationship to SLO achievement. Minimize dependencies. The simpler you keep your code, the less functions you'll have referring to other modules. Removing unnecessary complexity is an important way to ensure you have a maintainable system that meets your customers’ expectations. Localize dependencies. For the code you write, package together functions that depend on each other whenever possible. Stabilize dependencies. When dependencies are unavoidable, mitigate risks by ensuring these dependencies point to modules that are the least likely to change or are easier to substitute. When your action plan is complete, monitor the results of the efforts. The efficacy of your actions to resolve dependency risks should ultimately be measured by your SLOs",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 432.0456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " <em>DevOps</em> procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. <em>New</em> <em>Relic</em> recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com &gt; Service Maps"
      },
      "id": "60440f13e7b9d2ec025799f0"
    },
    {
      "sections": [
        "Set proactive alerting: understand and respond to performance issues",
        "Prerequisites",
        "1. Define required alerting policies based on Service Level Objectives",
        "2. Set specific alerts for performance, correctness, throughput, availability, and dependencies",
        "3. Identify groups to alert, and set broadcasting methods",
        "4. Leverage AI to fine-tune alerts and seek anomalies",
        "5. Create an alerts dashboard",
        "Conclusion",
        "For more help"
      ],
      "title": "Set proactive alerting: understand and respond to performance issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c8da73787dbeba3d1f2af43fbce84fb26e4d7852",
      "image": "https://docs.newrelic.com/static/49cfe6b2c2181499588c35b9720a1e4f/c1b63/new-relic-recent-anomalies-view.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues/",
      "published_at": "2021-07-09T15:47:11Z",
      "updated_at": "2021-07-09T15:47:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term \"alerting\" often carries some negative connotations; for too many developers, alerting correlates too closely with errors, mistakes, and ongoing issues. However, for developers who are proactive about alerting, they know they don’t have to stare at their dashboards all day, because effective alerts will tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Alerts can become overwhelming, so tune alerts and leverage AI so you get alerted on what matters. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, “95% of requests completed within 250 ms AND availability is 99.99%”), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it’s meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature DevOps customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic DevOps customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use Synthetic monitoring pings to determine if the site is up and scripted checks to determine that the most important capabilities (such as a checkout cart) are working. How's our underlying infrastructure? Set KPIs for key hardware, virtual hosts, containers, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site’s availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don’t yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we’ve set both a warning and a violation for throughput: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier -- this can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic approximately evenly across five different servers. You can set an alert based on a NRQL query, and notification to be sent if any server starts getting significantly more or less traffic than the other servers. Here’s the graph: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds And here’s a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups to alert, and set broadcasting methods Alerting without the proper broadcasting methods leaves you vulnerable. Your alerts strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the the types of alerts that warrant waking someone up. 4. Leverage AI to fine-tune alerts and seek anomalies To ensure you aren't training your teams to turn off or ignore notifications, keep your alerts valid and fresh. As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. To keep alerts to a minimum, leverage New Relic Applied Intelligence features, such as Incident Intelligence, which correlates related alerts into one actionable issue combining machine learning and manual input. Check to make sure alerts are correlated correctly and train your system to obtain the most accurate incident correlation. An additional way to reduce alert noise is by flapping detection and suppression. When an issue is \"flapping,\" it is cycling between an open and resolved state, creating a new alert every time it cycles. Effectively handling these can reduce the number of total alerts sent to your team. Finally, when you have maintenance scheduled, take advantage of alert muting rules to suppress those alerts you don't need. Now that you have tuned your alerts to valid notifications, you can proactively go after anomalies so you can fix issues before they become incidents. Enable Proactive Detection of anomalies and set some level of notification for them. 5. Create an alerts dashboard Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use NRQL to create your dashboards. For detailed instructions, check out Sending alerts data to Insights (Insights is no longer our querying interface but the same concepts apply). The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you’re using. For a more extensive discussion on notification channels, refer to the incident orchestration tutorial. Conclusion Establishing a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or infrastructure. With proactive alerting, you will decrease user-reported incidents, and allow your teams to spend less time firefighting and more time deploying significant changes to your product. For more help For more tips and best practices for alerting, see the following documentation: Tame application monitoring with dynamic targeting in New Relic Alerts Best practices for alert policies New Relic infrastructure monitoring best practices guide Infrastructure alerting examples",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.7431,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. <em>New</em> <em>Relic</em> often finds that our most mature <em>DevOps</em> customers set fewer alerts in general and focus those"
      },
      "id": "60445b8764441fe7fd378ee5"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-07-09T15:09:24Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.12228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Device</em> performance breakdown",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "In a <em>DevOps</em> world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With <em>New</em> <em>Relic</em> you can <em>measure</em> the <em>success</em> of your <em>DevOps</em> initiatives and learn how"
      },
      "id": "60440e5364441fb0c6378ef6"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation": [
    {
      "sections": [
        "Resolve dependency risk: identify and analyze potential issues",
        "Prerequisites",
        "1. Analyze dependencies with service maps",
        "2. Identify back-end application dependency risks",
        "Tip",
        "3. Identify front-end dependency risk",
        "4. Identify Microservice Dependencies",
        "5. Create an action plan for risk mitigation"
      ],
      "title": "Resolve dependency risk: identify and analyze potential issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "4911ddf0c6fca572b52e22fbe464f21f0c6f338f",
      "image": "https://docs.newrelic.com/static/d1d4cf78d193ae770219cfdb9f6f792f/c1b63/distributed-trace_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/resolve-dependency-risk-identify-analyze-potential-issues/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Successfully scaling DevOps requires a robust understanding of dependencies across application teams and related services. Use New Relics service maps to discover and mitigate risky dependencies from upstream and downstream services. Prerequisites This tutorial assumes you’ve completed the previous DevOps procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. New Relic recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com > Service Maps > App/Service list This initial view shows all applications that are configured in your account. Applications that have violated a warning threshold are shown in yellow, and those with an active alert are shown in red. Healthy applications appear in green. New Relic uses a bold line to map applications to the services (such as databases) they connect to. Familiarize yourself with these maps to see how applications and their services fit together. Take note of which applications have the most dependencies and which rely on the same dependency, such as an API. Click an application to see high level metrics about that app, including throughput, response time, Apdex score, and error rate for the last 30 minutes. Tracking throughput is a good way to determine which of your applications are serving the most traffic. After looking at the architecture as a whole, review the applications that have the most dependencies. Select the App/Services list to see a full list of your applications. one.newrelic.com > Service Maps > App/Service list In this example, we’ve chosen Tower-Chicago from the App/Services list. All of the traffic being sent to Tower-Chicago is coming from Proxy-East. In this case, Tower-Chicago is showing 48.3 requests per minute, or 11.3% of the 426 requests per minute flowing through Proxy-East. one.newrelic.com > Service Maps > App/Service list In most cases, the separate applications and services represented in service maps are created and maintained by separate teams. This exercise of walking through the dependencies of your architecture should involve representatives from each of those teams. Teams should work together to ask questions such as: How critical is this particular dependency? What would happen if it were to go down? What happened last time it went down? Was there a revenue loss? 2. Identify back-end application dependency risks Once you’ve analyzed your applications’ dependencies, you’ll want to examine the quality of dependency execution. For example, is the dependency stable and predictable for each application or transaction you’ve identified? To do this, you’ll first need to gather as much information as you can about the applications from New Relic Insights, which helps you analyze data that is collected about the applications in more detail. Here is an example NRQL query to further analyze back-end service performance: SELECT count(appName)/30 as 'Throughput', apdex(duration), average(duration), stddev(duration), max(duration), count(error_type), uniquecount(host) FROM Transaction FACET appName SINCE 30 MINUTES AGO Copy This query shows you each application’s request per minute (throughput), Apdex score, and an overview of how the application is performing overall (through the standard deviation calculation, in which lower numbers are generally better). It also shows errors for the time period and the number of hosts on which the application is running. insights.newrelic.com > query results Next, gather information on incidents and events related to the services from New Relic Alerts: Click Alerts > Incidents > All Incidents. alerts.newrelic.com > Incidents > All Incidents Click Alerts > Events > All Events. alerts.newrelic.com > Incidents > All Events Tip Using webhooks to send alert events to New Relic Insights, allows you to supplement your dashboards with Alerts data. The process is outlined in this community discussion post. Here is a simplified example of the results of this exercise: Application Number of dependencies RPM Hosts APDEX (avg) Last outage TTR (hrs) Routing Service 10 983 4 .93 2/19/18 .75 Tower Austin 1 58 1 .95 10/11/17 1.5 Proxy-East 11 498 4 .92 1/4/18 .25 Proxy-West 11 495 4 .97 12/3/17 .25 WebPortal 7 396 8 .98 4/1/18 2.5 Supplement this data with the data that your teams know about your service and that you gathered from the dependency exercise in step 1, and use that data to develop hypotheses about the highest risk areas in your services that should be mitigated. 3. Identify front-end dependency risk Once you’ve analyzed back-end dependencies, explore front-end dependencies. This is a critical step because as you walk higher up the stack and closer to the user, you will likely have more dependencies and abstractions. Service maps seamlessly integrate data from browser monitoring and mobile monitoring to help you understand the dependencies from front-end user interfaces to back-end services. one.newrelic.com > Service Maps Use the service map view to drill into front-end dependencies, and execute a similar exercise to the one you executed for back-end dependencies. This exercise will again expose data to help you identify risk areas you should address and optimize. We recommend that you conduct the analysis with user interface (UI) teams so that you can also gather a complementary qualitative understanding of what the UI teams consider critical based on their experience. A ranking from the UI teams of the most critical dependency is a useful output of this work. 4. Identify Microservice Dependencies If you are using microservices, you can have dozens, if not hundreds, of services that are calling each other. Use Distributed Tracing to see how all those services connect together and how your requests flow through those different services. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. A distributed trace is composed of multiple \"spans,\" which represent time spent in services or resources of those services. Click on the Distributed tracing menu in New Relic APM left nav. You can see “trace listing” view where you’ll be able to quickly identify slow traces and traces with errors. The scatter plot lets you easily see outliers. Below that are the trace summaries, click on a trace to see details. Dive into distributed traces to see how long each span takes. Click into each span to see historical performance charts and associated attributes that layer in the context you need to understand and troubleshoot issues. one.newrelic.com > APM > (select an app) > Distributed tracing This rounds out your list of dependencies. 5. Create an action plan for risk mitigation Once you’ve analyzed the dependencies across your application from both front-end and back-end services, create an action plan to reduce dependency risks and achieve your service level objectives (SLO). As you prioritize these next steps, we recommend you keep these four principles in mind: Understand your risk tolerance. It’s helpful to have a clear picture of your tolerance for risk, which ideally should be informed by your service level objectives (refer to the Establish Objectives and Baselines tutorial for more information). Set an alert policy to monitor dependencies that you’ve determined have a high relationship to SLO achievement. Minimize dependencies. The simpler you keep your code, the less functions you'll have referring to other modules. Removing unnecessary complexity is an important way to ensure you have a maintainable system that meets your customers’ expectations. Localize dependencies. For the code you write, package together functions that depend on each other whenever possible. Stabilize dependencies. When dependencies are unavoidable, mitigate risks by ensuring these dependencies point to modules that are the least likely to change or are easier to substitute. When your action plan is complete, monitor the results of the efforts. The efficacy of your actions to resolve dependency risks should ultimately be measured by your SLOs",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 432.0456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " <em>DevOps</em> procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. <em>New</em> <em>Relic</em> recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com &gt; Service Maps"
      },
      "id": "60440f13e7b9d2ec025799f0"
    },
    {
      "sections": [
        "Set proactive alerting: understand and respond to performance issues",
        "Prerequisites",
        "1. Define required alerting policies based on Service Level Objectives",
        "2. Set specific alerts for performance, correctness, throughput, availability, and dependencies",
        "3. Identify groups to alert, and set broadcasting methods",
        "4. Leverage AI to fine-tune alerts and seek anomalies",
        "5. Create an alerts dashboard",
        "Conclusion",
        "For more help"
      ],
      "title": "Set proactive alerting: understand and respond to performance issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c8da73787dbeba3d1f2af43fbce84fb26e4d7852",
      "image": "https://docs.newrelic.com/static/49cfe6b2c2181499588c35b9720a1e4f/c1b63/new-relic-recent-anomalies-view.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues/",
      "published_at": "2021-07-09T15:47:11Z",
      "updated_at": "2021-07-09T15:47:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term \"alerting\" often carries some negative connotations; for too many developers, alerting correlates too closely with errors, mistakes, and ongoing issues. However, for developers who are proactive about alerting, they know they don’t have to stare at their dashboards all day, because effective alerts will tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Alerts can become overwhelming, so tune alerts and leverage AI so you get alerted on what matters. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, “95% of requests completed within 250 ms AND availability is 99.99%”), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it’s meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature DevOps customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic DevOps customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use Synthetic monitoring pings to determine if the site is up and scripted checks to determine that the most important capabilities (such as a checkout cart) are working. How's our underlying infrastructure? Set KPIs for key hardware, virtual hosts, containers, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site’s availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don’t yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we’ve set both a warning and a violation for throughput: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier -- this can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic approximately evenly across five different servers. You can set an alert based on a NRQL query, and notification to be sent if any server starts getting significantly more or less traffic than the other servers. Here’s the graph: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds And here’s a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups to alert, and set broadcasting methods Alerting without the proper broadcasting methods leaves you vulnerable. Your alerts strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the the types of alerts that warrant waking someone up. 4. Leverage AI to fine-tune alerts and seek anomalies To ensure you aren't training your teams to turn off or ignore notifications, keep your alerts valid and fresh. As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. To keep alerts to a minimum, leverage New Relic Applied Intelligence features, such as Incident Intelligence, which correlates related alerts into one actionable issue combining machine learning and manual input. Check to make sure alerts are correlated correctly and train your system to obtain the most accurate incident correlation. An additional way to reduce alert noise is by flapping detection and suppression. When an issue is \"flapping,\" it is cycling between an open and resolved state, creating a new alert every time it cycles. Effectively handling these can reduce the number of total alerts sent to your team. Finally, when you have maintenance scheduled, take advantage of alert muting rules to suppress those alerts you don't need. Now that you have tuned your alerts to valid notifications, you can proactively go after anomalies so you can fix issues before they become incidents. Enable Proactive Detection of anomalies and set some level of notification for them. 5. Create an alerts dashboard Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use NRQL to create your dashboards. For detailed instructions, check out Sending alerts data to Insights (Insights is no longer our querying interface but the same concepts apply). The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you’re using. For a more extensive discussion on notification channels, refer to the incident orchestration tutorial. Conclusion Establishing a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or infrastructure. With proactive alerting, you will decrease user-reported incidents, and allow your teams to spend less time firefighting and more time deploying significant changes to your product. For more help For more tips and best practices for alerting, see the following documentation: Tame application monitoring with dynamic targeting in New Relic Alerts Best practices for alert policies New Relic infrastructure monitoring best practices guide Infrastructure alerting examples",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.7431,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. <em>New</em> <em>Relic</em> often finds that our most mature <em>DevOps</em> customers set fewer alerts in general and focus those"
      },
      "id": "60445b8764441fe7fd378ee5"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-07-09T15:09:24Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.12228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Device</em> performance breakdown",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "In a <em>DevOps</em> world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With <em>New</em> <em>Relic</em> you can <em>measure</em> the <em>success</em> of your <em>DevOps</em> initiatives and learn how"
      },
      "id": "60440e5364441fb0c6378ef6"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/customer-experience-improvement-track-experience-indicators": [
    {
      "sections": [
        "Resolve dependency risk: identify and analyze potential issues",
        "Prerequisites",
        "1. Analyze dependencies with service maps",
        "2. Identify back-end application dependency risks",
        "Tip",
        "3. Identify front-end dependency risk",
        "4. Identify Microservice Dependencies",
        "5. Create an action plan for risk mitigation"
      ],
      "title": "Resolve dependency risk: identify and analyze potential issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "4911ddf0c6fca572b52e22fbe464f21f0c6f338f",
      "image": "https://docs.newrelic.com/static/d1d4cf78d193ae770219cfdb9f6f792f/c1b63/distributed-trace_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/resolve-dependency-risk-identify-analyze-potential-issues/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Successfully scaling DevOps requires a robust understanding of dependencies across application teams and related services. Use New Relics service maps to discover and mitigate risky dependencies from upstream and downstream services. Prerequisites This tutorial assumes you’ve completed the previous DevOps procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. New Relic recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com > Service Maps > App/Service list This initial view shows all applications that are configured in your account. Applications that have violated a warning threshold are shown in yellow, and those with an active alert are shown in red. Healthy applications appear in green. New Relic uses a bold line to map applications to the services (such as databases) they connect to. Familiarize yourself with these maps to see how applications and their services fit together. Take note of which applications have the most dependencies and which rely on the same dependency, such as an API. Click an application to see high level metrics about that app, including throughput, response time, Apdex score, and error rate for the last 30 minutes. Tracking throughput is a good way to determine which of your applications are serving the most traffic. After looking at the architecture as a whole, review the applications that have the most dependencies. Select the App/Services list to see a full list of your applications. one.newrelic.com > Service Maps > App/Service list In this example, we’ve chosen Tower-Chicago from the App/Services list. All of the traffic being sent to Tower-Chicago is coming from Proxy-East. In this case, Tower-Chicago is showing 48.3 requests per minute, or 11.3% of the 426 requests per minute flowing through Proxy-East. one.newrelic.com > Service Maps > App/Service list In most cases, the separate applications and services represented in service maps are created and maintained by separate teams. This exercise of walking through the dependencies of your architecture should involve representatives from each of those teams. Teams should work together to ask questions such as: How critical is this particular dependency? What would happen if it were to go down? What happened last time it went down? Was there a revenue loss? 2. Identify back-end application dependency risks Once you’ve analyzed your applications’ dependencies, you’ll want to examine the quality of dependency execution. For example, is the dependency stable and predictable for each application or transaction you’ve identified? To do this, you’ll first need to gather as much information as you can about the applications from New Relic Insights, which helps you analyze data that is collected about the applications in more detail. Here is an example NRQL query to further analyze back-end service performance: SELECT count(appName)/30 as 'Throughput', apdex(duration), average(duration), stddev(duration), max(duration), count(error_type), uniquecount(host) FROM Transaction FACET appName SINCE 30 MINUTES AGO Copy This query shows you each application’s request per minute (throughput), Apdex score, and an overview of how the application is performing overall (through the standard deviation calculation, in which lower numbers are generally better). It also shows errors for the time period and the number of hosts on which the application is running. insights.newrelic.com > query results Next, gather information on incidents and events related to the services from New Relic Alerts: Click Alerts > Incidents > All Incidents. alerts.newrelic.com > Incidents > All Incidents Click Alerts > Events > All Events. alerts.newrelic.com > Incidents > All Events Tip Using webhooks to send alert events to New Relic Insights, allows you to supplement your dashboards with Alerts data. The process is outlined in this community discussion post. Here is a simplified example of the results of this exercise: Application Number of dependencies RPM Hosts APDEX (avg) Last outage TTR (hrs) Routing Service 10 983 4 .93 2/19/18 .75 Tower Austin 1 58 1 .95 10/11/17 1.5 Proxy-East 11 498 4 .92 1/4/18 .25 Proxy-West 11 495 4 .97 12/3/17 .25 WebPortal 7 396 8 .98 4/1/18 2.5 Supplement this data with the data that your teams know about your service and that you gathered from the dependency exercise in step 1, and use that data to develop hypotheses about the highest risk areas in your services that should be mitigated. 3. Identify front-end dependency risk Once you’ve analyzed back-end dependencies, explore front-end dependencies. This is a critical step because as you walk higher up the stack and closer to the user, you will likely have more dependencies and abstractions. Service maps seamlessly integrate data from browser monitoring and mobile monitoring to help you understand the dependencies from front-end user interfaces to back-end services. one.newrelic.com > Service Maps Use the service map view to drill into front-end dependencies, and execute a similar exercise to the one you executed for back-end dependencies. This exercise will again expose data to help you identify risk areas you should address and optimize. We recommend that you conduct the analysis with user interface (UI) teams so that you can also gather a complementary qualitative understanding of what the UI teams consider critical based on their experience. A ranking from the UI teams of the most critical dependency is a useful output of this work. 4. Identify Microservice Dependencies If you are using microservices, you can have dozens, if not hundreds, of services that are calling each other. Use Distributed Tracing to see how all those services connect together and how your requests flow through those different services. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. A distributed trace is composed of multiple \"spans,\" which represent time spent in services or resources of those services. Click on the Distributed tracing menu in New Relic APM left nav. You can see “trace listing” view where you’ll be able to quickly identify slow traces and traces with errors. The scatter plot lets you easily see outliers. Below that are the trace summaries, click on a trace to see details. Dive into distributed traces to see how long each span takes. Click into each span to see historical performance charts and associated attributes that layer in the context you need to understand and troubleshoot issues. one.newrelic.com > APM > (select an app) > Distributed tracing This rounds out your list of dependencies. 5. Create an action plan for risk mitigation Once you’ve analyzed the dependencies across your application from both front-end and back-end services, create an action plan to reduce dependency risks and achieve your service level objectives (SLO). As you prioritize these next steps, we recommend you keep these four principles in mind: Understand your risk tolerance. It’s helpful to have a clear picture of your tolerance for risk, which ideally should be informed by your service level objectives (refer to the Establish Objectives and Baselines tutorial for more information). Set an alert policy to monitor dependencies that you’ve determined have a high relationship to SLO achievement. Minimize dependencies. The simpler you keep your code, the less functions you'll have referring to other modules. Removing unnecessary complexity is an important way to ensure you have a maintainable system that meets your customers’ expectations. Localize dependencies. For the code you write, package together functions that depend on each other whenever possible. Stabilize dependencies. When dependencies are unavoidable, mitigate risks by ensuring these dependencies point to modules that are the least likely to change or are easier to substitute. When your action plan is complete, monitor the results of the efforts. The efficacy of your actions to resolve dependency risks should ultimately be measured by your SLOs",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 432.0453,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " <em>DevOps</em> procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. <em>New</em> <em>Relic</em> recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com &gt; Service Maps"
      },
      "id": "60440f13e7b9d2ec025799f0"
    },
    {
      "sections": [
        "Set proactive alerting: understand and respond to performance issues",
        "Prerequisites",
        "1. Define required alerting policies based on Service Level Objectives",
        "2. Set specific alerts for performance, correctness, throughput, availability, and dependencies",
        "3. Identify groups to alert, and set broadcasting methods",
        "4. Leverage AI to fine-tune alerts and seek anomalies",
        "5. Create an alerts dashboard",
        "Conclusion",
        "For more help"
      ],
      "title": "Set proactive alerting: understand and respond to performance issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c8da73787dbeba3d1f2af43fbce84fb26e4d7852",
      "image": "https://docs.newrelic.com/static/49cfe6b2c2181499588c35b9720a1e4f/c1b63/new-relic-recent-anomalies-view.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues/",
      "published_at": "2021-07-09T15:47:11Z",
      "updated_at": "2021-07-09T15:47:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term \"alerting\" often carries some negative connotations; for too many developers, alerting correlates too closely with errors, mistakes, and ongoing issues. However, for developers who are proactive about alerting, they know they don’t have to stare at their dashboards all day, because effective alerts will tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Alerts can become overwhelming, so tune alerts and leverage AI so you get alerted on what matters. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, “95% of requests completed within 250 ms AND availability is 99.99%”), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it’s meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature DevOps customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic DevOps customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use Synthetic monitoring pings to determine if the site is up and scripted checks to determine that the most important capabilities (such as a checkout cart) are working. How's our underlying infrastructure? Set KPIs for key hardware, virtual hosts, containers, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site’s availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don’t yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we’ve set both a warning and a violation for throughput: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier -- this can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic approximately evenly across five different servers. You can set an alert based on a NRQL query, and notification to be sent if any server starts getting significantly more or less traffic than the other servers. Here’s the graph: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds And here’s a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups to alert, and set broadcasting methods Alerting without the proper broadcasting methods leaves you vulnerable. Your alerts strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the the types of alerts that warrant waking someone up. 4. Leverage AI to fine-tune alerts and seek anomalies To ensure you aren't training your teams to turn off or ignore notifications, keep your alerts valid and fresh. As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. To keep alerts to a minimum, leverage New Relic Applied Intelligence features, such as Incident Intelligence, which correlates related alerts into one actionable issue combining machine learning and manual input. Check to make sure alerts are correlated correctly and train your system to obtain the most accurate incident correlation. An additional way to reduce alert noise is by flapping detection and suppression. When an issue is \"flapping,\" it is cycling between an open and resolved state, creating a new alert every time it cycles. Effectively handling these can reduce the number of total alerts sent to your team. Finally, when you have maintenance scheduled, take advantage of alert muting rules to suppress those alerts you don't need. Now that you have tuned your alerts to valid notifications, you can proactively go after anomalies so you can fix issues before they become incidents. Enable Proactive Detection of anomalies and set some level of notification for them. 5. Create an alerts dashboard Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use NRQL to create your dashboards. For detailed instructions, check out Sending alerts data to Insights (Insights is no longer our querying interface but the same concepts apply). The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you’re using. For a more extensive discussion on notification channels, refer to the incident orchestration tutorial. Conclusion Establishing a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or infrastructure. With proactive alerting, you will decrease user-reported incidents, and allow your teams to spend less time firefighting and more time deploying significant changes to your product. For more help For more tips and best practices for alerting, see the following documentation: Tame application monitoring with dynamic targeting in New Relic Alerts Best practices for alert policies New Relic infrastructure monitoring best practices guide Infrastructure alerting examples",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.74286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. <em>New</em> <em>Relic</em> often finds that our most mature <em>DevOps</em> customers set fewer alerts in general and focus those"
      },
      "id": "60445b8764441fe7fd378ee5"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-07-09T15:09:24Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Device</em> performance breakdown",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "In a <em>DevOps</em> world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With <em>New</em> <em>Relic</em> you can <em>measure</em> the <em>success</em> of your <em>DevOps</em> initiatives and learn how"
      },
      "id": "60440e5364441fb0c6378ef6"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/establish-objectives-baselines-define-team-slos": [
    {
      "sections": [
        "Resolve dependency risk: identify and analyze potential issues",
        "Prerequisites",
        "1. Analyze dependencies with service maps",
        "2. Identify back-end application dependency risks",
        "Tip",
        "3. Identify front-end dependency risk",
        "4. Identify Microservice Dependencies",
        "5. Create an action plan for risk mitigation"
      ],
      "title": "Resolve dependency risk: identify and analyze potential issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "4911ddf0c6fca572b52e22fbe464f21f0c6f338f",
      "image": "https://docs.newrelic.com/static/d1d4cf78d193ae770219cfdb9f6f792f/c1b63/distributed-trace_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/resolve-dependency-risk-identify-analyze-potential-issues/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Successfully scaling DevOps requires a robust understanding of dependencies across application teams and related services. Use New Relics service maps to discover and mitigate risky dependencies from upstream and downstream services. Prerequisites This tutorial assumes you’ve completed the previous DevOps procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. New Relic recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com > Service Maps > App/Service list This initial view shows all applications that are configured in your account. Applications that have violated a warning threshold are shown in yellow, and those with an active alert are shown in red. Healthy applications appear in green. New Relic uses a bold line to map applications to the services (such as databases) they connect to. Familiarize yourself with these maps to see how applications and their services fit together. Take note of which applications have the most dependencies and which rely on the same dependency, such as an API. Click an application to see high level metrics about that app, including throughput, response time, Apdex score, and error rate for the last 30 minutes. Tracking throughput is a good way to determine which of your applications are serving the most traffic. After looking at the architecture as a whole, review the applications that have the most dependencies. Select the App/Services list to see a full list of your applications. one.newrelic.com > Service Maps > App/Service list In this example, we’ve chosen Tower-Chicago from the App/Services list. All of the traffic being sent to Tower-Chicago is coming from Proxy-East. In this case, Tower-Chicago is showing 48.3 requests per minute, or 11.3% of the 426 requests per minute flowing through Proxy-East. one.newrelic.com > Service Maps > App/Service list In most cases, the separate applications and services represented in service maps are created and maintained by separate teams. This exercise of walking through the dependencies of your architecture should involve representatives from each of those teams. Teams should work together to ask questions such as: How critical is this particular dependency? What would happen if it were to go down? What happened last time it went down? Was there a revenue loss? 2. Identify back-end application dependency risks Once you’ve analyzed your applications’ dependencies, you’ll want to examine the quality of dependency execution. For example, is the dependency stable and predictable for each application or transaction you’ve identified? To do this, you’ll first need to gather as much information as you can about the applications from New Relic Insights, which helps you analyze data that is collected about the applications in more detail. Here is an example NRQL query to further analyze back-end service performance: SELECT count(appName)/30 as 'Throughput', apdex(duration), average(duration), stddev(duration), max(duration), count(error_type), uniquecount(host) FROM Transaction FACET appName SINCE 30 MINUTES AGO Copy This query shows you each application’s request per minute (throughput), Apdex score, and an overview of how the application is performing overall (through the standard deviation calculation, in which lower numbers are generally better). It also shows errors for the time period and the number of hosts on which the application is running. insights.newrelic.com > query results Next, gather information on incidents and events related to the services from New Relic Alerts: Click Alerts > Incidents > All Incidents. alerts.newrelic.com > Incidents > All Incidents Click Alerts > Events > All Events. alerts.newrelic.com > Incidents > All Events Tip Using webhooks to send alert events to New Relic Insights, allows you to supplement your dashboards with Alerts data. The process is outlined in this community discussion post. Here is a simplified example of the results of this exercise: Application Number of dependencies RPM Hosts APDEX (avg) Last outage TTR (hrs) Routing Service 10 983 4 .93 2/19/18 .75 Tower Austin 1 58 1 .95 10/11/17 1.5 Proxy-East 11 498 4 .92 1/4/18 .25 Proxy-West 11 495 4 .97 12/3/17 .25 WebPortal 7 396 8 .98 4/1/18 2.5 Supplement this data with the data that your teams know about your service and that you gathered from the dependency exercise in step 1, and use that data to develop hypotheses about the highest risk areas in your services that should be mitigated. 3. Identify front-end dependency risk Once you’ve analyzed back-end dependencies, explore front-end dependencies. This is a critical step because as you walk higher up the stack and closer to the user, you will likely have more dependencies and abstractions. Service maps seamlessly integrate data from browser monitoring and mobile monitoring to help you understand the dependencies from front-end user interfaces to back-end services. one.newrelic.com > Service Maps Use the service map view to drill into front-end dependencies, and execute a similar exercise to the one you executed for back-end dependencies. This exercise will again expose data to help you identify risk areas you should address and optimize. We recommend that you conduct the analysis with user interface (UI) teams so that you can also gather a complementary qualitative understanding of what the UI teams consider critical based on their experience. A ranking from the UI teams of the most critical dependency is a useful output of this work. 4. Identify Microservice Dependencies If you are using microservices, you can have dozens, if not hundreds, of services that are calling each other. Use Distributed Tracing to see how all those services connect together and how your requests flow through those different services. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. A distributed trace is composed of multiple \"spans,\" which represent time spent in services or resources of those services. Click on the Distributed tracing menu in New Relic APM left nav. You can see “trace listing” view where you’ll be able to quickly identify slow traces and traces with errors. The scatter plot lets you easily see outliers. Below that are the trace summaries, click on a trace to see details. Dive into distributed traces to see how long each span takes. Click into each span to see historical performance charts and associated attributes that layer in the context you need to understand and troubleshoot issues. one.newrelic.com > APM > (select an app) > Distributed tracing This rounds out your list of dependencies. 5. Create an action plan for risk mitigation Once you’ve analyzed the dependencies across your application from both front-end and back-end services, create an action plan to reduce dependency risks and achieve your service level objectives (SLO). As you prioritize these next steps, we recommend you keep these four principles in mind: Understand your risk tolerance. It’s helpful to have a clear picture of your tolerance for risk, which ideally should be informed by your service level objectives (refer to the Establish Objectives and Baselines tutorial for more information). Set an alert policy to monitor dependencies that you’ve determined have a high relationship to SLO achievement. Minimize dependencies. The simpler you keep your code, the less functions you'll have referring to other modules. Removing unnecessary complexity is an important way to ensure you have a maintainable system that meets your customers’ expectations. Localize dependencies. For the code you write, package together functions that depend on each other whenever possible. Stabilize dependencies. When dependencies are unavoidable, mitigate risks by ensuring these dependencies point to modules that are the least likely to change or are easier to substitute. When your action plan is complete, monitor the results of the efforts. The efficacy of your actions to resolve dependency risks should ultimately be measured by your SLOs",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 432.0453,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " <em>DevOps</em> procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. <em>New</em> <em>Relic</em> recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com &gt; Service Maps"
      },
      "id": "60440f13e7b9d2ec025799f0"
    },
    {
      "sections": [
        "Set proactive alerting: understand and respond to performance issues",
        "Prerequisites",
        "1. Define required alerting policies based on Service Level Objectives",
        "2. Set specific alerts for performance, correctness, throughput, availability, and dependencies",
        "3. Identify groups to alert, and set broadcasting methods",
        "4. Leverage AI to fine-tune alerts and seek anomalies",
        "5. Create an alerts dashboard",
        "Conclusion",
        "For more help"
      ],
      "title": "Set proactive alerting: understand and respond to performance issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c8da73787dbeba3d1f2af43fbce84fb26e4d7852",
      "image": "https://docs.newrelic.com/static/49cfe6b2c2181499588c35b9720a1e4f/c1b63/new-relic-recent-anomalies-view.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues/",
      "published_at": "2021-07-09T15:47:11Z",
      "updated_at": "2021-07-09T15:47:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term \"alerting\" often carries some negative connotations; for too many developers, alerting correlates too closely with errors, mistakes, and ongoing issues. However, for developers who are proactive about alerting, they know they don’t have to stare at their dashboards all day, because effective alerts will tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Alerts can become overwhelming, so tune alerts and leverage AI so you get alerted on what matters. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, “95% of requests completed within 250 ms AND availability is 99.99%”), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it’s meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature DevOps customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic DevOps customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use Synthetic monitoring pings to determine if the site is up and scripted checks to determine that the most important capabilities (such as a checkout cart) are working. How's our underlying infrastructure? Set KPIs for key hardware, virtual hosts, containers, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site’s availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don’t yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we’ve set both a warning and a violation for throughput: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier -- this can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic approximately evenly across five different servers. You can set an alert based on a NRQL query, and notification to be sent if any server starts getting significantly more or less traffic than the other servers. Here’s the graph: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds And here’s a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups to alert, and set broadcasting methods Alerting without the proper broadcasting methods leaves you vulnerable. Your alerts strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the the types of alerts that warrant waking someone up. 4. Leverage AI to fine-tune alerts and seek anomalies To ensure you aren't training your teams to turn off or ignore notifications, keep your alerts valid and fresh. As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. To keep alerts to a minimum, leverage New Relic Applied Intelligence features, such as Incident Intelligence, which correlates related alerts into one actionable issue combining machine learning and manual input. Check to make sure alerts are correlated correctly and train your system to obtain the most accurate incident correlation. An additional way to reduce alert noise is by flapping detection and suppression. When an issue is \"flapping,\" it is cycling between an open and resolved state, creating a new alert every time it cycles. Effectively handling these can reduce the number of total alerts sent to your team. Finally, when you have maintenance scheduled, take advantage of alert muting rules to suppress those alerts you don't need. Now that you have tuned your alerts to valid notifications, you can proactively go after anomalies so you can fix issues before they become incidents. Enable Proactive Detection of anomalies and set some level of notification for them. 5. Create an alerts dashboard Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use NRQL to create your dashboards. For detailed instructions, check out Sending alerts data to Insights (Insights is no longer our querying interface but the same concepts apply). The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you’re using. For a more extensive discussion on notification channels, refer to the incident orchestration tutorial. Conclusion Establishing a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or infrastructure. With proactive alerting, you will decrease user-reported incidents, and allow your teams to spend less time firefighting and more time deploying significant changes to your product. For more help For more tips and best practices for alerting, see the following documentation: Tame application monitoring with dynamic targeting in New Relic Alerts Best practices for alert policies New Relic infrastructure monitoring best practices guide Infrastructure alerting examples",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.74286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. <em>New</em> <em>Relic</em> often finds that our most mature <em>DevOps</em> customers set fewer alerts in general and focus those"
      },
      "id": "60445b8764441fe7fd378ee5"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-07-09T15:09:24Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Device</em> performance breakdown",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "In a <em>DevOps</em> world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With <em>New</em> <em>Relic</em> you can <em>measure</em> the <em>success</em> of your <em>DevOps</em> initiatives and learn how"
      },
      "id": "60440e5364441fb0c6378ef6"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/establish-team-dashboards-gather-visualize-key-metrics": [
    {
      "sections": [
        "Resolve dependency risk: identify and analyze potential issues",
        "Prerequisites",
        "1. Analyze dependencies with service maps",
        "2. Identify back-end application dependency risks",
        "Tip",
        "3. Identify front-end dependency risk",
        "4. Identify Microservice Dependencies",
        "5. Create an action plan for risk mitigation"
      ],
      "title": "Resolve dependency risk: identify and analyze potential issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "4911ddf0c6fca572b52e22fbe464f21f0c6f338f",
      "image": "https://docs.newrelic.com/static/d1d4cf78d193ae770219cfdb9f6f792f/c1b63/distributed-trace_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/resolve-dependency-risk-identify-analyze-potential-issues/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Successfully scaling DevOps requires a robust understanding of dependencies across application teams and related services. Use New Relics service maps to discover and mitigate risky dependencies from upstream and downstream services. Prerequisites This tutorial assumes you’ve completed the previous DevOps procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. New Relic recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com > Service Maps > App/Service list This initial view shows all applications that are configured in your account. Applications that have violated a warning threshold are shown in yellow, and those with an active alert are shown in red. Healthy applications appear in green. New Relic uses a bold line to map applications to the services (such as databases) they connect to. Familiarize yourself with these maps to see how applications and their services fit together. Take note of which applications have the most dependencies and which rely on the same dependency, such as an API. Click an application to see high level metrics about that app, including throughput, response time, Apdex score, and error rate for the last 30 minutes. Tracking throughput is a good way to determine which of your applications are serving the most traffic. After looking at the architecture as a whole, review the applications that have the most dependencies. Select the App/Services list to see a full list of your applications. one.newrelic.com > Service Maps > App/Service list In this example, we’ve chosen Tower-Chicago from the App/Services list. All of the traffic being sent to Tower-Chicago is coming from Proxy-East. In this case, Tower-Chicago is showing 48.3 requests per minute, or 11.3% of the 426 requests per minute flowing through Proxy-East. one.newrelic.com > Service Maps > App/Service list In most cases, the separate applications and services represented in service maps are created and maintained by separate teams. This exercise of walking through the dependencies of your architecture should involve representatives from each of those teams. Teams should work together to ask questions such as: How critical is this particular dependency? What would happen if it were to go down? What happened last time it went down? Was there a revenue loss? 2. Identify back-end application dependency risks Once you’ve analyzed your applications’ dependencies, you’ll want to examine the quality of dependency execution. For example, is the dependency stable and predictable for each application or transaction you’ve identified? To do this, you’ll first need to gather as much information as you can about the applications from New Relic Insights, which helps you analyze data that is collected about the applications in more detail. Here is an example NRQL query to further analyze back-end service performance: SELECT count(appName)/30 as 'Throughput', apdex(duration), average(duration), stddev(duration), max(duration), count(error_type), uniquecount(host) FROM Transaction FACET appName SINCE 30 MINUTES AGO Copy This query shows you each application’s request per minute (throughput), Apdex score, and an overview of how the application is performing overall (through the standard deviation calculation, in which lower numbers are generally better). It also shows errors for the time period and the number of hosts on which the application is running. insights.newrelic.com > query results Next, gather information on incidents and events related to the services from New Relic Alerts: Click Alerts > Incidents > All Incidents. alerts.newrelic.com > Incidents > All Incidents Click Alerts > Events > All Events. alerts.newrelic.com > Incidents > All Events Tip Using webhooks to send alert events to New Relic Insights, allows you to supplement your dashboards with Alerts data. The process is outlined in this community discussion post. Here is a simplified example of the results of this exercise: Application Number of dependencies RPM Hosts APDEX (avg) Last outage TTR (hrs) Routing Service 10 983 4 .93 2/19/18 .75 Tower Austin 1 58 1 .95 10/11/17 1.5 Proxy-East 11 498 4 .92 1/4/18 .25 Proxy-West 11 495 4 .97 12/3/17 .25 WebPortal 7 396 8 .98 4/1/18 2.5 Supplement this data with the data that your teams know about your service and that you gathered from the dependency exercise in step 1, and use that data to develop hypotheses about the highest risk areas in your services that should be mitigated. 3. Identify front-end dependency risk Once you’ve analyzed back-end dependencies, explore front-end dependencies. This is a critical step because as you walk higher up the stack and closer to the user, you will likely have more dependencies and abstractions. Service maps seamlessly integrate data from browser monitoring and mobile monitoring to help you understand the dependencies from front-end user interfaces to back-end services. one.newrelic.com > Service Maps Use the service map view to drill into front-end dependencies, and execute a similar exercise to the one you executed for back-end dependencies. This exercise will again expose data to help you identify risk areas you should address and optimize. We recommend that you conduct the analysis with user interface (UI) teams so that you can also gather a complementary qualitative understanding of what the UI teams consider critical based on their experience. A ranking from the UI teams of the most critical dependency is a useful output of this work. 4. Identify Microservice Dependencies If you are using microservices, you can have dozens, if not hundreds, of services that are calling each other. Use Distributed Tracing to see how all those services connect together and how your requests flow through those different services. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. A distributed trace is composed of multiple \"spans,\" which represent time spent in services or resources of those services. Click on the Distributed tracing menu in New Relic APM left nav. You can see “trace listing” view where you’ll be able to quickly identify slow traces and traces with errors. The scatter plot lets you easily see outliers. Below that are the trace summaries, click on a trace to see details. Dive into distributed traces to see how long each span takes. Click into each span to see historical performance charts and associated attributes that layer in the context you need to understand and troubleshoot issues. one.newrelic.com > APM > (select an app) > Distributed tracing This rounds out your list of dependencies. 5. Create an action plan for risk mitigation Once you’ve analyzed the dependencies across your application from both front-end and back-end services, create an action plan to reduce dependency risks and achieve your service level objectives (SLO). As you prioritize these next steps, we recommend you keep these four principles in mind: Understand your risk tolerance. It’s helpful to have a clear picture of your tolerance for risk, which ideally should be informed by your service level objectives (refer to the Establish Objectives and Baselines tutorial for more information). Set an alert policy to monitor dependencies that you’ve determined have a high relationship to SLO achievement. Minimize dependencies. The simpler you keep your code, the less functions you'll have referring to other modules. Removing unnecessary complexity is an important way to ensure you have a maintainable system that meets your customers’ expectations. Localize dependencies. For the code you write, package together functions that depend on each other whenever possible. Stabilize dependencies. When dependencies are unavoidable, mitigate risks by ensuring these dependencies point to modules that are the least likely to change or are easier to substitute. When your action plan is complete, monitor the results of the efforts. The efficacy of your actions to resolve dependency risks should ultimately be measured by your SLOs",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 432.04504,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " <em>DevOps</em> procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. <em>New</em> <em>Relic</em> recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com &gt; Service Maps"
      },
      "id": "60440f13e7b9d2ec025799f0"
    },
    {
      "sections": [
        "Set proactive alerting: understand and respond to performance issues",
        "Prerequisites",
        "1. Define required alerting policies based on Service Level Objectives",
        "2. Set specific alerts for performance, correctness, throughput, availability, and dependencies",
        "3. Identify groups to alert, and set broadcasting methods",
        "4. Leverage AI to fine-tune alerts and seek anomalies",
        "5. Create an alerts dashboard",
        "Conclusion",
        "For more help"
      ],
      "title": "Set proactive alerting: understand and respond to performance issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c8da73787dbeba3d1f2af43fbce84fb26e4d7852",
      "image": "https://docs.newrelic.com/static/49cfe6b2c2181499588c35b9720a1e4f/c1b63/new-relic-recent-anomalies-view.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues/",
      "published_at": "2021-07-09T15:47:11Z",
      "updated_at": "2021-07-09T15:47:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term \"alerting\" often carries some negative connotations; for too many developers, alerting correlates too closely with errors, mistakes, and ongoing issues. However, for developers who are proactive about alerting, they know they don’t have to stare at their dashboards all day, because effective alerts will tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Alerts can become overwhelming, so tune alerts and leverage AI so you get alerted on what matters. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, “95% of requests completed within 250 ms AND availability is 99.99%”), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it’s meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature DevOps customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic DevOps customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use Synthetic monitoring pings to determine if the site is up and scripted checks to determine that the most important capabilities (such as a checkout cart) are working. How's our underlying infrastructure? Set KPIs for key hardware, virtual hosts, containers, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site’s availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don’t yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we’ve set both a warning and a violation for throughput: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier -- this can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic approximately evenly across five different servers. You can set an alert based on a NRQL query, and notification to be sent if any server starts getting significantly more or less traffic than the other servers. Here’s the graph: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds And here’s a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups to alert, and set broadcasting methods Alerting without the proper broadcasting methods leaves you vulnerable. Your alerts strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the the types of alerts that warrant waking someone up. 4. Leverage AI to fine-tune alerts and seek anomalies To ensure you aren't training your teams to turn off or ignore notifications, keep your alerts valid and fresh. As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. To keep alerts to a minimum, leverage New Relic Applied Intelligence features, such as Incident Intelligence, which correlates related alerts into one actionable issue combining machine learning and manual input. Check to make sure alerts are correlated correctly and train your system to obtain the most accurate incident correlation. An additional way to reduce alert noise is by flapping detection and suppression. When an issue is \"flapping,\" it is cycling between an open and resolved state, creating a new alert every time it cycles. Effectively handling these can reduce the number of total alerts sent to your team. Finally, when you have maintenance scheduled, take advantage of alert muting rules to suppress those alerts you don't need. Now that you have tuned your alerts to valid notifications, you can proactively go after anomalies so you can fix issues before they become incidents. Enable Proactive Detection of anomalies and set some level of notification for them. 5. Create an alerts dashboard Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use NRQL to create your dashboards. For detailed instructions, check out Sending alerts data to Insights (Insights is no longer our querying interface but the same concepts apply). The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you’re using. For a more extensive discussion on notification channels, refer to the incident orchestration tutorial. Conclusion Establishing a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or infrastructure. With proactive alerting, you will decrease user-reported incidents, and allow your teams to spend less time firefighting and more time deploying significant changes to your product. For more help For more tips and best practices for alerting, see the following documentation: Tame application monitoring with dynamic targeting in New Relic Alerts Best practices for alert policies New Relic infrastructure monitoring best practices guide Infrastructure alerting examples",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.74255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. <em>New</em> <em>Relic</em> often finds that our most mature <em>DevOps</em> customers set fewer alerts in general and focus those"
      },
      "id": "60445b8764441fe7fd378ee5"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-07-09T15:09:24Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.12173,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Device</em> performance breakdown",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "In a <em>DevOps</em> world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With <em>New</em> <em>Relic</em> you can <em>measure</em> the <em>success</em> of your <em>DevOps</em> initiatives and learn how"
      },
      "id": "60440e5364441fb0c6378ef6"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/guide-measuring-devops-success": [
    {
      "sections": [
        "Resolve dependency risk: identify and analyze potential issues",
        "Prerequisites",
        "1. Analyze dependencies with service maps",
        "2. Identify back-end application dependency risks",
        "Tip",
        "3. Identify front-end dependency risk",
        "4. Identify Microservice Dependencies",
        "5. Create an action plan for risk mitigation"
      ],
      "title": "Resolve dependency risk: identify and analyze potential issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "4911ddf0c6fca572b52e22fbe464f21f0c6f338f",
      "image": "https://docs.newrelic.com/static/d1d4cf78d193ae770219cfdb9f6f792f/c1b63/distributed-trace_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/resolve-dependency-risk-identify-analyze-potential-issues/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Successfully scaling DevOps requires a robust understanding of dependencies across application teams and related services. Use New Relics service maps to discover and mitigate risky dependencies from upstream and downstream services. Prerequisites This tutorial assumes you’ve completed the previous DevOps procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. New Relic recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com > Service Maps > App/Service list This initial view shows all applications that are configured in your account. Applications that have violated a warning threshold are shown in yellow, and those with an active alert are shown in red. Healthy applications appear in green. New Relic uses a bold line to map applications to the services (such as databases) they connect to. Familiarize yourself with these maps to see how applications and their services fit together. Take note of which applications have the most dependencies and which rely on the same dependency, such as an API. Click an application to see high level metrics about that app, including throughput, response time, Apdex score, and error rate for the last 30 minutes. Tracking throughput is a good way to determine which of your applications are serving the most traffic. After looking at the architecture as a whole, review the applications that have the most dependencies. Select the App/Services list to see a full list of your applications. one.newrelic.com > Service Maps > App/Service list In this example, we’ve chosen Tower-Chicago from the App/Services list. All of the traffic being sent to Tower-Chicago is coming from Proxy-East. In this case, Tower-Chicago is showing 48.3 requests per minute, or 11.3% of the 426 requests per minute flowing through Proxy-East. one.newrelic.com > Service Maps > App/Service list In most cases, the separate applications and services represented in service maps are created and maintained by separate teams. This exercise of walking through the dependencies of your architecture should involve representatives from each of those teams. Teams should work together to ask questions such as: How critical is this particular dependency? What would happen if it were to go down? What happened last time it went down? Was there a revenue loss? 2. Identify back-end application dependency risks Once you’ve analyzed your applications’ dependencies, you’ll want to examine the quality of dependency execution. For example, is the dependency stable and predictable for each application or transaction you’ve identified? To do this, you’ll first need to gather as much information as you can about the applications from New Relic Insights, which helps you analyze data that is collected about the applications in more detail. Here is an example NRQL query to further analyze back-end service performance: SELECT count(appName)/30 as 'Throughput', apdex(duration), average(duration), stddev(duration), max(duration), count(error_type), uniquecount(host) FROM Transaction FACET appName SINCE 30 MINUTES AGO Copy This query shows you each application’s request per minute (throughput), Apdex score, and an overview of how the application is performing overall (through the standard deviation calculation, in which lower numbers are generally better). It also shows errors for the time period and the number of hosts on which the application is running. insights.newrelic.com > query results Next, gather information on incidents and events related to the services from New Relic Alerts: Click Alerts > Incidents > All Incidents. alerts.newrelic.com > Incidents > All Incidents Click Alerts > Events > All Events. alerts.newrelic.com > Incidents > All Events Tip Using webhooks to send alert events to New Relic Insights, allows you to supplement your dashboards with Alerts data. The process is outlined in this community discussion post. Here is a simplified example of the results of this exercise: Application Number of dependencies RPM Hosts APDEX (avg) Last outage TTR (hrs) Routing Service 10 983 4 .93 2/19/18 .75 Tower Austin 1 58 1 .95 10/11/17 1.5 Proxy-East 11 498 4 .92 1/4/18 .25 Proxy-West 11 495 4 .97 12/3/17 .25 WebPortal 7 396 8 .98 4/1/18 2.5 Supplement this data with the data that your teams know about your service and that you gathered from the dependency exercise in step 1, and use that data to develop hypotheses about the highest risk areas in your services that should be mitigated. 3. Identify front-end dependency risk Once you’ve analyzed back-end dependencies, explore front-end dependencies. This is a critical step because as you walk higher up the stack and closer to the user, you will likely have more dependencies and abstractions. Service maps seamlessly integrate data from browser monitoring and mobile monitoring to help you understand the dependencies from front-end user interfaces to back-end services. one.newrelic.com > Service Maps Use the service map view to drill into front-end dependencies, and execute a similar exercise to the one you executed for back-end dependencies. This exercise will again expose data to help you identify risk areas you should address and optimize. We recommend that you conduct the analysis with user interface (UI) teams so that you can also gather a complementary qualitative understanding of what the UI teams consider critical based on their experience. A ranking from the UI teams of the most critical dependency is a useful output of this work. 4. Identify Microservice Dependencies If you are using microservices, you can have dozens, if not hundreds, of services that are calling each other. Use Distributed Tracing to see how all those services connect together and how your requests flow through those different services. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. A distributed trace is composed of multiple \"spans,\" which represent time spent in services or resources of those services. Click on the Distributed tracing menu in New Relic APM left nav. You can see “trace listing” view where you’ll be able to quickly identify slow traces and traces with errors. The scatter plot lets you easily see outliers. Below that are the trace summaries, click on a trace to see details. Dive into distributed traces to see how long each span takes. Click into each span to see historical performance charts and associated attributes that layer in the context you need to understand and troubleshoot issues. one.newrelic.com > APM > (select an app) > Distributed tracing This rounds out your list of dependencies. 5. Create an action plan for risk mitigation Once you’ve analyzed the dependencies across your application from both front-end and back-end services, create an action plan to reduce dependency risks and achieve your service level objectives (SLO). As you prioritize these next steps, we recommend you keep these four principles in mind: Understand your risk tolerance. It’s helpful to have a clear picture of your tolerance for risk, which ideally should be informed by your service level objectives (refer to the Establish Objectives and Baselines tutorial for more information). Set an alert policy to monitor dependencies that you’ve determined have a high relationship to SLO achievement. Minimize dependencies. The simpler you keep your code, the less functions you'll have referring to other modules. Removing unnecessary complexity is an important way to ensure you have a maintainable system that meets your customers’ expectations. Localize dependencies. For the code you write, package together functions that depend on each other whenever possible. Stabilize dependencies. When dependencies are unavoidable, mitigate risks by ensuring these dependencies point to modules that are the least likely to change or are easier to substitute. When your action plan is complete, monitor the results of the efforts. The efficacy of your actions to resolve dependency risks should ultimately be measured by your SLOs",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 432.04504,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " <em>DevOps</em> procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. <em>New</em> <em>Relic</em> recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com &gt; Service Maps"
      },
      "id": "60440f13e7b9d2ec025799f0"
    },
    {
      "sections": [
        "Set proactive alerting: understand and respond to performance issues",
        "Prerequisites",
        "1. Define required alerting policies based on Service Level Objectives",
        "2. Set specific alerts for performance, correctness, throughput, availability, and dependencies",
        "3. Identify groups to alert, and set broadcasting methods",
        "4. Leverage AI to fine-tune alerts and seek anomalies",
        "5. Create an alerts dashboard",
        "Conclusion",
        "For more help"
      ],
      "title": "Set proactive alerting: understand and respond to performance issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c8da73787dbeba3d1f2af43fbce84fb26e4d7852",
      "image": "https://docs.newrelic.com/static/49cfe6b2c2181499588c35b9720a1e4f/c1b63/new-relic-recent-anomalies-view.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues/",
      "published_at": "2021-07-09T15:47:11Z",
      "updated_at": "2021-07-09T15:47:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term \"alerting\" often carries some negative connotations; for too many developers, alerting correlates too closely with errors, mistakes, and ongoing issues. However, for developers who are proactive about alerting, they know they don’t have to stare at their dashboards all day, because effective alerts will tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Alerts can become overwhelming, so tune alerts and leverage AI so you get alerted on what matters. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, “95% of requests completed within 250 ms AND availability is 99.99%”), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it’s meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature DevOps customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic DevOps customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use Synthetic monitoring pings to determine if the site is up and scripted checks to determine that the most important capabilities (such as a checkout cart) are working. How's our underlying infrastructure? Set KPIs for key hardware, virtual hosts, containers, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site’s availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don’t yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we’ve set both a warning and a violation for throughput: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier -- this can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic approximately evenly across five different servers. You can set an alert based on a NRQL query, and notification to be sent if any server starts getting significantly more or less traffic than the other servers. Here’s the graph: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds And here’s a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups to alert, and set broadcasting methods Alerting without the proper broadcasting methods leaves you vulnerable. Your alerts strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the the types of alerts that warrant waking someone up. 4. Leverage AI to fine-tune alerts and seek anomalies To ensure you aren't training your teams to turn off or ignore notifications, keep your alerts valid and fresh. As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. To keep alerts to a minimum, leverage New Relic Applied Intelligence features, such as Incident Intelligence, which correlates related alerts into one actionable issue combining machine learning and manual input. Check to make sure alerts are correlated correctly and train your system to obtain the most accurate incident correlation. An additional way to reduce alert noise is by flapping detection and suppression. When an issue is \"flapping,\" it is cycling between an open and resolved state, creating a new alert every time it cycles. Effectively handling these can reduce the number of total alerts sent to your team. Finally, when you have maintenance scheduled, take advantage of alert muting rules to suppress those alerts you don't need. Now that you have tuned your alerts to valid notifications, you can proactively go after anomalies so you can fix issues before they become incidents. Enable Proactive Detection of anomalies and set some level of notification for them. 5. Create an alerts dashboard Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use NRQL to create your dashboards. For detailed instructions, check out Sending alerts data to Insights (Insights is no longer our querying interface but the same concepts apply). The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you’re using. For a more extensive discussion on notification channels, refer to the incident orchestration tutorial. Conclusion Establishing a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or infrastructure. With proactive alerting, you will decrease user-reported incidents, and allow your teams to spend less time firefighting and more time deploying significant changes to your product. For more help For more tips and best practices for alerting, see the following documentation: Tame application monitoring with dynamic targeting in New Relic Alerts Best practices for alert policies New Relic infrastructure monitoring best practices guide Infrastructure alerting examples",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.74255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. <em>New</em> <em>Relic</em> often finds that our most mature <em>DevOps</em> customers set fewer alerts in general and focus those"
      },
      "id": "60445b8764441fe7fd378ee5"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-07-09T15:09:24Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.12173,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Device</em> performance breakdown",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "In a <em>DevOps</em> world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With <em>New</em> <em>Relic</em> you can <em>measure</em> the <em>success</em> of your <em>DevOps</em> initiatives and learn how"
      },
      "id": "60440e5364441fb0c6378ef6"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/incident-learning-retrospectives": [
    {
      "sections": [
        "Resolve dependency risk: identify and analyze potential issues",
        "Prerequisites",
        "1. Analyze dependencies with service maps",
        "2. Identify back-end application dependency risks",
        "Tip",
        "3. Identify front-end dependency risk",
        "4. Identify Microservice Dependencies",
        "5. Create an action plan for risk mitigation"
      ],
      "title": "Resolve dependency risk: identify and analyze potential issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "4911ddf0c6fca572b52e22fbe464f21f0c6f338f",
      "image": "https://docs.newrelic.com/static/d1d4cf78d193ae770219cfdb9f6f792f/c1b63/distributed-trace_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/resolve-dependency-risk-identify-analyze-potential-issues/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Successfully scaling DevOps requires a robust understanding of dependencies across application teams and related services. Use New Relics service maps to discover and mitigate risky dependencies from upstream and downstream services. Prerequisites This tutorial assumes you’ve completed the previous DevOps procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. New Relic recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com > Service Maps > App/Service list This initial view shows all applications that are configured in your account. Applications that have violated a warning threshold are shown in yellow, and those with an active alert are shown in red. Healthy applications appear in green. New Relic uses a bold line to map applications to the services (such as databases) they connect to. Familiarize yourself with these maps to see how applications and their services fit together. Take note of which applications have the most dependencies and which rely on the same dependency, such as an API. Click an application to see high level metrics about that app, including throughput, response time, Apdex score, and error rate for the last 30 minutes. Tracking throughput is a good way to determine which of your applications are serving the most traffic. After looking at the architecture as a whole, review the applications that have the most dependencies. Select the App/Services list to see a full list of your applications. one.newrelic.com > Service Maps > App/Service list In this example, we’ve chosen Tower-Chicago from the App/Services list. All of the traffic being sent to Tower-Chicago is coming from Proxy-East. In this case, Tower-Chicago is showing 48.3 requests per minute, or 11.3% of the 426 requests per minute flowing through Proxy-East. one.newrelic.com > Service Maps > App/Service list In most cases, the separate applications and services represented in service maps are created and maintained by separate teams. This exercise of walking through the dependencies of your architecture should involve representatives from each of those teams. Teams should work together to ask questions such as: How critical is this particular dependency? What would happen if it were to go down? What happened last time it went down? Was there a revenue loss? 2. Identify back-end application dependency risks Once you’ve analyzed your applications’ dependencies, you’ll want to examine the quality of dependency execution. For example, is the dependency stable and predictable for each application or transaction you’ve identified? To do this, you’ll first need to gather as much information as you can about the applications from New Relic Insights, which helps you analyze data that is collected about the applications in more detail. Here is an example NRQL query to further analyze back-end service performance: SELECT count(appName)/30 as 'Throughput', apdex(duration), average(duration), stddev(duration), max(duration), count(error_type), uniquecount(host) FROM Transaction FACET appName SINCE 30 MINUTES AGO Copy This query shows you each application’s request per minute (throughput), Apdex score, and an overview of how the application is performing overall (through the standard deviation calculation, in which lower numbers are generally better). It also shows errors for the time period and the number of hosts on which the application is running. insights.newrelic.com > query results Next, gather information on incidents and events related to the services from New Relic Alerts: Click Alerts > Incidents > All Incidents. alerts.newrelic.com > Incidents > All Incidents Click Alerts > Events > All Events. alerts.newrelic.com > Incidents > All Events Tip Using webhooks to send alert events to New Relic Insights, allows you to supplement your dashboards with Alerts data. The process is outlined in this community discussion post. Here is a simplified example of the results of this exercise: Application Number of dependencies RPM Hosts APDEX (avg) Last outage TTR (hrs) Routing Service 10 983 4 .93 2/19/18 .75 Tower Austin 1 58 1 .95 10/11/17 1.5 Proxy-East 11 498 4 .92 1/4/18 .25 Proxy-West 11 495 4 .97 12/3/17 .25 WebPortal 7 396 8 .98 4/1/18 2.5 Supplement this data with the data that your teams know about your service and that you gathered from the dependency exercise in step 1, and use that data to develop hypotheses about the highest risk areas in your services that should be mitigated. 3. Identify front-end dependency risk Once you’ve analyzed back-end dependencies, explore front-end dependencies. This is a critical step because as you walk higher up the stack and closer to the user, you will likely have more dependencies and abstractions. Service maps seamlessly integrate data from browser monitoring and mobile monitoring to help you understand the dependencies from front-end user interfaces to back-end services. one.newrelic.com > Service Maps Use the service map view to drill into front-end dependencies, and execute a similar exercise to the one you executed for back-end dependencies. This exercise will again expose data to help you identify risk areas you should address and optimize. We recommend that you conduct the analysis with user interface (UI) teams so that you can also gather a complementary qualitative understanding of what the UI teams consider critical based on their experience. A ranking from the UI teams of the most critical dependency is a useful output of this work. 4. Identify Microservice Dependencies If you are using microservices, you can have dozens, if not hundreds, of services that are calling each other. Use Distributed Tracing to see how all those services connect together and how your requests flow through those different services. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. A distributed trace is composed of multiple \"spans,\" which represent time spent in services or resources of those services. Click on the Distributed tracing menu in New Relic APM left nav. You can see “trace listing” view where you’ll be able to quickly identify slow traces and traces with errors. The scatter plot lets you easily see outliers. Below that are the trace summaries, click on a trace to see details. Dive into distributed traces to see how long each span takes. Click into each span to see historical performance charts and associated attributes that layer in the context you need to understand and troubleshoot issues. one.newrelic.com > APM > (select an app) > Distributed tracing This rounds out your list of dependencies. 5. Create an action plan for risk mitigation Once you’ve analyzed the dependencies across your application from both front-end and back-end services, create an action plan to reduce dependency risks and achieve your service level objectives (SLO). As you prioritize these next steps, we recommend you keep these four principles in mind: Understand your risk tolerance. It’s helpful to have a clear picture of your tolerance for risk, which ideally should be informed by your service level objectives (refer to the Establish Objectives and Baselines tutorial for more information). Set an alert policy to monitor dependencies that you’ve determined have a high relationship to SLO achievement. Minimize dependencies. The simpler you keep your code, the less functions you'll have referring to other modules. Removing unnecessary complexity is an important way to ensure you have a maintainable system that meets your customers’ expectations. Localize dependencies. For the code you write, package together functions that depend on each other whenever possible. Stabilize dependencies. When dependencies are unavoidable, mitigate risks by ensuring these dependencies point to modules that are the least likely to change or are easier to substitute. When your action plan is complete, monitor the results of the efforts. The efficacy of your actions to resolve dependency risks should ultimately be measured by your SLOs",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 432.04474,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " <em>DevOps</em> procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. <em>New</em> <em>Relic</em> recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com &gt; Service Maps"
      },
      "id": "60440f13e7b9d2ec025799f0"
    },
    {
      "sections": [
        "Set proactive alerting: understand and respond to performance issues",
        "Prerequisites",
        "1. Define required alerting policies based on Service Level Objectives",
        "2. Set specific alerts for performance, correctness, throughput, availability, and dependencies",
        "3. Identify groups to alert, and set broadcasting methods",
        "4. Leverage AI to fine-tune alerts and seek anomalies",
        "5. Create an alerts dashboard",
        "Conclusion",
        "For more help"
      ],
      "title": "Set proactive alerting: understand and respond to performance issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c8da73787dbeba3d1f2af43fbce84fb26e4d7852",
      "image": "https://docs.newrelic.com/static/49cfe6b2c2181499588c35b9720a1e4f/c1b63/new-relic-recent-anomalies-view.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues/",
      "published_at": "2021-07-09T15:47:11Z",
      "updated_at": "2021-07-09T15:47:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term \"alerting\" often carries some negative connotations; for too many developers, alerting correlates too closely with errors, mistakes, and ongoing issues. However, for developers who are proactive about alerting, they know they don’t have to stare at their dashboards all day, because effective alerts will tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Alerts can become overwhelming, so tune alerts and leverage AI so you get alerted on what matters. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, “95% of requests completed within 250 ms AND availability is 99.99%”), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it’s meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature DevOps customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic DevOps customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use Synthetic monitoring pings to determine if the site is up and scripted checks to determine that the most important capabilities (such as a checkout cart) are working. How's our underlying infrastructure? Set KPIs for key hardware, virtual hosts, containers, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site’s availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don’t yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we’ve set both a warning and a violation for throughput: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier -- this can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic approximately evenly across five different servers. You can set an alert based on a NRQL query, and notification to be sent if any server starts getting significantly more or less traffic than the other servers. Here’s the graph: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds And here’s a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups to alert, and set broadcasting methods Alerting without the proper broadcasting methods leaves you vulnerable. Your alerts strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the the types of alerts that warrant waking someone up. 4. Leverage AI to fine-tune alerts and seek anomalies To ensure you aren't training your teams to turn off or ignore notifications, keep your alerts valid and fresh. As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. To keep alerts to a minimum, leverage New Relic Applied Intelligence features, such as Incident Intelligence, which correlates related alerts into one actionable issue combining machine learning and manual input. Check to make sure alerts are correlated correctly and train your system to obtain the most accurate incident correlation. An additional way to reduce alert noise is by flapping detection and suppression. When an issue is \"flapping,\" it is cycling between an open and resolved state, creating a new alert every time it cycles. Effectively handling these can reduce the number of total alerts sent to your team. Finally, when you have maintenance scheduled, take advantage of alert muting rules to suppress those alerts you don't need. Now that you have tuned your alerts to valid notifications, you can proactively go after anomalies so you can fix issues before they become incidents. Enable Proactive Detection of anomalies and set some level of notification for them. 5. Create an alerts dashboard Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use NRQL to create your dashboards. For detailed instructions, check out Sending alerts data to Insights (Insights is no longer our querying interface but the same concepts apply). The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you’re using. For a more extensive discussion on notification channels, refer to the incident orchestration tutorial. Conclusion Establishing a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or infrastructure. With proactive alerting, you will decrease user-reported incidents, and allow your teams to spend less time firefighting and more time deploying significant changes to your product. For more help For more tips and best practices for alerting, see the following documentation: Tame application monitoring with dynamic targeting in New Relic Alerts Best practices for alert policies New Relic infrastructure monitoring best practices guide Infrastructure alerting examples",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.7423,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. <em>New</em> <em>Relic</em> often finds that our most mature <em>DevOps</em> customers set fewer alerts in general and focus those"
      },
      "id": "60445b8764441fe7fd378ee5"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-07-09T15:09:24Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.12146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Device</em> performance breakdown",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "In a <em>DevOps</em> world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With <em>New</em> <em>Relic</em> you can <em>measure</em> the <em>success</em> of your <em>DevOps</em> initiatives and learn how"
      },
      "id": "60440e5364441fb0c6378ef6"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/incident-orchestration-align-teams-tools-processes": [
    {
      "sections": [
        "Resolve dependency risk: identify and analyze potential issues",
        "Prerequisites",
        "1. Analyze dependencies with service maps",
        "2. Identify back-end application dependency risks",
        "Tip",
        "3. Identify front-end dependency risk",
        "4. Identify Microservice Dependencies",
        "5. Create an action plan for risk mitigation"
      ],
      "title": "Resolve dependency risk: identify and analyze potential issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "4911ddf0c6fca572b52e22fbe464f21f0c6f338f",
      "image": "https://docs.newrelic.com/static/d1d4cf78d193ae770219cfdb9f6f792f/c1b63/distributed-trace_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/resolve-dependency-risk-identify-analyze-potential-issues/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Successfully scaling DevOps requires a robust understanding of dependencies across application teams and related services. Use New Relics service maps to discover and mitigate risky dependencies from upstream and downstream services. Prerequisites This tutorial assumes you’ve completed the previous DevOps procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. New Relic recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com > Service Maps > App/Service list This initial view shows all applications that are configured in your account. Applications that have violated a warning threshold are shown in yellow, and those with an active alert are shown in red. Healthy applications appear in green. New Relic uses a bold line to map applications to the services (such as databases) they connect to. Familiarize yourself with these maps to see how applications and their services fit together. Take note of which applications have the most dependencies and which rely on the same dependency, such as an API. Click an application to see high level metrics about that app, including throughput, response time, Apdex score, and error rate for the last 30 minutes. Tracking throughput is a good way to determine which of your applications are serving the most traffic. After looking at the architecture as a whole, review the applications that have the most dependencies. Select the App/Services list to see a full list of your applications. one.newrelic.com > Service Maps > App/Service list In this example, we’ve chosen Tower-Chicago from the App/Services list. All of the traffic being sent to Tower-Chicago is coming from Proxy-East. In this case, Tower-Chicago is showing 48.3 requests per minute, or 11.3% of the 426 requests per minute flowing through Proxy-East. one.newrelic.com > Service Maps > App/Service list In most cases, the separate applications and services represented in service maps are created and maintained by separate teams. This exercise of walking through the dependencies of your architecture should involve representatives from each of those teams. Teams should work together to ask questions such as: How critical is this particular dependency? What would happen if it were to go down? What happened last time it went down? Was there a revenue loss? 2. Identify back-end application dependency risks Once you’ve analyzed your applications’ dependencies, you’ll want to examine the quality of dependency execution. For example, is the dependency stable and predictable for each application or transaction you’ve identified? To do this, you’ll first need to gather as much information as you can about the applications from New Relic Insights, which helps you analyze data that is collected about the applications in more detail. Here is an example NRQL query to further analyze back-end service performance: SELECT count(appName)/30 as 'Throughput', apdex(duration), average(duration), stddev(duration), max(duration), count(error_type), uniquecount(host) FROM Transaction FACET appName SINCE 30 MINUTES AGO Copy This query shows you each application’s request per minute (throughput), Apdex score, and an overview of how the application is performing overall (through the standard deviation calculation, in which lower numbers are generally better). It also shows errors for the time period and the number of hosts on which the application is running. insights.newrelic.com > query results Next, gather information on incidents and events related to the services from New Relic Alerts: Click Alerts > Incidents > All Incidents. alerts.newrelic.com > Incidents > All Incidents Click Alerts > Events > All Events. alerts.newrelic.com > Incidents > All Events Tip Using webhooks to send alert events to New Relic Insights, allows you to supplement your dashboards with Alerts data. The process is outlined in this community discussion post. Here is a simplified example of the results of this exercise: Application Number of dependencies RPM Hosts APDEX (avg) Last outage TTR (hrs) Routing Service 10 983 4 .93 2/19/18 .75 Tower Austin 1 58 1 .95 10/11/17 1.5 Proxy-East 11 498 4 .92 1/4/18 .25 Proxy-West 11 495 4 .97 12/3/17 .25 WebPortal 7 396 8 .98 4/1/18 2.5 Supplement this data with the data that your teams know about your service and that you gathered from the dependency exercise in step 1, and use that data to develop hypotheses about the highest risk areas in your services that should be mitigated. 3. Identify front-end dependency risk Once you’ve analyzed back-end dependencies, explore front-end dependencies. This is a critical step because as you walk higher up the stack and closer to the user, you will likely have more dependencies and abstractions. Service maps seamlessly integrate data from browser monitoring and mobile monitoring to help you understand the dependencies from front-end user interfaces to back-end services. one.newrelic.com > Service Maps Use the service map view to drill into front-end dependencies, and execute a similar exercise to the one you executed for back-end dependencies. This exercise will again expose data to help you identify risk areas you should address and optimize. We recommend that you conduct the analysis with user interface (UI) teams so that you can also gather a complementary qualitative understanding of what the UI teams consider critical based on their experience. A ranking from the UI teams of the most critical dependency is a useful output of this work. 4. Identify Microservice Dependencies If you are using microservices, you can have dozens, if not hundreds, of services that are calling each other. Use Distributed Tracing to see how all those services connect together and how your requests flow through those different services. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. A distributed trace is composed of multiple \"spans,\" which represent time spent in services or resources of those services. Click on the Distributed tracing menu in New Relic APM left nav. You can see “trace listing” view where you’ll be able to quickly identify slow traces and traces with errors. The scatter plot lets you easily see outliers. Below that are the trace summaries, click on a trace to see details. Dive into distributed traces to see how long each span takes. Click into each span to see historical performance charts and associated attributes that layer in the context you need to understand and troubleshoot issues. one.newrelic.com > APM > (select an app) > Distributed tracing This rounds out your list of dependencies. 5. Create an action plan for risk mitigation Once you’ve analyzed the dependencies across your application from both front-end and back-end services, create an action plan to reduce dependency risks and achieve your service level objectives (SLO). As you prioritize these next steps, we recommend you keep these four principles in mind: Understand your risk tolerance. It’s helpful to have a clear picture of your tolerance for risk, which ideally should be informed by your service level objectives (refer to the Establish Objectives and Baselines tutorial for more information). Set an alert policy to monitor dependencies that you’ve determined have a high relationship to SLO achievement. Minimize dependencies. The simpler you keep your code, the less functions you'll have referring to other modules. Removing unnecessary complexity is an important way to ensure you have a maintainable system that meets your customers’ expectations. Localize dependencies. For the code you write, package together functions that depend on each other whenever possible. Stabilize dependencies. When dependencies are unavoidable, mitigate risks by ensuring these dependencies point to modules that are the least likely to change or are easier to substitute. When your action plan is complete, monitor the results of the efforts. The efficacy of your actions to resolve dependency risks should ultimately be measured by your SLOs",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 432.04474,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " <em>DevOps</em> procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. <em>New</em> <em>Relic</em> recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com &gt; Service Maps"
      },
      "id": "60440f13e7b9d2ec025799f0"
    },
    {
      "sections": [
        "Set proactive alerting: understand and respond to performance issues",
        "Prerequisites",
        "1. Define required alerting policies based on Service Level Objectives",
        "2. Set specific alerts for performance, correctness, throughput, availability, and dependencies",
        "3. Identify groups to alert, and set broadcasting methods",
        "4. Leverage AI to fine-tune alerts and seek anomalies",
        "5. Create an alerts dashboard",
        "Conclusion",
        "For more help"
      ],
      "title": "Set proactive alerting: understand and respond to performance issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c8da73787dbeba3d1f2af43fbce84fb26e4d7852",
      "image": "https://docs.newrelic.com/static/49cfe6b2c2181499588c35b9720a1e4f/c1b63/new-relic-recent-anomalies-view.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues/",
      "published_at": "2021-07-09T15:47:11Z",
      "updated_at": "2021-07-09T15:47:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term \"alerting\" often carries some negative connotations; for too many developers, alerting correlates too closely with errors, mistakes, and ongoing issues. However, for developers who are proactive about alerting, they know they don’t have to stare at their dashboards all day, because effective alerts will tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Alerts can become overwhelming, so tune alerts and leverage AI so you get alerted on what matters. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, “95% of requests completed within 250 ms AND availability is 99.99%”), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it’s meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature DevOps customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic DevOps customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use Synthetic monitoring pings to determine if the site is up and scripted checks to determine that the most important capabilities (such as a checkout cart) are working. How's our underlying infrastructure? Set KPIs for key hardware, virtual hosts, containers, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site’s availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don’t yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we’ve set both a warning and a violation for throughput: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier -- this can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic approximately evenly across five different servers. You can set an alert based on a NRQL query, and notification to be sent if any server starts getting significantly more or less traffic than the other servers. Here’s the graph: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds And here’s a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups to alert, and set broadcasting methods Alerting without the proper broadcasting methods leaves you vulnerable. Your alerts strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the the types of alerts that warrant waking someone up. 4. Leverage AI to fine-tune alerts and seek anomalies To ensure you aren't training your teams to turn off or ignore notifications, keep your alerts valid and fresh. As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. To keep alerts to a minimum, leverage New Relic Applied Intelligence features, such as Incident Intelligence, which correlates related alerts into one actionable issue combining machine learning and manual input. Check to make sure alerts are correlated correctly and train your system to obtain the most accurate incident correlation. An additional way to reduce alert noise is by flapping detection and suppression. When an issue is \"flapping,\" it is cycling between an open and resolved state, creating a new alert every time it cycles. Effectively handling these can reduce the number of total alerts sent to your team. Finally, when you have maintenance scheduled, take advantage of alert muting rules to suppress those alerts you don't need. Now that you have tuned your alerts to valid notifications, you can proactively go after anomalies so you can fix issues before they become incidents. Enable Proactive Detection of anomalies and set some level of notification for them. 5. Create an alerts dashboard Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use NRQL to create your dashboards. For detailed instructions, check out Sending alerts data to Insights (Insights is no longer our querying interface but the same concepts apply). The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you’re using. For a more extensive discussion on notification channels, refer to the incident orchestration tutorial. Conclusion Establishing a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or infrastructure. With proactive alerting, you will decrease user-reported incidents, and allow your teams to spend less time firefighting and more time deploying significant changes to your product. For more help For more tips and best practices for alerting, see the following documentation: Tame application monitoring with dynamic targeting in New Relic Alerts Best practices for alert policies New Relic infrastructure monitoring best practices guide Infrastructure alerting examples",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.7423,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. <em>New</em> <em>Relic</em> often finds that our most mature <em>DevOps</em> customers set fewer alerts in general and focus those"
      },
      "id": "60445b8764441fe7fd378ee5"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-07-09T15:09:24Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.12146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Device</em> performance breakdown",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "In a <em>DevOps</em> world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With <em>New</em> <em>Relic</em> you can <em>measure</em> the <em>success</em> of your <em>DevOps</em> initiatives and learn how"
      },
      "id": "60440e5364441fb0c6378ef6"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/infrastructure-resource-sizing-analyze-operation-metrics": [
    {
      "sections": [
        "Resolve dependency risk: identify and analyze potential issues",
        "Prerequisites",
        "1. Analyze dependencies with service maps",
        "2. Identify back-end application dependency risks",
        "Tip",
        "3. Identify front-end dependency risk",
        "4. Identify Microservice Dependencies",
        "5. Create an action plan for risk mitigation"
      ],
      "title": "Resolve dependency risk: identify and analyze potential issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "4911ddf0c6fca572b52e22fbe464f21f0c6f338f",
      "image": "https://docs.newrelic.com/static/d1d4cf78d193ae770219cfdb9f6f792f/c1b63/distributed-trace_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/resolve-dependency-risk-identify-analyze-potential-issues/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Successfully scaling DevOps requires a robust understanding of dependencies across application teams and related services. Use New Relics service maps to discover and mitigate risky dependencies from upstream and downstream services. Prerequisites This tutorial assumes you’ve completed the previous DevOps procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. New Relic recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com > Service Maps > App/Service list This initial view shows all applications that are configured in your account. Applications that have violated a warning threshold are shown in yellow, and those with an active alert are shown in red. Healthy applications appear in green. New Relic uses a bold line to map applications to the services (such as databases) they connect to. Familiarize yourself with these maps to see how applications and their services fit together. Take note of which applications have the most dependencies and which rely on the same dependency, such as an API. Click an application to see high level metrics about that app, including throughput, response time, Apdex score, and error rate for the last 30 minutes. Tracking throughput is a good way to determine which of your applications are serving the most traffic. After looking at the architecture as a whole, review the applications that have the most dependencies. Select the App/Services list to see a full list of your applications. one.newrelic.com > Service Maps > App/Service list In this example, we’ve chosen Tower-Chicago from the App/Services list. All of the traffic being sent to Tower-Chicago is coming from Proxy-East. In this case, Tower-Chicago is showing 48.3 requests per minute, or 11.3% of the 426 requests per minute flowing through Proxy-East. one.newrelic.com > Service Maps > App/Service list In most cases, the separate applications and services represented in service maps are created and maintained by separate teams. This exercise of walking through the dependencies of your architecture should involve representatives from each of those teams. Teams should work together to ask questions such as: How critical is this particular dependency? What would happen if it were to go down? What happened last time it went down? Was there a revenue loss? 2. Identify back-end application dependency risks Once you’ve analyzed your applications’ dependencies, you’ll want to examine the quality of dependency execution. For example, is the dependency stable and predictable for each application or transaction you’ve identified? To do this, you’ll first need to gather as much information as you can about the applications from New Relic Insights, which helps you analyze data that is collected about the applications in more detail. Here is an example NRQL query to further analyze back-end service performance: SELECT count(appName)/30 as 'Throughput', apdex(duration), average(duration), stddev(duration), max(duration), count(error_type), uniquecount(host) FROM Transaction FACET appName SINCE 30 MINUTES AGO Copy This query shows you each application’s request per minute (throughput), Apdex score, and an overview of how the application is performing overall (through the standard deviation calculation, in which lower numbers are generally better). It also shows errors for the time period and the number of hosts on which the application is running. insights.newrelic.com > query results Next, gather information on incidents and events related to the services from New Relic Alerts: Click Alerts > Incidents > All Incidents. alerts.newrelic.com > Incidents > All Incidents Click Alerts > Events > All Events. alerts.newrelic.com > Incidents > All Events Tip Using webhooks to send alert events to New Relic Insights, allows you to supplement your dashboards with Alerts data. The process is outlined in this community discussion post. Here is a simplified example of the results of this exercise: Application Number of dependencies RPM Hosts APDEX (avg) Last outage TTR (hrs) Routing Service 10 983 4 .93 2/19/18 .75 Tower Austin 1 58 1 .95 10/11/17 1.5 Proxy-East 11 498 4 .92 1/4/18 .25 Proxy-West 11 495 4 .97 12/3/17 .25 WebPortal 7 396 8 .98 4/1/18 2.5 Supplement this data with the data that your teams know about your service and that you gathered from the dependency exercise in step 1, and use that data to develop hypotheses about the highest risk areas in your services that should be mitigated. 3. Identify front-end dependency risk Once you’ve analyzed back-end dependencies, explore front-end dependencies. This is a critical step because as you walk higher up the stack and closer to the user, you will likely have more dependencies and abstractions. Service maps seamlessly integrate data from browser monitoring and mobile monitoring to help you understand the dependencies from front-end user interfaces to back-end services. one.newrelic.com > Service Maps Use the service map view to drill into front-end dependencies, and execute a similar exercise to the one you executed for back-end dependencies. This exercise will again expose data to help you identify risk areas you should address and optimize. We recommend that you conduct the analysis with user interface (UI) teams so that you can also gather a complementary qualitative understanding of what the UI teams consider critical based on their experience. A ranking from the UI teams of the most critical dependency is a useful output of this work. 4. Identify Microservice Dependencies If you are using microservices, you can have dozens, if not hundreds, of services that are calling each other. Use Distributed Tracing to see how all those services connect together and how your requests flow through those different services. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. A distributed trace is composed of multiple \"spans,\" which represent time spent in services or resources of those services. Click on the Distributed tracing menu in New Relic APM left nav. You can see “trace listing” view where you’ll be able to quickly identify slow traces and traces with errors. The scatter plot lets you easily see outliers. Below that are the trace summaries, click on a trace to see details. Dive into distributed traces to see how long each span takes. Click into each span to see historical performance charts and associated attributes that layer in the context you need to understand and troubleshoot issues. one.newrelic.com > APM > (select an app) > Distributed tracing This rounds out your list of dependencies. 5. Create an action plan for risk mitigation Once you’ve analyzed the dependencies across your application from both front-end and back-end services, create an action plan to reduce dependency risks and achieve your service level objectives (SLO). As you prioritize these next steps, we recommend you keep these four principles in mind: Understand your risk tolerance. It’s helpful to have a clear picture of your tolerance for risk, which ideally should be informed by your service level objectives (refer to the Establish Objectives and Baselines tutorial for more information). Set an alert policy to monitor dependencies that you’ve determined have a high relationship to SLO achievement. Minimize dependencies. The simpler you keep your code, the less functions you'll have referring to other modules. Removing unnecessary complexity is an important way to ensure you have a maintainable system that meets your customers’ expectations. Localize dependencies. For the code you write, package together functions that depend on each other whenever possible. Stabilize dependencies. When dependencies are unavoidable, mitigate risks by ensuring these dependencies point to modules that are the least likely to change or are easier to substitute. When your action plan is complete, monitor the results of the efforts. The efficacy of your actions to resolve dependency risks should ultimately be measured by your SLOs",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 432.04446,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " <em>DevOps</em> procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. <em>New</em> <em>Relic</em> recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com &gt; Service Maps"
      },
      "id": "60440f13e7b9d2ec025799f0"
    },
    {
      "sections": [
        "Set proactive alerting: understand and respond to performance issues",
        "Prerequisites",
        "1. Define required alerting policies based on Service Level Objectives",
        "2. Set specific alerts for performance, correctness, throughput, availability, and dependencies",
        "3. Identify groups to alert, and set broadcasting methods",
        "4. Leverage AI to fine-tune alerts and seek anomalies",
        "5. Create an alerts dashboard",
        "Conclusion",
        "For more help"
      ],
      "title": "Set proactive alerting: understand and respond to performance issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c8da73787dbeba3d1f2af43fbce84fb26e4d7852",
      "image": "https://docs.newrelic.com/static/49cfe6b2c2181499588c35b9720a1e4f/c1b63/new-relic-recent-anomalies-view.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues/",
      "published_at": "2021-07-09T15:47:11Z",
      "updated_at": "2021-07-09T15:47:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term \"alerting\" often carries some negative connotations; for too many developers, alerting correlates too closely with errors, mistakes, and ongoing issues. However, for developers who are proactive about alerting, they know they don’t have to stare at their dashboards all day, because effective alerts will tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Alerts can become overwhelming, so tune alerts and leverage AI so you get alerted on what matters. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, “95% of requests completed within 250 ms AND availability is 99.99%”), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it’s meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature DevOps customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic DevOps customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use Synthetic monitoring pings to determine if the site is up and scripted checks to determine that the most important capabilities (such as a checkout cart) are working. How's our underlying infrastructure? Set KPIs for key hardware, virtual hosts, containers, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site’s availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don’t yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we’ve set both a warning and a violation for throughput: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier -- this can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic approximately evenly across five different servers. You can set an alert based on a NRQL query, and notification to be sent if any server starts getting significantly more or less traffic than the other servers. Here’s the graph: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds And here’s a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups to alert, and set broadcasting methods Alerting without the proper broadcasting methods leaves you vulnerable. Your alerts strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the the types of alerts that warrant waking someone up. 4. Leverage AI to fine-tune alerts and seek anomalies To ensure you aren't training your teams to turn off or ignore notifications, keep your alerts valid and fresh. As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. To keep alerts to a minimum, leverage New Relic Applied Intelligence features, such as Incident Intelligence, which correlates related alerts into one actionable issue combining machine learning and manual input. Check to make sure alerts are correlated correctly and train your system to obtain the most accurate incident correlation. An additional way to reduce alert noise is by flapping detection and suppression. When an issue is \"flapping,\" it is cycling between an open and resolved state, creating a new alert every time it cycles. Effectively handling these can reduce the number of total alerts sent to your team. Finally, when you have maintenance scheduled, take advantage of alert muting rules to suppress those alerts you don't need. Now that you have tuned your alerts to valid notifications, you can proactively go after anomalies so you can fix issues before they become incidents. Enable Proactive Detection of anomalies and set some level of notification for them. 5. Create an alerts dashboard Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use NRQL to create your dashboards. For detailed instructions, check out Sending alerts data to Insights (Insights is no longer our querying interface but the same concepts apply). The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you’re using. For a more extensive discussion on notification channels, refer to the incident orchestration tutorial. Conclusion Establishing a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or infrastructure. With proactive alerting, you will decrease user-reported incidents, and allow your teams to spend less time firefighting and more time deploying significant changes to your product. For more help For more tips and best practices for alerting, see the following documentation: Tame application monitoring with dynamic targeting in New Relic Alerts Best practices for alert policies New Relic infrastructure monitoring best practices guide Infrastructure alerting examples",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.742,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. <em>New</em> <em>Relic</em> often finds that our most mature <em>DevOps</em> customers set fewer alerts in general and focus those"
      },
      "id": "60445b8764441fe7fd378ee5"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-07-09T15:09:24Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.1212,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Device</em> performance breakdown",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "In a <em>DevOps</em> world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With <em>New</em> <em>Relic</em> you can <em>measure</em> the <em>success</em> of your <em>DevOps</em> initiatives and learn how"
      },
      "id": "60440e5364441fb0c6378ef6"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/iterate-measure-impact-track-metrics-after-deployments": [
    {
      "sections": [
        "Resolve dependency risk: identify and analyze potential issues",
        "Prerequisites",
        "1. Analyze dependencies with service maps",
        "2. Identify back-end application dependency risks",
        "Tip",
        "3. Identify front-end dependency risk",
        "4. Identify Microservice Dependencies",
        "5. Create an action plan for risk mitigation"
      ],
      "title": "Resolve dependency risk: identify and analyze potential issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "4911ddf0c6fca572b52e22fbe464f21f0c6f338f",
      "image": "https://docs.newrelic.com/static/d1d4cf78d193ae770219cfdb9f6f792f/c1b63/distributed-trace_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/resolve-dependency-risk-identify-analyze-potential-issues/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Successfully scaling DevOps requires a robust understanding of dependencies across application teams and related services. Use New Relics service maps to discover and mitigate risky dependencies from upstream and downstream services. Prerequisites This tutorial assumes you’ve completed the previous DevOps procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. New Relic recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com > Service Maps > App/Service list This initial view shows all applications that are configured in your account. Applications that have violated a warning threshold are shown in yellow, and those with an active alert are shown in red. Healthy applications appear in green. New Relic uses a bold line to map applications to the services (such as databases) they connect to. Familiarize yourself with these maps to see how applications and their services fit together. Take note of which applications have the most dependencies and which rely on the same dependency, such as an API. Click an application to see high level metrics about that app, including throughput, response time, Apdex score, and error rate for the last 30 minutes. Tracking throughput is a good way to determine which of your applications are serving the most traffic. After looking at the architecture as a whole, review the applications that have the most dependencies. Select the App/Services list to see a full list of your applications. one.newrelic.com > Service Maps > App/Service list In this example, we’ve chosen Tower-Chicago from the App/Services list. All of the traffic being sent to Tower-Chicago is coming from Proxy-East. In this case, Tower-Chicago is showing 48.3 requests per minute, or 11.3% of the 426 requests per minute flowing through Proxy-East. one.newrelic.com > Service Maps > App/Service list In most cases, the separate applications and services represented in service maps are created and maintained by separate teams. This exercise of walking through the dependencies of your architecture should involve representatives from each of those teams. Teams should work together to ask questions such as: How critical is this particular dependency? What would happen if it were to go down? What happened last time it went down? Was there a revenue loss? 2. Identify back-end application dependency risks Once you’ve analyzed your applications’ dependencies, you’ll want to examine the quality of dependency execution. For example, is the dependency stable and predictable for each application or transaction you’ve identified? To do this, you’ll first need to gather as much information as you can about the applications from New Relic Insights, which helps you analyze data that is collected about the applications in more detail. Here is an example NRQL query to further analyze back-end service performance: SELECT count(appName)/30 as 'Throughput', apdex(duration), average(duration), stddev(duration), max(duration), count(error_type), uniquecount(host) FROM Transaction FACET appName SINCE 30 MINUTES AGO Copy This query shows you each application’s request per minute (throughput), Apdex score, and an overview of how the application is performing overall (through the standard deviation calculation, in which lower numbers are generally better). It also shows errors for the time period and the number of hosts on which the application is running. insights.newrelic.com > query results Next, gather information on incidents and events related to the services from New Relic Alerts: Click Alerts > Incidents > All Incidents. alerts.newrelic.com > Incidents > All Incidents Click Alerts > Events > All Events. alerts.newrelic.com > Incidents > All Events Tip Using webhooks to send alert events to New Relic Insights, allows you to supplement your dashboards with Alerts data. The process is outlined in this community discussion post. Here is a simplified example of the results of this exercise: Application Number of dependencies RPM Hosts APDEX (avg) Last outage TTR (hrs) Routing Service 10 983 4 .93 2/19/18 .75 Tower Austin 1 58 1 .95 10/11/17 1.5 Proxy-East 11 498 4 .92 1/4/18 .25 Proxy-West 11 495 4 .97 12/3/17 .25 WebPortal 7 396 8 .98 4/1/18 2.5 Supplement this data with the data that your teams know about your service and that you gathered from the dependency exercise in step 1, and use that data to develop hypotheses about the highest risk areas in your services that should be mitigated. 3. Identify front-end dependency risk Once you’ve analyzed back-end dependencies, explore front-end dependencies. This is a critical step because as you walk higher up the stack and closer to the user, you will likely have more dependencies and abstractions. Service maps seamlessly integrate data from browser monitoring and mobile monitoring to help you understand the dependencies from front-end user interfaces to back-end services. one.newrelic.com > Service Maps Use the service map view to drill into front-end dependencies, and execute a similar exercise to the one you executed for back-end dependencies. This exercise will again expose data to help you identify risk areas you should address and optimize. We recommend that you conduct the analysis with user interface (UI) teams so that you can also gather a complementary qualitative understanding of what the UI teams consider critical based on their experience. A ranking from the UI teams of the most critical dependency is a useful output of this work. 4. Identify Microservice Dependencies If you are using microservices, you can have dozens, if not hundreds, of services that are calling each other. Use Distributed Tracing to see how all those services connect together and how your requests flow through those different services. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. A distributed trace is composed of multiple \"spans,\" which represent time spent in services or resources of those services. Click on the Distributed tracing menu in New Relic APM left nav. You can see “trace listing” view where you’ll be able to quickly identify slow traces and traces with errors. The scatter plot lets you easily see outliers. Below that are the trace summaries, click on a trace to see details. Dive into distributed traces to see how long each span takes. Click into each span to see historical performance charts and associated attributes that layer in the context you need to understand and troubleshoot issues. one.newrelic.com > APM > (select an app) > Distributed tracing This rounds out your list of dependencies. 5. Create an action plan for risk mitigation Once you’ve analyzed the dependencies across your application from both front-end and back-end services, create an action plan to reduce dependency risks and achieve your service level objectives (SLO). As you prioritize these next steps, we recommend you keep these four principles in mind: Understand your risk tolerance. It’s helpful to have a clear picture of your tolerance for risk, which ideally should be informed by your service level objectives (refer to the Establish Objectives and Baselines tutorial for more information). Set an alert policy to monitor dependencies that you’ve determined have a high relationship to SLO achievement. Minimize dependencies. The simpler you keep your code, the less functions you'll have referring to other modules. Removing unnecessary complexity is an important way to ensure you have a maintainable system that meets your customers’ expectations. Localize dependencies. For the code you write, package together functions that depend on each other whenever possible. Stabilize dependencies. When dependencies are unavoidable, mitigate risks by ensuring these dependencies point to modules that are the least likely to change or are easier to substitute. When your action plan is complete, monitor the results of the efforts. The efficacy of your actions to resolve dependency risks should ultimately be measured by your SLOs",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 432.04446,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " <em>DevOps</em> procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. <em>New</em> <em>Relic</em> recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com &gt; Service Maps"
      },
      "id": "60440f13e7b9d2ec025799f0"
    },
    {
      "sections": [
        "Set proactive alerting: understand and respond to performance issues",
        "Prerequisites",
        "1. Define required alerting policies based on Service Level Objectives",
        "2. Set specific alerts for performance, correctness, throughput, availability, and dependencies",
        "3. Identify groups to alert, and set broadcasting methods",
        "4. Leverage AI to fine-tune alerts and seek anomalies",
        "5. Create an alerts dashboard",
        "Conclusion",
        "For more help"
      ],
      "title": "Set proactive alerting: understand and respond to performance issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c8da73787dbeba3d1f2af43fbce84fb26e4d7852",
      "image": "https://docs.newrelic.com/static/49cfe6b2c2181499588c35b9720a1e4f/c1b63/new-relic-recent-anomalies-view.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues/",
      "published_at": "2021-07-09T15:47:11Z",
      "updated_at": "2021-07-09T15:47:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term \"alerting\" often carries some negative connotations; for too many developers, alerting correlates too closely with errors, mistakes, and ongoing issues. However, for developers who are proactive about alerting, they know they don’t have to stare at their dashboards all day, because effective alerts will tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Alerts can become overwhelming, so tune alerts and leverage AI so you get alerted on what matters. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, “95% of requests completed within 250 ms AND availability is 99.99%”), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it’s meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature DevOps customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic DevOps customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use Synthetic monitoring pings to determine if the site is up and scripted checks to determine that the most important capabilities (such as a checkout cart) are working. How's our underlying infrastructure? Set KPIs for key hardware, virtual hosts, containers, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site’s availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don’t yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we’ve set both a warning and a violation for throughput: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier -- this can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic approximately evenly across five different servers. You can set an alert based on a NRQL query, and notification to be sent if any server starts getting significantly more or less traffic than the other servers. Here’s the graph: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds And here’s a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups to alert, and set broadcasting methods Alerting without the proper broadcasting methods leaves you vulnerable. Your alerts strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the the types of alerts that warrant waking someone up. 4. Leverage AI to fine-tune alerts and seek anomalies To ensure you aren't training your teams to turn off or ignore notifications, keep your alerts valid and fresh. As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. To keep alerts to a minimum, leverage New Relic Applied Intelligence features, such as Incident Intelligence, which correlates related alerts into one actionable issue combining machine learning and manual input. Check to make sure alerts are correlated correctly and train your system to obtain the most accurate incident correlation. An additional way to reduce alert noise is by flapping detection and suppression. When an issue is \"flapping,\" it is cycling between an open and resolved state, creating a new alert every time it cycles. Effectively handling these can reduce the number of total alerts sent to your team. Finally, when you have maintenance scheduled, take advantage of alert muting rules to suppress those alerts you don't need. Now that you have tuned your alerts to valid notifications, you can proactively go after anomalies so you can fix issues before they become incidents. Enable Proactive Detection of anomalies and set some level of notification for them. 5. Create an alerts dashboard Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use NRQL to create your dashboards. For detailed instructions, check out Sending alerts data to Insights (Insights is no longer our querying interface but the same concepts apply). The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you’re using. For a more extensive discussion on notification channels, refer to the incident orchestration tutorial. Conclusion Establishing a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or infrastructure. With proactive alerting, you will decrease user-reported incidents, and allow your teams to spend less time firefighting and more time deploying significant changes to your product. For more help For more tips and best practices for alerting, see the following documentation: Tame application monitoring with dynamic targeting in New Relic Alerts Best practices for alert policies New Relic infrastructure monitoring best practices guide Infrastructure alerting examples",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.742,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. <em>New</em> <em>Relic</em> often finds that our most mature <em>DevOps</em> customers set fewer alerts in general and focus those"
      },
      "id": "60445b8764441fe7fd378ee5"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-07-09T15:09:24Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.1212,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Device</em> performance breakdown",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "In a <em>DevOps</em> world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With <em>New</em> <em>Relic</em> you can <em>measure</em> the <em>success</em> of your <em>DevOps</em> initiatives and learn how"
      },
      "id": "60440e5364441fb0c6378ef6"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/measure-code-pipelines": [
    {
      "sections": [
        "Resolve dependency risk: identify and analyze potential issues",
        "Prerequisites",
        "1. Analyze dependencies with service maps",
        "2. Identify back-end application dependency risks",
        "Tip",
        "3. Identify front-end dependency risk",
        "4. Identify Microservice Dependencies",
        "5. Create an action plan for risk mitigation"
      ],
      "title": "Resolve dependency risk: identify and analyze potential issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "4911ddf0c6fca572b52e22fbe464f21f0c6f338f",
      "image": "https://docs.newrelic.com/static/d1d4cf78d193ae770219cfdb9f6f792f/c1b63/distributed-trace_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/resolve-dependency-risk-identify-analyze-potential-issues/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Successfully scaling DevOps requires a robust understanding of dependencies across application teams and related services. Use New Relics service maps to discover and mitigate risky dependencies from upstream and downstream services. Prerequisites This tutorial assumes you’ve completed the previous DevOps procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. New Relic recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com > Service Maps > App/Service list This initial view shows all applications that are configured in your account. Applications that have violated a warning threshold are shown in yellow, and those with an active alert are shown in red. Healthy applications appear in green. New Relic uses a bold line to map applications to the services (such as databases) they connect to. Familiarize yourself with these maps to see how applications and their services fit together. Take note of which applications have the most dependencies and which rely on the same dependency, such as an API. Click an application to see high level metrics about that app, including throughput, response time, Apdex score, and error rate for the last 30 minutes. Tracking throughput is a good way to determine which of your applications are serving the most traffic. After looking at the architecture as a whole, review the applications that have the most dependencies. Select the App/Services list to see a full list of your applications. one.newrelic.com > Service Maps > App/Service list In this example, we’ve chosen Tower-Chicago from the App/Services list. All of the traffic being sent to Tower-Chicago is coming from Proxy-East. In this case, Tower-Chicago is showing 48.3 requests per minute, or 11.3% of the 426 requests per minute flowing through Proxy-East. one.newrelic.com > Service Maps > App/Service list In most cases, the separate applications and services represented in service maps are created and maintained by separate teams. This exercise of walking through the dependencies of your architecture should involve representatives from each of those teams. Teams should work together to ask questions such as: How critical is this particular dependency? What would happen if it were to go down? What happened last time it went down? Was there a revenue loss? 2. Identify back-end application dependency risks Once you’ve analyzed your applications’ dependencies, you’ll want to examine the quality of dependency execution. For example, is the dependency stable and predictable for each application or transaction you’ve identified? To do this, you’ll first need to gather as much information as you can about the applications from New Relic Insights, which helps you analyze data that is collected about the applications in more detail. Here is an example NRQL query to further analyze back-end service performance: SELECT count(appName)/30 as 'Throughput', apdex(duration), average(duration), stddev(duration), max(duration), count(error_type), uniquecount(host) FROM Transaction FACET appName SINCE 30 MINUTES AGO Copy This query shows you each application’s request per minute (throughput), Apdex score, and an overview of how the application is performing overall (through the standard deviation calculation, in which lower numbers are generally better). It also shows errors for the time period and the number of hosts on which the application is running. insights.newrelic.com > query results Next, gather information on incidents and events related to the services from New Relic Alerts: Click Alerts > Incidents > All Incidents. alerts.newrelic.com > Incidents > All Incidents Click Alerts > Events > All Events. alerts.newrelic.com > Incidents > All Events Tip Using webhooks to send alert events to New Relic Insights, allows you to supplement your dashboards with Alerts data. The process is outlined in this community discussion post. Here is a simplified example of the results of this exercise: Application Number of dependencies RPM Hosts APDEX (avg) Last outage TTR (hrs) Routing Service 10 983 4 .93 2/19/18 .75 Tower Austin 1 58 1 .95 10/11/17 1.5 Proxy-East 11 498 4 .92 1/4/18 .25 Proxy-West 11 495 4 .97 12/3/17 .25 WebPortal 7 396 8 .98 4/1/18 2.5 Supplement this data with the data that your teams know about your service and that you gathered from the dependency exercise in step 1, and use that data to develop hypotheses about the highest risk areas in your services that should be mitigated. 3. Identify front-end dependency risk Once you’ve analyzed back-end dependencies, explore front-end dependencies. This is a critical step because as you walk higher up the stack and closer to the user, you will likely have more dependencies and abstractions. Service maps seamlessly integrate data from browser monitoring and mobile monitoring to help you understand the dependencies from front-end user interfaces to back-end services. one.newrelic.com > Service Maps Use the service map view to drill into front-end dependencies, and execute a similar exercise to the one you executed for back-end dependencies. This exercise will again expose data to help you identify risk areas you should address and optimize. We recommend that you conduct the analysis with user interface (UI) teams so that you can also gather a complementary qualitative understanding of what the UI teams consider critical based on their experience. A ranking from the UI teams of the most critical dependency is a useful output of this work. 4. Identify Microservice Dependencies If you are using microservices, you can have dozens, if not hundreds, of services that are calling each other. Use Distributed Tracing to see how all those services connect together and how your requests flow through those different services. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. A distributed trace is composed of multiple \"spans,\" which represent time spent in services or resources of those services. Click on the Distributed tracing menu in New Relic APM left nav. You can see “trace listing” view where you’ll be able to quickly identify slow traces and traces with errors. The scatter plot lets you easily see outliers. Below that are the trace summaries, click on a trace to see details. Dive into distributed traces to see how long each span takes. Click into each span to see historical performance charts and associated attributes that layer in the context you need to understand and troubleshoot issues. one.newrelic.com > APM > (select an app) > Distributed tracing This rounds out your list of dependencies. 5. Create an action plan for risk mitigation Once you’ve analyzed the dependencies across your application from both front-end and back-end services, create an action plan to reduce dependency risks and achieve your service level objectives (SLO). As you prioritize these next steps, we recommend you keep these four principles in mind: Understand your risk tolerance. It’s helpful to have a clear picture of your tolerance for risk, which ideally should be informed by your service level objectives (refer to the Establish Objectives and Baselines tutorial for more information). Set an alert policy to monitor dependencies that you’ve determined have a high relationship to SLO achievement. Minimize dependencies. The simpler you keep your code, the less functions you'll have referring to other modules. Removing unnecessary complexity is an important way to ensure you have a maintainable system that meets your customers’ expectations. Localize dependencies. For the code you write, package together functions that depend on each other whenever possible. Stabilize dependencies. When dependencies are unavoidable, mitigate risks by ensuring these dependencies point to modules that are the least likely to change or are easier to substitute. When your action plan is complete, monitor the results of the efforts. The efficacy of your actions to resolve dependency risks should ultimately be measured by your SLOs",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 432.0442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " <em>DevOps</em> procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. <em>New</em> <em>Relic</em> recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com &gt; Service Maps"
      },
      "id": "60440f13e7b9d2ec025799f0"
    },
    {
      "sections": [
        "Set proactive alerting: understand and respond to performance issues",
        "Prerequisites",
        "1. Define required alerting policies based on Service Level Objectives",
        "2. Set specific alerts for performance, correctness, throughput, availability, and dependencies",
        "3. Identify groups to alert, and set broadcasting methods",
        "4. Leverage AI to fine-tune alerts and seek anomalies",
        "5. Create an alerts dashboard",
        "Conclusion",
        "For more help"
      ],
      "title": "Set proactive alerting: understand and respond to performance issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c8da73787dbeba3d1f2af43fbce84fb26e4d7852",
      "image": "https://docs.newrelic.com/static/49cfe6b2c2181499588c35b9720a1e4f/c1b63/new-relic-recent-anomalies-view.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues/",
      "published_at": "2021-07-09T15:47:11Z",
      "updated_at": "2021-07-09T15:47:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term \"alerting\" often carries some negative connotations; for too many developers, alerting correlates too closely with errors, mistakes, and ongoing issues. However, for developers who are proactive about alerting, they know they don’t have to stare at their dashboards all day, because effective alerts will tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Alerts can become overwhelming, so tune alerts and leverage AI so you get alerted on what matters. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, “95% of requests completed within 250 ms AND availability is 99.99%”), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it’s meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature DevOps customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic DevOps customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use Synthetic monitoring pings to determine if the site is up and scripted checks to determine that the most important capabilities (such as a checkout cart) are working. How's our underlying infrastructure? Set KPIs for key hardware, virtual hosts, containers, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site’s availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don’t yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we’ve set both a warning and a violation for throughput: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier -- this can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic approximately evenly across five different servers. You can set an alert based on a NRQL query, and notification to be sent if any server starts getting significantly more or less traffic than the other servers. Here’s the graph: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds And here’s a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups to alert, and set broadcasting methods Alerting without the proper broadcasting methods leaves you vulnerable. Your alerts strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the the types of alerts that warrant waking someone up. 4. Leverage AI to fine-tune alerts and seek anomalies To ensure you aren't training your teams to turn off or ignore notifications, keep your alerts valid and fresh. As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. To keep alerts to a minimum, leverage New Relic Applied Intelligence features, such as Incident Intelligence, which correlates related alerts into one actionable issue combining machine learning and manual input. Check to make sure alerts are correlated correctly and train your system to obtain the most accurate incident correlation. An additional way to reduce alert noise is by flapping detection and suppression. When an issue is \"flapping,\" it is cycling between an open and resolved state, creating a new alert every time it cycles. Effectively handling these can reduce the number of total alerts sent to your team. Finally, when you have maintenance scheduled, take advantage of alert muting rules to suppress those alerts you don't need. Now that you have tuned your alerts to valid notifications, you can proactively go after anomalies so you can fix issues before they become incidents. Enable Proactive Detection of anomalies and set some level of notification for them. 5. Create an alerts dashboard Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use NRQL to create your dashboards. For detailed instructions, check out Sending alerts data to Insights (Insights is no longer our querying interface but the same concepts apply). The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you’re using. For a more extensive discussion on notification channels, refer to the incident orchestration tutorial. Conclusion Establishing a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or infrastructure. With proactive alerting, you will decrease user-reported incidents, and allow your teams to spend less time firefighting and more time deploying significant changes to your product. For more help For more tips and best practices for alerting, see the following documentation: Tame application monitoring with dynamic targeting in New Relic Alerts Best practices for alert policies New Relic infrastructure monitoring best practices guide Infrastructure alerting examples",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.74176,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. <em>New</em> <em>Relic</em> often finds that our most mature <em>DevOps</em> customers set fewer alerts in general and focus those"
      },
      "id": "60445b8764441fe7fd378ee5"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-07-09T15:09:24Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.1209,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Device</em> performance breakdown",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "In a <em>DevOps</em> world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With <em>New</em> <em>Relic</em> you can <em>measure</em> the <em>success</em> of your <em>DevOps</em> initiatives and learn how"
      },
      "id": "60440e5364441fb0c6378ef6"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress": [
    {
      "sections": [
        "Resolve dependency risk: identify and analyze potential issues",
        "Prerequisites",
        "1. Analyze dependencies with service maps",
        "2. Identify back-end application dependency risks",
        "Tip",
        "3. Identify front-end dependency risk",
        "4. Identify Microservice Dependencies",
        "5. Create an action plan for risk mitigation"
      ],
      "title": "Resolve dependency risk: identify and analyze potential issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "4911ddf0c6fca572b52e22fbe464f21f0c6f338f",
      "image": "https://docs.newrelic.com/static/d1d4cf78d193ae770219cfdb9f6f792f/c1b63/distributed-trace_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/resolve-dependency-risk-identify-analyze-potential-issues/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Successfully scaling DevOps requires a robust understanding of dependencies across application teams and related services. Use New Relics service maps to discover and mitigate risky dependencies from upstream and downstream services. Prerequisites This tutorial assumes you’ve completed the previous DevOps procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. New Relic recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com > Service Maps > App/Service list This initial view shows all applications that are configured in your account. Applications that have violated a warning threshold are shown in yellow, and those with an active alert are shown in red. Healthy applications appear in green. New Relic uses a bold line to map applications to the services (such as databases) they connect to. Familiarize yourself with these maps to see how applications and their services fit together. Take note of which applications have the most dependencies and which rely on the same dependency, such as an API. Click an application to see high level metrics about that app, including throughput, response time, Apdex score, and error rate for the last 30 minutes. Tracking throughput is a good way to determine which of your applications are serving the most traffic. After looking at the architecture as a whole, review the applications that have the most dependencies. Select the App/Services list to see a full list of your applications. one.newrelic.com > Service Maps > App/Service list In this example, we’ve chosen Tower-Chicago from the App/Services list. All of the traffic being sent to Tower-Chicago is coming from Proxy-East. In this case, Tower-Chicago is showing 48.3 requests per minute, or 11.3% of the 426 requests per minute flowing through Proxy-East. one.newrelic.com > Service Maps > App/Service list In most cases, the separate applications and services represented in service maps are created and maintained by separate teams. This exercise of walking through the dependencies of your architecture should involve representatives from each of those teams. Teams should work together to ask questions such as: How critical is this particular dependency? What would happen if it were to go down? What happened last time it went down? Was there a revenue loss? 2. Identify back-end application dependency risks Once you’ve analyzed your applications’ dependencies, you’ll want to examine the quality of dependency execution. For example, is the dependency stable and predictable for each application or transaction you’ve identified? To do this, you’ll first need to gather as much information as you can about the applications from New Relic Insights, which helps you analyze data that is collected about the applications in more detail. Here is an example NRQL query to further analyze back-end service performance: SELECT count(appName)/30 as 'Throughput', apdex(duration), average(duration), stddev(duration), max(duration), count(error_type), uniquecount(host) FROM Transaction FACET appName SINCE 30 MINUTES AGO Copy This query shows you each application’s request per minute (throughput), Apdex score, and an overview of how the application is performing overall (through the standard deviation calculation, in which lower numbers are generally better). It also shows errors for the time period and the number of hosts on which the application is running. insights.newrelic.com > query results Next, gather information on incidents and events related to the services from New Relic Alerts: Click Alerts > Incidents > All Incidents. alerts.newrelic.com > Incidents > All Incidents Click Alerts > Events > All Events. alerts.newrelic.com > Incidents > All Events Tip Using webhooks to send alert events to New Relic Insights, allows you to supplement your dashboards with Alerts data. The process is outlined in this community discussion post. Here is a simplified example of the results of this exercise: Application Number of dependencies RPM Hosts APDEX (avg) Last outage TTR (hrs) Routing Service 10 983 4 .93 2/19/18 .75 Tower Austin 1 58 1 .95 10/11/17 1.5 Proxy-East 11 498 4 .92 1/4/18 .25 Proxy-West 11 495 4 .97 12/3/17 .25 WebPortal 7 396 8 .98 4/1/18 2.5 Supplement this data with the data that your teams know about your service and that you gathered from the dependency exercise in step 1, and use that data to develop hypotheses about the highest risk areas in your services that should be mitigated. 3. Identify front-end dependency risk Once you’ve analyzed back-end dependencies, explore front-end dependencies. This is a critical step because as you walk higher up the stack and closer to the user, you will likely have more dependencies and abstractions. Service maps seamlessly integrate data from browser monitoring and mobile monitoring to help you understand the dependencies from front-end user interfaces to back-end services. one.newrelic.com > Service Maps Use the service map view to drill into front-end dependencies, and execute a similar exercise to the one you executed for back-end dependencies. This exercise will again expose data to help you identify risk areas you should address and optimize. We recommend that you conduct the analysis with user interface (UI) teams so that you can also gather a complementary qualitative understanding of what the UI teams consider critical based on their experience. A ranking from the UI teams of the most critical dependency is a useful output of this work. 4. Identify Microservice Dependencies If you are using microservices, you can have dozens, if not hundreds, of services that are calling each other. Use Distributed Tracing to see how all those services connect together and how your requests flow through those different services. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. A distributed trace is composed of multiple \"spans,\" which represent time spent in services or resources of those services. Click on the Distributed tracing menu in New Relic APM left nav. You can see “trace listing” view where you’ll be able to quickly identify slow traces and traces with errors. The scatter plot lets you easily see outliers. Below that are the trace summaries, click on a trace to see details. Dive into distributed traces to see how long each span takes. Click into each span to see historical performance charts and associated attributes that layer in the context you need to understand and troubleshoot issues. one.newrelic.com > APM > (select an app) > Distributed tracing This rounds out your list of dependencies. 5. Create an action plan for risk mitigation Once you’ve analyzed the dependencies across your application from both front-end and back-end services, create an action plan to reduce dependency risks and achieve your service level objectives (SLO). As you prioritize these next steps, we recommend you keep these four principles in mind: Understand your risk tolerance. It’s helpful to have a clear picture of your tolerance for risk, which ideally should be informed by your service level objectives (refer to the Establish Objectives and Baselines tutorial for more information). Set an alert policy to monitor dependencies that you’ve determined have a high relationship to SLO achievement. Minimize dependencies. The simpler you keep your code, the less functions you'll have referring to other modules. Removing unnecessary complexity is an important way to ensure you have a maintainable system that meets your customers’ expectations. Localize dependencies. For the code you write, package together functions that depend on each other whenever possible. Stabilize dependencies. When dependencies are unavoidable, mitigate risks by ensuring these dependencies point to modules that are the least likely to change or are easier to substitute. When your action plan is complete, monitor the results of the efforts. The efficacy of your actions to resolve dependency risks should ultimately be measured by your SLOs",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 432.0442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " <em>DevOps</em> procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. <em>New</em> <em>Relic</em> recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com &gt; Service Maps"
      },
      "id": "60440f13e7b9d2ec025799f0"
    },
    {
      "sections": [
        "Set proactive alerting: understand and respond to performance issues",
        "Prerequisites",
        "1. Define required alerting policies based on Service Level Objectives",
        "2. Set specific alerts for performance, correctness, throughput, availability, and dependencies",
        "3. Identify groups to alert, and set broadcasting methods",
        "4. Leverage AI to fine-tune alerts and seek anomalies",
        "5. Create an alerts dashboard",
        "Conclusion",
        "For more help"
      ],
      "title": "Set proactive alerting: understand and respond to performance issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c8da73787dbeba3d1f2af43fbce84fb26e4d7852",
      "image": "https://docs.newrelic.com/static/49cfe6b2c2181499588c35b9720a1e4f/c1b63/new-relic-recent-anomalies-view.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues/",
      "published_at": "2021-07-09T15:47:11Z",
      "updated_at": "2021-07-09T15:47:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term \"alerting\" often carries some negative connotations; for too many developers, alerting correlates too closely with errors, mistakes, and ongoing issues. However, for developers who are proactive about alerting, they know they don’t have to stare at their dashboards all day, because effective alerts will tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Alerts can become overwhelming, so tune alerts and leverage AI so you get alerted on what matters. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, “95% of requests completed within 250 ms AND availability is 99.99%”), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it’s meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature DevOps customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic DevOps customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use Synthetic monitoring pings to determine if the site is up and scripted checks to determine that the most important capabilities (such as a checkout cart) are working. How's our underlying infrastructure? Set KPIs for key hardware, virtual hosts, containers, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site’s availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don’t yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we’ve set both a warning and a violation for throughput: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier -- this can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic approximately evenly across five different servers. You can set an alert based on a NRQL query, and notification to be sent if any server starts getting significantly more or less traffic than the other servers. Here’s the graph: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds And here’s a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups to alert, and set broadcasting methods Alerting without the proper broadcasting methods leaves you vulnerable. Your alerts strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the the types of alerts that warrant waking someone up. 4. Leverage AI to fine-tune alerts and seek anomalies To ensure you aren't training your teams to turn off or ignore notifications, keep your alerts valid and fresh. As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. To keep alerts to a minimum, leverage New Relic Applied Intelligence features, such as Incident Intelligence, which correlates related alerts into one actionable issue combining machine learning and manual input. Check to make sure alerts are correlated correctly and train your system to obtain the most accurate incident correlation. An additional way to reduce alert noise is by flapping detection and suppression. When an issue is \"flapping,\" it is cycling between an open and resolved state, creating a new alert every time it cycles. Effectively handling these can reduce the number of total alerts sent to your team. Finally, when you have maintenance scheduled, take advantage of alert muting rules to suppress those alerts you don't need. Now that you have tuned your alerts to valid notifications, you can proactively go after anomalies so you can fix issues before they become incidents. Enable Proactive Detection of anomalies and set some level of notification for them. 5. Create an alerts dashboard Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use NRQL to create your dashboards. For detailed instructions, check out Sending alerts data to Insights (Insights is no longer our querying interface but the same concepts apply). The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you’re using. For a more extensive discussion on notification channels, refer to the incident orchestration tutorial. Conclusion Establishing a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or infrastructure. With proactive alerting, you will decrease user-reported incidents, and allow your teams to spend less time firefighting and more time deploying significant changes to your product. For more help For more tips and best practices for alerting, see the following documentation: Tame application monitoring with dynamic targeting in New Relic Alerts Best practices for alert policies New Relic infrastructure monitoring best practices guide Infrastructure alerting examples",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.74176,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. <em>New</em> <em>Relic</em> often finds that our most mature <em>DevOps</em> customers set fewer alerts in general and focus those"
      },
      "id": "60445b8764441fe7fd378ee5"
    },
    {
      "sections": [
        "Guide to measuring DevOps success",
        "Prepare your DevOps team",
        "Activate well-defined processes",
        "Optimize your team, process, and enterprise"
      ],
      "title": "Guide to measuring DevOps success",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c420ed2384a6adfb6afbfa4b1ab56386c34c78a1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/guide-measuring-devops-success/",
      "published_at": "2021-07-09T09:13:31Z",
      "updated_at": "2021-07-09T09:13:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these guides to enable your DevOps team for success. The solutions in these guides provide best practices for using New Relic at every stage of measuring DevOps success: Preparing, Activating, and Optimizing. Each of these guides focus on identifying key performance metrics and creating a greater digital experience for customers. Monitoring with New Relic from the beginning to the end of your journey lets you measure your DevOps impact at every step of the way. Prepare your DevOps team Preparing your DevOps team for measurable success starts by setting clear service level objectives (SLOs), and putting instrumentation in place to quantitatively understand progress. App Remediation Establish objectives and baselines Setup proactive alerting Activate well-defined processes Define and hone your process using New Relic Alerts, APM, and Insights. Establish team dashboards Iterate and measure impact Incident orchestration Optimize your team, process, and enterprise Continue to monitor with New Relic to constantly optimize your performance and customer experience. Resolve dependency risk Customer experience improvement Infrastructure resource sizing Operations review",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 425.43372,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to <em>measuring</em> <em>DevOps</em> <em>success</em>",
        "sections": "Guide to <em>measuring</em> <em>DevOps</em> <em>success</em>",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "Follow these guides to enable your <em>DevOps</em> team for <em>success</em>. The <em>solutions</em> in these guides provide best practices for using <em>New</em> <em>Relic</em> at every stage of measuring <em>DevOps</em> <em>success</em>: Preparing, Activating, and Optimizing. Each of these guides focus on identifying key performance metrics and creating"
      },
      "id": "604415a764441f9935378edb"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/resolve-dependency-risk-identify-analyze-potential-issues": [
    {
      "sections": [
        "Set proactive alerting: understand and respond to performance issues",
        "Prerequisites",
        "1. Define required alerting policies based on Service Level Objectives",
        "2. Set specific alerts for performance, correctness, throughput, availability, and dependencies",
        "3. Identify groups to alert, and set broadcasting methods",
        "4. Leverage AI to fine-tune alerts and seek anomalies",
        "5. Create an alerts dashboard",
        "Conclusion",
        "For more help"
      ],
      "title": "Set proactive alerting: understand and respond to performance issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c8da73787dbeba3d1f2af43fbce84fb26e4d7852",
      "image": "https://docs.newrelic.com/static/49cfe6b2c2181499588c35b9720a1e4f/c1b63/new-relic-recent-anomalies-view.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues/",
      "published_at": "2021-07-09T15:47:11Z",
      "updated_at": "2021-07-09T15:47:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term \"alerting\" often carries some negative connotations; for too many developers, alerting correlates too closely with errors, mistakes, and ongoing issues. However, for developers who are proactive about alerting, they know they don’t have to stare at their dashboards all day, because effective alerts will tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Alerts can become overwhelming, so tune alerts and leverage AI so you get alerted on what matters. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the tutorial Establish objectives and baselines before you begin this one. Optional: added custom attributes and events. 1. Define required alerting policies based on Service Level Objectives A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, “95% of requests completed within 250 ms AND availability is 99.99%”), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it’s meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature DevOps customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic DevOps customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use Synthetic monitoring pings to determine if the site is up and scripted checks to determine that the most important capabilities (such as a checkout cart) are working. How's our underlying infrastructure? Set KPIs for key hardware, virtual hosts, containers, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site’s availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don’t yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we’ve set both a warning and a violation for throughput: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier -- this can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic approximately evenly across five different servers. You can set an alert based on a NRQL query, and notification to be sent if any server starts getting significantly more or less traffic than the other servers. Here’s the graph: alerts.newrelic.com > (select an alert policy) > (select an alert condition) > Define thresholds And here’s a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups to alert, and set broadcasting methods Alerting without the proper broadcasting methods leaves you vulnerable. Your alerts strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the the types of alerts that warrant waking someone up. 4. Leverage AI to fine-tune alerts and seek anomalies To ensure you aren't training your teams to turn off or ignore notifications, keep your alerts valid and fresh. As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. To keep alerts to a minimum, leverage New Relic Applied Intelligence features, such as Incident Intelligence, which correlates related alerts into one actionable issue combining machine learning and manual input. Check to make sure alerts are correlated correctly and train your system to obtain the most accurate incident correlation. An additional way to reduce alert noise is by flapping detection and suppression. When an issue is \"flapping,\" it is cycling between an open and resolved state, creating a new alert every time it cycles. Effectively handling these can reduce the number of total alerts sent to your team. Finally, when you have maintenance scheduled, take advantage of alert muting rules to suppress those alerts you don't need. Now that you have tuned your alerts to valid notifications, you can proactively go after anomalies so you can fix issues before they become incidents. Enable Proactive Detection of anomalies and set some level of notification for them. 5. Create an alerts dashboard Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use NRQL to create your dashboards. For detailed instructions, check out Sending alerts data to Insights (Insights is no longer our querying interface but the same concepts apply). The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you’re using. For a more extensive discussion on notification channels, refer to the incident orchestration tutorial. Conclusion Establishing a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or infrastructure. With proactive alerting, you will decrease user-reported incidents, and allow your teams to spend less time firefighting and more time deploying significant changes to your product. For more help For more tips and best practices for alerting, see the following documentation: Tame application monitoring with dynamic targeting in New Relic Alerts Best practices for alert policies New Relic infrastructure monitoring best practices guide Infrastructure alerting examples",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.74176,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " half a millisecond, or if the error rate goes higher than .20%. However, not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. <em>New</em> <em>Relic</em> often finds that our most mature <em>DevOps</em> customers set fewer alerts in general and focus those"
      },
      "id": "60445b8764441fe7fd378ee5"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-07-09T15:09:24Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.1209,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Device</em> performance breakdown",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "In a <em>DevOps</em> world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With <em>New</em> <em>Relic</em> you can <em>measure</em> the <em>success</em> of your <em>DevOps</em> initiatives and learn how"
      },
      "id": "60440e5364441fb0c6378ef6"
    },
    {
      "sections": [
        "Guide to measuring DevOps success",
        "Prepare your DevOps team",
        "Activate well-defined processes",
        "Optimize your team, process, and enterprise"
      ],
      "title": "Guide to measuring DevOps success",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c420ed2384a6adfb6afbfa4b1ab56386c34c78a1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/guide-measuring-devops-success/",
      "published_at": "2021-07-09T09:13:31Z",
      "updated_at": "2021-07-09T09:13:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these guides to enable your DevOps team for success. The solutions in these guides provide best practices for using New Relic at every stage of measuring DevOps success: Preparing, Activating, and Optimizing. Each of these guides focus on identifying key performance metrics and creating a greater digital experience for customers. Monitoring with New Relic from the beginning to the end of your journey lets you measure your DevOps impact at every step of the way. Prepare your DevOps team Preparing your DevOps team for measurable success starts by setting clear service level objectives (SLOs), and putting instrumentation in place to quantitatively understand progress. App Remediation Establish objectives and baselines Setup proactive alerting Activate well-defined processes Define and hone your process using New Relic Alerts, APM, and Insights. Establish team dashboards Iterate and measure impact Incident orchestration Optimize your team, process, and enterprise Continue to monitor with New Relic to constantly optimize your performance and customer experience. Resolve dependency risk Customer experience improvement Infrastructure resource sizing Operations review",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 425.43372,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to <em>measuring</em> <em>DevOps</em> <em>success</em>",
        "sections": "Guide to <em>measuring</em> <em>DevOps</em> <em>success</em>",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "Follow these guides to enable your <em>DevOps</em> team for <em>success</em>. The <em>solutions</em> in these guides provide best practices for using <em>New</em> <em>Relic</em> at every stage of measuring <em>DevOps</em> <em>success</em>: Preparing, Activating, and Optimizing. Each of these guides focus on identifying key performance metrics and creating"
      },
      "id": "604415a764441f9935378edb"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/set-proactive-alerting-understand-respond-performance-issues": [
    {
      "sections": [
        "Resolve dependency risk: identify and analyze potential issues",
        "Prerequisites",
        "1. Analyze dependencies with service maps",
        "2. Identify back-end application dependency risks",
        "Tip",
        "3. Identify front-end dependency risk",
        "4. Identify Microservice Dependencies",
        "5. Create an action plan for risk mitigation"
      ],
      "title": "Resolve dependency risk: identify and analyze potential issues",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "4911ddf0c6fca572b52e22fbe464f21f0c6f338f",
      "image": "https://docs.newrelic.com/static/d1d4cf78d193ae770219cfdb9f6f792f/c1b63/distributed-trace_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/resolve-dependency-risk-identify-analyze-potential-issues/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Successfully scaling DevOps requires a robust understanding of dependencies across application teams and related services. Use New Relics service maps to discover and mitigate risky dependencies from upstream and downstream services. Prerequisites This tutorial assumes you’ve completed the previous DevOps procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. New Relic recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com > Service Maps > App/Service list This initial view shows all applications that are configured in your account. Applications that have violated a warning threshold are shown in yellow, and those with an active alert are shown in red. Healthy applications appear in green. New Relic uses a bold line to map applications to the services (such as databases) they connect to. Familiarize yourself with these maps to see how applications and their services fit together. Take note of which applications have the most dependencies and which rely on the same dependency, such as an API. Click an application to see high level metrics about that app, including throughput, response time, Apdex score, and error rate for the last 30 minutes. Tracking throughput is a good way to determine which of your applications are serving the most traffic. After looking at the architecture as a whole, review the applications that have the most dependencies. Select the App/Services list to see a full list of your applications. one.newrelic.com > Service Maps > App/Service list In this example, we’ve chosen Tower-Chicago from the App/Services list. All of the traffic being sent to Tower-Chicago is coming from Proxy-East. In this case, Tower-Chicago is showing 48.3 requests per minute, or 11.3% of the 426 requests per minute flowing through Proxy-East. one.newrelic.com > Service Maps > App/Service list In most cases, the separate applications and services represented in service maps are created and maintained by separate teams. This exercise of walking through the dependencies of your architecture should involve representatives from each of those teams. Teams should work together to ask questions such as: How critical is this particular dependency? What would happen if it were to go down? What happened last time it went down? Was there a revenue loss? 2. Identify back-end application dependency risks Once you’ve analyzed your applications’ dependencies, you’ll want to examine the quality of dependency execution. For example, is the dependency stable and predictable for each application or transaction you’ve identified? To do this, you’ll first need to gather as much information as you can about the applications from New Relic Insights, which helps you analyze data that is collected about the applications in more detail. Here is an example NRQL query to further analyze back-end service performance: SELECT count(appName)/30 as 'Throughput', apdex(duration), average(duration), stddev(duration), max(duration), count(error_type), uniquecount(host) FROM Transaction FACET appName SINCE 30 MINUTES AGO Copy This query shows you each application’s request per minute (throughput), Apdex score, and an overview of how the application is performing overall (through the standard deviation calculation, in which lower numbers are generally better). It also shows errors for the time period and the number of hosts on which the application is running. insights.newrelic.com > query results Next, gather information on incidents and events related to the services from New Relic Alerts: Click Alerts > Incidents > All Incidents. alerts.newrelic.com > Incidents > All Incidents Click Alerts > Events > All Events. alerts.newrelic.com > Incidents > All Events Tip Using webhooks to send alert events to New Relic Insights, allows you to supplement your dashboards with Alerts data. The process is outlined in this community discussion post. Here is a simplified example of the results of this exercise: Application Number of dependencies RPM Hosts APDEX (avg) Last outage TTR (hrs) Routing Service 10 983 4 .93 2/19/18 .75 Tower Austin 1 58 1 .95 10/11/17 1.5 Proxy-East 11 498 4 .92 1/4/18 .25 Proxy-West 11 495 4 .97 12/3/17 .25 WebPortal 7 396 8 .98 4/1/18 2.5 Supplement this data with the data that your teams know about your service and that you gathered from the dependency exercise in step 1, and use that data to develop hypotheses about the highest risk areas in your services that should be mitigated. 3. Identify front-end dependency risk Once you’ve analyzed back-end dependencies, explore front-end dependencies. This is a critical step because as you walk higher up the stack and closer to the user, you will likely have more dependencies and abstractions. Service maps seamlessly integrate data from browser monitoring and mobile monitoring to help you understand the dependencies from front-end user interfaces to back-end services. one.newrelic.com > Service Maps Use the service map view to drill into front-end dependencies, and execute a similar exercise to the one you executed for back-end dependencies. This exercise will again expose data to help you identify risk areas you should address and optimize. We recommend that you conduct the analysis with user interface (UI) teams so that you can also gather a complementary qualitative understanding of what the UI teams consider critical based on their experience. A ranking from the UI teams of the most critical dependency is a useful output of this work. 4. Identify Microservice Dependencies If you are using microservices, you can have dozens, if not hundreds, of services that are calling each other. Use Distributed Tracing to see how all those services connect together and how your requests flow through those different services. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. A distributed trace is composed of multiple \"spans,\" which represent time spent in services or resources of those services. Click on the Distributed tracing menu in New Relic APM left nav. You can see “trace listing” view where you’ll be able to quickly identify slow traces and traces with errors. The scatter plot lets you easily see outliers. Below that are the trace summaries, click on a trace to see details. Dive into distributed traces to see how long each span takes. Click into each span to see historical performance charts and associated attributes that layer in the context you need to understand and troubleshoot issues. one.newrelic.com > APM > (select an app) > Distributed tracing This rounds out your list of dependencies. 5. Create an action plan for risk mitigation Once you’ve analyzed the dependencies across your application from both front-end and back-end services, create an action plan to reduce dependency risks and achieve your service level objectives (SLO). As you prioritize these next steps, we recommend you keep these four principles in mind: Understand your risk tolerance. It’s helpful to have a clear picture of your tolerance for risk, which ideally should be informed by your service level objectives (refer to the Establish Objectives and Baselines tutorial for more information). Set an alert policy to monitor dependencies that you’ve determined have a high relationship to SLO achievement. Minimize dependencies. The simpler you keep your code, the less functions you'll have referring to other modules. Removing unnecessary complexity is an important way to ensure you have a maintainable system that meets your customers’ expectations. Localize dependencies. For the code you write, package together functions that depend on each other whenever possible. Stabilize dependencies. When dependencies are unavoidable, mitigate risks by ensuring these dependencies point to modules that are the least likely to change or are easier to substitute. When your action plan is complete, monitor the results of the efforts. The efficacy of your actions to resolve dependency risks should ultimately be measured by your SLOs",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 432.0439,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": " <em>DevOps</em> procedures. 1. Analyze dependencies with service maps Use service maps for each application and note any dependent systems and transactions. <em>New</em> <em>Relic</em> recommends that you start by viewing the entire architecture using the Discover your environment option. one.newrelic.com &gt; Service Maps"
      },
      "id": "60440f13e7b9d2ec025799f0"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-07-09T15:09:24Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 431.12064,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Device</em> performance breakdown",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "In a <em>DevOps</em> world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With <em>New</em> <em>Relic</em> you can <em>measure</em> the <em>success</em> of your <em>DevOps</em> initiatives and learn how"
      },
      "id": "60440e5364441fb0c6378ef6"
    },
    {
      "sections": [
        "Guide to measuring DevOps success",
        "Prepare your DevOps team",
        "Activate well-defined processes",
        "Optimize your team, process, and enterprise"
      ],
      "title": "Guide to measuring DevOps success",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "c420ed2384a6adfb6afbfa4b1ab56386c34c78a1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/guide-measuring-devops-success/",
      "published_at": "2021-07-09T09:13:31Z",
      "updated_at": "2021-07-09T09:13:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow these guides to enable your DevOps team for success. The solutions in these guides provide best practices for using New Relic at every stage of measuring DevOps success: Preparing, Activating, and Optimizing. Each of these guides focus on identifying key performance metrics and creating a greater digital experience for customers. Monitoring with New Relic from the beginning to the end of your journey lets you measure your DevOps impact at every step of the way. Prepare your DevOps team Preparing your DevOps team for measurable success starts by setting clear service level objectives (SLOs), and putting instrumentation in place to quantitatively understand progress. App Remediation Establish objectives and baselines Setup proactive alerting Activate well-defined processes Define and hone your process using New Relic Alerts, APM, and Insights. Establish team dashboards Iterate and measure impact Incident orchestration Optimize your team, process, and enterprise Continue to monitor with New Relic to constantly optimize your performance and customer experience. Resolve dependency risk Customer experience improvement Infrastructure resource sizing Operations review",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 425.43347,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to <em>measuring</em> <em>DevOps</em> <em>success</em>",
        "sections": "Guide to <em>measuring</em> <em>DevOps</em> <em>success</em>",
        "tags": "<em>Measure</em> <em>DevOps</em> <em>success</em>",
        "body": "Follow these guides to enable your <em>DevOps</em> team for <em>success</em>. The <em>solutions</em> in these guides provide best practices for using <em>New</em> <em>Relic</em> at every stage of measuring <em>DevOps</em> <em>success</em>: Preparing, Activating, and Optimizing. Each of these guides focus on identifying key performance metrics and creating"
      },
      "id": "604415a764441f9935378edb"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/adopt-cloud-services": [
    {
      "sections": [
        "Analyze distributed systems",
        "1. Identify high-priority areas to monitor",
        "2. Instrument to get the visibility you require",
        "3. Create dashboards",
        "4. Dig deeper with distributed tracing",
        "5. Annotate message queues with distributed tracing payload APIs",
        "Example annotated message queue",
        "6. Annotate and tag traces with custom attributes",
        "Tip",
        "7. Leverage Synthetics to get a high-level view of system health",
        "For more help"
      ],
      "title": "Analyze distributed systems",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "af1cf5a80f8254c90509e562fb68a6ded2f7207f",
      "image": "https://docs.newrelic.com/static/838e50badd634f1f188cf821785f6696/2cffa/APm_distributed-tracing-catalyst-TWO.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/analyze-distributed-systems/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a monolithic application, a simple stack trace can contain enough diagnostic data to determine the root cause of a code defect. But cloud computing and microservices have blurred the lines between software and infrastructure; in modern architectures, requests are distributed across many smaller services—often with ephemeral lifespans—hosted in both on-premise and cloud environments. Spotting code defects becomes much more complex. APM's distributed tracing automatically helps teams troubleshoot such distributed systems. Distributed traces are just one component of a well-monitored system. You need a holistic view of your distributed system, especially when tracking the root cause of a defect, as there are volumes of data to evaluate and understand. When managing a microservices environment, it's critical that you have the capability to spot bottlenecks and problem spans quickly so that you don't compromise your mean-time-to-resolution (MTTR) or end-user experience. At New Relic, we understand these challenges inherently. In our journey, we've transitioned from a Ruby monolith to a multi-language distributed environment built on more than 300 microservices, for which we average 50 code deploys a day. Such challenges inform both how we've built and how we monitor New Relic. Use the New Relic platform to translate your data into relevant insights, so you can collaborate around a common framework to build context and quickly optimize and troubleshoot your complex, distributed systems. 1. Identify high-priority areas to monitor Distributed systems are complex. Before engaging with the New Relic platform, we recommend that you identify the most critical areas of your systems to observe, and focus on instrumenting those high-priority areas first. Google's SRE handbook suggests monitoring the \"four golden signals\": traffic, latency, errors, and saturation, as shown in the following dashboard: Dashboards: Visualize key areas to monitor with dashboards. Too often, teams monitor what is either 1) easy to measure or 2) interpretable. Avoid this fallacy. When making choices about what to monitor, involve product managers and other stakeholders from your organization. Your goal is to monitor what matters to your business, not to overload your teams with noise. 2. Instrument to get the visibility you require Once you've identified your key priorities, instrument the appropriate parts of your system with the New Relic platform. Monitor your web apps with APM. See compatibility and requirements for New Relic agents and products to learn precise compatibility details for each supported language and then install the APM agent on your application stack. Steps for installing APM agents vary based on language. Enable distributed tracing for APM, which will affect some existing APM features. If you're accustomed to using APM without distributed tracing, read the transition guide before you enable this feature. Monitor your compute resources with infrastructure. See compatibility and requirements for infrastructure monitoring for supported operating systems and environments. You can also instrument other products and services with on-host integrations. Monitor your front-end experience with mobile and browser. 3. Create dashboards Use dashboards to get an overview of your entire system and baseline performance, so you can better understand how the components work together. Insights provides a single framework for aligning disparate teams around relevant data. Approach this first build as your launching point, giving your teams something to react to as you begin to ascribe context to your system. You should continue to build and iterate your dashboards as you analyze, troubleshoot, and optimize your distributed system. Even after you have a basic understanding of your system, use dashboards to inform the decisions you make going forward. Dashboards provide central repository of truth, allowing all stakeholders to build context about the health of your system. Here is an example of a query that displays the slowest applications. SELECT percentile(duration, 99) as 'Slowest duration' FROM Transaction FACET name Copy Using this query you can focus on the slowest application to dig deeper: After running the query, dashboards displays the slowest durations. 4. Dig deeper with distributed tracing After you have basic instrumentation and contextual dashboards in place, you can begin to dig deeper to troubleshoot or optimize your system. A differentiated feature in New Relic One's Global Distributed Tracing is that you can come in with vague context for what you're investigating and search across all accounts and traces to get down to the actual user interactions that have those attributes somewhere in their trace. You no longer must begin with the application or specific entity to search for traces that include that application. For example, start with an analysis of your complex service calls, using the distributed tracing UI to: View a scatter plot chart showing the frequency, duration, and other facets of your distributed traces Group traces by root entry, service, service entry, or traces with errors View a trace list Filter specific traces to meet certain parameters You'll likely discover that you want to take the analysis one step further by annotating your traces with information that adds context to your troubleshooting, like User ID. You can do this in New Relic using custom attributes. one.newrelic.com > APM > Distributed tracing: use the distributed tracing UI to monitor and analyze modern distributed systems. 5. Annotate message queues with distributed tracing payload APIs To see connections between services in some environments—for example, in a system that relies heavily on queues—you may need to do some manual instrumentation using the distributed tracing payload APIs to ensure you're propagating the payload. This gives agents the necessary context to create spans with the right correlation; you'll see end-to-end traces for all linked services, including those that cross through the queue. Example annotated message queue For example: Start a transaction. Create the distributed tracing payload on the producer service within a New Relic transaction. As part of the message, add the distributed tracing payload. ​​newrelic.setTransactionName(\"Send Message\") // Create SQS service object var sqs = new AWS.SQS({apiVersion: '2012-11-05'}); var transactionHandle = newrelic.getTransaction(); var payload = transactionHandle.createDistributedTracePayload(); var jsonPayload = payload.text(); //add the jsonPayload as a MessageAttribute var params = { DelaySeconds: 10, MessageAttributes: { \"Testing\": { DataType: \"String\", StringValue: \"123\" }, \"TraceContext\": { DataType: \"String\", StringValue: jsonPayload } }, MessageBody: \"Testing 123\", QueueUrl: \"https://sqs.us-west-2.amazonaws.com/408155283954/sqs-testing\" }; Copy With the context of a transaction, receive the payload on the consumer service. sqs.receiveMessage(params, function(err, data) { if (err) { console.log(\"Receive Error\", err); } else if (data && data.Messages) { console.log(\"trace context:\") var traceContext = data.Messages[0].MessageAttributes.TraceContext.StringValue; if (traceContext != \"\") { var transactionHandle = newrelic.getTransaction(); transactionHandle.acceptDistributedTracePayload(traceContext); } Copy 6. Annotate and tag traces with custom attributes We recommend that you use custom attributes to decorate events with additional information for better tracing. For example, by adding key-value pairs, you can attach a user ID to trace a specific user through the call stack and review failing requests to determine if that user is having an unusually poor experience. We recommend adding custom attributes based on your use case; for example, if your instrumenting an order management system, you could add an order number custom attribute to your traces. To add custom attributes, you must first enable them for your agent, and then make an API call to record the attribute. Tip For more agent-specific information on collecting custom attributes, see Collect custom attributes sqs.sendMessage(params, function(err, data) { if (err) { res.send(\"Error: \"+ err); } else { res.send(\"Success! Message ID: \"+ data.MessageId); newrelic.addCustomAttribute(\"Message ID\", data.MessageId) } }); Copy 7. Leverage Synthetics to get a high-level view of system health In complex, distributed systems, you need to track and monitor many signals. Sometimes it may be that no one signal is concerning, yet your whole system is behaving anomalously. To get a complete picture, it's critical to analyze symptomatic data in tandem with system-level data. Synthetics allows you to interact with the entire system as an external user would, giving your teams high-level checks for performance and user experience. These external checks help you understand if the entire system is doing what you want regardless of what specific signals may indicate. For more help For more tips and best practices on distributed tracing and custom attributes, see the following: Distributed Tracing Anomaly Detection: A Faster, Easier Way to Troubleshoot Microservices Environments Introduction to distributed tracing Collect custom attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.11298,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " that you don&#x27;t compromise <em>your</em> mean-time-to-resolution (MTTR) or end-user experience. At <em>New</em> <em>Relic</em>, we understand these challenges inherently. In our journey, we&#x27;ve transitioned from a Ruby monolith to a multi-language distributed <em>environment</em> built on more than 300 microservices, for which we average"
      },
      "id": "603ebd8264441f02694e887f"
    },
    {
      "sections": [
        "Set proactive alerts and align teams, tools, and processes for incident response",
        "Prerequisites",
        "1. Define policies",
        "Example questions and KPI solutions",
        "2. Set specific alerts",
        "3. Identify groups",
        "4. Determine thresholds",
        "5. Set notification channels",
        "6. Automate resolution",
        "7. Establish reviews",
        "Example post mortem report",
        "8. Fine-tune process",
        "Expert tip"
      ],
      "title": "Set proactive alerts and align teams, tools, and processes for incident response ",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "454d902dd8ff1ace1070b7ad42489dda5405845c",
      "image": "https://docs.newrelic.com/static/ecb7124a85903b58a0fbb042ddb29cc6/c483d/proactive-baseline-alerts-devops_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/set-proactive-alerts-align-teams-tools-processes-incident-response/",
      "published_at": "2021-07-09T16:00:00Z",
      "updated_at": "2021-07-09T16:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term alerting often carries some negative connotations: many developers correlate alerting with errors, mistakes, and ongoing issues. However, developers who are proactive about alerting, know they don't have to stare at dashboards all day because effective alerts tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Further, a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or environment. With proactive alerting, you'll decrease user-reported incidents, and your teams will spend less time firefighting and more time deploying significant changes to your product. After you define the right alerts, proper incident orchestration aligns your teams, tools, and processes to prepare for incidents and outages in your software. The goal is to provide your teams a predictable framework and process to: Maximize efficiency in communication and effort. Minimize the overall impact to your business. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the Establish objectives and baselines tutorial. Optionally added custom attributes and events. 1. Define policies Define required alerting policies based on SLOs. A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples of service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, 95% of requests completed within 250 ms AND availability is 99.99%), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it's meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than 0.20%. However, not every SLO needs to become an alert. A strong alerting strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alerting strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” Example questions and KPI solutions For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use browser monitoring and APM to alert on site availability. How's our underlying infrastructure? Set KPIs for key hardware, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie them to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site's availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don't yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we've set both a warning and a violation for throughput: alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier, which can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic across five different servers. You can set an alert based on a NRQL query and receive a notification if any server starts getting significantly more or less traffic than the other servers. Here is an example chart: And here's a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups Identify groups to alert, set broadcasting methods, and assign first responders to team dashboards Alerting without the proper broadcasting methods leaves you vulnerable. Your alerting strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack or PagerDuty). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the types of alerts that warrant waking someone up. Recommendation: For each team dashboard, make sure: It has an owner who assumes responsibility for the health of the applications and features it monitors. There is no ambiguity about who is responsible for attending to and resolving an alert condition. This policy will vary between organizations depending on size, structure, and culture. For example, some teams may prefer to assign dashboards and alerts based on de-facto features or application ownership. Other teams may prefer to adopt an on-call rotation (often referred to as pager duty). In on-call rotations, designated team members handle all first-line incident responses, and they resolve or delegate responsibilities based on predetermined incident thresholds. 4. Determine thresholds Determine incident thresholds for alert conditions For each of your applications: Identify the thresholds for what is officially considered an incident. Make sure each set of threshold criteria is context-dependent. Document incident evaluation and known remediation procedures in runbooks. Include links to your runbooks when you define conditions and thresholds for your alert policies. For instance, a certain alert condition may be dismissable during low-traffic periods but require active remediation during peak hours. 5. Set notification channels Ensure alerts have auditable notification channels Make sure that communications during critical incidents take place in easily accessible and highly visible channels. A group chat room dedicated to incident communication is usually a great choice. This allows all stakeholders to participate or observe and provides a chronology of notifications, key decisions, and actions for postmortem analysis. Use any of the available notification channels in New Relic Alerts. For example, to set up a notification channel in Slack: Make sure your organization has completed New Relic's integration requirements with Slack. In the Slack app, select the dropdown in the top-left corner of the app, and select Customize Slack. Click Configure apps. From the list of app integrations, select New Relic. Expand the instructions for New Relic Alerts, and follow the steps to configure notifications from New Relic. 6. Automate resolution Automate triage and resolution steps Automation of simple or repeatable incident response tasks will increase efficiency and minimize the impact of incidents. With proper automation in place, you can disable or isolate faulty application components as soon as an alert threshold is reached, rather than after a notification has been issued. For example, a team managing an application for a digital media company wants to be able to remove commenting abilities from the website if the system has errors. In this case, they could: Add an endpoint to their front-end web application that will toggle a feature flag enabling or disabling the UI components associated with posting comments on an article. Create an alert policy with a threshold set on the sustained error rate in the commenting service. Assign a webhook notification channel that will send a POST request to this endpoint, as well as to the standard team notification channels. In this scenario, errors in the commenting system will trigger the webhook and remove the commenting UI from the website. Users can still use core functionality of the site without seeing errors generated by the commenting service. The application will maintain a stable but degraded state, allowing the team to focus on recovery without the pressure of preventing users from accessing the site. You can also use webhooks to create issues and action items in ticketing systems that have REST APIs, such as Zendesk. Use New Relic Alerts to create a webhook notification channel, and customize the webhook payload as needed. New Relic also provides integrations for common ticketing systems. You can use any of these integrations to file tickets from New Relic APM. 7. Establish reviews Establish a post mortem process After the incident has been resolved, key stakeholders and participants must capture accurate and thorough documentation of the incident. At a minimum, we recommend that the retro documentation includes: A root cause analysis A chronology and summary of remediation steps and their result, whether they were successful or not A measure of the impact to the business in terms of user experience and financial losses, if possible Recommendations for system or feature improvements to prevent a recurrence Recommendations for process and communication improvements Store post mortem reports in a highly visible, searchable repository, such as a shared drive folder or wiki. Culturally, it's essential that this process focuses on constructive learning and improvement rather than punishment or blame. Example post mortem report Here is a brief example of a post mortem report: Post mortem Comments Date March 1, 2018 Executive summary From approximately 1:45PM until 2:30PM, users could not add items to their carts, which prevented any checkouts from occurring during the incident period. Root cause We determined that a change was made to the CSS rules on the product detail page that effectively disabled the Add to cart button. Timeline 1:50PM: Successful checkouts < 10 for 5 minutes alert triggered; assigned to Alice. 1:55PM: After reviewing the ecommerce team dashboard, Alice determined that the threshold was breached immediately following a deploy by Bob. She notified him of the incident. 2:00PM: Alice and Bob began troubleshooting. Attempts at recreating the issue in production were successful. 2:20PM: Bob determined that his change to the CSS on the product detail page disabled the Add to cart button. He deployed a hotfix. 2:30PM: Functionality was restored and the incident was resolved. Impact No checkouts were completed during the duration of the incident. Our typical revenue for a Thursday during this timeframe is $30,000. Recommendations We have been discussing implementing New Relic Synthetics for awhile now. If we had a Synthetic check on the checkout process, this issue would have been detected immediately. We should also implement more thorough unit tests in the front-end web app. 8. Fine-tune process Fine-tune alerts and thresholds As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. When rolling out new code or modifications that could negatively impact performance over a period of time, loosen your threshold conditions to allow for these short-term changes. For instance, we recommend using pre-established baselines and thresholds to increase efficiency during high-impact times for your business, such as annual events and major releases. Fine-tuning gives you the flexibility you need to increase efficiencies and extend your notification channels. As noted earlier, we recommend you start with a group chat service when you first establish notifications. Once you've identified other tools you'd like to integrate with, set up a notification channel to maintain your momentum. Tools such as xMatters and PagerDuty provide popular integrations, but don't overlook simple methods, such as webhooks. The goal is to continuously improve your alerting scheme. Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use the New Relic query language and the Insights query API to create your dashboards. For detailed instructions, check out Sending alerts data to Insights. The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you're using. Expert tip In addition to instrumenting and measuring application and infrastructure metrics, mature DevOps organizations often measure and optimize the efficiency of incident response processes. For example, you can use webhooks to send alert events to New Relic Insights. This allows you to supplement your team dashboards with New Relic Alerts data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.02258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Example questions and KPI <em>solutions</em>",
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " Fine-tune alerts and thresholds As you use <em>New</em> <em>Relic</em> to <em>optimize</em> <em>your</em> application and infrastructure performance, tighten <em>your</em> <em>New</em> <em>Relic</em> Alerts policy conditions to keep pace with <em>your</em> improved performance. When rolling out <em>new</em> code or modifications that could negatively impact performance over"
      },
      "id": "603ebf0be7b9d2b3982a07a9"
    },
    {
      "sections": [
        "Customer experience improvement: Track experience indicators",
        "1. Use custom attributes to associate performance data",
        "2. Create dashboards with performance and business metrics",
        "Tip",
        "3. Share dashboards across departments",
        "4. Use data to separate performance by cohort and debug issues at the customer level"
      ],
      "title": "Customer experience improvement: Track experience indicators",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "6c4c1f69fa347ab2ada2360a61a559803a2f7ce5",
      "image": "https://docs.newrelic.com/static/65dadbef1fe9c07817f7ead13e12e05e/302a4/Insights-catalyst-dashbaord-1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/customer-experience-improvement-track-experience-indicators/",
      "published_at": "2021-07-09T15:10:29Z",
      "updated_at": "2021-07-09T15:10:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This tutorial covers methods to identify and track the key indicators of customer experience and clarifies the effects of application and infrastructure performance on your business. A clear understanding of what creates a successful customer experience can help modern software teams become more efficient and boost productivity. An efficient, well-functioning IT culture helps organizations make rapid, frequent releases and product changes. A strong culture also democratizes data beyond the typical backend users, making it available to groups such as customer service, support, sales, and marketing. However, this information enablement is useful only if it serves to optimize customer experience. The four steps outlined here are designed to help you leverage the data you collect to make the greatest possible improvements in your organization’s digital customer experience. 1. Use custom attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with your application. In New Relic, you collect this data with custom attributes. If you plan to collect this information in both the frontend and backend, be sure to forward custom attributes from APM to browser. Here are some common attributes to collect: User ID Organization or customer ID A/B testing cohort value High-value customer indicator Purchase value or product IDs (for e-commerce) If you’ve completed the Establish objectives and baselines tutorials, consider what service-level objectives (SLOs) or key metrics you defined in those stages. New Relic recommends including attributes like the ones listed above to measure the impact of your changes and optimizations at a customer level—rather than just measuring pure performance. 2. Create dashboards with performance and business metrics Using the attributes collected in Step 1, build dashboards to examine the impact of performance issues on your users. insights.newrelic.com > Dashboards For example, if you were collecting a custom username attribute, you could use NRQL queries like these to create your widgets for your New Relic Insights dashboard: Number of errors by username: SELECT count(*) FROM TransactionError FACET username Copy Median response time by username: SELECT percentile(duration,50) FROM Transaction FACET username Copy Total purchase value in transactions with errors: SELECT sum(purchaseTotal) FROM TransactionError FACET username Copy Tip If you include a FACET clause in your queries, you’ll be able to click into metric results to see corresponding change in the performance data. For more information on faceting, see Linking Between Dashboards to Drill Into Your Data. 3. Share dashboards across departments Dashboards, data, and metrics that nobody looks at or knows about might as well not exist. When considering how, or with whom, to share your dashboards, consider the following questions: Which teams are responsible for applications that have high levels of end-user interaction? What non-engineering teams could benefit from this information? Customer support: Could customer issues be resolved faster? Product/engineering: Could the product team make more informed roadmap decisions? Customer success: Can this data be used to make customers more successful? Are there other teams that can benefit from cohort analysis that includes performance metrics? 4. Use data to separate performance by cohort and debug issues at the customer level After you create your dashboards, use them to scope issues affecting particular customers or sets of customers. For example, the following widget shows which apps have errors for a particular user: insights.newrelic.com > Dashboards Use attributes that track user and performance to set alerts on high priority users or customers. For example, you could include a WHERE clause in your NRQL queries to scope the results to a set of user IDs or customer IDs. Set alerts on any performance or business metric that is tied to these attributes. See NRQL alerts will change how you think about using New Relic data for more information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 429.2118,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with <em>your</em> application. In <em>New</em> <em>Relic</em>, you collect this data"
      },
      "id": "603ebeb964441f6e314e88a1"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/analyze-distributed-systems": [
    {
      "sections": [
        "Set proactive alerts and align teams, tools, and processes for incident response",
        "Prerequisites",
        "1. Define policies",
        "Example questions and KPI solutions",
        "2. Set specific alerts",
        "3. Identify groups",
        "4. Determine thresholds",
        "5. Set notification channels",
        "6. Automate resolution",
        "7. Establish reviews",
        "Example post mortem report",
        "8. Fine-tune process",
        "Expert tip"
      ],
      "title": "Set proactive alerts and align teams, tools, and processes for incident response ",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "454d902dd8ff1ace1070b7ad42489dda5405845c",
      "image": "https://docs.newrelic.com/static/ecb7124a85903b58a0fbb042ddb29cc6/c483d/proactive-baseline-alerts-devops_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/set-proactive-alerts-align-teams-tools-processes-incident-response/",
      "published_at": "2021-07-09T16:00:00Z",
      "updated_at": "2021-07-09T16:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term alerting often carries some negative connotations: many developers correlate alerting with errors, mistakes, and ongoing issues. However, developers who are proactive about alerting, know they don't have to stare at dashboards all day because effective alerts tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Further, a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or environment. With proactive alerting, you'll decrease user-reported incidents, and your teams will spend less time firefighting and more time deploying significant changes to your product. After you define the right alerts, proper incident orchestration aligns your teams, tools, and processes to prepare for incidents and outages in your software. The goal is to provide your teams a predictable framework and process to: Maximize efficiency in communication and effort. Minimize the overall impact to your business. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the Establish objectives and baselines tutorial. Optionally added custom attributes and events. 1. Define policies Define required alerting policies based on SLOs. A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples of service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, 95% of requests completed within 250 ms AND availability is 99.99%), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it's meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than 0.20%. However, not every SLO needs to become an alert. A strong alerting strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alerting strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” Example questions and KPI solutions For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use browser monitoring and APM to alert on site availability. How's our underlying infrastructure? Set KPIs for key hardware, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie them to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site's availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don't yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we've set both a warning and a violation for throughput: alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier, which can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic across five different servers. You can set an alert based on a NRQL query and receive a notification if any server starts getting significantly more or less traffic than the other servers. Here is an example chart: And here's a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups Identify groups to alert, set broadcasting methods, and assign first responders to team dashboards Alerting without the proper broadcasting methods leaves you vulnerable. Your alerting strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack or PagerDuty). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the types of alerts that warrant waking someone up. Recommendation: For each team dashboard, make sure: It has an owner who assumes responsibility for the health of the applications and features it monitors. There is no ambiguity about who is responsible for attending to and resolving an alert condition. This policy will vary between organizations depending on size, structure, and culture. For example, some teams may prefer to assign dashboards and alerts based on de-facto features or application ownership. Other teams may prefer to adopt an on-call rotation (often referred to as pager duty). In on-call rotations, designated team members handle all first-line incident responses, and they resolve or delegate responsibilities based on predetermined incident thresholds. 4. Determine thresholds Determine incident thresholds for alert conditions For each of your applications: Identify the thresholds for what is officially considered an incident. Make sure each set of threshold criteria is context-dependent. Document incident evaluation and known remediation procedures in runbooks. Include links to your runbooks when you define conditions and thresholds for your alert policies. For instance, a certain alert condition may be dismissable during low-traffic periods but require active remediation during peak hours. 5. Set notification channels Ensure alerts have auditable notification channels Make sure that communications during critical incidents take place in easily accessible and highly visible channels. A group chat room dedicated to incident communication is usually a great choice. This allows all stakeholders to participate or observe and provides a chronology of notifications, key decisions, and actions for postmortem analysis. Use any of the available notification channels in New Relic Alerts. For example, to set up a notification channel in Slack: Make sure your organization has completed New Relic's integration requirements with Slack. In the Slack app, select the dropdown in the top-left corner of the app, and select Customize Slack. Click Configure apps. From the list of app integrations, select New Relic. Expand the instructions for New Relic Alerts, and follow the steps to configure notifications from New Relic. 6. Automate resolution Automate triage and resolution steps Automation of simple or repeatable incident response tasks will increase efficiency and minimize the impact of incidents. With proper automation in place, you can disable or isolate faulty application components as soon as an alert threshold is reached, rather than after a notification has been issued. For example, a team managing an application for a digital media company wants to be able to remove commenting abilities from the website if the system has errors. In this case, they could: Add an endpoint to their front-end web application that will toggle a feature flag enabling or disabling the UI components associated with posting comments on an article. Create an alert policy with a threshold set on the sustained error rate in the commenting service. Assign a webhook notification channel that will send a POST request to this endpoint, as well as to the standard team notification channels. In this scenario, errors in the commenting system will trigger the webhook and remove the commenting UI from the website. Users can still use core functionality of the site without seeing errors generated by the commenting service. The application will maintain a stable but degraded state, allowing the team to focus on recovery without the pressure of preventing users from accessing the site. You can also use webhooks to create issues and action items in ticketing systems that have REST APIs, such as Zendesk. Use New Relic Alerts to create a webhook notification channel, and customize the webhook payload as needed. New Relic also provides integrations for common ticketing systems. You can use any of these integrations to file tickets from New Relic APM. 7. Establish reviews Establish a post mortem process After the incident has been resolved, key stakeholders and participants must capture accurate and thorough documentation of the incident. At a minimum, we recommend that the retro documentation includes: A root cause analysis A chronology and summary of remediation steps and their result, whether they were successful or not A measure of the impact to the business in terms of user experience and financial losses, if possible Recommendations for system or feature improvements to prevent a recurrence Recommendations for process and communication improvements Store post mortem reports in a highly visible, searchable repository, such as a shared drive folder or wiki. Culturally, it's essential that this process focuses on constructive learning and improvement rather than punishment or blame. Example post mortem report Here is a brief example of a post mortem report: Post mortem Comments Date March 1, 2018 Executive summary From approximately 1:45PM until 2:30PM, users could not add items to their carts, which prevented any checkouts from occurring during the incident period. Root cause We determined that a change was made to the CSS rules on the product detail page that effectively disabled the Add to cart button. Timeline 1:50PM: Successful checkouts < 10 for 5 minutes alert triggered; assigned to Alice. 1:55PM: After reviewing the ecommerce team dashboard, Alice determined that the threshold was breached immediately following a deploy by Bob. She notified him of the incident. 2:00PM: Alice and Bob began troubleshooting. Attempts at recreating the issue in production were successful. 2:20PM: Bob determined that his change to the CSS on the product detail page disabled the Add to cart button. He deployed a hotfix. 2:30PM: Functionality was restored and the incident was resolved. Impact No checkouts were completed during the duration of the incident. Our typical revenue for a Thursday during this timeframe is $30,000. Recommendations We have been discussing implementing New Relic Synthetics for awhile now. If we had a Synthetic check on the checkout process, this issue would have been detected immediately. We should also implement more thorough unit tests in the front-end web app. 8. Fine-tune process Fine-tune alerts and thresholds As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. When rolling out new code or modifications that could negatively impact performance over a period of time, loosen your threshold conditions to allow for these short-term changes. For instance, we recommend using pre-established baselines and thresholds to increase efficiency during high-impact times for your business, such as annual events and major releases. Fine-tuning gives you the flexibility you need to increase efficiencies and extend your notification channels. As noted earlier, we recommend you start with a group chat service when you first establish notifications. Once you've identified other tools you'd like to integrate with, set up a notification channel to maintain your momentum. Tools such as xMatters and PagerDuty provide popular integrations, but don't overlook simple methods, such as webhooks. The goal is to continuously improve your alerting scheme. Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use the New Relic query language and the Insights query API to create your dashboards. For detailed instructions, check out Sending alerts data to Insights. The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you're using. Expert tip In addition to instrumenting and measuring application and infrastructure metrics, mature DevOps organizations often measure and optimize the efficiency of incident response processes. For example, you can use webhooks to send alert events to New Relic Insights. This allows you to supplement your team dashboards with New Relic Alerts data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.02228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Example questions and KPI <em>solutions</em>",
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " Fine-tune alerts and thresholds As you use <em>New</em> <em>Relic</em> to <em>optimize</em> <em>your</em> application and infrastructure performance, tighten <em>your</em> <em>New</em> <em>Relic</em> Alerts policy conditions to keep pace with <em>your</em> improved performance. When rolling out <em>new</em> code or modifications that could negatively impact performance over"
      },
      "id": "603ebf0be7b9d2b3982a07a9"
    },
    {
      "sections": [
        "Customer experience improvement: Track experience indicators",
        "1. Use custom attributes to associate performance data",
        "2. Create dashboards with performance and business metrics",
        "Tip",
        "3. Share dashboards across departments",
        "4. Use data to separate performance by cohort and debug issues at the customer level"
      ],
      "title": "Customer experience improvement: Track experience indicators",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "6c4c1f69fa347ab2ada2360a61a559803a2f7ce5",
      "image": "https://docs.newrelic.com/static/65dadbef1fe9c07817f7ead13e12e05e/302a4/Insights-catalyst-dashbaord-1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/customer-experience-improvement-track-experience-indicators/",
      "published_at": "2021-07-09T15:10:29Z",
      "updated_at": "2021-07-09T15:10:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This tutorial covers methods to identify and track the key indicators of customer experience and clarifies the effects of application and infrastructure performance on your business. A clear understanding of what creates a successful customer experience can help modern software teams become more efficient and boost productivity. An efficient, well-functioning IT culture helps organizations make rapid, frequent releases and product changes. A strong culture also democratizes data beyond the typical backend users, making it available to groups such as customer service, support, sales, and marketing. However, this information enablement is useful only if it serves to optimize customer experience. The four steps outlined here are designed to help you leverage the data you collect to make the greatest possible improvements in your organization’s digital customer experience. 1. Use custom attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with your application. In New Relic, you collect this data with custom attributes. If you plan to collect this information in both the frontend and backend, be sure to forward custom attributes from APM to browser. Here are some common attributes to collect: User ID Organization or customer ID A/B testing cohort value High-value customer indicator Purchase value or product IDs (for e-commerce) If you’ve completed the Establish objectives and baselines tutorials, consider what service-level objectives (SLOs) or key metrics you defined in those stages. New Relic recommends including attributes like the ones listed above to measure the impact of your changes and optimizations at a customer level—rather than just measuring pure performance. 2. Create dashboards with performance and business metrics Using the attributes collected in Step 1, build dashboards to examine the impact of performance issues on your users. insights.newrelic.com > Dashboards For example, if you were collecting a custom username attribute, you could use NRQL queries like these to create your widgets for your New Relic Insights dashboard: Number of errors by username: SELECT count(*) FROM TransactionError FACET username Copy Median response time by username: SELECT percentile(duration,50) FROM Transaction FACET username Copy Total purchase value in transactions with errors: SELECT sum(purchaseTotal) FROM TransactionError FACET username Copy Tip If you include a FACET clause in your queries, you’ll be able to click into metric results to see corresponding change in the performance data. For more information on faceting, see Linking Between Dashboards to Drill Into Your Data. 3. Share dashboards across departments Dashboards, data, and metrics that nobody looks at or knows about might as well not exist. When considering how, or with whom, to share your dashboards, consider the following questions: Which teams are responsible for applications that have high levels of end-user interaction? What non-engineering teams could benefit from this information? Customer support: Could customer issues be resolved faster? Product/engineering: Could the product team make more informed roadmap decisions? Customer success: Can this data be used to make customers more successful? Are there other teams that can benefit from cohort analysis that includes performance metrics? 4. Use data to separate performance by cohort and debug issues at the customer level After you create your dashboards, use them to scope issues affecting particular customers or sets of customers. For example, the following widget shows which apps have errors for a particular user: insights.newrelic.com > Dashboards Use attributes that track user and performance to set alerts on high priority users or customers. For example, you could include a WHERE clause in your NRQL queries to scope the results to a set of user IDs or customer IDs. Set alerts on any performance or business metric that is tied to these attributes. See NRQL alerts will change how you think about using New Relic data for more information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 429.2115,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with <em>your</em> application. In <em>New</em> <em>Relic</em>, you collect this data"
      },
      "id": "603ebeb964441f6e314e88a1"
    },
    {
      "sections": [
        "Manage your containerized environment",
        "1. Update to latest infrastructure agent and enable Kubernetes integration",
        "2. Leverage the Kubernetes cluster explorer to further explore cluster performance and health",
        "3. Navigate out-of-the-box dashboards to analyze historical metrics of your Kubernetes environment",
        "4. Monitor applications running in Kubernetes with APM",
        "Correlate your Kubernetes back-end with end-user experience using browser and synthetic monitoring",
        "6. Bring teams together with dashboards tailored to specific business use cases and KPIs",
        "Learn more"
      ],
      "title": "Manage your containerized environment",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "71ba4468ed7d078021ccd705c78e72cfb5e92b5f",
      "image": "https://docs.newrelic.com/static/f744b0e1c8aac86e63f46a5798df58ae/c1b63/cont_environment01.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/manage-your-containerized-environment/",
      "published_at": "2021-07-09T10:36:00Z",
      "updated_at": "2021-07-09T10:36:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Widespread adoption of containers has changed the way applications are written and deployed. Container orchestration technologies such as Kubernetes are making it easier for teams to schedule, deploy, and manage their containerized applications. But challenges still exist that require teams to rethink their environment and application monitoring strategies: Challenge 1: Containers are ephemeral by nature. Knowing the containers or pod or node (host) where the application is currently running is not necessarily an indication of where it was running 5, 15, or 30 minutes ago when the issue occurred. Containers are deployed in dynamic, constantly evolving environments that require a modern monitoring approach. Challenge 2: Often, organizations are adopting containers as they break down monolithic applications into multiple microservices. This new approach introduces new complexity to the system and the sheer scale and dimensionality of containers is hard to conceptualize in an easy-to-understand format. Challenge 3: Delivering a differentiated end-user experience is a key initiative for all organizations, and containers are being adopted to help organizations release better software, faster. But with this tremendous opportunity also comes risk, because every time a new container is deployed, the cluster is impacted. Organizations need context into how infrastructure changes impact the application stack, and how changes to both the infrastructure and application stack affect the end-user experience. Getting all of this data in real-time in a digestible format is a significant challenge in distributed, containerized environments. The New Relic platform offers customers both ease of use and ease of deployment for containerized Kubernetes environments. With a few clicks you have the data and confidence to move forward intelligently. These six steps illustrate how to use the New Relic One platform to manage your containers and how they are scheduled: 1. Update to latest infrastructure agent and enable Kubernetes integration To get started, you'll need to deploy the latest Infrastructure agent onto a Kubernetes cluster with a DaemonSet. Leveraging DaemonSets is vital in dynamic, containerized environments, because when a new node is deployed or the cluster scales up or down, the DaemonSet ensures the New Relic agent is running on these new nodes. In addition, to build a complete picture of your Kubernetes environment, New Relic aggregates data from many resources, including Kube-state metrics. New Relic's “Kubernetes aware” approach makes it easy for Kubernetes to do its job as an orchestrator without missing a single node, cluster, or event. 2. Leverage the Kubernetes cluster explorer to further explore cluster performance and health Once the Kubernetes integration is installed, you can access the New Relic Kubernetes cluster explorer, which offers a differentiated, intuitive way to visualize the health and performance of Kubernetes clusters. It applies advanced capabilities to filter, sort, and search for Kubernetes entities, helping teams understand the relationships and dependencies within an environment. It's a powerful and innovative solution to the challenges associated with running Kubernetes at massive scale. 3. Navigate out-of-the-box dashboards to analyze historical metrics of your Kubernetes environment Above and beyond what the cluster explorer provides, New Relic provides out-of-the-box dashboards that allow customers to analyze performance and operating metrics of their Kubernetes environments. Key metrics include the number of containers, resource consumption, pending pods, out of memory (OOM) kills, and stuck pods. These metrics may be particularly relevant to Kubernetes administrators who require reliable, up-to-date information on resource consumption against pre-set thresholds. Access these dashboards directly from the cluster explorer where you can first visually explore your cluster and then use filters to drive down into specific dashboards that match that filter. 4. Monitor applications running in Kubernetes with APM One advantage of New Relic's Infrastructure agent being application-aware is that the cluster explorer is automatically aware of New Relic agents that are deployed on new applications. To fully exploit these capabilities, we recommend monitoring all existing and future containerized applications running in Kubernetes by installing the APM agent on them. Starting again from the cluster explorer, you can dig into what's happening in your applications from the context of the Kubernetes cluster. This gives you the ability to intuitively correlate your infrastructure and applications and begin analytically troubleshooting across the stack. Cloud-native applications use many interconnected services. The cluster explorer will correlate the application and link to its distributed tracings. In complex systems the ability to trace and identify pathways and latency bottlenecks are not optional. Correlate your Kubernetes back-end with end-user experience using browser and synthetic monitoring If you are orchestrating an end-user facing application, New Relic allows you to view the end-to-end impact your infrastructure and services have on your customer experience. We tackle end-user management in two ways: With synthetic monitoring, you can track application availability and performance from a wide variety of global locations visualizing if customer experience is impacted due to geography. With browser and mobile, we recommend monitoring such KPIs as load time and availability. Marrying end-user data with metrics and dashboards provided by the cluster explorer enables operators, administrators, app developers, and business personnel to align on common initiatives. 6. Bring teams together with dashboards tailored to specific business use cases and KPIs With dashboards, you can build custom visualizations from an end-to-end service perspective to analyze the cluster, pods, application, and end-user experience in one clean visual display. By using New Relic's dashboards, cross-organizational teams can align to share a common language and single source of truth, helping them make better decisions and drive business impact. The top two rows of this sample dashboard visualize various aspects of a Kubernetes environment while the third row illustrates valuable information regarding the applications that are deployed to this cluster. The bottom row displays the end-user viewpoint. Learn more Actively, where we enable availability monitoring for one user in one location with synthetic monitoring Passively, where you can analyze a macro view of all users across all geographies with browser monitoring and mobile monitoring. Bring teams together with dashboards tailored to specific business use cases and KPIs Kubernetes Monitoring Guide",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 424.81934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> containerized <em>environment</em>",
        "sections": "Manage <em>your</em> containerized <em>environment</em>",
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": ", to build a complete picture of <em>your</em> Kubernetes <em>environment</em>, <em>New</em> <em>Relic</em> aggregates data from many resources, including Kube-state metrics. <em>New</em> <em>Relic</em>&#x27;s “Kubernetes aware” approach makes it easy for Kubernetes to do its job as an orchestrator without missing a single node, cluster, or event. 2. Leverage"
      },
      "id": "603ebf49196a670d96a83d81"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/customer-experience-improvement-track-experience-indicators": [
    {
      "sections": [
        "Analyze distributed systems",
        "1. Identify high-priority areas to monitor",
        "2. Instrument to get the visibility you require",
        "3. Create dashboards",
        "4. Dig deeper with distributed tracing",
        "5. Annotate message queues with distributed tracing payload APIs",
        "Example annotated message queue",
        "6. Annotate and tag traces with custom attributes",
        "Tip",
        "7. Leverage Synthetics to get a high-level view of system health",
        "For more help"
      ],
      "title": "Analyze distributed systems",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "af1cf5a80f8254c90509e562fb68a6ded2f7207f",
      "image": "https://docs.newrelic.com/static/838e50badd634f1f188cf821785f6696/2cffa/APm_distributed-tracing-catalyst-TWO.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/analyze-distributed-systems/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a monolithic application, a simple stack trace can contain enough diagnostic data to determine the root cause of a code defect. But cloud computing and microservices have blurred the lines between software and infrastructure; in modern architectures, requests are distributed across many smaller services—often with ephemeral lifespans—hosted in both on-premise and cloud environments. Spotting code defects becomes much more complex. APM's distributed tracing automatically helps teams troubleshoot such distributed systems. Distributed traces are just one component of a well-monitored system. You need a holistic view of your distributed system, especially when tracking the root cause of a defect, as there are volumes of data to evaluate and understand. When managing a microservices environment, it's critical that you have the capability to spot bottlenecks and problem spans quickly so that you don't compromise your mean-time-to-resolution (MTTR) or end-user experience. At New Relic, we understand these challenges inherently. In our journey, we've transitioned from a Ruby monolith to a multi-language distributed environment built on more than 300 microservices, for which we average 50 code deploys a day. Such challenges inform both how we've built and how we monitor New Relic. Use the New Relic platform to translate your data into relevant insights, so you can collaborate around a common framework to build context and quickly optimize and troubleshoot your complex, distributed systems. 1. Identify high-priority areas to monitor Distributed systems are complex. Before engaging with the New Relic platform, we recommend that you identify the most critical areas of your systems to observe, and focus on instrumenting those high-priority areas first. Google's SRE handbook suggests monitoring the \"four golden signals\": traffic, latency, errors, and saturation, as shown in the following dashboard: Dashboards: Visualize key areas to monitor with dashboards. Too often, teams monitor what is either 1) easy to measure or 2) interpretable. Avoid this fallacy. When making choices about what to monitor, involve product managers and other stakeholders from your organization. Your goal is to monitor what matters to your business, not to overload your teams with noise. 2. Instrument to get the visibility you require Once you've identified your key priorities, instrument the appropriate parts of your system with the New Relic platform. Monitor your web apps with APM. See compatibility and requirements for New Relic agents and products to learn precise compatibility details for each supported language and then install the APM agent on your application stack. Steps for installing APM agents vary based on language. Enable distributed tracing for APM, which will affect some existing APM features. If you're accustomed to using APM without distributed tracing, read the transition guide before you enable this feature. Monitor your compute resources with infrastructure. See compatibility and requirements for infrastructure monitoring for supported operating systems and environments. You can also instrument other products and services with on-host integrations. Monitor your front-end experience with mobile and browser. 3. Create dashboards Use dashboards to get an overview of your entire system and baseline performance, so you can better understand how the components work together. Insights provides a single framework for aligning disparate teams around relevant data. Approach this first build as your launching point, giving your teams something to react to as you begin to ascribe context to your system. You should continue to build and iterate your dashboards as you analyze, troubleshoot, and optimize your distributed system. Even after you have a basic understanding of your system, use dashboards to inform the decisions you make going forward. Dashboards provide central repository of truth, allowing all stakeholders to build context about the health of your system. Here is an example of a query that displays the slowest applications. SELECT percentile(duration, 99) as 'Slowest duration' FROM Transaction FACET name Copy Using this query you can focus on the slowest application to dig deeper: After running the query, dashboards displays the slowest durations. 4. Dig deeper with distributed tracing After you have basic instrumentation and contextual dashboards in place, you can begin to dig deeper to troubleshoot or optimize your system. A differentiated feature in New Relic One's Global Distributed Tracing is that you can come in with vague context for what you're investigating and search across all accounts and traces to get down to the actual user interactions that have those attributes somewhere in their trace. You no longer must begin with the application or specific entity to search for traces that include that application. For example, start with an analysis of your complex service calls, using the distributed tracing UI to: View a scatter plot chart showing the frequency, duration, and other facets of your distributed traces Group traces by root entry, service, service entry, or traces with errors View a trace list Filter specific traces to meet certain parameters You'll likely discover that you want to take the analysis one step further by annotating your traces with information that adds context to your troubleshooting, like User ID. You can do this in New Relic using custom attributes. one.newrelic.com > APM > Distributed tracing: use the distributed tracing UI to monitor and analyze modern distributed systems. 5. Annotate message queues with distributed tracing payload APIs To see connections between services in some environments—for example, in a system that relies heavily on queues—you may need to do some manual instrumentation using the distributed tracing payload APIs to ensure you're propagating the payload. This gives agents the necessary context to create spans with the right correlation; you'll see end-to-end traces for all linked services, including those that cross through the queue. Example annotated message queue For example: Start a transaction. Create the distributed tracing payload on the producer service within a New Relic transaction. As part of the message, add the distributed tracing payload. ​​newrelic.setTransactionName(\"Send Message\") // Create SQS service object var sqs = new AWS.SQS({apiVersion: '2012-11-05'}); var transactionHandle = newrelic.getTransaction(); var payload = transactionHandle.createDistributedTracePayload(); var jsonPayload = payload.text(); //add the jsonPayload as a MessageAttribute var params = { DelaySeconds: 10, MessageAttributes: { \"Testing\": { DataType: \"String\", StringValue: \"123\" }, \"TraceContext\": { DataType: \"String\", StringValue: jsonPayload } }, MessageBody: \"Testing 123\", QueueUrl: \"https://sqs.us-west-2.amazonaws.com/408155283954/sqs-testing\" }; Copy With the context of a transaction, receive the payload on the consumer service. sqs.receiveMessage(params, function(err, data) { if (err) { console.log(\"Receive Error\", err); } else if (data && data.Messages) { console.log(\"trace context:\") var traceContext = data.Messages[0].MessageAttributes.TraceContext.StringValue; if (traceContext != \"\") { var transactionHandle = newrelic.getTransaction(); transactionHandle.acceptDistributedTracePayload(traceContext); } Copy 6. Annotate and tag traces with custom attributes We recommend that you use custom attributes to decorate events with additional information for better tracing. For example, by adding key-value pairs, you can attach a user ID to trace a specific user through the call stack and review failing requests to determine if that user is having an unusually poor experience. We recommend adding custom attributes based on your use case; for example, if your instrumenting an order management system, you could add an order number custom attribute to your traces. To add custom attributes, you must first enable them for your agent, and then make an API call to record the attribute. Tip For more agent-specific information on collecting custom attributes, see Collect custom attributes sqs.sendMessage(params, function(err, data) { if (err) { res.send(\"Error: \"+ err); } else { res.send(\"Success! Message ID: \"+ data.MessageId); newrelic.addCustomAttribute(\"Message ID\", data.MessageId) } }); Copy 7. Leverage Synthetics to get a high-level view of system health In complex, distributed systems, you need to track and monitor many signals. Sometimes it may be that no one signal is concerning, yet your whole system is behaving anomalously. To get a complete picture, it's critical to analyze symptomatic data in tandem with system-level data. Synthetics allows you to interact with the entire system as an external user would, giving your teams high-level checks for performance and user experience. These external checks help you understand if the entire system is doing what you want regardless of what specific signals may indicate. For more help For more tips and best practices on distributed tracing and custom attributes, see the following: Distributed Tracing Anomaly Detection: A Faster, Easier Way to Troubleshoot Microservices Environments Introduction to distributed tracing Collect custom attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.1127,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " that you don&#x27;t compromise <em>your</em> mean-time-to-resolution (MTTR) or end-user experience. At <em>New</em> <em>Relic</em>, we understand these challenges inherently. In our journey, we&#x27;ve transitioned from a Ruby monolith to a multi-language distributed <em>environment</em> built on more than 300 microservices, for which we average"
      },
      "id": "603ebd8264441f02694e887f"
    },
    {
      "sections": [
        "Set proactive alerts and align teams, tools, and processes for incident response",
        "Prerequisites",
        "1. Define policies",
        "Example questions and KPI solutions",
        "2. Set specific alerts",
        "3. Identify groups",
        "4. Determine thresholds",
        "5. Set notification channels",
        "6. Automate resolution",
        "7. Establish reviews",
        "Example post mortem report",
        "8. Fine-tune process",
        "Expert tip"
      ],
      "title": "Set proactive alerts and align teams, tools, and processes for incident response ",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "454d902dd8ff1ace1070b7ad42489dda5405845c",
      "image": "https://docs.newrelic.com/static/ecb7124a85903b58a0fbb042ddb29cc6/c483d/proactive-baseline-alerts-devops_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/set-proactive-alerts-align-teams-tools-processes-incident-response/",
      "published_at": "2021-07-09T16:00:00Z",
      "updated_at": "2021-07-09T16:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term alerting often carries some negative connotations: many developers correlate alerting with errors, mistakes, and ongoing issues. However, developers who are proactive about alerting, know they don't have to stare at dashboards all day because effective alerts tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Further, a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or environment. With proactive alerting, you'll decrease user-reported incidents, and your teams will spend less time firefighting and more time deploying significant changes to your product. After you define the right alerts, proper incident orchestration aligns your teams, tools, and processes to prepare for incidents and outages in your software. The goal is to provide your teams a predictable framework and process to: Maximize efficiency in communication and effort. Minimize the overall impact to your business. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the Establish objectives and baselines tutorial. Optionally added custom attributes and events. 1. Define policies Define required alerting policies based on SLOs. A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples of service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, 95% of requests completed within 250 ms AND availability is 99.99%), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it's meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than 0.20%. However, not every SLO needs to become an alert. A strong alerting strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alerting strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” Example questions and KPI solutions For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use browser monitoring and APM to alert on site availability. How's our underlying infrastructure? Set KPIs for key hardware, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie them to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site's availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don't yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we've set both a warning and a violation for throughput: alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier, which can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic across five different servers. You can set an alert based on a NRQL query and receive a notification if any server starts getting significantly more or less traffic than the other servers. Here is an example chart: And here's a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups Identify groups to alert, set broadcasting methods, and assign first responders to team dashboards Alerting without the proper broadcasting methods leaves you vulnerable. Your alerting strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack or PagerDuty). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the types of alerts that warrant waking someone up. Recommendation: For each team dashboard, make sure: It has an owner who assumes responsibility for the health of the applications and features it monitors. There is no ambiguity about who is responsible for attending to and resolving an alert condition. This policy will vary between organizations depending on size, structure, and culture. For example, some teams may prefer to assign dashboards and alerts based on de-facto features or application ownership. Other teams may prefer to adopt an on-call rotation (often referred to as pager duty). In on-call rotations, designated team members handle all first-line incident responses, and they resolve or delegate responsibilities based on predetermined incident thresholds. 4. Determine thresholds Determine incident thresholds for alert conditions For each of your applications: Identify the thresholds for what is officially considered an incident. Make sure each set of threshold criteria is context-dependent. Document incident evaluation and known remediation procedures in runbooks. Include links to your runbooks when you define conditions and thresholds for your alert policies. For instance, a certain alert condition may be dismissable during low-traffic periods but require active remediation during peak hours. 5. Set notification channels Ensure alerts have auditable notification channels Make sure that communications during critical incidents take place in easily accessible and highly visible channels. A group chat room dedicated to incident communication is usually a great choice. This allows all stakeholders to participate or observe and provides a chronology of notifications, key decisions, and actions for postmortem analysis. Use any of the available notification channels in New Relic Alerts. For example, to set up a notification channel in Slack: Make sure your organization has completed New Relic's integration requirements with Slack. In the Slack app, select the dropdown in the top-left corner of the app, and select Customize Slack. Click Configure apps. From the list of app integrations, select New Relic. Expand the instructions for New Relic Alerts, and follow the steps to configure notifications from New Relic. 6. Automate resolution Automate triage and resolution steps Automation of simple or repeatable incident response tasks will increase efficiency and minimize the impact of incidents. With proper automation in place, you can disable or isolate faulty application components as soon as an alert threshold is reached, rather than after a notification has been issued. For example, a team managing an application for a digital media company wants to be able to remove commenting abilities from the website if the system has errors. In this case, they could: Add an endpoint to their front-end web application that will toggle a feature flag enabling or disabling the UI components associated with posting comments on an article. Create an alert policy with a threshold set on the sustained error rate in the commenting service. Assign a webhook notification channel that will send a POST request to this endpoint, as well as to the standard team notification channels. In this scenario, errors in the commenting system will trigger the webhook and remove the commenting UI from the website. Users can still use core functionality of the site without seeing errors generated by the commenting service. The application will maintain a stable but degraded state, allowing the team to focus on recovery without the pressure of preventing users from accessing the site. You can also use webhooks to create issues and action items in ticketing systems that have REST APIs, such as Zendesk. Use New Relic Alerts to create a webhook notification channel, and customize the webhook payload as needed. New Relic also provides integrations for common ticketing systems. You can use any of these integrations to file tickets from New Relic APM. 7. Establish reviews Establish a post mortem process After the incident has been resolved, key stakeholders and participants must capture accurate and thorough documentation of the incident. At a minimum, we recommend that the retro documentation includes: A root cause analysis A chronology and summary of remediation steps and their result, whether they were successful or not A measure of the impact to the business in terms of user experience and financial losses, if possible Recommendations for system or feature improvements to prevent a recurrence Recommendations for process and communication improvements Store post mortem reports in a highly visible, searchable repository, such as a shared drive folder or wiki. Culturally, it's essential that this process focuses on constructive learning and improvement rather than punishment or blame. Example post mortem report Here is a brief example of a post mortem report: Post mortem Comments Date March 1, 2018 Executive summary From approximately 1:45PM until 2:30PM, users could not add items to their carts, which prevented any checkouts from occurring during the incident period. Root cause We determined that a change was made to the CSS rules on the product detail page that effectively disabled the Add to cart button. Timeline 1:50PM: Successful checkouts < 10 for 5 minutes alert triggered; assigned to Alice. 1:55PM: After reviewing the ecommerce team dashboard, Alice determined that the threshold was breached immediately following a deploy by Bob. She notified him of the incident. 2:00PM: Alice and Bob began troubleshooting. Attempts at recreating the issue in production were successful. 2:20PM: Bob determined that his change to the CSS on the product detail page disabled the Add to cart button. He deployed a hotfix. 2:30PM: Functionality was restored and the incident was resolved. Impact No checkouts were completed during the duration of the incident. Our typical revenue for a Thursday during this timeframe is $30,000. Recommendations We have been discussing implementing New Relic Synthetics for awhile now. If we had a Synthetic check on the checkout process, this issue would have been detected immediately. We should also implement more thorough unit tests in the front-end web app. 8. Fine-tune process Fine-tune alerts and thresholds As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. When rolling out new code or modifications that could negatively impact performance over a period of time, loosen your threshold conditions to allow for these short-term changes. For instance, we recommend using pre-established baselines and thresholds to increase efficiency during high-impact times for your business, such as annual events and major releases. Fine-tuning gives you the flexibility you need to increase efficiencies and extend your notification channels. As noted earlier, we recommend you start with a group chat service when you first establish notifications. Once you've identified other tools you'd like to integrate with, set up a notification channel to maintain your momentum. Tools such as xMatters and PagerDuty provide popular integrations, but don't overlook simple methods, such as webhooks. The goal is to continuously improve your alerting scheme. Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use the New Relic query language and the Insights query API to create your dashboards. For detailed instructions, check out Sending alerts data to Insights. The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you're using. Expert tip In addition to instrumenting and measuring application and infrastructure metrics, mature DevOps organizations often measure and optimize the efficiency of incident response processes. For example, you can use webhooks to send alert events to New Relic Insights. This allows you to supplement your team dashboards with New Relic Alerts data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.02228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Example questions and KPI <em>solutions</em>",
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " Fine-tune alerts and thresholds As you use <em>New</em> <em>Relic</em> to <em>optimize</em> <em>your</em> application and infrastructure performance, tighten <em>your</em> <em>New</em> <em>Relic</em> Alerts policy conditions to keep pace with <em>your</em> improved performance. When rolling out <em>new</em> code or modifications that could negatively impact performance over"
      },
      "id": "603ebf0be7b9d2b3982a07a9"
    },
    {
      "sections": [
        "Manage your containerized environment",
        "1. Update to latest infrastructure agent and enable Kubernetes integration",
        "2. Leverage the Kubernetes cluster explorer to further explore cluster performance and health",
        "3. Navigate out-of-the-box dashboards to analyze historical metrics of your Kubernetes environment",
        "4. Monitor applications running in Kubernetes with APM",
        "Correlate your Kubernetes back-end with end-user experience using browser and synthetic monitoring",
        "6. Bring teams together with dashboards tailored to specific business use cases and KPIs",
        "Learn more"
      ],
      "title": "Manage your containerized environment",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "71ba4468ed7d078021ccd705c78e72cfb5e92b5f",
      "image": "https://docs.newrelic.com/static/f744b0e1c8aac86e63f46a5798df58ae/c1b63/cont_environment01.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/manage-your-containerized-environment/",
      "published_at": "2021-07-09T10:36:00Z",
      "updated_at": "2021-07-09T10:36:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Widespread adoption of containers has changed the way applications are written and deployed. Container orchestration technologies such as Kubernetes are making it easier for teams to schedule, deploy, and manage their containerized applications. But challenges still exist that require teams to rethink their environment and application monitoring strategies: Challenge 1: Containers are ephemeral by nature. Knowing the containers or pod or node (host) where the application is currently running is not necessarily an indication of where it was running 5, 15, or 30 minutes ago when the issue occurred. Containers are deployed in dynamic, constantly evolving environments that require a modern monitoring approach. Challenge 2: Often, organizations are adopting containers as they break down monolithic applications into multiple microservices. This new approach introduces new complexity to the system and the sheer scale and dimensionality of containers is hard to conceptualize in an easy-to-understand format. Challenge 3: Delivering a differentiated end-user experience is a key initiative for all organizations, and containers are being adopted to help organizations release better software, faster. But with this tremendous opportunity also comes risk, because every time a new container is deployed, the cluster is impacted. Organizations need context into how infrastructure changes impact the application stack, and how changes to both the infrastructure and application stack affect the end-user experience. Getting all of this data in real-time in a digestible format is a significant challenge in distributed, containerized environments. The New Relic platform offers customers both ease of use and ease of deployment for containerized Kubernetes environments. With a few clicks you have the data and confidence to move forward intelligently. These six steps illustrate how to use the New Relic One platform to manage your containers and how they are scheduled: 1. Update to latest infrastructure agent and enable Kubernetes integration To get started, you'll need to deploy the latest Infrastructure agent onto a Kubernetes cluster with a DaemonSet. Leveraging DaemonSets is vital in dynamic, containerized environments, because when a new node is deployed or the cluster scales up or down, the DaemonSet ensures the New Relic agent is running on these new nodes. In addition, to build a complete picture of your Kubernetes environment, New Relic aggregates data from many resources, including Kube-state metrics. New Relic's “Kubernetes aware” approach makes it easy for Kubernetes to do its job as an orchestrator without missing a single node, cluster, or event. 2. Leverage the Kubernetes cluster explorer to further explore cluster performance and health Once the Kubernetes integration is installed, you can access the New Relic Kubernetes cluster explorer, which offers a differentiated, intuitive way to visualize the health and performance of Kubernetes clusters. It applies advanced capabilities to filter, sort, and search for Kubernetes entities, helping teams understand the relationships and dependencies within an environment. It's a powerful and innovative solution to the challenges associated with running Kubernetes at massive scale. 3. Navigate out-of-the-box dashboards to analyze historical metrics of your Kubernetes environment Above and beyond what the cluster explorer provides, New Relic provides out-of-the-box dashboards that allow customers to analyze performance and operating metrics of their Kubernetes environments. Key metrics include the number of containers, resource consumption, pending pods, out of memory (OOM) kills, and stuck pods. These metrics may be particularly relevant to Kubernetes administrators who require reliable, up-to-date information on resource consumption against pre-set thresholds. Access these dashboards directly from the cluster explorer where you can first visually explore your cluster and then use filters to drive down into specific dashboards that match that filter. 4. Monitor applications running in Kubernetes with APM One advantage of New Relic's Infrastructure agent being application-aware is that the cluster explorer is automatically aware of New Relic agents that are deployed on new applications. To fully exploit these capabilities, we recommend monitoring all existing and future containerized applications running in Kubernetes by installing the APM agent on them. Starting again from the cluster explorer, you can dig into what's happening in your applications from the context of the Kubernetes cluster. This gives you the ability to intuitively correlate your infrastructure and applications and begin analytically troubleshooting across the stack. Cloud-native applications use many interconnected services. The cluster explorer will correlate the application and link to its distributed tracings. In complex systems the ability to trace and identify pathways and latency bottlenecks are not optional. Correlate your Kubernetes back-end with end-user experience using browser and synthetic monitoring If you are orchestrating an end-user facing application, New Relic allows you to view the end-to-end impact your infrastructure and services have on your customer experience. We tackle end-user management in two ways: With synthetic monitoring, you can track application availability and performance from a wide variety of global locations visualizing if customer experience is impacted due to geography. With browser and mobile, we recommend monitoring such KPIs as load time and availability. Marrying end-user data with metrics and dashboards provided by the cluster explorer enables operators, administrators, app developers, and business personnel to align on common initiatives. 6. Bring teams together with dashboards tailored to specific business use cases and KPIs With dashboards, you can build custom visualizations from an end-to-end service perspective to analyze the cluster, pods, application, and end-user experience in one clean visual display. By using New Relic's dashboards, cross-organizational teams can align to share a common language and single source of truth, helping them make better decisions and drive business impact. The top two rows of this sample dashboard visualize various aspects of a Kubernetes environment while the third row illustrates valuable information regarding the applications that are deployed to this cluster. The bottom row displays the end-user viewpoint. Learn more Actively, where we enable availability monitoring for one user in one location with synthetic monitoring Passively, where you can analyze a macro view of all users across all geographies with browser monitoring and mobile monitoring. Bring teams together with dashboards tailored to specific business use cases and KPIs Kubernetes Monitoring Guide",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 424.81934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> containerized <em>environment</em>",
        "sections": "Manage <em>your</em> containerized <em>environment</em>",
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": ", to build a complete picture of <em>your</em> Kubernetes <em>environment</em>, <em>New</em> <em>Relic</em> aggregates data from many resources, including Kube-state metrics. <em>New</em> <em>Relic</em>&#x27;s “Kubernetes aware” approach makes it easy for Kubernetes to do its job as an orchestrator without missing a single node, cluster, or event. 2. Leverage"
      },
      "id": "603ebf49196a670d96a83d81"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/guide-optimizing-your-cloud-native-environment": [
    {
      "sections": [
        "Analyze distributed systems",
        "1. Identify high-priority areas to monitor",
        "2. Instrument to get the visibility you require",
        "3. Create dashboards",
        "4. Dig deeper with distributed tracing",
        "5. Annotate message queues with distributed tracing payload APIs",
        "Example annotated message queue",
        "6. Annotate and tag traces with custom attributes",
        "Tip",
        "7. Leverage Synthetics to get a high-level view of system health",
        "For more help"
      ],
      "title": "Analyze distributed systems",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "af1cf5a80f8254c90509e562fb68a6ded2f7207f",
      "image": "https://docs.newrelic.com/static/838e50badd634f1f188cf821785f6696/2cffa/APm_distributed-tracing-catalyst-TWO.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/analyze-distributed-systems/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a monolithic application, a simple stack trace can contain enough diagnostic data to determine the root cause of a code defect. But cloud computing and microservices have blurred the lines between software and infrastructure; in modern architectures, requests are distributed across many smaller services—often with ephemeral lifespans—hosted in both on-premise and cloud environments. Spotting code defects becomes much more complex. APM's distributed tracing automatically helps teams troubleshoot such distributed systems. Distributed traces are just one component of a well-monitored system. You need a holistic view of your distributed system, especially when tracking the root cause of a defect, as there are volumes of data to evaluate and understand. When managing a microservices environment, it's critical that you have the capability to spot bottlenecks and problem spans quickly so that you don't compromise your mean-time-to-resolution (MTTR) or end-user experience. At New Relic, we understand these challenges inherently. In our journey, we've transitioned from a Ruby monolith to a multi-language distributed environment built on more than 300 microservices, for which we average 50 code deploys a day. Such challenges inform both how we've built and how we monitor New Relic. Use the New Relic platform to translate your data into relevant insights, so you can collaborate around a common framework to build context and quickly optimize and troubleshoot your complex, distributed systems. 1. Identify high-priority areas to monitor Distributed systems are complex. Before engaging with the New Relic platform, we recommend that you identify the most critical areas of your systems to observe, and focus on instrumenting those high-priority areas first. Google's SRE handbook suggests monitoring the \"four golden signals\": traffic, latency, errors, and saturation, as shown in the following dashboard: Dashboards: Visualize key areas to monitor with dashboards. Too often, teams monitor what is either 1) easy to measure or 2) interpretable. Avoid this fallacy. When making choices about what to monitor, involve product managers and other stakeholders from your organization. Your goal is to monitor what matters to your business, not to overload your teams with noise. 2. Instrument to get the visibility you require Once you've identified your key priorities, instrument the appropriate parts of your system with the New Relic platform. Monitor your web apps with APM. See compatibility and requirements for New Relic agents and products to learn precise compatibility details for each supported language and then install the APM agent on your application stack. Steps for installing APM agents vary based on language. Enable distributed tracing for APM, which will affect some existing APM features. If you're accustomed to using APM without distributed tracing, read the transition guide before you enable this feature. Monitor your compute resources with infrastructure. See compatibility and requirements for infrastructure monitoring for supported operating systems and environments. You can also instrument other products and services with on-host integrations. Monitor your front-end experience with mobile and browser. 3. Create dashboards Use dashboards to get an overview of your entire system and baseline performance, so you can better understand how the components work together. Insights provides a single framework for aligning disparate teams around relevant data. Approach this first build as your launching point, giving your teams something to react to as you begin to ascribe context to your system. You should continue to build and iterate your dashboards as you analyze, troubleshoot, and optimize your distributed system. Even after you have a basic understanding of your system, use dashboards to inform the decisions you make going forward. Dashboards provide central repository of truth, allowing all stakeholders to build context about the health of your system. Here is an example of a query that displays the slowest applications. SELECT percentile(duration, 99) as 'Slowest duration' FROM Transaction FACET name Copy Using this query you can focus on the slowest application to dig deeper: After running the query, dashboards displays the slowest durations. 4. Dig deeper with distributed tracing After you have basic instrumentation and contextual dashboards in place, you can begin to dig deeper to troubleshoot or optimize your system. A differentiated feature in New Relic One's Global Distributed Tracing is that you can come in with vague context for what you're investigating and search across all accounts and traces to get down to the actual user interactions that have those attributes somewhere in their trace. You no longer must begin with the application or specific entity to search for traces that include that application. For example, start with an analysis of your complex service calls, using the distributed tracing UI to: View a scatter plot chart showing the frequency, duration, and other facets of your distributed traces Group traces by root entry, service, service entry, or traces with errors View a trace list Filter specific traces to meet certain parameters You'll likely discover that you want to take the analysis one step further by annotating your traces with information that adds context to your troubleshooting, like User ID. You can do this in New Relic using custom attributes. one.newrelic.com > APM > Distributed tracing: use the distributed tracing UI to monitor and analyze modern distributed systems. 5. Annotate message queues with distributed tracing payload APIs To see connections between services in some environments—for example, in a system that relies heavily on queues—you may need to do some manual instrumentation using the distributed tracing payload APIs to ensure you're propagating the payload. This gives agents the necessary context to create spans with the right correlation; you'll see end-to-end traces for all linked services, including those that cross through the queue. Example annotated message queue For example: Start a transaction. Create the distributed tracing payload on the producer service within a New Relic transaction. As part of the message, add the distributed tracing payload. ​​newrelic.setTransactionName(\"Send Message\") // Create SQS service object var sqs = new AWS.SQS({apiVersion: '2012-11-05'}); var transactionHandle = newrelic.getTransaction(); var payload = transactionHandle.createDistributedTracePayload(); var jsonPayload = payload.text(); //add the jsonPayload as a MessageAttribute var params = { DelaySeconds: 10, MessageAttributes: { \"Testing\": { DataType: \"String\", StringValue: \"123\" }, \"TraceContext\": { DataType: \"String\", StringValue: jsonPayload } }, MessageBody: \"Testing 123\", QueueUrl: \"https://sqs.us-west-2.amazonaws.com/408155283954/sqs-testing\" }; Copy With the context of a transaction, receive the payload on the consumer service. sqs.receiveMessage(params, function(err, data) { if (err) { console.log(\"Receive Error\", err); } else if (data && data.Messages) { console.log(\"trace context:\") var traceContext = data.Messages[0].MessageAttributes.TraceContext.StringValue; if (traceContext != \"\") { var transactionHandle = newrelic.getTransaction(); transactionHandle.acceptDistributedTracePayload(traceContext); } Copy 6. Annotate and tag traces with custom attributes We recommend that you use custom attributes to decorate events with additional information for better tracing. For example, by adding key-value pairs, you can attach a user ID to trace a specific user through the call stack and review failing requests to determine if that user is having an unusually poor experience. We recommend adding custom attributes based on your use case; for example, if your instrumenting an order management system, you could add an order number custom attribute to your traces. To add custom attributes, you must first enable them for your agent, and then make an API call to record the attribute. Tip For more agent-specific information on collecting custom attributes, see Collect custom attributes sqs.sendMessage(params, function(err, data) { if (err) { res.send(\"Error: \"+ err); } else { res.send(\"Success! Message ID: \"+ data.MessageId); newrelic.addCustomAttribute(\"Message ID\", data.MessageId) } }); Copy 7. Leverage Synthetics to get a high-level view of system health In complex, distributed systems, you need to track and monitor many signals. Sometimes it may be that no one signal is concerning, yet your whole system is behaving anomalously. To get a complete picture, it's critical to analyze symptomatic data in tandem with system-level data. Synthetics allows you to interact with the entire system as an external user would, giving your teams high-level checks for performance and user experience. These external checks help you understand if the entire system is doing what you want regardless of what specific signals may indicate. For more help For more tips and best practices on distributed tracing and custom attributes, see the following: Distributed Tracing Anomaly Detection: A Faster, Easier Way to Troubleshoot Microservices Environments Introduction to distributed tracing Collect custom attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.11243,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " that you don&#x27;t compromise <em>your</em> mean-time-to-resolution (MTTR) or end-user experience. At <em>New</em> <em>Relic</em>, we understand these challenges inherently. In our journey, we&#x27;ve transitioned from a Ruby monolith to a multi-language distributed <em>environment</em> built on more than 300 microservices, for which we average"
      },
      "id": "603ebd8264441f02694e887f"
    },
    {
      "sections": [
        "Set proactive alerts and align teams, tools, and processes for incident response",
        "Prerequisites",
        "1. Define policies",
        "Example questions and KPI solutions",
        "2. Set specific alerts",
        "3. Identify groups",
        "4. Determine thresholds",
        "5. Set notification channels",
        "6. Automate resolution",
        "7. Establish reviews",
        "Example post mortem report",
        "8. Fine-tune process",
        "Expert tip"
      ],
      "title": "Set proactive alerts and align teams, tools, and processes for incident response ",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "454d902dd8ff1ace1070b7ad42489dda5405845c",
      "image": "https://docs.newrelic.com/static/ecb7124a85903b58a0fbb042ddb29cc6/c483d/proactive-baseline-alerts-devops_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/set-proactive-alerts-align-teams-tools-processes-incident-response/",
      "published_at": "2021-07-09T16:00:00Z",
      "updated_at": "2021-07-09T16:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term alerting often carries some negative connotations: many developers correlate alerting with errors, mistakes, and ongoing issues. However, developers who are proactive about alerting, know they don't have to stare at dashboards all day because effective alerts tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Further, a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or environment. With proactive alerting, you'll decrease user-reported incidents, and your teams will spend less time firefighting and more time deploying significant changes to your product. After you define the right alerts, proper incident orchestration aligns your teams, tools, and processes to prepare for incidents and outages in your software. The goal is to provide your teams a predictable framework and process to: Maximize efficiency in communication and effort. Minimize the overall impact to your business. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the Establish objectives and baselines tutorial. Optionally added custom attributes and events. 1. Define policies Define required alerting policies based on SLOs. A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples of service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, 95% of requests completed within 250 ms AND availability is 99.99%), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it's meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than 0.20%. However, not every SLO needs to become an alert. A strong alerting strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alerting strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” Example questions and KPI solutions For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use browser monitoring and APM to alert on site availability. How's our underlying infrastructure? Set KPIs for key hardware, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie them to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site's availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don't yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we've set both a warning and a violation for throughput: alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier, which can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic across five different servers. You can set an alert based on a NRQL query and receive a notification if any server starts getting significantly more or less traffic than the other servers. Here is an example chart: And here's a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups Identify groups to alert, set broadcasting methods, and assign first responders to team dashboards Alerting without the proper broadcasting methods leaves you vulnerable. Your alerting strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack or PagerDuty). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the types of alerts that warrant waking someone up. Recommendation: For each team dashboard, make sure: It has an owner who assumes responsibility for the health of the applications and features it monitors. There is no ambiguity about who is responsible for attending to and resolving an alert condition. This policy will vary between organizations depending on size, structure, and culture. For example, some teams may prefer to assign dashboards and alerts based on de-facto features or application ownership. Other teams may prefer to adopt an on-call rotation (often referred to as pager duty). In on-call rotations, designated team members handle all first-line incident responses, and they resolve or delegate responsibilities based on predetermined incident thresholds. 4. Determine thresholds Determine incident thresholds for alert conditions For each of your applications: Identify the thresholds for what is officially considered an incident. Make sure each set of threshold criteria is context-dependent. Document incident evaluation and known remediation procedures in runbooks. Include links to your runbooks when you define conditions and thresholds for your alert policies. For instance, a certain alert condition may be dismissable during low-traffic periods but require active remediation during peak hours. 5. Set notification channels Ensure alerts have auditable notification channels Make sure that communications during critical incidents take place in easily accessible and highly visible channels. A group chat room dedicated to incident communication is usually a great choice. This allows all stakeholders to participate or observe and provides a chronology of notifications, key decisions, and actions for postmortem analysis. Use any of the available notification channels in New Relic Alerts. For example, to set up a notification channel in Slack: Make sure your organization has completed New Relic's integration requirements with Slack. In the Slack app, select the dropdown in the top-left corner of the app, and select Customize Slack. Click Configure apps. From the list of app integrations, select New Relic. Expand the instructions for New Relic Alerts, and follow the steps to configure notifications from New Relic. 6. Automate resolution Automate triage and resolution steps Automation of simple or repeatable incident response tasks will increase efficiency and minimize the impact of incidents. With proper automation in place, you can disable or isolate faulty application components as soon as an alert threshold is reached, rather than after a notification has been issued. For example, a team managing an application for a digital media company wants to be able to remove commenting abilities from the website if the system has errors. In this case, they could: Add an endpoint to their front-end web application that will toggle a feature flag enabling or disabling the UI components associated with posting comments on an article. Create an alert policy with a threshold set on the sustained error rate in the commenting service. Assign a webhook notification channel that will send a POST request to this endpoint, as well as to the standard team notification channels. In this scenario, errors in the commenting system will trigger the webhook and remove the commenting UI from the website. Users can still use core functionality of the site without seeing errors generated by the commenting service. The application will maintain a stable but degraded state, allowing the team to focus on recovery without the pressure of preventing users from accessing the site. You can also use webhooks to create issues and action items in ticketing systems that have REST APIs, such as Zendesk. Use New Relic Alerts to create a webhook notification channel, and customize the webhook payload as needed. New Relic also provides integrations for common ticketing systems. You can use any of these integrations to file tickets from New Relic APM. 7. Establish reviews Establish a post mortem process After the incident has been resolved, key stakeholders and participants must capture accurate and thorough documentation of the incident. At a minimum, we recommend that the retro documentation includes: A root cause analysis A chronology and summary of remediation steps and their result, whether they were successful or not A measure of the impact to the business in terms of user experience and financial losses, if possible Recommendations for system or feature improvements to prevent a recurrence Recommendations for process and communication improvements Store post mortem reports in a highly visible, searchable repository, such as a shared drive folder or wiki. Culturally, it's essential that this process focuses on constructive learning and improvement rather than punishment or blame. Example post mortem report Here is a brief example of a post mortem report: Post mortem Comments Date March 1, 2018 Executive summary From approximately 1:45PM until 2:30PM, users could not add items to their carts, which prevented any checkouts from occurring during the incident period. Root cause We determined that a change was made to the CSS rules on the product detail page that effectively disabled the Add to cart button. Timeline 1:50PM: Successful checkouts < 10 for 5 minutes alert triggered; assigned to Alice. 1:55PM: After reviewing the ecommerce team dashboard, Alice determined that the threshold was breached immediately following a deploy by Bob. She notified him of the incident. 2:00PM: Alice and Bob began troubleshooting. Attempts at recreating the issue in production were successful. 2:20PM: Bob determined that his change to the CSS on the product detail page disabled the Add to cart button. He deployed a hotfix. 2:30PM: Functionality was restored and the incident was resolved. Impact No checkouts were completed during the duration of the incident. Our typical revenue for a Thursday during this timeframe is $30,000. Recommendations We have been discussing implementing New Relic Synthetics for awhile now. If we had a Synthetic check on the checkout process, this issue would have been detected immediately. We should also implement more thorough unit tests in the front-end web app. 8. Fine-tune process Fine-tune alerts and thresholds As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. When rolling out new code or modifications that could negatively impact performance over a period of time, loosen your threshold conditions to allow for these short-term changes. For instance, we recommend using pre-established baselines and thresholds to increase efficiency during high-impact times for your business, such as annual events and major releases. Fine-tuning gives you the flexibility you need to increase efficiencies and extend your notification channels. As noted earlier, we recommend you start with a group chat service when you first establish notifications. Once you've identified other tools you'd like to integrate with, set up a notification channel to maintain your momentum. Tools such as xMatters and PagerDuty provide popular integrations, but don't overlook simple methods, such as webhooks. The goal is to continuously improve your alerting scheme. Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use the New Relic query language and the Insights query API to create your dashboards. For detailed instructions, check out Sending alerts data to Insights. The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you're using. Expert tip In addition to instrumenting and measuring application and infrastructure metrics, mature DevOps organizations often measure and optimize the efficiency of incident response processes. For example, you can use webhooks to send alert events to New Relic Insights. This allows you to supplement your team dashboards with New Relic Alerts data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.02203,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Example questions and KPI <em>solutions</em>",
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " Fine-tune alerts and thresholds As you use <em>New</em> <em>Relic</em> to <em>optimize</em> <em>your</em> application and infrastructure performance, tighten <em>your</em> <em>New</em> <em>Relic</em> Alerts policy conditions to keep pace with <em>your</em> improved performance. When rolling out <em>new</em> code or modifications that could negatively impact performance over"
      },
      "id": "603ebf0be7b9d2b3982a07a9"
    },
    {
      "sections": [
        "Customer experience improvement: Track experience indicators",
        "1. Use custom attributes to associate performance data",
        "2. Create dashboards with performance and business metrics",
        "Tip",
        "3. Share dashboards across departments",
        "4. Use data to separate performance by cohort and debug issues at the customer level"
      ],
      "title": "Customer experience improvement: Track experience indicators",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "6c4c1f69fa347ab2ada2360a61a559803a2f7ce5",
      "image": "https://docs.newrelic.com/static/65dadbef1fe9c07817f7ead13e12e05e/302a4/Insights-catalyst-dashbaord-1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/customer-experience-improvement-track-experience-indicators/",
      "published_at": "2021-07-09T15:10:29Z",
      "updated_at": "2021-07-09T15:10:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This tutorial covers methods to identify and track the key indicators of customer experience and clarifies the effects of application and infrastructure performance on your business. A clear understanding of what creates a successful customer experience can help modern software teams become more efficient and boost productivity. An efficient, well-functioning IT culture helps organizations make rapid, frequent releases and product changes. A strong culture also democratizes data beyond the typical backend users, making it available to groups such as customer service, support, sales, and marketing. However, this information enablement is useful only if it serves to optimize customer experience. The four steps outlined here are designed to help you leverage the data you collect to make the greatest possible improvements in your organization’s digital customer experience. 1. Use custom attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with your application. In New Relic, you collect this data with custom attributes. If you plan to collect this information in both the frontend and backend, be sure to forward custom attributes from APM to browser. Here are some common attributes to collect: User ID Organization or customer ID A/B testing cohort value High-value customer indicator Purchase value or product IDs (for e-commerce) If you’ve completed the Establish objectives and baselines tutorials, consider what service-level objectives (SLOs) or key metrics you defined in those stages. New Relic recommends including attributes like the ones listed above to measure the impact of your changes and optimizations at a customer level—rather than just measuring pure performance. 2. Create dashboards with performance and business metrics Using the attributes collected in Step 1, build dashboards to examine the impact of performance issues on your users. insights.newrelic.com > Dashboards For example, if you were collecting a custom username attribute, you could use NRQL queries like these to create your widgets for your New Relic Insights dashboard: Number of errors by username: SELECT count(*) FROM TransactionError FACET username Copy Median response time by username: SELECT percentile(duration,50) FROM Transaction FACET username Copy Total purchase value in transactions with errors: SELECT sum(purchaseTotal) FROM TransactionError FACET username Copy Tip If you include a FACET clause in your queries, you’ll be able to click into metric results to see corresponding change in the performance data. For more information on faceting, see Linking Between Dashboards to Drill Into Your Data. 3. Share dashboards across departments Dashboards, data, and metrics that nobody looks at or knows about might as well not exist. When considering how, or with whom, to share your dashboards, consider the following questions: Which teams are responsible for applications that have high levels of end-user interaction? What non-engineering teams could benefit from this information? Customer support: Could customer issues be resolved faster? Product/engineering: Could the product team make more informed roadmap decisions? Customer success: Can this data be used to make customers more successful? Are there other teams that can benefit from cohort analysis that includes performance metrics? 4. Use data to separate performance by cohort and debug issues at the customer level After you create your dashboards, use them to scope issues affecting particular customers or sets of customers. For example, the following widget shows which apps have errors for a particular user: insights.newrelic.com > Dashboards Use attributes that track user and performance to set alerts on high priority users or customers. For example, you could include a WHERE clause in your NRQL queries to scope the results to a set of user IDs or customer IDs. Set alerts on any performance or business metric that is tied to these attributes. See NRQL alerts will change how you think about using New Relic data for more information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 429.21124,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with <em>your</em> application. In <em>New</em> <em>Relic</em>, you collect this data"
      },
      "id": "603ebeb964441f6e314e88a1"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/iterate-measure-impact-track-metrics-after-deployments": [
    {
      "sections": [
        "Analyze distributed systems",
        "1. Identify high-priority areas to monitor",
        "2. Instrument to get the visibility you require",
        "3. Create dashboards",
        "4. Dig deeper with distributed tracing",
        "5. Annotate message queues with distributed tracing payload APIs",
        "Example annotated message queue",
        "6. Annotate and tag traces with custom attributes",
        "Tip",
        "7. Leverage Synthetics to get a high-level view of system health",
        "For more help"
      ],
      "title": "Analyze distributed systems",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "af1cf5a80f8254c90509e562fb68a6ded2f7207f",
      "image": "https://docs.newrelic.com/static/838e50badd634f1f188cf821785f6696/2cffa/APm_distributed-tracing-catalyst-TWO.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/analyze-distributed-systems/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a monolithic application, a simple stack trace can contain enough diagnostic data to determine the root cause of a code defect. But cloud computing and microservices have blurred the lines between software and infrastructure; in modern architectures, requests are distributed across many smaller services—often with ephemeral lifespans—hosted in both on-premise and cloud environments. Spotting code defects becomes much more complex. APM's distributed tracing automatically helps teams troubleshoot such distributed systems. Distributed traces are just one component of a well-monitored system. You need a holistic view of your distributed system, especially when tracking the root cause of a defect, as there are volumes of data to evaluate and understand. When managing a microservices environment, it's critical that you have the capability to spot bottlenecks and problem spans quickly so that you don't compromise your mean-time-to-resolution (MTTR) or end-user experience. At New Relic, we understand these challenges inherently. In our journey, we've transitioned from a Ruby monolith to a multi-language distributed environment built on more than 300 microservices, for which we average 50 code deploys a day. Such challenges inform both how we've built and how we monitor New Relic. Use the New Relic platform to translate your data into relevant insights, so you can collaborate around a common framework to build context and quickly optimize and troubleshoot your complex, distributed systems. 1. Identify high-priority areas to monitor Distributed systems are complex. Before engaging with the New Relic platform, we recommend that you identify the most critical areas of your systems to observe, and focus on instrumenting those high-priority areas first. Google's SRE handbook suggests monitoring the \"four golden signals\": traffic, latency, errors, and saturation, as shown in the following dashboard: Dashboards: Visualize key areas to monitor with dashboards. Too often, teams monitor what is either 1) easy to measure or 2) interpretable. Avoid this fallacy. When making choices about what to monitor, involve product managers and other stakeholders from your organization. Your goal is to monitor what matters to your business, not to overload your teams with noise. 2. Instrument to get the visibility you require Once you've identified your key priorities, instrument the appropriate parts of your system with the New Relic platform. Monitor your web apps with APM. See compatibility and requirements for New Relic agents and products to learn precise compatibility details for each supported language and then install the APM agent on your application stack. Steps for installing APM agents vary based on language. Enable distributed tracing for APM, which will affect some existing APM features. If you're accustomed to using APM without distributed tracing, read the transition guide before you enable this feature. Monitor your compute resources with infrastructure. See compatibility and requirements for infrastructure monitoring for supported operating systems and environments. You can also instrument other products and services with on-host integrations. Monitor your front-end experience with mobile and browser. 3. Create dashboards Use dashboards to get an overview of your entire system and baseline performance, so you can better understand how the components work together. Insights provides a single framework for aligning disparate teams around relevant data. Approach this first build as your launching point, giving your teams something to react to as you begin to ascribe context to your system. You should continue to build and iterate your dashboards as you analyze, troubleshoot, and optimize your distributed system. Even after you have a basic understanding of your system, use dashboards to inform the decisions you make going forward. Dashboards provide central repository of truth, allowing all stakeholders to build context about the health of your system. Here is an example of a query that displays the slowest applications. SELECT percentile(duration, 99) as 'Slowest duration' FROM Transaction FACET name Copy Using this query you can focus on the slowest application to dig deeper: After running the query, dashboards displays the slowest durations. 4. Dig deeper with distributed tracing After you have basic instrumentation and contextual dashboards in place, you can begin to dig deeper to troubleshoot or optimize your system. A differentiated feature in New Relic One's Global Distributed Tracing is that you can come in with vague context for what you're investigating and search across all accounts and traces to get down to the actual user interactions that have those attributes somewhere in their trace. You no longer must begin with the application or specific entity to search for traces that include that application. For example, start with an analysis of your complex service calls, using the distributed tracing UI to: View a scatter plot chart showing the frequency, duration, and other facets of your distributed traces Group traces by root entry, service, service entry, or traces with errors View a trace list Filter specific traces to meet certain parameters You'll likely discover that you want to take the analysis one step further by annotating your traces with information that adds context to your troubleshooting, like User ID. You can do this in New Relic using custom attributes. one.newrelic.com > APM > Distributed tracing: use the distributed tracing UI to monitor and analyze modern distributed systems. 5. Annotate message queues with distributed tracing payload APIs To see connections between services in some environments—for example, in a system that relies heavily on queues—you may need to do some manual instrumentation using the distributed tracing payload APIs to ensure you're propagating the payload. This gives agents the necessary context to create spans with the right correlation; you'll see end-to-end traces for all linked services, including those that cross through the queue. Example annotated message queue For example: Start a transaction. Create the distributed tracing payload on the producer service within a New Relic transaction. As part of the message, add the distributed tracing payload. ​​newrelic.setTransactionName(\"Send Message\") // Create SQS service object var sqs = new AWS.SQS({apiVersion: '2012-11-05'}); var transactionHandle = newrelic.getTransaction(); var payload = transactionHandle.createDistributedTracePayload(); var jsonPayload = payload.text(); //add the jsonPayload as a MessageAttribute var params = { DelaySeconds: 10, MessageAttributes: { \"Testing\": { DataType: \"String\", StringValue: \"123\" }, \"TraceContext\": { DataType: \"String\", StringValue: jsonPayload } }, MessageBody: \"Testing 123\", QueueUrl: \"https://sqs.us-west-2.amazonaws.com/408155283954/sqs-testing\" }; Copy With the context of a transaction, receive the payload on the consumer service. sqs.receiveMessage(params, function(err, data) { if (err) { console.log(\"Receive Error\", err); } else if (data && data.Messages) { console.log(\"trace context:\") var traceContext = data.Messages[0].MessageAttributes.TraceContext.StringValue; if (traceContext != \"\") { var transactionHandle = newrelic.getTransaction(); transactionHandle.acceptDistributedTracePayload(traceContext); } Copy 6. Annotate and tag traces with custom attributes We recommend that you use custom attributes to decorate events with additional information for better tracing. For example, by adding key-value pairs, you can attach a user ID to trace a specific user through the call stack and review failing requests to determine if that user is having an unusually poor experience. We recommend adding custom attributes based on your use case; for example, if your instrumenting an order management system, you could add an order number custom attribute to your traces. To add custom attributes, you must first enable them for your agent, and then make an API call to record the attribute. Tip For more agent-specific information on collecting custom attributes, see Collect custom attributes sqs.sendMessage(params, function(err, data) { if (err) { res.send(\"Error: \"+ err); } else { res.send(\"Success! Message ID: \"+ data.MessageId); newrelic.addCustomAttribute(\"Message ID\", data.MessageId) } }); Copy 7. Leverage Synthetics to get a high-level view of system health In complex, distributed systems, you need to track and monitor many signals. Sometimes it may be that no one signal is concerning, yet your whole system is behaving anomalously. To get a complete picture, it's critical to analyze symptomatic data in tandem with system-level data. Synthetics allows you to interact with the entire system as an external user would, giving your teams high-level checks for performance and user experience. These external checks help you understand if the entire system is doing what you want regardless of what specific signals may indicate. For more help For more tips and best practices on distributed tracing and custom attributes, see the following: Distributed Tracing Anomaly Detection: A Faster, Easier Way to Troubleshoot Microservices Environments Introduction to distributed tracing Collect custom attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.11243,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " that you don&#x27;t compromise <em>your</em> mean-time-to-resolution (MTTR) or end-user experience. At <em>New</em> <em>Relic</em>, we understand these challenges inherently. In our journey, we&#x27;ve transitioned from a Ruby monolith to a multi-language distributed <em>environment</em> built on more than 300 microservices, for which we average"
      },
      "id": "603ebd8264441f02694e887f"
    },
    {
      "sections": [
        "Set proactive alerts and align teams, tools, and processes for incident response",
        "Prerequisites",
        "1. Define policies",
        "Example questions and KPI solutions",
        "2. Set specific alerts",
        "3. Identify groups",
        "4. Determine thresholds",
        "5. Set notification channels",
        "6. Automate resolution",
        "7. Establish reviews",
        "Example post mortem report",
        "8. Fine-tune process",
        "Expert tip"
      ],
      "title": "Set proactive alerts and align teams, tools, and processes for incident response ",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "454d902dd8ff1ace1070b7ad42489dda5405845c",
      "image": "https://docs.newrelic.com/static/ecb7124a85903b58a0fbb042ddb29cc6/c483d/proactive-baseline-alerts-devops_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/set-proactive-alerts-align-teams-tools-processes-incident-response/",
      "published_at": "2021-07-09T16:00:00Z",
      "updated_at": "2021-07-09T16:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term alerting often carries some negative connotations: many developers correlate alerting with errors, mistakes, and ongoing issues. However, developers who are proactive about alerting, know they don't have to stare at dashboards all day because effective alerts tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Further, a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or environment. With proactive alerting, you'll decrease user-reported incidents, and your teams will spend less time firefighting and more time deploying significant changes to your product. After you define the right alerts, proper incident orchestration aligns your teams, tools, and processes to prepare for incidents and outages in your software. The goal is to provide your teams a predictable framework and process to: Maximize efficiency in communication and effort. Minimize the overall impact to your business. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the Establish objectives and baselines tutorial. Optionally added custom attributes and events. 1. Define policies Define required alerting policies based on SLOs. A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples of service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, 95% of requests completed within 250 ms AND availability is 99.99%), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it's meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than 0.20%. However, not every SLO needs to become an alert. A strong alerting strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alerting strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” Example questions and KPI solutions For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use browser monitoring and APM to alert on site availability. How's our underlying infrastructure? Set KPIs for key hardware, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie them to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site's availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don't yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we've set both a warning and a violation for throughput: alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier, which can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic across five different servers. You can set an alert based on a NRQL query and receive a notification if any server starts getting significantly more or less traffic than the other servers. Here is an example chart: And here's a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups Identify groups to alert, set broadcasting methods, and assign first responders to team dashboards Alerting without the proper broadcasting methods leaves you vulnerable. Your alerting strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack or PagerDuty). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the types of alerts that warrant waking someone up. Recommendation: For each team dashboard, make sure: It has an owner who assumes responsibility for the health of the applications and features it monitors. There is no ambiguity about who is responsible for attending to and resolving an alert condition. This policy will vary between organizations depending on size, structure, and culture. For example, some teams may prefer to assign dashboards and alerts based on de-facto features or application ownership. Other teams may prefer to adopt an on-call rotation (often referred to as pager duty). In on-call rotations, designated team members handle all first-line incident responses, and they resolve or delegate responsibilities based on predetermined incident thresholds. 4. Determine thresholds Determine incident thresholds for alert conditions For each of your applications: Identify the thresholds for what is officially considered an incident. Make sure each set of threshold criteria is context-dependent. Document incident evaluation and known remediation procedures in runbooks. Include links to your runbooks when you define conditions and thresholds for your alert policies. For instance, a certain alert condition may be dismissable during low-traffic periods but require active remediation during peak hours. 5. Set notification channels Ensure alerts have auditable notification channels Make sure that communications during critical incidents take place in easily accessible and highly visible channels. A group chat room dedicated to incident communication is usually a great choice. This allows all stakeholders to participate or observe and provides a chronology of notifications, key decisions, and actions for postmortem analysis. Use any of the available notification channels in New Relic Alerts. For example, to set up a notification channel in Slack: Make sure your organization has completed New Relic's integration requirements with Slack. In the Slack app, select the dropdown in the top-left corner of the app, and select Customize Slack. Click Configure apps. From the list of app integrations, select New Relic. Expand the instructions for New Relic Alerts, and follow the steps to configure notifications from New Relic. 6. Automate resolution Automate triage and resolution steps Automation of simple or repeatable incident response tasks will increase efficiency and minimize the impact of incidents. With proper automation in place, you can disable or isolate faulty application components as soon as an alert threshold is reached, rather than after a notification has been issued. For example, a team managing an application for a digital media company wants to be able to remove commenting abilities from the website if the system has errors. In this case, they could: Add an endpoint to their front-end web application that will toggle a feature flag enabling or disabling the UI components associated with posting comments on an article. Create an alert policy with a threshold set on the sustained error rate in the commenting service. Assign a webhook notification channel that will send a POST request to this endpoint, as well as to the standard team notification channels. In this scenario, errors in the commenting system will trigger the webhook and remove the commenting UI from the website. Users can still use core functionality of the site without seeing errors generated by the commenting service. The application will maintain a stable but degraded state, allowing the team to focus on recovery without the pressure of preventing users from accessing the site. You can also use webhooks to create issues and action items in ticketing systems that have REST APIs, such as Zendesk. Use New Relic Alerts to create a webhook notification channel, and customize the webhook payload as needed. New Relic also provides integrations for common ticketing systems. You can use any of these integrations to file tickets from New Relic APM. 7. Establish reviews Establish a post mortem process After the incident has been resolved, key stakeholders and participants must capture accurate and thorough documentation of the incident. At a minimum, we recommend that the retro documentation includes: A root cause analysis A chronology and summary of remediation steps and their result, whether they were successful or not A measure of the impact to the business in terms of user experience and financial losses, if possible Recommendations for system or feature improvements to prevent a recurrence Recommendations for process and communication improvements Store post mortem reports in a highly visible, searchable repository, such as a shared drive folder or wiki. Culturally, it's essential that this process focuses on constructive learning and improvement rather than punishment or blame. Example post mortem report Here is a brief example of a post mortem report: Post mortem Comments Date March 1, 2018 Executive summary From approximately 1:45PM until 2:30PM, users could not add items to their carts, which prevented any checkouts from occurring during the incident period. Root cause We determined that a change was made to the CSS rules on the product detail page that effectively disabled the Add to cart button. Timeline 1:50PM: Successful checkouts < 10 for 5 minutes alert triggered; assigned to Alice. 1:55PM: After reviewing the ecommerce team dashboard, Alice determined that the threshold was breached immediately following a deploy by Bob. She notified him of the incident. 2:00PM: Alice and Bob began troubleshooting. Attempts at recreating the issue in production were successful. 2:20PM: Bob determined that his change to the CSS on the product detail page disabled the Add to cart button. He deployed a hotfix. 2:30PM: Functionality was restored and the incident was resolved. Impact No checkouts were completed during the duration of the incident. Our typical revenue for a Thursday during this timeframe is $30,000. Recommendations We have been discussing implementing New Relic Synthetics for awhile now. If we had a Synthetic check on the checkout process, this issue would have been detected immediately. We should also implement more thorough unit tests in the front-end web app. 8. Fine-tune process Fine-tune alerts and thresholds As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. When rolling out new code or modifications that could negatively impact performance over a period of time, loosen your threshold conditions to allow for these short-term changes. For instance, we recommend using pre-established baselines and thresholds to increase efficiency during high-impact times for your business, such as annual events and major releases. Fine-tuning gives you the flexibility you need to increase efficiencies and extend your notification channels. As noted earlier, we recommend you start with a group chat service when you first establish notifications. Once you've identified other tools you'd like to integrate with, set up a notification channel to maintain your momentum. Tools such as xMatters and PagerDuty provide popular integrations, but don't overlook simple methods, such as webhooks. The goal is to continuously improve your alerting scheme. Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use the New Relic query language and the Insights query API to create your dashboards. For detailed instructions, check out Sending alerts data to Insights. The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you're using. Expert tip In addition to instrumenting and measuring application and infrastructure metrics, mature DevOps organizations often measure and optimize the efficiency of incident response processes. For example, you can use webhooks to send alert events to New Relic Insights. This allows you to supplement your team dashboards with New Relic Alerts data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.02203,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Example questions and KPI <em>solutions</em>",
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " Fine-tune alerts and thresholds As you use <em>New</em> <em>Relic</em> to <em>optimize</em> <em>your</em> application and infrastructure performance, tighten <em>your</em> <em>New</em> <em>Relic</em> Alerts policy conditions to keep pace with <em>your</em> improved performance. When rolling out <em>new</em> code or modifications that could negatively impact performance over"
      },
      "id": "603ebf0be7b9d2b3982a07a9"
    },
    {
      "sections": [
        "Customer experience improvement: Track experience indicators",
        "1. Use custom attributes to associate performance data",
        "2. Create dashboards with performance and business metrics",
        "Tip",
        "3. Share dashboards across departments",
        "4. Use data to separate performance by cohort and debug issues at the customer level"
      ],
      "title": "Customer experience improvement: Track experience indicators",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "6c4c1f69fa347ab2ada2360a61a559803a2f7ce5",
      "image": "https://docs.newrelic.com/static/65dadbef1fe9c07817f7ead13e12e05e/302a4/Insights-catalyst-dashbaord-1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/customer-experience-improvement-track-experience-indicators/",
      "published_at": "2021-07-09T15:10:29Z",
      "updated_at": "2021-07-09T15:10:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This tutorial covers methods to identify and track the key indicators of customer experience and clarifies the effects of application and infrastructure performance on your business. A clear understanding of what creates a successful customer experience can help modern software teams become more efficient and boost productivity. An efficient, well-functioning IT culture helps organizations make rapid, frequent releases and product changes. A strong culture also democratizes data beyond the typical backend users, making it available to groups such as customer service, support, sales, and marketing. However, this information enablement is useful only if it serves to optimize customer experience. The four steps outlined here are designed to help you leverage the data you collect to make the greatest possible improvements in your organization’s digital customer experience. 1. Use custom attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with your application. In New Relic, you collect this data with custom attributes. If you plan to collect this information in both the frontend and backend, be sure to forward custom attributes from APM to browser. Here are some common attributes to collect: User ID Organization or customer ID A/B testing cohort value High-value customer indicator Purchase value or product IDs (for e-commerce) If you’ve completed the Establish objectives and baselines tutorials, consider what service-level objectives (SLOs) or key metrics you defined in those stages. New Relic recommends including attributes like the ones listed above to measure the impact of your changes and optimizations at a customer level—rather than just measuring pure performance. 2. Create dashboards with performance and business metrics Using the attributes collected in Step 1, build dashboards to examine the impact of performance issues on your users. insights.newrelic.com > Dashboards For example, if you were collecting a custom username attribute, you could use NRQL queries like these to create your widgets for your New Relic Insights dashboard: Number of errors by username: SELECT count(*) FROM TransactionError FACET username Copy Median response time by username: SELECT percentile(duration,50) FROM Transaction FACET username Copy Total purchase value in transactions with errors: SELECT sum(purchaseTotal) FROM TransactionError FACET username Copy Tip If you include a FACET clause in your queries, you’ll be able to click into metric results to see corresponding change in the performance data. For more information on faceting, see Linking Between Dashboards to Drill Into Your Data. 3. Share dashboards across departments Dashboards, data, and metrics that nobody looks at or knows about might as well not exist. When considering how, or with whom, to share your dashboards, consider the following questions: Which teams are responsible for applications that have high levels of end-user interaction? What non-engineering teams could benefit from this information? Customer support: Could customer issues be resolved faster? Product/engineering: Could the product team make more informed roadmap decisions? Customer success: Can this data be used to make customers more successful? Are there other teams that can benefit from cohort analysis that includes performance metrics? 4. Use data to separate performance by cohort and debug issues at the customer level After you create your dashboards, use them to scope issues affecting particular customers or sets of customers. For example, the following widget shows which apps have errors for a particular user: insights.newrelic.com > Dashboards Use attributes that track user and performance to set alerts on high priority users or customers. For example, you could include a WHERE clause in your NRQL queries to scope the results to a set of user IDs or customer IDs. Set alerts on any performance or business metric that is tied to these attributes. See NRQL alerts will change how you think about using New Relic data for more information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 429.21124,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with <em>your</em> application. In <em>New</em> <em>Relic</em>, you collect this data"
      },
      "id": "603ebeb964441f6e314e88a1"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/manage-your-containerized-environment": [
    {
      "sections": [
        "Analyze distributed systems",
        "1. Identify high-priority areas to monitor",
        "2. Instrument to get the visibility you require",
        "3. Create dashboards",
        "4. Dig deeper with distributed tracing",
        "5. Annotate message queues with distributed tracing payload APIs",
        "Example annotated message queue",
        "6. Annotate and tag traces with custom attributes",
        "Tip",
        "7. Leverage Synthetics to get a high-level view of system health",
        "For more help"
      ],
      "title": "Analyze distributed systems",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "af1cf5a80f8254c90509e562fb68a6ded2f7207f",
      "image": "https://docs.newrelic.com/static/838e50badd634f1f188cf821785f6696/2cffa/APm_distributed-tracing-catalyst-TWO.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/analyze-distributed-systems/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a monolithic application, a simple stack trace can contain enough diagnostic data to determine the root cause of a code defect. But cloud computing and microservices have blurred the lines between software and infrastructure; in modern architectures, requests are distributed across many smaller services—often with ephemeral lifespans—hosted in both on-premise and cloud environments. Spotting code defects becomes much more complex. APM's distributed tracing automatically helps teams troubleshoot such distributed systems. Distributed traces are just one component of a well-monitored system. You need a holistic view of your distributed system, especially when tracking the root cause of a defect, as there are volumes of data to evaluate and understand. When managing a microservices environment, it's critical that you have the capability to spot bottlenecks and problem spans quickly so that you don't compromise your mean-time-to-resolution (MTTR) or end-user experience. At New Relic, we understand these challenges inherently. In our journey, we've transitioned from a Ruby monolith to a multi-language distributed environment built on more than 300 microservices, for which we average 50 code deploys a day. Such challenges inform both how we've built and how we monitor New Relic. Use the New Relic platform to translate your data into relevant insights, so you can collaborate around a common framework to build context and quickly optimize and troubleshoot your complex, distributed systems. 1. Identify high-priority areas to monitor Distributed systems are complex. Before engaging with the New Relic platform, we recommend that you identify the most critical areas of your systems to observe, and focus on instrumenting those high-priority areas first. Google's SRE handbook suggests monitoring the \"four golden signals\": traffic, latency, errors, and saturation, as shown in the following dashboard: Dashboards: Visualize key areas to monitor with dashboards. Too often, teams monitor what is either 1) easy to measure or 2) interpretable. Avoid this fallacy. When making choices about what to monitor, involve product managers and other stakeholders from your organization. Your goal is to monitor what matters to your business, not to overload your teams with noise. 2. Instrument to get the visibility you require Once you've identified your key priorities, instrument the appropriate parts of your system with the New Relic platform. Monitor your web apps with APM. See compatibility and requirements for New Relic agents and products to learn precise compatibility details for each supported language and then install the APM agent on your application stack. Steps for installing APM agents vary based on language. Enable distributed tracing for APM, which will affect some existing APM features. If you're accustomed to using APM without distributed tracing, read the transition guide before you enable this feature. Monitor your compute resources with infrastructure. See compatibility and requirements for infrastructure monitoring for supported operating systems and environments. You can also instrument other products and services with on-host integrations. Monitor your front-end experience with mobile and browser. 3. Create dashboards Use dashboards to get an overview of your entire system and baseline performance, so you can better understand how the components work together. Insights provides a single framework for aligning disparate teams around relevant data. Approach this first build as your launching point, giving your teams something to react to as you begin to ascribe context to your system. You should continue to build and iterate your dashboards as you analyze, troubleshoot, and optimize your distributed system. Even after you have a basic understanding of your system, use dashboards to inform the decisions you make going forward. Dashboards provide central repository of truth, allowing all stakeholders to build context about the health of your system. Here is an example of a query that displays the slowest applications. SELECT percentile(duration, 99) as 'Slowest duration' FROM Transaction FACET name Copy Using this query you can focus on the slowest application to dig deeper: After running the query, dashboards displays the slowest durations. 4. Dig deeper with distributed tracing After you have basic instrumentation and contextual dashboards in place, you can begin to dig deeper to troubleshoot or optimize your system. A differentiated feature in New Relic One's Global Distributed Tracing is that you can come in with vague context for what you're investigating and search across all accounts and traces to get down to the actual user interactions that have those attributes somewhere in their trace. You no longer must begin with the application or specific entity to search for traces that include that application. For example, start with an analysis of your complex service calls, using the distributed tracing UI to: View a scatter plot chart showing the frequency, duration, and other facets of your distributed traces Group traces by root entry, service, service entry, or traces with errors View a trace list Filter specific traces to meet certain parameters You'll likely discover that you want to take the analysis one step further by annotating your traces with information that adds context to your troubleshooting, like User ID. You can do this in New Relic using custom attributes. one.newrelic.com > APM > Distributed tracing: use the distributed tracing UI to monitor and analyze modern distributed systems. 5. Annotate message queues with distributed tracing payload APIs To see connections between services in some environments—for example, in a system that relies heavily on queues—you may need to do some manual instrumentation using the distributed tracing payload APIs to ensure you're propagating the payload. This gives agents the necessary context to create spans with the right correlation; you'll see end-to-end traces for all linked services, including those that cross through the queue. Example annotated message queue For example: Start a transaction. Create the distributed tracing payload on the producer service within a New Relic transaction. As part of the message, add the distributed tracing payload. ​​newrelic.setTransactionName(\"Send Message\") // Create SQS service object var sqs = new AWS.SQS({apiVersion: '2012-11-05'}); var transactionHandle = newrelic.getTransaction(); var payload = transactionHandle.createDistributedTracePayload(); var jsonPayload = payload.text(); //add the jsonPayload as a MessageAttribute var params = { DelaySeconds: 10, MessageAttributes: { \"Testing\": { DataType: \"String\", StringValue: \"123\" }, \"TraceContext\": { DataType: \"String\", StringValue: jsonPayload } }, MessageBody: \"Testing 123\", QueueUrl: \"https://sqs.us-west-2.amazonaws.com/408155283954/sqs-testing\" }; Copy With the context of a transaction, receive the payload on the consumer service. sqs.receiveMessage(params, function(err, data) { if (err) { console.log(\"Receive Error\", err); } else if (data && data.Messages) { console.log(\"trace context:\") var traceContext = data.Messages[0].MessageAttributes.TraceContext.StringValue; if (traceContext != \"\") { var transactionHandle = newrelic.getTransaction(); transactionHandle.acceptDistributedTracePayload(traceContext); } Copy 6. Annotate and tag traces with custom attributes We recommend that you use custom attributes to decorate events with additional information for better tracing. For example, by adding key-value pairs, you can attach a user ID to trace a specific user through the call stack and review failing requests to determine if that user is having an unusually poor experience. We recommend adding custom attributes based on your use case; for example, if your instrumenting an order management system, you could add an order number custom attribute to your traces. To add custom attributes, you must first enable them for your agent, and then make an API call to record the attribute. Tip For more agent-specific information on collecting custom attributes, see Collect custom attributes sqs.sendMessage(params, function(err, data) { if (err) { res.send(\"Error: \"+ err); } else { res.send(\"Success! Message ID: \"+ data.MessageId); newrelic.addCustomAttribute(\"Message ID\", data.MessageId) } }); Copy 7. Leverage Synthetics to get a high-level view of system health In complex, distributed systems, you need to track and monitor many signals. Sometimes it may be that no one signal is concerning, yet your whole system is behaving anomalously. To get a complete picture, it's critical to analyze symptomatic data in tandem with system-level data. Synthetics allows you to interact with the entire system as an external user would, giving your teams high-level checks for performance and user experience. These external checks help you understand if the entire system is doing what you want regardless of what specific signals may indicate. For more help For more tips and best practices on distributed tracing and custom attributes, see the following: Distributed Tracing Anomaly Detection: A Faster, Easier Way to Troubleshoot Microservices Environments Introduction to distributed tracing Collect custom attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.11215,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " that you don&#x27;t compromise <em>your</em> mean-time-to-resolution (MTTR) or end-user experience. At <em>New</em> <em>Relic</em>, we understand these challenges inherently. In our journey, we&#x27;ve transitioned from a Ruby monolith to a multi-language distributed <em>environment</em> built on more than 300 microservices, for which we average"
      },
      "id": "603ebd8264441f02694e887f"
    },
    {
      "sections": [
        "Set proactive alerts and align teams, tools, and processes for incident response",
        "Prerequisites",
        "1. Define policies",
        "Example questions and KPI solutions",
        "2. Set specific alerts",
        "3. Identify groups",
        "4. Determine thresholds",
        "5. Set notification channels",
        "6. Automate resolution",
        "7. Establish reviews",
        "Example post mortem report",
        "8. Fine-tune process",
        "Expert tip"
      ],
      "title": "Set proactive alerts and align teams, tools, and processes for incident response ",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "454d902dd8ff1ace1070b7ad42489dda5405845c",
      "image": "https://docs.newrelic.com/static/ecb7124a85903b58a0fbb042ddb29cc6/c483d/proactive-baseline-alerts-devops_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/set-proactive-alerts-align-teams-tools-processes-incident-response/",
      "published_at": "2021-07-09T16:00:00Z",
      "updated_at": "2021-07-09T16:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term alerting often carries some negative connotations: many developers correlate alerting with errors, mistakes, and ongoing issues. However, developers who are proactive about alerting, know they don't have to stare at dashboards all day because effective alerts tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Further, a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or environment. With proactive alerting, you'll decrease user-reported incidents, and your teams will spend less time firefighting and more time deploying significant changes to your product. After you define the right alerts, proper incident orchestration aligns your teams, tools, and processes to prepare for incidents and outages in your software. The goal is to provide your teams a predictable framework and process to: Maximize efficiency in communication and effort. Minimize the overall impact to your business. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the Establish objectives and baselines tutorial. Optionally added custom attributes and events. 1. Define policies Define required alerting policies based on SLOs. A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples of service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, 95% of requests completed within 250 ms AND availability is 99.99%), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it's meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than 0.20%. However, not every SLO needs to become an alert. A strong alerting strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alerting strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” Example questions and KPI solutions For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use browser monitoring and APM to alert on site availability. How's our underlying infrastructure? Set KPIs for key hardware, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie them to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site's availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don't yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we've set both a warning and a violation for throughput: alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier, which can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic across five different servers. You can set an alert based on a NRQL query and receive a notification if any server starts getting significantly more or less traffic than the other servers. Here is an example chart: And here's a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups Identify groups to alert, set broadcasting methods, and assign first responders to team dashboards Alerting without the proper broadcasting methods leaves you vulnerable. Your alerting strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack or PagerDuty). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the types of alerts that warrant waking someone up. Recommendation: For each team dashboard, make sure: It has an owner who assumes responsibility for the health of the applications and features it monitors. There is no ambiguity about who is responsible for attending to and resolving an alert condition. This policy will vary between organizations depending on size, structure, and culture. For example, some teams may prefer to assign dashboards and alerts based on de-facto features or application ownership. Other teams may prefer to adopt an on-call rotation (often referred to as pager duty). In on-call rotations, designated team members handle all first-line incident responses, and they resolve or delegate responsibilities based on predetermined incident thresholds. 4. Determine thresholds Determine incident thresholds for alert conditions For each of your applications: Identify the thresholds for what is officially considered an incident. Make sure each set of threshold criteria is context-dependent. Document incident evaluation and known remediation procedures in runbooks. Include links to your runbooks when you define conditions and thresholds for your alert policies. For instance, a certain alert condition may be dismissable during low-traffic periods but require active remediation during peak hours. 5. Set notification channels Ensure alerts have auditable notification channels Make sure that communications during critical incidents take place in easily accessible and highly visible channels. A group chat room dedicated to incident communication is usually a great choice. This allows all stakeholders to participate or observe and provides a chronology of notifications, key decisions, and actions for postmortem analysis. Use any of the available notification channels in New Relic Alerts. For example, to set up a notification channel in Slack: Make sure your organization has completed New Relic's integration requirements with Slack. In the Slack app, select the dropdown in the top-left corner of the app, and select Customize Slack. Click Configure apps. From the list of app integrations, select New Relic. Expand the instructions for New Relic Alerts, and follow the steps to configure notifications from New Relic. 6. Automate resolution Automate triage and resolution steps Automation of simple or repeatable incident response tasks will increase efficiency and minimize the impact of incidents. With proper automation in place, you can disable or isolate faulty application components as soon as an alert threshold is reached, rather than after a notification has been issued. For example, a team managing an application for a digital media company wants to be able to remove commenting abilities from the website if the system has errors. In this case, they could: Add an endpoint to their front-end web application that will toggle a feature flag enabling or disabling the UI components associated with posting comments on an article. Create an alert policy with a threshold set on the sustained error rate in the commenting service. Assign a webhook notification channel that will send a POST request to this endpoint, as well as to the standard team notification channels. In this scenario, errors in the commenting system will trigger the webhook and remove the commenting UI from the website. Users can still use core functionality of the site without seeing errors generated by the commenting service. The application will maintain a stable but degraded state, allowing the team to focus on recovery without the pressure of preventing users from accessing the site. You can also use webhooks to create issues and action items in ticketing systems that have REST APIs, such as Zendesk. Use New Relic Alerts to create a webhook notification channel, and customize the webhook payload as needed. New Relic also provides integrations for common ticketing systems. You can use any of these integrations to file tickets from New Relic APM. 7. Establish reviews Establish a post mortem process After the incident has been resolved, key stakeholders and participants must capture accurate and thorough documentation of the incident. At a minimum, we recommend that the retro documentation includes: A root cause analysis A chronology and summary of remediation steps and their result, whether they were successful or not A measure of the impact to the business in terms of user experience and financial losses, if possible Recommendations for system or feature improvements to prevent a recurrence Recommendations for process and communication improvements Store post mortem reports in a highly visible, searchable repository, such as a shared drive folder or wiki. Culturally, it's essential that this process focuses on constructive learning and improvement rather than punishment or blame. Example post mortem report Here is a brief example of a post mortem report: Post mortem Comments Date March 1, 2018 Executive summary From approximately 1:45PM until 2:30PM, users could not add items to their carts, which prevented any checkouts from occurring during the incident period. Root cause We determined that a change was made to the CSS rules on the product detail page that effectively disabled the Add to cart button. Timeline 1:50PM: Successful checkouts < 10 for 5 minutes alert triggered; assigned to Alice. 1:55PM: After reviewing the ecommerce team dashboard, Alice determined that the threshold was breached immediately following a deploy by Bob. She notified him of the incident. 2:00PM: Alice and Bob began troubleshooting. Attempts at recreating the issue in production were successful. 2:20PM: Bob determined that his change to the CSS on the product detail page disabled the Add to cart button. He deployed a hotfix. 2:30PM: Functionality was restored and the incident was resolved. Impact No checkouts were completed during the duration of the incident. Our typical revenue for a Thursday during this timeframe is $30,000. Recommendations We have been discussing implementing New Relic Synthetics for awhile now. If we had a Synthetic check on the checkout process, this issue would have been detected immediately. We should also implement more thorough unit tests in the front-end web app. 8. Fine-tune process Fine-tune alerts and thresholds As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. When rolling out new code or modifications that could negatively impact performance over a period of time, loosen your threshold conditions to allow for these short-term changes. For instance, we recommend using pre-established baselines and thresholds to increase efficiency during high-impact times for your business, such as annual events and major releases. Fine-tuning gives you the flexibility you need to increase efficiencies and extend your notification channels. As noted earlier, we recommend you start with a group chat service when you first establish notifications. Once you've identified other tools you'd like to integrate with, set up a notification channel to maintain your momentum. Tools such as xMatters and PagerDuty provide popular integrations, but don't overlook simple methods, such as webhooks. The goal is to continuously improve your alerting scheme. Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use the New Relic query language and the Insights query API to create your dashboards. For detailed instructions, check out Sending alerts data to Insights. The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you're using. Expert tip In addition to instrumenting and measuring application and infrastructure metrics, mature DevOps organizations often measure and optimize the efficiency of incident response processes. For example, you can use webhooks to send alert events to New Relic Insights. This allows you to supplement your team dashboards with New Relic Alerts data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.02173,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Example questions and KPI <em>solutions</em>",
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " Fine-tune alerts and thresholds As you use <em>New</em> <em>Relic</em> to <em>optimize</em> <em>your</em> application and infrastructure performance, tighten <em>your</em> <em>New</em> <em>Relic</em> Alerts policy conditions to keep pace with <em>your</em> improved performance. When rolling out <em>new</em> code or modifications that could negatively impact performance over"
      },
      "id": "603ebf0be7b9d2b3982a07a9"
    },
    {
      "sections": [
        "Customer experience improvement: Track experience indicators",
        "1. Use custom attributes to associate performance data",
        "2. Create dashboards with performance and business metrics",
        "Tip",
        "3. Share dashboards across departments",
        "4. Use data to separate performance by cohort and debug issues at the customer level"
      ],
      "title": "Customer experience improvement: Track experience indicators",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "6c4c1f69fa347ab2ada2360a61a559803a2f7ce5",
      "image": "https://docs.newrelic.com/static/65dadbef1fe9c07817f7ead13e12e05e/302a4/Insights-catalyst-dashbaord-1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/customer-experience-improvement-track-experience-indicators/",
      "published_at": "2021-07-09T15:10:29Z",
      "updated_at": "2021-07-09T15:10:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This tutorial covers methods to identify and track the key indicators of customer experience and clarifies the effects of application and infrastructure performance on your business. A clear understanding of what creates a successful customer experience can help modern software teams become more efficient and boost productivity. An efficient, well-functioning IT culture helps organizations make rapid, frequent releases and product changes. A strong culture also democratizes data beyond the typical backend users, making it available to groups such as customer service, support, sales, and marketing. However, this information enablement is useful only if it serves to optimize customer experience. The four steps outlined here are designed to help you leverage the data you collect to make the greatest possible improvements in your organization’s digital customer experience. 1. Use custom attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with your application. In New Relic, you collect this data with custom attributes. If you plan to collect this information in both the frontend and backend, be sure to forward custom attributes from APM to browser. Here are some common attributes to collect: User ID Organization or customer ID A/B testing cohort value High-value customer indicator Purchase value or product IDs (for e-commerce) If you’ve completed the Establish objectives and baselines tutorials, consider what service-level objectives (SLOs) or key metrics you defined in those stages. New Relic recommends including attributes like the ones listed above to measure the impact of your changes and optimizations at a customer level—rather than just measuring pure performance. 2. Create dashboards with performance and business metrics Using the attributes collected in Step 1, build dashboards to examine the impact of performance issues on your users. insights.newrelic.com > Dashboards For example, if you were collecting a custom username attribute, you could use NRQL queries like these to create your widgets for your New Relic Insights dashboard: Number of errors by username: SELECT count(*) FROM TransactionError FACET username Copy Median response time by username: SELECT percentile(duration,50) FROM Transaction FACET username Copy Total purchase value in transactions with errors: SELECT sum(purchaseTotal) FROM TransactionError FACET username Copy Tip If you include a FACET clause in your queries, you’ll be able to click into metric results to see corresponding change in the performance data. For more information on faceting, see Linking Between Dashboards to Drill Into Your Data. 3. Share dashboards across departments Dashboards, data, and metrics that nobody looks at or knows about might as well not exist. When considering how, or with whom, to share your dashboards, consider the following questions: Which teams are responsible for applications that have high levels of end-user interaction? What non-engineering teams could benefit from this information? Customer support: Could customer issues be resolved faster? Product/engineering: Could the product team make more informed roadmap decisions? Customer success: Can this data be used to make customers more successful? Are there other teams that can benefit from cohort analysis that includes performance metrics? 4. Use data to separate performance by cohort and debug issues at the customer level After you create your dashboards, use them to scope issues affecting particular customers or sets of customers. For example, the following widget shows which apps have errors for a particular user: insights.newrelic.com > Dashboards Use attributes that track user and performance to set alerts on high priority users or customers. For example, you could include a WHERE clause in your NRQL queries to scope the results to a set of user IDs or customer IDs. Set alerts on any performance or business metric that is tied to these attributes. See NRQL alerts will change how you think about using New Relic data for more information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 429.21094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with <em>your</em> application. In <em>New</em> <em>Relic</em>, you collect this data"
      },
      "id": "603ebeb964441f6e314e88a1"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/migrate-microservices": [
    {
      "sections": [
        "Analyze distributed systems",
        "1. Identify high-priority areas to monitor",
        "2. Instrument to get the visibility you require",
        "3. Create dashboards",
        "4. Dig deeper with distributed tracing",
        "5. Annotate message queues with distributed tracing payload APIs",
        "Example annotated message queue",
        "6. Annotate and tag traces with custom attributes",
        "Tip",
        "7. Leverage Synthetics to get a high-level view of system health",
        "For more help"
      ],
      "title": "Analyze distributed systems",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "af1cf5a80f8254c90509e562fb68a6ded2f7207f",
      "image": "https://docs.newrelic.com/static/838e50badd634f1f188cf821785f6696/2cffa/APm_distributed-tracing-catalyst-TWO.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/analyze-distributed-systems/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a monolithic application, a simple stack trace can contain enough diagnostic data to determine the root cause of a code defect. But cloud computing and microservices have blurred the lines between software and infrastructure; in modern architectures, requests are distributed across many smaller services—often with ephemeral lifespans—hosted in both on-premise and cloud environments. Spotting code defects becomes much more complex. APM's distributed tracing automatically helps teams troubleshoot such distributed systems. Distributed traces are just one component of a well-monitored system. You need a holistic view of your distributed system, especially when tracking the root cause of a defect, as there are volumes of data to evaluate and understand. When managing a microservices environment, it's critical that you have the capability to spot bottlenecks and problem spans quickly so that you don't compromise your mean-time-to-resolution (MTTR) or end-user experience. At New Relic, we understand these challenges inherently. In our journey, we've transitioned from a Ruby monolith to a multi-language distributed environment built on more than 300 microservices, for which we average 50 code deploys a day. Such challenges inform both how we've built and how we monitor New Relic. Use the New Relic platform to translate your data into relevant insights, so you can collaborate around a common framework to build context and quickly optimize and troubleshoot your complex, distributed systems. 1. Identify high-priority areas to monitor Distributed systems are complex. Before engaging with the New Relic platform, we recommend that you identify the most critical areas of your systems to observe, and focus on instrumenting those high-priority areas first. Google's SRE handbook suggests monitoring the \"four golden signals\": traffic, latency, errors, and saturation, as shown in the following dashboard: Dashboards: Visualize key areas to monitor with dashboards. Too often, teams monitor what is either 1) easy to measure or 2) interpretable. Avoid this fallacy. When making choices about what to monitor, involve product managers and other stakeholders from your organization. Your goal is to monitor what matters to your business, not to overload your teams with noise. 2. Instrument to get the visibility you require Once you've identified your key priorities, instrument the appropriate parts of your system with the New Relic platform. Monitor your web apps with APM. See compatibility and requirements for New Relic agents and products to learn precise compatibility details for each supported language and then install the APM agent on your application stack. Steps for installing APM agents vary based on language. Enable distributed tracing for APM, which will affect some existing APM features. If you're accustomed to using APM without distributed tracing, read the transition guide before you enable this feature. Monitor your compute resources with infrastructure. See compatibility and requirements for infrastructure monitoring for supported operating systems and environments. You can also instrument other products and services with on-host integrations. Monitor your front-end experience with mobile and browser. 3. Create dashboards Use dashboards to get an overview of your entire system and baseline performance, so you can better understand how the components work together. Insights provides a single framework for aligning disparate teams around relevant data. Approach this first build as your launching point, giving your teams something to react to as you begin to ascribe context to your system. You should continue to build and iterate your dashboards as you analyze, troubleshoot, and optimize your distributed system. Even after you have a basic understanding of your system, use dashboards to inform the decisions you make going forward. Dashboards provide central repository of truth, allowing all stakeholders to build context about the health of your system. Here is an example of a query that displays the slowest applications. SELECT percentile(duration, 99) as 'Slowest duration' FROM Transaction FACET name Copy Using this query you can focus on the slowest application to dig deeper: After running the query, dashboards displays the slowest durations. 4. Dig deeper with distributed tracing After you have basic instrumentation and contextual dashboards in place, you can begin to dig deeper to troubleshoot or optimize your system. A differentiated feature in New Relic One's Global Distributed Tracing is that you can come in with vague context for what you're investigating and search across all accounts and traces to get down to the actual user interactions that have those attributes somewhere in their trace. You no longer must begin with the application or specific entity to search for traces that include that application. For example, start with an analysis of your complex service calls, using the distributed tracing UI to: View a scatter plot chart showing the frequency, duration, and other facets of your distributed traces Group traces by root entry, service, service entry, or traces with errors View a trace list Filter specific traces to meet certain parameters You'll likely discover that you want to take the analysis one step further by annotating your traces with information that adds context to your troubleshooting, like User ID. You can do this in New Relic using custom attributes. one.newrelic.com > APM > Distributed tracing: use the distributed tracing UI to monitor and analyze modern distributed systems. 5. Annotate message queues with distributed tracing payload APIs To see connections between services in some environments—for example, in a system that relies heavily on queues—you may need to do some manual instrumentation using the distributed tracing payload APIs to ensure you're propagating the payload. This gives agents the necessary context to create spans with the right correlation; you'll see end-to-end traces for all linked services, including those that cross through the queue. Example annotated message queue For example: Start a transaction. Create the distributed tracing payload on the producer service within a New Relic transaction. As part of the message, add the distributed tracing payload. ​​newrelic.setTransactionName(\"Send Message\") // Create SQS service object var sqs = new AWS.SQS({apiVersion: '2012-11-05'}); var transactionHandle = newrelic.getTransaction(); var payload = transactionHandle.createDistributedTracePayload(); var jsonPayload = payload.text(); //add the jsonPayload as a MessageAttribute var params = { DelaySeconds: 10, MessageAttributes: { \"Testing\": { DataType: \"String\", StringValue: \"123\" }, \"TraceContext\": { DataType: \"String\", StringValue: jsonPayload } }, MessageBody: \"Testing 123\", QueueUrl: \"https://sqs.us-west-2.amazonaws.com/408155283954/sqs-testing\" }; Copy With the context of a transaction, receive the payload on the consumer service. sqs.receiveMessage(params, function(err, data) { if (err) { console.log(\"Receive Error\", err); } else if (data && data.Messages) { console.log(\"trace context:\") var traceContext = data.Messages[0].MessageAttributes.TraceContext.StringValue; if (traceContext != \"\") { var transactionHandle = newrelic.getTransaction(); transactionHandle.acceptDistributedTracePayload(traceContext); } Copy 6. Annotate and tag traces with custom attributes We recommend that you use custom attributes to decorate events with additional information for better tracing. For example, by adding key-value pairs, you can attach a user ID to trace a specific user through the call stack and review failing requests to determine if that user is having an unusually poor experience. We recommend adding custom attributes based on your use case; for example, if your instrumenting an order management system, you could add an order number custom attribute to your traces. To add custom attributes, you must first enable them for your agent, and then make an API call to record the attribute. Tip For more agent-specific information on collecting custom attributes, see Collect custom attributes sqs.sendMessage(params, function(err, data) { if (err) { res.send(\"Error: \"+ err); } else { res.send(\"Success! Message ID: \"+ data.MessageId); newrelic.addCustomAttribute(\"Message ID\", data.MessageId) } }); Copy 7. Leverage Synthetics to get a high-level view of system health In complex, distributed systems, you need to track and monitor many signals. Sometimes it may be that no one signal is concerning, yet your whole system is behaving anomalously. To get a complete picture, it's critical to analyze symptomatic data in tandem with system-level data. Synthetics allows you to interact with the entire system as an external user would, giving your teams high-level checks for performance and user experience. These external checks help you understand if the entire system is doing what you want regardless of what specific signals may indicate. For more help For more tips and best practices on distributed tracing and custom attributes, see the following: Distributed Tracing Anomaly Detection: A Faster, Easier Way to Troubleshoot Microservices Environments Introduction to distributed tracing Collect custom attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.11215,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " that you don&#x27;t compromise <em>your</em> mean-time-to-resolution (MTTR) or end-user experience. At <em>New</em> <em>Relic</em>, we understand these challenges inherently. In our journey, we&#x27;ve transitioned from a Ruby monolith to a multi-language distributed <em>environment</em> built on more than 300 microservices, for which we average"
      },
      "id": "603ebd8264441f02694e887f"
    },
    {
      "sections": [
        "Set proactive alerts and align teams, tools, and processes for incident response",
        "Prerequisites",
        "1. Define policies",
        "Example questions and KPI solutions",
        "2. Set specific alerts",
        "3. Identify groups",
        "4. Determine thresholds",
        "5. Set notification channels",
        "6. Automate resolution",
        "7. Establish reviews",
        "Example post mortem report",
        "8. Fine-tune process",
        "Expert tip"
      ],
      "title": "Set proactive alerts and align teams, tools, and processes for incident response ",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "454d902dd8ff1ace1070b7ad42489dda5405845c",
      "image": "https://docs.newrelic.com/static/ecb7124a85903b58a0fbb042ddb29cc6/c483d/proactive-baseline-alerts-devops_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/set-proactive-alerts-align-teams-tools-processes-incident-response/",
      "published_at": "2021-07-09T16:00:00Z",
      "updated_at": "2021-07-09T16:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term alerting often carries some negative connotations: many developers correlate alerting with errors, mistakes, and ongoing issues. However, developers who are proactive about alerting, know they don't have to stare at dashboards all day because effective alerts tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Further, a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or environment. With proactive alerting, you'll decrease user-reported incidents, and your teams will spend less time firefighting and more time deploying significant changes to your product. After you define the right alerts, proper incident orchestration aligns your teams, tools, and processes to prepare for incidents and outages in your software. The goal is to provide your teams a predictable framework and process to: Maximize efficiency in communication and effort. Minimize the overall impact to your business. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the Establish objectives and baselines tutorial. Optionally added custom attributes and events. 1. Define policies Define required alerting policies based on SLOs. A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples of service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, 95% of requests completed within 250 ms AND availability is 99.99%), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it's meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than 0.20%. However, not every SLO needs to become an alert. A strong alerting strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alerting strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” Example questions and KPI solutions For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use browser monitoring and APM to alert on site availability. How's our underlying infrastructure? Set KPIs for key hardware, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie them to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site's availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don't yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we've set both a warning and a violation for throughput: alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier, which can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic across five different servers. You can set an alert based on a NRQL query and receive a notification if any server starts getting significantly more or less traffic than the other servers. Here is an example chart: And here's a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups Identify groups to alert, set broadcasting methods, and assign first responders to team dashboards Alerting without the proper broadcasting methods leaves you vulnerable. Your alerting strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack or PagerDuty). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the types of alerts that warrant waking someone up. Recommendation: For each team dashboard, make sure: It has an owner who assumes responsibility for the health of the applications and features it monitors. There is no ambiguity about who is responsible for attending to and resolving an alert condition. This policy will vary between organizations depending on size, structure, and culture. For example, some teams may prefer to assign dashboards and alerts based on de-facto features or application ownership. Other teams may prefer to adopt an on-call rotation (often referred to as pager duty). In on-call rotations, designated team members handle all first-line incident responses, and they resolve or delegate responsibilities based on predetermined incident thresholds. 4. Determine thresholds Determine incident thresholds for alert conditions For each of your applications: Identify the thresholds for what is officially considered an incident. Make sure each set of threshold criteria is context-dependent. Document incident evaluation and known remediation procedures in runbooks. Include links to your runbooks when you define conditions and thresholds for your alert policies. For instance, a certain alert condition may be dismissable during low-traffic periods but require active remediation during peak hours. 5. Set notification channels Ensure alerts have auditable notification channels Make sure that communications during critical incidents take place in easily accessible and highly visible channels. A group chat room dedicated to incident communication is usually a great choice. This allows all stakeholders to participate or observe and provides a chronology of notifications, key decisions, and actions for postmortem analysis. Use any of the available notification channels in New Relic Alerts. For example, to set up a notification channel in Slack: Make sure your organization has completed New Relic's integration requirements with Slack. In the Slack app, select the dropdown in the top-left corner of the app, and select Customize Slack. Click Configure apps. From the list of app integrations, select New Relic. Expand the instructions for New Relic Alerts, and follow the steps to configure notifications from New Relic. 6. Automate resolution Automate triage and resolution steps Automation of simple or repeatable incident response tasks will increase efficiency and minimize the impact of incidents. With proper automation in place, you can disable or isolate faulty application components as soon as an alert threshold is reached, rather than after a notification has been issued. For example, a team managing an application for a digital media company wants to be able to remove commenting abilities from the website if the system has errors. In this case, they could: Add an endpoint to their front-end web application that will toggle a feature flag enabling or disabling the UI components associated with posting comments on an article. Create an alert policy with a threshold set on the sustained error rate in the commenting service. Assign a webhook notification channel that will send a POST request to this endpoint, as well as to the standard team notification channels. In this scenario, errors in the commenting system will trigger the webhook and remove the commenting UI from the website. Users can still use core functionality of the site without seeing errors generated by the commenting service. The application will maintain a stable but degraded state, allowing the team to focus on recovery without the pressure of preventing users from accessing the site. You can also use webhooks to create issues and action items in ticketing systems that have REST APIs, such as Zendesk. Use New Relic Alerts to create a webhook notification channel, and customize the webhook payload as needed. New Relic also provides integrations for common ticketing systems. You can use any of these integrations to file tickets from New Relic APM. 7. Establish reviews Establish a post mortem process After the incident has been resolved, key stakeholders and participants must capture accurate and thorough documentation of the incident. At a minimum, we recommend that the retro documentation includes: A root cause analysis A chronology and summary of remediation steps and their result, whether they were successful or not A measure of the impact to the business in terms of user experience and financial losses, if possible Recommendations for system or feature improvements to prevent a recurrence Recommendations for process and communication improvements Store post mortem reports in a highly visible, searchable repository, such as a shared drive folder or wiki. Culturally, it's essential that this process focuses on constructive learning and improvement rather than punishment or blame. Example post mortem report Here is a brief example of a post mortem report: Post mortem Comments Date March 1, 2018 Executive summary From approximately 1:45PM until 2:30PM, users could not add items to their carts, which prevented any checkouts from occurring during the incident period. Root cause We determined that a change was made to the CSS rules on the product detail page that effectively disabled the Add to cart button. Timeline 1:50PM: Successful checkouts < 10 for 5 minutes alert triggered; assigned to Alice. 1:55PM: After reviewing the ecommerce team dashboard, Alice determined that the threshold was breached immediately following a deploy by Bob. She notified him of the incident. 2:00PM: Alice and Bob began troubleshooting. Attempts at recreating the issue in production were successful. 2:20PM: Bob determined that his change to the CSS on the product detail page disabled the Add to cart button. He deployed a hotfix. 2:30PM: Functionality was restored and the incident was resolved. Impact No checkouts were completed during the duration of the incident. Our typical revenue for a Thursday during this timeframe is $30,000. Recommendations We have been discussing implementing New Relic Synthetics for awhile now. If we had a Synthetic check on the checkout process, this issue would have been detected immediately. We should also implement more thorough unit tests in the front-end web app. 8. Fine-tune process Fine-tune alerts and thresholds As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. When rolling out new code or modifications that could negatively impact performance over a period of time, loosen your threshold conditions to allow for these short-term changes. For instance, we recommend using pre-established baselines and thresholds to increase efficiency during high-impact times for your business, such as annual events and major releases. Fine-tuning gives you the flexibility you need to increase efficiencies and extend your notification channels. As noted earlier, we recommend you start with a group chat service when you first establish notifications. Once you've identified other tools you'd like to integrate with, set up a notification channel to maintain your momentum. Tools such as xMatters and PagerDuty provide popular integrations, but don't overlook simple methods, such as webhooks. The goal is to continuously improve your alerting scheme. Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use the New Relic query language and the Insights query API to create your dashboards. For detailed instructions, check out Sending alerts data to Insights. The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you're using. Expert tip In addition to instrumenting and measuring application and infrastructure metrics, mature DevOps organizations often measure and optimize the efficiency of incident response processes. For example, you can use webhooks to send alert events to New Relic Insights. This allows you to supplement your team dashboards with New Relic Alerts data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.02173,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Example questions and KPI <em>solutions</em>",
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " Fine-tune alerts and thresholds As you use <em>New</em> <em>Relic</em> to <em>optimize</em> <em>your</em> application and infrastructure performance, tighten <em>your</em> <em>New</em> <em>Relic</em> Alerts policy conditions to keep pace with <em>your</em> improved performance. When rolling out <em>new</em> code or modifications that could negatively impact performance over"
      },
      "id": "603ebf0be7b9d2b3982a07a9"
    },
    {
      "sections": [
        "Customer experience improvement: Track experience indicators",
        "1. Use custom attributes to associate performance data",
        "2. Create dashboards with performance and business metrics",
        "Tip",
        "3. Share dashboards across departments",
        "4. Use data to separate performance by cohort and debug issues at the customer level"
      ],
      "title": "Customer experience improvement: Track experience indicators",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "6c4c1f69fa347ab2ada2360a61a559803a2f7ce5",
      "image": "https://docs.newrelic.com/static/65dadbef1fe9c07817f7ead13e12e05e/302a4/Insights-catalyst-dashbaord-1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/customer-experience-improvement-track-experience-indicators/",
      "published_at": "2021-07-09T15:10:29Z",
      "updated_at": "2021-07-09T15:10:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This tutorial covers methods to identify and track the key indicators of customer experience and clarifies the effects of application and infrastructure performance on your business. A clear understanding of what creates a successful customer experience can help modern software teams become more efficient and boost productivity. An efficient, well-functioning IT culture helps organizations make rapid, frequent releases and product changes. A strong culture also democratizes data beyond the typical backend users, making it available to groups such as customer service, support, sales, and marketing. However, this information enablement is useful only if it serves to optimize customer experience. The four steps outlined here are designed to help you leverage the data you collect to make the greatest possible improvements in your organization’s digital customer experience. 1. Use custom attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with your application. In New Relic, you collect this data with custom attributes. If you plan to collect this information in both the frontend and backend, be sure to forward custom attributes from APM to browser. Here are some common attributes to collect: User ID Organization or customer ID A/B testing cohort value High-value customer indicator Purchase value or product IDs (for e-commerce) If you’ve completed the Establish objectives and baselines tutorials, consider what service-level objectives (SLOs) or key metrics you defined in those stages. New Relic recommends including attributes like the ones listed above to measure the impact of your changes and optimizations at a customer level—rather than just measuring pure performance. 2. Create dashboards with performance and business metrics Using the attributes collected in Step 1, build dashboards to examine the impact of performance issues on your users. insights.newrelic.com > Dashboards For example, if you were collecting a custom username attribute, you could use NRQL queries like these to create your widgets for your New Relic Insights dashboard: Number of errors by username: SELECT count(*) FROM TransactionError FACET username Copy Median response time by username: SELECT percentile(duration,50) FROM Transaction FACET username Copy Total purchase value in transactions with errors: SELECT sum(purchaseTotal) FROM TransactionError FACET username Copy Tip If you include a FACET clause in your queries, you’ll be able to click into metric results to see corresponding change in the performance data. For more information on faceting, see Linking Between Dashboards to Drill Into Your Data. 3. Share dashboards across departments Dashboards, data, and metrics that nobody looks at or knows about might as well not exist. When considering how, or with whom, to share your dashboards, consider the following questions: Which teams are responsible for applications that have high levels of end-user interaction? What non-engineering teams could benefit from this information? Customer support: Could customer issues be resolved faster? Product/engineering: Could the product team make more informed roadmap decisions? Customer success: Can this data be used to make customers more successful? Are there other teams that can benefit from cohort analysis that includes performance metrics? 4. Use data to separate performance by cohort and debug issues at the customer level After you create your dashboards, use them to scope issues affecting particular customers or sets of customers. For example, the following widget shows which apps have errors for a particular user: insights.newrelic.com > Dashboards Use attributes that track user and performance to set alerts on high priority users or customers. For example, you could include a WHERE clause in your NRQL queries to scope the results to a set of user IDs or customer IDs. Set alerts on any performance or business metric that is tied to these attributes. See NRQL alerts will change how you think about using New Relic data for more information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 429.21094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with <em>your</em> application. In <em>New</em> <em>Relic</em>, you collect this data"
      },
      "id": "603ebeb964441f6e314e88a1"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/optimize-cloud-architecture-spend-continuously-improve-your-modern-cloud-environment": [
    {
      "sections": [
        "Analyze distributed systems",
        "1. Identify high-priority areas to monitor",
        "2. Instrument to get the visibility you require",
        "3. Create dashboards",
        "4. Dig deeper with distributed tracing",
        "5. Annotate message queues with distributed tracing payload APIs",
        "Example annotated message queue",
        "6. Annotate and tag traces with custom attributes",
        "Tip",
        "7. Leverage Synthetics to get a high-level view of system health",
        "For more help"
      ],
      "title": "Analyze distributed systems",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "af1cf5a80f8254c90509e562fb68a6ded2f7207f",
      "image": "https://docs.newrelic.com/static/838e50badd634f1f188cf821785f6696/2cffa/APm_distributed-tracing-catalyst-TWO.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/analyze-distributed-systems/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a monolithic application, a simple stack trace can contain enough diagnostic data to determine the root cause of a code defect. But cloud computing and microservices have blurred the lines between software and infrastructure; in modern architectures, requests are distributed across many smaller services—often with ephemeral lifespans—hosted in both on-premise and cloud environments. Spotting code defects becomes much more complex. APM's distributed tracing automatically helps teams troubleshoot such distributed systems. Distributed traces are just one component of a well-monitored system. You need a holistic view of your distributed system, especially when tracking the root cause of a defect, as there are volumes of data to evaluate and understand. When managing a microservices environment, it's critical that you have the capability to spot bottlenecks and problem spans quickly so that you don't compromise your mean-time-to-resolution (MTTR) or end-user experience. At New Relic, we understand these challenges inherently. In our journey, we've transitioned from a Ruby monolith to a multi-language distributed environment built on more than 300 microservices, for which we average 50 code deploys a day. Such challenges inform both how we've built and how we monitor New Relic. Use the New Relic platform to translate your data into relevant insights, so you can collaborate around a common framework to build context and quickly optimize and troubleshoot your complex, distributed systems. 1. Identify high-priority areas to monitor Distributed systems are complex. Before engaging with the New Relic platform, we recommend that you identify the most critical areas of your systems to observe, and focus on instrumenting those high-priority areas first. Google's SRE handbook suggests monitoring the \"four golden signals\": traffic, latency, errors, and saturation, as shown in the following dashboard: Dashboards: Visualize key areas to monitor with dashboards. Too often, teams monitor what is either 1) easy to measure or 2) interpretable. Avoid this fallacy. When making choices about what to monitor, involve product managers and other stakeholders from your organization. Your goal is to monitor what matters to your business, not to overload your teams with noise. 2. Instrument to get the visibility you require Once you've identified your key priorities, instrument the appropriate parts of your system with the New Relic platform. Monitor your web apps with APM. See compatibility and requirements for New Relic agents and products to learn precise compatibility details for each supported language and then install the APM agent on your application stack. Steps for installing APM agents vary based on language. Enable distributed tracing for APM, which will affect some existing APM features. If you're accustomed to using APM without distributed tracing, read the transition guide before you enable this feature. Monitor your compute resources with infrastructure. See compatibility and requirements for infrastructure monitoring for supported operating systems and environments. You can also instrument other products and services with on-host integrations. Monitor your front-end experience with mobile and browser. 3. Create dashboards Use dashboards to get an overview of your entire system and baseline performance, so you can better understand how the components work together. Insights provides a single framework for aligning disparate teams around relevant data. Approach this first build as your launching point, giving your teams something to react to as you begin to ascribe context to your system. You should continue to build and iterate your dashboards as you analyze, troubleshoot, and optimize your distributed system. Even after you have a basic understanding of your system, use dashboards to inform the decisions you make going forward. Dashboards provide central repository of truth, allowing all stakeholders to build context about the health of your system. Here is an example of a query that displays the slowest applications. SELECT percentile(duration, 99) as 'Slowest duration' FROM Transaction FACET name Copy Using this query you can focus on the slowest application to dig deeper: After running the query, dashboards displays the slowest durations. 4. Dig deeper with distributed tracing After you have basic instrumentation and contextual dashboards in place, you can begin to dig deeper to troubleshoot or optimize your system. A differentiated feature in New Relic One's Global Distributed Tracing is that you can come in with vague context for what you're investigating and search across all accounts and traces to get down to the actual user interactions that have those attributes somewhere in their trace. You no longer must begin with the application or specific entity to search for traces that include that application. For example, start with an analysis of your complex service calls, using the distributed tracing UI to: View a scatter plot chart showing the frequency, duration, and other facets of your distributed traces Group traces by root entry, service, service entry, or traces with errors View a trace list Filter specific traces to meet certain parameters You'll likely discover that you want to take the analysis one step further by annotating your traces with information that adds context to your troubleshooting, like User ID. You can do this in New Relic using custom attributes. one.newrelic.com > APM > Distributed tracing: use the distributed tracing UI to monitor and analyze modern distributed systems. 5. Annotate message queues with distributed tracing payload APIs To see connections between services in some environments—for example, in a system that relies heavily on queues—you may need to do some manual instrumentation using the distributed tracing payload APIs to ensure you're propagating the payload. This gives agents the necessary context to create spans with the right correlation; you'll see end-to-end traces for all linked services, including those that cross through the queue. Example annotated message queue For example: Start a transaction. Create the distributed tracing payload on the producer service within a New Relic transaction. As part of the message, add the distributed tracing payload. ​​newrelic.setTransactionName(\"Send Message\") // Create SQS service object var sqs = new AWS.SQS({apiVersion: '2012-11-05'}); var transactionHandle = newrelic.getTransaction(); var payload = transactionHandle.createDistributedTracePayload(); var jsonPayload = payload.text(); //add the jsonPayload as a MessageAttribute var params = { DelaySeconds: 10, MessageAttributes: { \"Testing\": { DataType: \"String\", StringValue: \"123\" }, \"TraceContext\": { DataType: \"String\", StringValue: jsonPayload } }, MessageBody: \"Testing 123\", QueueUrl: \"https://sqs.us-west-2.amazonaws.com/408155283954/sqs-testing\" }; Copy With the context of a transaction, receive the payload on the consumer service. sqs.receiveMessage(params, function(err, data) { if (err) { console.log(\"Receive Error\", err); } else if (data && data.Messages) { console.log(\"trace context:\") var traceContext = data.Messages[0].MessageAttributes.TraceContext.StringValue; if (traceContext != \"\") { var transactionHandle = newrelic.getTransaction(); transactionHandle.acceptDistributedTracePayload(traceContext); } Copy 6. Annotate and tag traces with custom attributes We recommend that you use custom attributes to decorate events with additional information for better tracing. For example, by adding key-value pairs, you can attach a user ID to trace a specific user through the call stack and review failing requests to determine if that user is having an unusually poor experience. We recommend adding custom attributes based on your use case; for example, if your instrumenting an order management system, you could add an order number custom attribute to your traces. To add custom attributes, you must first enable them for your agent, and then make an API call to record the attribute. Tip For more agent-specific information on collecting custom attributes, see Collect custom attributes sqs.sendMessage(params, function(err, data) { if (err) { res.send(\"Error: \"+ err); } else { res.send(\"Success! Message ID: \"+ data.MessageId); newrelic.addCustomAttribute(\"Message ID\", data.MessageId) } }); Copy 7. Leverage Synthetics to get a high-level view of system health In complex, distributed systems, you need to track and monitor many signals. Sometimes it may be that no one signal is concerning, yet your whole system is behaving anomalously. To get a complete picture, it's critical to analyze symptomatic data in tandem with system-level data. Synthetics allows you to interact with the entire system as an external user would, giving your teams high-level checks for performance and user experience. These external checks help you understand if the entire system is doing what you want regardless of what specific signals may indicate. For more help For more tips and best practices on distributed tracing and custom attributes, see the following: Distributed Tracing Anomaly Detection: A Faster, Easier Way to Troubleshoot Microservices Environments Introduction to distributed tracing Collect custom attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.11188,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " that you don&#x27;t compromise <em>your</em> mean-time-to-resolution (MTTR) or end-user experience. At <em>New</em> <em>Relic</em>, we understand these challenges inherently. In our journey, we&#x27;ve transitioned from a Ruby monolith to a multi-language distributed <em>environment</em> built on more than 300 microservices, for which we average"
      },
      "id": "603ebd8264441f02694e887f"
    },
    {
      "sections": [
        "Set proactive alerts and align teams, tools, and processes for incident response",
        "Prerequisites",
        "1. Define policies",
        "Example questions and KPI solutions",
        "2. Set specific alerts",
        "3. Identify groups",
        "4. Determine thresholds",
        "5. Set notification channels",
        "6. Automate resolution",
        "7. Establish reviews",
        "Example post mortem report",
        "8. Fine-tune process",
        "Expert tip"
      ],
      "title": "Set proactive alerts and align teams, tools, and processes for incident response ",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "454d902dd8ff1ace1070b7ad42489dda5405845c",
      "image": "https://docs.newrelic.com/static/ecb7124a85903b58a0fbb042ddb29cc6/c483d/proactive-baseline-alerts-devops_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/set-proactive-alerts-align-teams-tools-processes-incident-response/",
      "published_at": "2021-07-09T16:00:00Z",
      "updated_at": "2021-07-09T16:00:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The term alerting often carries some negative connotations: many developers correlate alerting with errors, mistakes, and ongoing issues. However, developers who are proactive about alerting, know they don't have to stare at dashboards all day because effective alerts tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Further, a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or environment. With proactive alerting, you'll decrease user-reported incidents, and your teams will spend less time firefighting and more time deploying significant changes to your product. After you define the right alerts, proper incident orchestration aligns your teams, tools, and processes to prepare for incidents and outages in your software. The goal is to provide your teams a predictable framework and process to: Maximize efficiency in communication and effort. Minimize the overall impact to your business. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the Establish objectives and baselines tutorial. Optionally added custom attributes and events. 1. Define policies Define required alerting policies based on SLOs. A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples of service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, 95% of requests completed within 250 ms AND availability is 99.99%), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it's meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than 0.20%. However, not every SLO needs to become an alert. A strong alerting strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alerting strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” Example questions and KPI solutions For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? Use browser monitoring and APM to alert on site availability. How's our underlying infrastructure? Set KPIs for key hardware, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie them to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site's availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don't yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds You can set this same kind of alert in browser to catch sub-optimal performance. In the following example, we've set both a warning and a violation for throughput: alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier, which can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic across five different servers. You can set an alert based on a NRQL query and receive a notification if any server starts getting significantly more or less traffic than the other servers. Here is an example chart: And here's a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Copy Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups Identify groups to alert, set broadcasting methods, and assign first responders to team dashboards Alerting without the proper broadcasting methods leaves you vulnerable. Your alerting strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack or PagerDuty). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the types of alerts that warrant waking someone up. Recommendation: For each team dashboard, make sure: It has an owner who assumes responsibility for the health of the applications and features it monitors. There is no ambiguity about who is responsible for attending to and resolving an alert condition. This policy will vary between organizations depending on size, structure, and culture. For example, some teams may prefer to assign dashboards and alerts based on de-facto features or application ownership. Other teams may prefer to adopt an on-call rotation (often referred to as pager duty). In on-call rotations, designated team members handle all first-line incident responses, and they resolve or delegate responsibilities based on predetermined incident thresholds. 4. Determine thresholds Determine incident thresholds for alert conditions For each of your applications: Identify the thresholds for what is officially considered an incident. Make sure each set of threshold criteria is context-dependent. Document incident evaluation and known remediation procedures in runbooks. Include links to your runbooks when you define conditions and thresholds for your alert policies. For instance, a certain alert condition may be dismissable during low-traffic periods but require active remediation during peak hours. 5. Set notification channels Ensure alerts have auditable notification channels Make sure that communications during critical incidents take place in easily accessible and highly visible channels. A group chat room dedicated to incident communication is usually a great choice. This allows all stakeholders to participate or observe and provides a chronology of notifications, key decisions, and actions for postmortem analysis. Use any of the available notification channels in New Relic Alerts. For example, to set up a notification channel in Slack: Make sure your organization has completed New Relic's integration requirements with Slack. In the Slack app, select the dropdown in the top-left corner of the app, and select Customize Slack. Click Configure apps. From the list of app integrations, select New Relic. Expand the instructions for New Relic Alerts, and follow the steps to configure notifications from New Relic. 6. Automate resolution Automate triage and resolution steps Automation of simple or repeatable incident response tasks will increase efficiency and minimize the impact of incidents. With proper automation in place, you can disable or isolate faulty application components as soon as an alert threshold is reached, rather than after a notification has been issued. For example, a team managing an application for a digital media company wants to be able to remove commenting abilities from the website if the system has errors. In this case, they could: Add an endpoint to their front-end web application that will toggle a feature flag enabling or disabling the UI components associated with posting comments on an article. Create an alert policy with a threshold set on the sustained error rate in the commenting service. Assign a webhook notification channel that will send a POST request to this endpoint, as well as to the standard team notification channels. In this scenario, errors in the commenting system will trigger the webhook and remove the commenting UI from the website. Users can still use core functionality of the site without seeing errors generated by the commenting service. The application will maintain a stable but degraded state, allowing the team to focus on recovery without the pressure of preventing users from accessing the site. You can also use webhooks to create issues and action items in ticketing systems that have REST APIs, such as Zendesk. Use New Relic Alerts to create a webhook notification channel, and customize the webhook payload as needed. New Relic also provides integrations for common ticketing systems. You can use any of these integrations to file tickets from New Relic APM. 7. Establish reviews Establish a post mortem process After the incident has been resolved, key stakeholders and participants must capture accurate and thorough documentation of the incident. At a minimum, we recommend that the retro documentation includes: A root cause analysis A chronology and summary of remediation steps and their result, whether they were successful or not A measure of the impact to the business in terms of user experience and financial losses, if possible Recommendations for system or feature improvements to prevent a recurrence Recommendations for process and communication improvements Store post mortem reports in a highly visible, searchable repository, such as a shared drive folder or wiki. Culturally, it's essential that this process focuses on constructive learning and improvement rather than punishment or blame. Example post mortem report Here is a brief example of a post mortem report: Post mortem Comments Date March 1, 2018 Executive summary From approximately 1:45PM until 2:30PM, users could not add items to their carts, which prevented any checkouts from occurring during the incident period. Root cause We determined that a change was made to the CSS rules on the product detail page that effectively disabled the Add to cart button. Timeline 1:50PM: Successful checkouts < 10 for 5 minutes alert triggered; assigned to Alice. 1:55PM: After reviewing the ecommerce team dashboard, Alice determined that the threshold was breached immediately following a deploy by Bob. She notified him of the incident. 2:00PM: Alice and Bob began troubleshooting. Attempts at recreating the issue in production were successful. 2:20PM: Bob determined that his change to the CSS on the product detail page disabled the Add to cart button. He deployed a hotfix. 2:30PM: Functionality was restored and the incident was resolved. Impact No checkouts were completed during the duration of the incident. Our typical revenue for a Thursday during this timeframe is $30,000. Recommendations We have been discussing implementing New Relic Synthetics for awhile now. If we had a Synthetic check on the checkout process, this issue would have been detected immediately. We should also implement more thorough unit tests in the front-end web app. 8. Fine-tune process Fine-tune alerts and thresholds As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. When rolling out new code or modifications that could negatively impact performance over a period of time, loosen your threshold conditions to allow for these short-term changes. For instance, we recommend using pre-established baselines and thresholds to increase efficiency during high-impact times for your business, such as annual events and major releases. Fine-tuning gives you the flexibility you need to increase efficiencies and extend your notification channels. As noted earlier, we recommend you start with a group chat service when you first establish notifications. Once you've identified other tools you'd like to integrate with, set up a notification channel to maintain your momentum. Tools such as xMatters and PagerDuty provide popular integrations, but don't overlook simple methods, such as webhooks. The goal is to continuously improve your alerting scheme. Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use the New Relic query language and the Insights query API to create your dashboards. For detailed instructions, check out Sending alerts data to Insights. The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Copy Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Copy Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Copy Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Copy Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you're using. Expert tip In addition to instrumenting and measuring application and infrastructure metrics, mature DevOps organizations often measure and optimize the efficiency of incident response processes. For example, you can use webhooks to send alert events to New Relic Insights. This allows you to supplement your team dashboards with New Relic Alerts data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.02148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Example questions and KPI <em>solutions</em>",
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " Fine-tune alerts and thresholds As you use <em>New</em> <em>Relic</em> to <em>optimize</em> <em>your</em> application and infrastructure performance, tighten <em>your</em> <em>New</em> <em>Relic</em> Alerts policy conditions to keep pace with <em>your</em> improved performance. When rolling out <em>new</em> code or modifications that could negatively impact performance over"
      },
      "id": "603ebf0be7b9d2b3982a07a9"
    },
    {
      "sections": [
        "Customer experience improvement: Track experience indicators",
        "1. Use custom attributes to associate performance data",
        "2. Create dashboards with performance and business metrics",
        "Tip",
        "3. Share dashboards across departments",
        "4. Use data to separate performance by cohort and debug issues at the customer level"
      ],
      "title": "Customer experience improvement: Track experience indicators",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "6c4c1f69fa347ab2ada2360a61a559803a2f7ce5",
      "image": "https://docs.newrelic.com/static/65dadbef1fe9c07817f7ead13e12e05e/302a4/Insights-catalyst-dashbaord-1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/customer-experience-improvement-track-experience-indicators/",
      "published_at": "2021-07-09T15:10:29Z",
      "updated_at": "2021-07-09T15:10:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This tutorial covers methods to identify and track the key indicators of customer experience and clarifies the effects of application and infrastructure performance on your business. A clear understanding of what creates a successful customer experience can help modern software teams become more efficient and boost productivity. An efficient, well-functioning IT culture helps organizations make rapid, frequent releases and product changes. A strong culture also democratizes data beyond the typical backend users, making it available to groups such as customer service, support, sales, and marketing. However, this information enablement is useful only if it serves to optimize customer experience. The four steps outlined here are designed to help you leverage the data you collect to make the greatest possible improvements in your organization’s digital customer experience. 1. Use custom attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with your application. In New Relic, you collect this data with custom attributes. If you plan to collect this information in both the frontend and backend, be sure to forward custom attributes from APM to browser. Here are some common attributes to collect: User ID Organization or customer ID A/B testing cohort value High-value customer indicator Purchase value or product IDs (for e-commerce) If you’ve completed the Establish objectives and baselines tutorials, consider what service-level objectives (SLOs) or key metrics you defined in those stages. New Relic recommends including attributes like the ones listed above to measure the impact of your changes and optimizations at a customer level—rather than just measuring pure performance. 2. Create dashboards with performance and business metrics Using the attributes collected in Step 1, build dashboards to examine the impact of performance issues on your users. insights.newrelic.com > Dashboards For example, if you were collecting a custom username attribute, you could use NRQL queries like these to create your widgets for your New Relic Insights dashboard: Number of errors by username: SELECT count(*) FROM TransactionError FACET username Copy Median response time by username: SELECT percentile(duration,50) FROM Transaction FACET username Copy Total purchase value in transactions with errors: SELECT sum(purchaseTotal) FROM TransactionError FACET username Copy Tip If you include a FACET clause in your queries, you’ll be able to click into metric results to see corresponding change in the performance data. For more information on faceting, see Linking Between Dashboards to Drill Into Your Data. 3. Share dashboards across departments Dashboards, data, and metrics that nobody looks at or knows about might as well not exist. When considering how, or with whom, to share your dashboards, consider the following questions: Which teams are responsible for applications that have high levels of end-user interaction? What non-engineering teams could benefit from this information? Customer support: Could customer issues be resolved faster? Product/engineering: Could the product team make more informed roadmap decisions? Customer success: Can this data be used to make customers more successful? Are there other teams that can benefit from cohort analysis that includes performance metrics? 4. Use data to separate performance by cohort and debug issues at the customer level After you create your dashboards, use them to scope issues affecting particular customers or sets of customers. For example, the following widget shows which apps have errors for a particular user: insights.newrelic.com > Dashboards Use attributes that track user and performance to set alerts on high priority users or customers. For example, you could include a WHERE clause in your NRQL queries to scope the results to a set of user IDs or customer IDs. Set alerts on any performance or business metric that is tied to these attributes. See NRQL alerts will change how you think about using New Relic data for more information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 429.2107,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with <em>your</em> application. In <em>New</em> <em>Relic</em>, you collect this data"
      },
      "id": "603ebeb964441f6e314e88a1"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/set-proactive-alerts-align-teams-tools-processes-incident-response": [
    {
      "sections": [
        "Analyze distributed systems",
        "1. Identify high-priority areas to monitor",
        "2. Instrument to get the visibility you require",
        "3. Create dashboards",
        "4. Dig deeper with distributed tracing",
        "5. Annotate message queues with distributed tracing payload APIs",
        "Example annotated message queue",
        "6. Annotate and tag traces with custom attributes",
        "Tip",
        "7. Leverage Synthetics to get a high-level view of system health",
        "For more help"
      ],
      "title": "Analyze distributed systems",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "af1cf5a80f8254c90509e562fb68a6ded2f7207f",
      "image": "https://docs.newrelic.com/static/838e50badd634f1f188cf821785f6696/2cffa/APm_distributed-tracing-catalyst-TWO.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/analyze-distributed-systems/",
      "published_at": "2021-07-09T16:05:31Z",
      "updated_at": "2021-07-09T16:05:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a monolithic application, a simple stack trace can contain enough diagnostic data to determine the root cause of a code defect. But cloud computing and microservices have blurred the lines between software and infrastructure; in modern architectures, requests are distributed across many smaller services—often with ephemeral lifespans—hosted in both on-premise and cloud environments. Spotting code defects becomes much more complex. APM's distributed tracing automatically helps teams troubleshoot such distributed systems. Distributed traces are just one component of a well-monitored system. You need a holistic view of your distributed system, especially when tracking the root cause of a defect, as there are volumes of data to evaluate and understand. When managing a microservices environment, it's critical that you have the capability to spot bottlenecks and problem spans quickly so that you don't compromise your mean-time-to-resolution (MTTR) or end-user experience. At New Relic, we understand these challenges inherently. In our journey, we've transitioned from a Ruby monolith to a multi-language distributed environment built on more than 300 microservices, for which we average 50 code deploys a day. Such challenges inform both how we've built and how we monitor New Relic. Use the New Relic platform to translate your data into relevant insights, so you can collaborate around a common framework to build context and quickly optimize and troubleshoot your complex, distributed systems. 1. Identify high-priority areas to monitor Distributed systems are complex. Before engaging with the New Relic platform, we recommend that you identify the most critical areas of your systems to observe, and focus on instrumenting those high-priority areas first. Google's SRE handbook suggests monitoring the \"four golden signals\": traffic, latency, errors, and saturation, as shown in the following dashboard: Dashboards: Visualize key areas to monitor with dashboards. Too often, teams monitor what is either 1) easy to measure or 2) interpretable. Avoid this fallacy. When making choices about what to monitor, involve product managers and other stakeholders from your organization. Your goal is to monitor what matters to your business, not to overload your teams with noise. 2. Instrument to get the visibility you require Once you've identified your key priorities, instrument the appropriate parts of your system with the New Relic platform. Monitor your web apps with APM. See compatibility and requirements for New Relic agents and products to learn precise compatibility details for each supported language and then install the APM agent on your application stack. Steps for installing APM agents vary based on language. Enable distributed tracing for APM, which will affect some existing APM features. If you're accustomed to using APM without distributed tracing, read the transition guide before you enable this feature. Monitor your compute resources with infrastructure. See compatibility and requirements for infrastructure monitoring for supported operating systems and environments. You can also instrument other products and services with on-host integrations. Monitor your front-end experience with mobile and browser. 3. Create dashboards Use dashboards to get an overview of your entire system and baseline performance, so you can better understand how the components work together. Insights provides a single framework for aligning disparate teams around relevant data. Approach this first build as your launching point, giving your teams something to react to as you begin to ascribe context to your system. You should continue to build and iterate your dashboards as you analyze, troubleshoot, and optimize your distributed system. Even after you have a basic understanding of your system, use dashboards to inform the decisions you make going forward. Dashboards provide central repository of truth, allowing all stakeholders to build context about the health of your system. Here is an example of a query that displays the slowest applications. SELECT percentile(duration, 99) as 'Slowest duration' FROM Transaction FACET name Copy Using this query you can focus on the slowest application to dig deeper: After running the query, dashboards displays the slowest durations. 4. Dig deeper with distributed tracing After you have basic instrumentation and contextual dashboards in place, you can begin to dig deeper to troubleshoot or optimize your system. A differentiated feature in New Relic One's Global Distributed Tracing is that you can come in with vague context for what you're investigating and search across all accounts and traces to get down to the actual user interactions that have those attributes somewhere in their trace. You no longer must begin with the application or specific entity to search for traces that include that application. For example, start with an analysis of your complex service calls, using the distributed tracing UI to: View a scatter plot chart showing the frequency, duration, and other facets of your distributed traces Group traces by root entry, service, service entry, or traces with errors View a trace list Filter specific traces to meet certain parameters You'll likely discover that you want to take the analysis one step further by annotating your traces with information that adds context to your troubleshooting, like User ID. You can do this in New Relic using custom attributes. one.newrelic.com > APM > Distributed tracing: use the distributed tracing UI to monitor and analyze modern distributed systems. 5. Annotate message queues with distributed tracing payload APIs To see connections between services in some environments—for example, in a system that relies heavily on queues—you may need to do some manual instrumentation using the distributed tracing payload APIs to ensure you're propagating the payload. This gives agents the necessary context to create spans with the right correlation; you'll see end-to-end traces for all linked services, including those that cross through the queue. Example annotated message queue For example: Start a transaction. Create the distributed tracing payload on the producer service within a New Relic transaction. As part of the message, add the distributed tracing payload. ​​newrelic.setTransactionName(\"Send Message\") // Create SQS service object var sqs = new AWS.SQS({apiVersion: '2012-11-05'}); var transactionHandle = newrelic.getTransaction(); var payload = transactionHandle.createDistributedTracePayload(); var jsonPayload = payload.text(); //add the jsonPayload as a MessageAttribute var params = { DelaySeconds: 10, MessageAttributes: { \"Testing\": { DataType: \"String\", StringValue: \"123\" }, \"TraceContext\": { DataType: \"String\", StringValue: jsonPayload } }, MessageBody: \"Testing 123\", QueueUrl: \"https://sqs.us-west-2.amazonaws.com/408155283954/sqs-testing\" }; Copy With the context of a transaction, receive the payload on the consumer service. sqs.receiveMessage(params, function(err, data) { if (err) { console.log(\"Receive Error\", err); } else if (data && data.Messages) { console.log(\"trace context:\") var traceContext = data.Messages[0].MessageAttributes.TraceContext.StringValue; if (traceContext != \"\") { var transactionHandle = newrelic.getTransaction(); transactionHandle.acceptDistributedTracePayload(traceContext); } Copy 6. Annotate and tag traces with custom attributes We recommend that you use custom attributes to decorate events with additional information for better tracing. For example, by adding key-value pairs, you can attach a user ID to trace a specific user through the call stack and review failing requests to determine if that user is having an unusually poor experience. We recommend adding custom attributes based on your use case; for example, if your instrumenting an order management system, you could add an order number custom attribute to your traces. To add custom attributes, you must first enable them for your agent, and then make an API call to record the attribute. Tip For more agent-specific information on collecting custom attributes, see Collect custom attributes sqs.sendMessage(params, function(err, data) { if (err) { res.send(\"Error: \"+ err); } else { res.send(\"Success! Message ID: \"+ data.MessageId); newrelic.addCustomAttribute(\"Message ID\", data.MessageId) } }); Copy 7. Leverage Synthetics to get a high-level view of system health In complex, distributed systems, you need to track and monitor many signals. Sometimes it may be that no one signal is concerning, yet your whole system is behaving anomalously. To get a complete picture, it's critical to analyze symptomatic data in tandem with system-level data. Synthetics allows you to interact with the entire system as an external user would, giving your teams high-level checks for performance and user experience. These external checks help you understand if the entire system is doing what you want regardless of what specific signals may indicate. For more help For more tips and best practices on distributed tracing and custom attributes, see the following: Distributed Tracing Anomaly Detection: A Faster, Easier Way to Troubleshoot Microservices Environments Introduction to distributed tracing Collect custom attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 430.11188,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " that you don&#x27;t compromise <em>your</em> mean-time-to-resolution (MTTR) or end-user experience. At <em>New</em> <em>Relic</em>, we understand these challenges inherently. In our journey, we&#x27;ve transitioned from a Ruby monolith to a multi-language distributed <em>environment</em> built on more than 300 microservices, for which we average"
      },
      "id": "603ebd8264441f02694e887f"
    },
    {
      "sections": [
        "Customer experience improvement: Track experience indicators",
        "1. Use custom attributes to associate performance data",
        "2. Create dashboards with performance and business metrics",
        "Tip",
        "3. Share dashboards across departments",
        "4. Use data to separate performance by cohort and debug issues at the customer level"
      ],
      "title": "Customer experience improvement: Track experience indicators",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "6c4c1f69fa347ab2ada2360a61a559803a2f7ce5",
      "image": "https://docs.newrelic.com/static/65dadbef1fe9c07817f7ead13e12e05e/302a4/Insights-catalyst-dashbaord-1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/customer-experience-improvement-track-experience-indicators/",
      "published_at": "2021-07-09T15:10:29Z",
      "updated_at": "2021-07-09T15:10:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This tutorial covers methods to identify and track the key indicators of customer experience and clarifies the effects of application and infrastructure performance on your business. A clear understanding of what creates a successful customer experience can help modern software teams become more efficient and boost productivity. An efficient, well-functioning IT culture helps organizations make rapid, frequent releases and product changes. A strong culture also democratizes data beyond the typical backend users, making it available to groups such as customer service, support, sales, and marketing. However, this information enablement is useful only if it serves to optimize customer experience. The four steps outlined here are designed to help you leverage the data you collect to make the greatest possible improvements in your organization’s digital customer experience. 1. Use custom attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with your application. In New Relic, you collect this data with custom attributes. If you plan to collect this information in both the frontend and backend, be sure to forward custom attributes from APM to browser. Here are some common attributes to collect: User ID Organization or customer ID A/B testing cohort value High-value customer indicator Purchase value or product IDs (for e-commerce) If you’ve completed the Establish objectives and baselines tutorials, consider what service-level objectives (SLOs) or key metrics you defined in those stages. New Relic recommends including attributes like the ones listed above to measure the impact of your changes and optimizations at a customer level—rather than just measuring pure performance. 2. Create dashboards with performance and business metrics Using the attributes collected in Step 1, build dashboards to examine the impact of performance issues on your users. insights.newrelic.com > Dashboards For example, if you were collecting a custom username attribute, you could use NRQL queries like these to create your widgets for your New Relic Insights dashboard: Number of errors by username: SELECT count(*) FROM TransactionError FACET username Copy Median response time by username: SELECT percentile(duration,50) FROM Transaction FACET username Copy Total purchase value in transactions with errors: SELECT sum(purchaseTotal) FROM TransactionError FACET username Copy Tip If you include a FACET clause in your queries, you’ll be able to click into metric results to see corresponding change in the performance data. For more information on faceting, see Linking Between Dashboards to Drill Into Your Data. 3. Share dashboards across departments Dashboards, data, and metrics that nobody looks at or knows about might as well not exist. When considering how, or with whom, to share your dashboards, consider the following questions: Which teams are responsible for applications that have high levels of end-user interaction? What non-engineering teams could benefit from this information? Customer support: Could customer issues be resolved faster? Product/engineering: Could the product team make more informed roadmap decisions? Customer success: Can this data be used to make customers more successful? Are there other teams that can benefit from cohort analysis that includes performance metrics? 4. Use data to separate performance by cohort and debug issues at the customer level After you create your dashboards, use them to scope issues affecting particular customers or sets of customers. For example, the following widget shows which apps have errors for a particular user: insights.newrelic.com > Dashboards Use attributes that track user and performance to set alerts on high priority users or customers. For example, you could include a WHERE clause in your NRQL queries to scope the results to a set of user IDs or customer IDs. Set alerts on any performance or business metric that is tied to these attributes. See NRQL alerts will change how you think about using New Relic data for more information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 429.2107,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": " attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with <em>your</em> application. In <em>New</em> <em>Relic</em>, you collect this data"
      },
      "id": "603ebeb964441f6e314e88a1"
    },
    {
      "sections": [
        "Manage your containerized environment",
        "1. Update to latest infrastructure agent and enable Kubernetes integration",
        "2. Leverage the Kubernetes cluster explorer to further explore cluster performance and health",
        "3. Navigate out-of-the-box dashboards to analyze historical metrics of your Kubernetes environment",
        "4. Monitor applications running in Kubernetes with APM",
        "Correlate your Kubernetes back-end with end-user experience using browser and synthetic monitoring",
        "6. Bring teams together with dashboards tailored to specific business use cases and KPIs",
        "Learn more"
      ],
      "title": "Manage your containerized environment",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Optimize your cloud native environment"
      ],
      "external_id": "71ba4468ed7d078021ccd705c78e72cfb5e92b5f",
      "image": "https://docs.newrelic.com/static/f744b0e1c8aac86e63f46a5798df58ae/c1b63/cont_environment01.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/manage-your-containerized-environment/",
      "published_at": "2021-07-09T10:36:00Z",
      "updated_at": "2021-07-09T10:36:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Widespread adoption of containers has changed the way applications are written and deployed. Container orchestration technologies such as Kubernetes are making it easier for teams to schedule, deploy, and manage their containerized applications. But challenges still exist that require teams to rethink their environment and application monitoring strategies: Challenge 1: Containers are ephemeral by nature. Knowing the containers or pod or node (host) where the application is currently running is not necessarily an indication of where it was running 5, 15, or 30 minutes ago when the issue occurred. Containers are deployed in dynamic, constantly evolving environments that require a modern monitoring approach. Challenge 2: Often, organizations are adopting containers as they break down monolithic applications into multiple microservices. This new approach introduces new complexity to the system and the sheer scale and dimensionality of containers is hard to conceptualize in an easy-to-understand format. Challenge 3: Delivering a differentiated end-user experience is a key initiative for all organizations, and containers are being adopted to help organizations release better software, faster. But with this tremendous opportunity also comes risk, because every time a new container is deployed, the cluster is impacted. Organizations need context into how infrastructure changes impact the application stack, and how changes to both the infrastructure and application stack affect the end-user experience. Getting all of this data in real-time in a digestible format is a significant challenge in distributed, containerized environments. The New Relic platform offers customers both ease of use and ease of deployment for containerized Kubernetes environments. With a few clicks you have the data and confidence to move forward intelligently. These six steps illustrate how to use the New Relic One platform to manage your containers and how they are scheduled: 1. Update to latest infrastructure agent and enable Kubernetes integration To get started, you'll need to deploy the latest Infrastructure agent onto a Kubernetes cluster with a DaemonSet. Leveraging DaemonSets is vital in dynamic, containerized environments, because when a new node is deployed or the cluster scales up or down, the DaemonSet ensures the New Relic agent is running on these new nodes. In addition, to build a complete picture of your Kubernetes environment, New Relic aggregates data from many resources, including Kube-state metrics. New Relic's “Kubernetes aware” approach makes it easy for Kubernetes to do its job as an orchestrator without missing a single node, cluster, or event. 2. Leverage the Kubernetes cluster explorer to further explore cluster performance and health Once the Kubernetes integration is installed, you can access the New Relic Kubernetes cluster explorer, which offers a differentiated, intuitive way to visualize the health and performance of Kubernetes clusters. It applies advanced capabilities to filter, sort, and search for Kubernetes entities, helping teams understand the relationships and dependencies within an environment. It's a powerful and innovative solution to the challenges associated with running Kubernetes at massive scale. 3. Navigate out-of-the-box dashboards to analyze historical metrics of your Kubernetes environment Above and beyond what the cluster explorer provides, New Relic provides out-of-the-box dashboards that allow customers to analyze performance and operating metrics of their Kubernetes environments. Key metrics include the number of containers, resource consumption, pending pods, out of memory (OOM) kills, and stuck pods. These metrics may be particularly relevant to Kubernetes administrators who require reliable, up-to-date information on resource consumption against pre-set thresholds. Access these dashboards directly from the cluster explorer where you can first visually explore your cluster and then use filters to drive down into specific dashboards that match that filter. 4. Monitor applications running in Kubernetes with APM One advantage of New Relic's Infrastructure agent being application-aware is that the cluster explorer is automatically aware of New Relic agents that are deployed on new applications. To fully exploit these capabilities, we recommend monitoring all existing and future containerized applications running in Kubernetes by installing the APM agent on them. Starting again from the cluster explorer, you can dig into what's happening in your applications from the context of the Kubernetes cluster. This gives you the ability to intuitively correlate your infrastructure and applications and begin analytically troubleshooting across the stack. Cloud-native applications use many interconnected services. The cluster explorer will correlate the application and link to its distributed tracings. In complex systems the ability to trace and identify pathways and latency bottlenecks are not optional. Correlate your Kubernetes back-end with end-user experience using browser and synthetic monitoring If you are orchestrating an end-user facing application, New Relic allows you to view the end-to-end impact your infrastructure and services have on your customer experience. We tackle end-user management in two ways: With synthetic monitoring, you can track application availability and performance from a wide variety of global locations visualizing if customer experience is impacted due to geography. With browser and mobile, we recommend monitoring such KPIs as load time and availability. Marrying end-user data with metrics and dashboards provided by the cluster explorer enables operators, administrators, app developers, and business personnel to align on common initiatives. 6. Bring teams together with dashboards tailored to specific business use cases and KPIs With dashboards, you can build custom visualizations from an end-to-end service perspective to analyze the cluster, pods, application, and end-user experience in one clean visual display. By using New Relic's dashboards, cross-organizational teams can align to share a common language and single source of truth, helping them make better decisions and drive business impact. The top two rows of this sample dashboard visualize various aspects of a Kubernetes environment while the third row illustrates valuable information regarding the applications that are deployed to this cluster. The bottom row displays the end-user viewpoint. Learn more Actively, where we enable availability monitoring for one user in one location with synthetic monitoring Passively, where you can analyze a macro view of all users across all geographies with browser monitoring and mobile monitoring. Bring teams together with dashboards tailored to specific business use cases and KPIs Kubernetes Monitoring Guide",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 424.81854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> containerized <em>environment</em>",
        "sections": "Manage <em>your</em> containerized <em>environment</em>",
        "tags": "<em>Optimize</em> <em>your</em> <em>cloud</em> <em>native</em> <em>environment</em>",
        "body": ", to build a complete picture of <em>your</em> Kubernetes <em>environment</em>, <em>New</em> <em>Relic</em> aggregates data from many resources, including Kube-state metrics. <em>New</em> <em>Relic</em>&#x27;s “Kubernetes aware” approach makes it easy for Kubernetes to do its job as an orchestrator without missing a single node, cluster, or event. 2. Leverage"
      },
      "id": "603ebf49196a670d96a83d81"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/create-application-baselines": [
    {
      "sections": [
        "Validate cloud improvements",
        "1. Identify KPIs",
        "2. Deploy monitoring tools",
        "Install New Relic APM",
        "Install New Relic Infrastructure",
        "Tip",
        "Install New Relic Infrastructure integrations",
        "3. Gather custom data",
        "4. Create baselines",
        "5. Validate improvements with Dashboards"
      ],
      "title": "Validate cloud improvements",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "e8083557674f0bd9a67aadade85517b9f5a517df",
      "image": "https://docs.newrelic.com/static/bd6f185deecee0d1735e167f1831d877/c1b63/KPIs-validate-improvement_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/validate-cloud-improvements/",
      "published_at": "2021-07-09T12:54:07Z",
      "updated_at": "2021-07-09T12:54:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you migrate your applications to the cloud and integrate cloud services, use New Relic to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the New Relic platform to measure KPIs helps you eliminate blind spots and see the connections between entities—from your application code to your cloud infrastructure (including containers running in highly distributed microservices), to your customer experience. Your goal is to create a collection of metrics in several categories that you can visualize in dashboards in New Relic Dashboards. To validate cloud improvements, group KPIs in the following categories, from least to most strong: Application and infrastructure performance End-user experience, including website and mobile application performance Audience and content trends DevOps productivity Application revenue analytics Future business goals 2. Deploy monitoring tools To start monitoring your KPIs, verify that the applications that you want to migrate are compatible with the requirements for the New Relic products you want to use. Then, install the New Relic agents: Install New Relic APM Review the compatibility and requirements and then install APM agents on your application stack. After installing the APM agents, review the architecture of the applications you instrumented with an APM agent. Take note of all hosts that are part of each tier of the application stack (database, application, web server, etc.), so you can install New Relic Infrastructure agents on each of those hosts. Install New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, install the Infrastructure agent on the hosts that you identified so you can start to gather data for your KPIs. Tip If you use Ansible, Chef, or Puppet for automation, you can use those tools to deploy Infrastructure agents to your hosts. Install New Relic Infrastructure integrations You can also monitor and report data about services that your code depends on using New Relic integrations. New Relic offers cloud integrations for Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform as well as on-host integrations. Tip If you are using AWS as a cloud provider, take advantage of New Relic’s AWS billing integrations to stay on top of your budget and prove the success of your migration. 3. Gather custom data To manage, search for, and filter resources, assign metadata to your cloud resources in the form of tags. Tags are labels that consist of key-value pairs that you use to annotate your Infrastructure data. Tag formats are different between AWS, Azure, and Google. Google, for example, has the shortest allowable lengths for keys and values. In addition, they all have different requirements for case sensitivity and allowable characters. To make sure that your tags are usable across most cloud providers: Use only lowercase letters, numbers, underscores, and dashes. Keep keys and values under 63 characters. New Relic reports data contained in specific events to your account as part of its “out-of-the-box” functionality. You can add additional data to those events by using custom attributes. If you determine that you need to collect custom data, review custom data requirements, and report custom event data. For more detailed information about sending custom data, check out these New Relic University tutorials: APM custom data overview Adding custom events using the API 4. Create baselines In order to validate the value of moving to the cloud, you need to get baselines for your applications before you move to the cloud. Define pre-migration baselines for applications and their underlying infrastructures that you have designated for cloud service improvements based on your KPIs. To stay on top of your KPIs as you are moving, create baseline alerts for applications monitored by APM and browser and use NRQL alerts to get notified on any spikes or drops in your KPIs. The following dashboard tracks key performance indicators for applications designated to move to the cloud: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs. After you migrate applications to the cloud, apply the same criteria to post-migration baselines so you can compare your results from before and after your migration. 5. Validate improvements with Dashboards Dashboards is a single location to view all the data that New Relic products gather. Use New Relic Dashboards to visualize your KPIs before and after your move: Transaction and TransactionError event types with APM PageView and PageAction event types with browser Default Infrastructure events and attributes for your systems, processes, events, storage, and network, Infrastructure integrations, and custom attributes Mobile event types with Mobile SyntheticCheck, SyntheticRequest, and SyntheticPrivateMinion event types with Synthetics The following dashboard shows KPI data used to validate cloud improvements: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs pre- and post-migration. Use dashboards to validate the value of adopting a new cloud service and to answer key questions about application performance and customer experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.6896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Validate <em>cloud</em> improvements",
        "sections": "Install <em>New</em> <em>Relic</em> APM",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "After you migrate your applications to the <em>cloud</em> and integrate <em>cloud</em> services, use <em>New</em> <em>Relic</em> to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key"
      },
      "id": "60445c48e7b9d2052c5799d4"
    },
    {
      "sections": [
        "Refactor your applications",
        "1. Deploy monitoring",
        "Cloud-based integrations",
        "2. Set deployment markers",
        "3. Establish baselines",
        "4. Refactor your applications",
        "5. Create dashboards to track refactoring your applications",
        "6. Create comparison dashboards"
      ],
      "title": "Refactor your applications",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "fcea859e043f6ff33898803636b9a7a6de04508a",
      "image": "https://docs.newrelic.com/static/fc360bb9af89fe16ea8351e90b16ec09/c1b63/screen-deployments-page.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/refactor-your-applications/",
      "published_at": "2021-07-09T11:32:22Z",
      "updated_at": "2021-07-09T11:32:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At each step of your cloud adoption process, New Relic plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage cloud costs. New Relic can also help you refactor, or re-architect, your software and services when you migrate them to the cloud. One key aspect of refactoring your software is splitting out your components into different services available from your cloud provider. For example, you might move your database component away from a traditional MySQL database to a cloud-hosted solution, like Amazon Relational Database (RDS) services such as DynamoDB or Aurora. If you move to the Azure cloud, you might adopt Azure SQL or Cosmos DB. When you move to solutions like those, you increase your database redundancy and resiliency. If you evaluate your overall ROI properly, you should start to see the cost/benefit ratio taking effect once you complete your refactoring. 1. Deploy monitoring New Relic is a true multi-tenant SaaS solution, meaning New Relic designed the agents to work at every layer of your application stack. To get started, deploy the agents: APM to collect application-tier performance metrics Browser monitoring to collect front-end web metrics Mobile monitoring to collect front-end mobile app metrics Infrastructure to collect host/server metrics Cloud-based integrations As you refactor your application and integrate new cloud services, you can also use New Relic to monitor and report data about your cloud services, offering you a comprehensive view of your entire architecture in one place. Cloud-based integrations available through New Relic include Amazon Web Services (AWS) and Microsoft Azure. This tutorial describes a database migration and focuses on APM and Infrastructure. 2. Set deployment markers With New Relic, you can track deployments by setting deployment markers. Deployment tracking lets you quickly see how deployments affect your application’s performance and gauge its performance before and after you refactor. You can view deployments on the Deployments page in APM: rpm.newrelic.com/apm > (selected app) > Events > Deployments: Here is an example of the Deployments page and details about a selected deployment. 3. Establish baselines When you install the APM agent at the application layer, New Relic immediately starts collecting and displaying metrics. Use these metrics to set your pre-migration application baseline. APM agents collect performance metrics about outbound calls to databases. In the Monitoring section of the APM UI, click Databases to see a view of your database metrics. The following shows a database running on MySQL that will be refactored to use DynamoDB after migrating to AWS: one.newrelic.com > APM > (select an app) > Monitoring > Databases: Use this page to view and sort detailed information about database performance. 4. Refactor your applications To take advantage of the cloud, research what services are available from your cloud provider, and then re-architect and uncouple your applications. 5. Create dashboards to track refactoring your applications Apply your KPIs to your baseline measurements to validate cloud improvements, and, ideally, start seeing the impact of moving to the cloud. New Relic’s reporting for database interactions goes much deeper than high-level performance metrics about calls to the database layer in APM. You get access to metrics about slow queries so you can filter by database vendor and cache type. You can also see host and instance details for databases visually within Service Maps and within the context of transaction traces. Because all of your performance metrics are available in New Relic Insights, it is easy to build dashboards to show the performance of your database calls before, during, and after your refactoring in a single unified view. Here is an example of an Insights dashboard for an application that uses DynamoDB and was migrated to AWS: insights.newrelic.com: Build a dashboard that shows the performance of your database calls. 6. Create comparison dashboards To compare both the pre- and post-refactor baselines, create an Insights dashboard that displays the KPIs you baselined. The following dashboard shows the MySQL request query latency as compared with all of the operations for DynamoDB. You can see that, for this example, the request query latency for DynamoDB is too small to even register on the graph. Performance is clearly optimized with this cloud-based database. insights.newrelic.com: Use Insights dashboards to visualize pre- and post-refactor baselines. With APM agents and the integrations New Relic provides, you can measure the effectiveness of refactoring your applications using a broad spectrum of metrics.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.5912,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Cloud</em>-based integrations",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "At each step of your <em>cloud</em> <em>adoption</em> process, <em>New</em> <em>Relic</em> plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage <em>cloud</em> costs. <em>New</em> <em>Relic</em> can also help you refactor, or re-architect, your software and services when you migrate them"
      },
      "id": "60445da6e7b9d2bf265799ee"
    },
    {
      "sections": [
        "Optimize customer experience",
        "1. Identify applications scoped for improvement",
        "2. Deploy monitoring: Browser, mobile, and synthetics",
        "Deploy browser to monitor your front-end data",
        "Deploy mobile monitoring, if your company has a mobile app",
        "Tip",
        "Synthetics—it’s already there!",
        "3. Identify your relevant metrics",
        "KPIs for business performance",
        "KPIs that are specific to your company",
        "KPIs for application and infrastructure teams",
        "4. Create dashboards showing KPIs from before and after your migration"
      ],
      "title": "Optimize customer experience",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "2d4df116b6dedf8a3d0911b0ad0e7bbd11b991d9",
      "image": "https://docs.newrelic.com/static/b84aceb32c77eb0a35e93a26ea700075/c1b63/optimize_exp.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-customer-experience/",
      "published_at": "2021-07-09T10:50:42Z",
      "updated_at": "2021-07-09T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You have been running in the cloud for awhile now, or you just completed your migration from on-premise to the cloud. You have gone through your planning stages, identified your dependencies, tested your assumptions, and everything is looking great. But there are still some big questions: How are your customers experiencing your service? Did the performance of your front-end applications improve, or did performance stay the same? Or did it worsen in ways you did not expect? New Relic provides a suite of front-end monitoring—browser, mobile, and synthetic—to help you monitor and improve your front-end applications. With dashboards, you can bring together information from each one of these product to give you an overall view of what your customer is experiencing. Follow the steps in this doc to optimize your customer experience after you migrate to the cloud. 1. Identify applications scoped for improvement When you identify applications that you want to improve, start with applications where you have some clearly defined KPIs (Key Performance Indicators) that are relevant to the overall performance of your business. Selecting an application that tells a complete story of your performance, regarding key performance indicators, builds trust that you are doing the right level of monitoring and gathering the right metrics. When measuring front-end application performance, most companies think about these common KPIs: Availability percentage Average duration Page load time Throughput Apdex Response time Use those common KPIs as a guideline when identifying applications. Take each one of the metrics and consider it from the perspective of your company's CEO and business team. What is the actual impact on your company's business if your application becomes unavailable? How many users will your site lose if your page loads start to take over four seconds? How many dollars are lost if your applications are not able to handle throughput spikes and some users get no response during those spikes? These are serious questions to answer, and, if you are only measuring metrics on the server/application side, you are very likely not seeing what your customers are seeing on the frontend of the application. That is why browser, mobile, and synthetics are key to understanding the complete picture of your application performance. With dashboards, you bring all of these metrics together and give your company a single place to see every metric that is crucial to your success. 2. Deploy monitoring: Browser, mobile, and synthetics To start monitoring, you need to deploy browser, mobile, and synthetics agents. With browser, you gain deep insight into how your users are interacting with your application or website. Mobile monitoring allows you to monitor and manage the performance of your iOS and Android applications. Synthetics is a suite of automated, scriptable tools to monitor your websites and API endpoints. Just like with all of New Relic's agents, browser, mobile, and synthetics are quick to deploy. Here is a quick overview of each and links to documentation to help you get going: Deploy browser to monitor your front-end data In a nutshell, browser monitoring is a snippet of JavaScript that needs to appear in all of your application's webpages. It has no dependencies on other libraries, so it does not cause additional delays when bringing jQuery or other frameworks into the webpage. There are three ways to install the browser agent: Method When to use this method Enable via APM Typically, the quickest path is to let the APM agent dynamically inject the snippet into your pages on the server side. This works for many common web technologies, such as .NET, JSP, and other Java solutions. The documentation provides a complete reference for the languages and frameworks that allow this option. Copy/paste method If you are using an unsupported framework or are in an environment where you can instrument only the webpages but cannot install APM on the back-end, use the copy/paste method. New Relic presents a snippet directly in the UI, and you copy it and paste it into a global page template on your end. Just pick one that is used by all of your webpages and put it there, and then the snippet appears on all pages. Enable via the API You can perform a manual instrumentation, in which your developers can add instrumentation to your webpages using a server-side API. New Relic supports this for many server-side languages. Refer to the documentation for an example of how to do this in Java. Whichever method you choose, you quickly have front-end performance data from your web pages. Just like with APM and other New Relic products, the overview tells you the “big picture” story of your performance data—in this case, your front-end data: one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the browser apps index, the Summary page shows a summary of browser performance for that app. Set alert conditions on metrics like Page view load time and Throughput, as well as JS Errors and Ajax response time. This is not just about seeing a slowdown and fixing it—this is about real users having a frustrating experience and potentially walking away from your application, costing your company potential profits. If you do not already have SLAs defined for these kinds of metrics, now is the time to define them. If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your cloud metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with New Relic products. Deploy mobile monitoring, if your company has a mobile app If your company has a mobile application, install Mobile monitoring. Tip Monitoring performance metrics about your webpages as they work in mobile browsers is handled by the browser agent. If you do not have a native mobile application, you can skip this section. The mobile monitoring agents support most common devices running on iOS and Android. The install process for iOS and Android requires you to include the mobile SDK in your applications. The SDK is as low impact as possible in terms of resource consumption (CPU and memory) while simultaneously providing you a broad and deep spectrum of performance data about your mobile applications. Slow performance on your mobile apps can be just as impactful to your business as slow performance in webpages. Think of top-level metrics like crash occurrences, HTTP errors/network failures, and HTTP response times in terms of your business KPIs. What happens to your business objectives when your mobile app starts spiking in terms of crash rate? Do users get frustrated and give up when the app takes forever to pull down data from your back-end systems or from third-party resources? The mobile monitoring overview page pulls together a set of metrics that you should be setting SLAs and alert conditions on: one.newrelic.com > Mobile > (select an app) > Summary: Quickly view crash occurrences, app launches, and more with mobile monitoring. Once you get to know these top level metrics, you can quickly start using your mobile metrics to find root causes, so you can add new alert conditions on lower-level metrics and discover any regression problems down the road. You can also monitor the back-end systems and cloud services that support your mobile apps. Improving the back-end systems and cloud services has a direct result in their improvement. Check out Monitor your cloud services to gain more insight. Synthetics—it’s already there! With Synthetics, there is nothing to install—the agents are already installed at many global locations and are just waiting for you to start using them. Synthetics lets you quickly define monitors, which run on a schedule you pick and make automated calls from those global locations back into your systems. There are four different types of monitors, and they have the following functions: Type of monitor What this monitor can do for you Ping Point a ping monitor at one of your webpages, and New Relic tells you if that page is responding as expected. Think of Ping as a simple “up/down” test but with a few extra features that you will quickly get to know. Simple browser The job of a simple browser is to simulate all of the work that a real browser would do to build out one of your webpages. Where are the slow points? How can you quickly see a waterfall view of the page buildout? Simple browser quickly gets you all this data. Scripted browser This monitor lets you define a key workflow in your webpages (for example, registering, searching, or purchasing a product) as a script that the monitor runs for you on the frequency you select. If any step in the script fails, New Relic notifies you, with full details about where the failure happened and what it was. API test Testing your API endpoints is just as important as testing your webpages—if one of them stops working as expected, the downstream effects on your systems can be bad news for you and your customers. Define a script that pulls back data from one of your endpoints, tests what it gets back, and alerts you when it encounters a problem. Here are a few things to remember about Synthetics: You can alert on every metric recorded by the monitors, from “is it up/down?” to “what came back from my API endpoint?” All of your performance data from Synthetics can be quickly viewed in terms of SLAs and KPIs. Just like with the other areas of your instrumentation, it helps your entire team to start defining your SLAs for your KPIs. The metrics from Synthetics help you prove out the value of having moved to cloud-hosted services. For any test that you want to run on a resource inside your firewall, there are private minions that you can quickly and securely stand up in your own environment. They are available in the list of locations for your monitors, just like the the rest of the default global locations. 3. Identify your relevant metrics It is vital to identify which metrics are the most important to your business and use these metrics to define your KPIs. Answer the following questions to begin identifying the relevant metrics: What are your KPIs? Are you setting SLAs for them? Here is a look at some examples of KPIs: KPIs for business performance Here are some examples of KPIs that companies in many industries consider to be key to business performance: General DOM readiness Page render Apdex Mobile crash rate Web Session count Session duration Page views DOM readiness Page render Error % Apdex Mobile App launches User counts Load time Response time Crash rates Crash locations Error rates (HTTP, network) API errors Session duration Video Video play count Video play duration Video bit rate Video buffering time Video success rate Errors (video, advertisement) Trends Active users Product views Session duration Sales/Retail Cart value Abandon rate Funnels Click-throughs Revenue (made, loss) KPIs that are specific to your company You might start with KPIs from the business performance list and then build them out to be more specific to your own company’s performance: Geography Business unit Product Product name Device type Store/location Mobile platform Carrier Website name Page name Browser type Error type Application name Cloud provider Success/fail reason KPIs for application and infrastructure teams Here are some KPI ideas for your application and infrastructure teams for the server side: Application/Infrastructure Apdex Availability Throughput App/API/DB response times Error % Memory footprint CPU workload Disk workload Network throughput DevOps Builds Commits Deploys Errors Support incidents MTTR With New Relic products in place across your ecosystem, you can collect a large number of these metrics right out of the box. Once you have all of the data flowing, dashboards is the place where you start creating dashboards from before and after your migration to show your teams the value of moving to the cloud. 4. Create dashboards showing KPIs from before and after your migration So, what might a starter dashboard look like for this part of your migration project? Consider this example: one.newrelic.com > Dashboards: Create customizable dashboards to monitor performance and business data. The rows represent the “before” and “after” perspectives. The widgets in these rows get you answers to the key questions behind your KPIs: What is my site's availability? Which global locations are experiencing the slowest performance? How can I use Apdex scoring to measure customer satisfaction levels with my application's performance? How many are satisfied? How many are OK (tolerating)? How many are frustrated with my site? With just a few setup steps, you can get your monitors running, and then head over to New Relic dashboards and design your widgets. Check out the Introduction to New Relic One dashboards which shows you many examples of these kinds of queries, using data from your own account. You can quickly get a feel for how to start building queries, widgets, and dashboards. After you identify your SLAs and KPIs, browser and mobile monitoring let you quickly start collecting data from your webpages and mobile apps, and Synthetics lets you schedule the monitors you need so that you can find out about problems before your customers start telling you about them. Bringing it all together in dashboards, you can start building the before/after perspective you need to prove the value of moving to the cloud and gain information that will help you optimize your customer’s experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.0361,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": ". If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your <em>cloud</em> metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with <em>New</em> <em>Relic</em> products. Deploy mobile monitoring, if your company has"
      },
      "id": "60445c0064441f4b53378f00"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/guide-planning-your-cloud-adoption-strategy": [
    {
      "sections": [
        "Validate cloud improvements",
        "1. Identify KPIs",
        "2. Deploy monitoring tools",
        "Install New Relic APM",
        "Install New Relic Infrastructure",
        "Tip",
        "Install New Relic Infrastructure integrations",
        "3. Gather custom data",
        "4. Create baselines",
        "5. Validate improvements with Dashboards"
      ],
      "title": "Validate cloud improvements",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "e8083557674f0bd9a67aadade85517b9f5a517df",
      "image": "https://docs.newrelic.com/static/bd6f185deecee0d1735e167f1831d877/c1b63/KPIs-validate-improvement_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/validate-cloud-improvements/",
      "published_at": "2021-07-09T12:54:07Z",
      "updated_at": "2021-07-09T12:54:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you migrate your applications to the cloud and integrate cloud services, use New Relic to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the New Relic platform to measure KPIs helps you eliminate blind spots and see the connections between entities—from your application code to your cloud infrastructure (including containers running in highly distributed microservices), to your customer experience. Your goal is to create a collection of metrics in several categories that you can visualize in dashboards in New Relic Dashboards. To validate cloud improvements, group KPIs in the following categories, from least to most strong: Application and infrastructure performance End-user experience, including website and mobile application performance Audience and content trends DevOps productivity Application revenue analytics Future business goals 2. Deploy monitoring tools To start monitoring your KPIs, verify that the applications that you want to migrate are compatible with the requirements for the New Relic products you want to use. Then, install the New Relic agents: Install New Relic APM Review the compatibility and requirements and then install APM agents on your application stack. After installing the APM agents, review the architecture of the applications you instrumented with an APM agent. Take note of all hosts that are part of each tier of the application stack (database, application, web server, etc.), so you can install New Relic Infrastructure agents on each of those hosts. Install New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, install the Infrastructure agent on the hosts that you identified so you can start to gather data for your KPIs. Tip If you use Ansible, Chef, or Puppet for automation, you can use those tools to deploy Infrastructure agents to your hosts. Install New Relic Infrastructure integrations You can also monitor and report data about services that your code depends on using New Relic integrations. New Relic offers cloud integrations for Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform as well as on-host integrations. Tip If you are using AWS as a cloud provider, take advantage of New Relic’s AWS billing integrations to stay on top of your budget and prove the success of your migration. 3. Gather custom data To manage, search for, and filter resources, assign metadata to your cloud resources in the form of tags. Tags are labels that consist of key-value pairs that you use to annotate your Infrastructure data. Tag formats are different between AWS, Azure, and Google. Google, for example, has the shortest allowable lengths for keys and values. In addition, they all have different requirements for case sensitivity and allowable characters. To make sure that your tags are usable across most cloud providers: Use only lowercase letters, numbers, underscores, and dashes. Keep keys and values under 63 characters. New Relic reports data contained in specific events to your account as part of its “out-of-the-box” functionality. You can add additional data to those events by using custom attributes. If you determine that you need to collect custom data, review custom data requirements, and report custom event data. For more detailed information about sending custom data, check out these New Relic University tutorials: APM custom data overview Adding custom events using the API 4. Create baselines In order to validate the value of moving to the cloud, you need to get baselines for your applications before you move to the cloud. Define pre-migration baselines for applications and their underlying infrastructures that you have designated for cloud service improvements based on your KPIs. To stay on top of your KPIs as you are moving, create baseline alerts for applications monitored by APM and browser and use NRQL alerts to get notified on any spikes or drops in your KPIs. The following dashboard tracks key performance indicators for applications designated to move to the cloud: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs. After you migrate applications to the cloud, apply the same criteria to post-migration baselines so you can compare your results from before and after your migration. 5. Validate improvements with Dashboards Dashboards is a single location to view all the data that New Relic products gather. Use New Relic Dashboards to visualize your KPIs before and after your move: Transaction and TransactionError event types with APM PageView and PageAction event types with browser Default Infrastructure events and attributes for your systems, processes, events, storage, and network, Infrastructure integrations, and custom attributes Mobile event types with Mobile SyntheticCheck, SyntheticRequest, and SyntheticPrivateMinion event types with Synthetics The following dashboard shows KPI data used to validate cloud improvements: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs pre- and post-migration. Use dashboards to validate the value of adopting a new cloud service and to answer key questions about application performance and customer experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.6896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Validate <em>cloud</em> improvements",
        "sections": "Install <em>New</em> <em>Relic</em> APM",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "After you migrate your applications to the <em>cloud</em> and integrate <em>cloud</em> services, use <em>New</em> <em>Relic</em> to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key"
      },
      "id": "60445c48e7b9d2052c5799d4"
    },
    {
      "sections": [
        "Refactor your applications",
        "1. Deploy monitoring",
        "Cloud-based integrations",
        "2. Set deployment markers",
        "3. Establish baselines",
        "4. Refactor your applications",
        "5. Create dashboards to track refactoring your applications",
        "6. Create comparison dashboards"
      ],
      "title": "Refactor your applications",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "fcea859e043f6ff33898803636b9a7a6de04508a",
      "image": "https://docs.newrelic.com/static/fc360bb9af89fe16ea8351e90b16ec09/c1b63/screen-deployments-page.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/refactor-your-applications/",
      "published_at": "2021-07-09T11:32:22Z",
      "updated_at": "2021-07-09T11:32:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At each step of your cloud adoption process, New Relic plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage cloud costs. New Relic can also help you refactor, or re-architect, your software and services when you migrate them to the cloud. One key aspect of refactoring your software is splitting out your components into different services available from your cloud provider. For example, you might move your database component away from a traditional MySQL database to a cloud-hosted solution, like Amazon Relational Database (RDS) services such as DynamoDB or Aurora. If you move to the Azure cloud, you might adopt Azure SQL or Cosmos DB. When you move to solutions like those, you increase your database redundancy and resiliency. If you evaluate your overall ROI properly, you should start to see the cost/benefit ratio taking effect once you complete your refactoring. 1. Deploy monitoring New Relic is a true multi-tenant SaaS solution, meaning New Relic designed the agents to work at every layer of your application stack. To get started, deploy the agents: APM to collect application-tier performance metrics Browser monitoring to collect front-end web metrics Mobile monitoring to collect front-end mobile app metrics Infrastructure to collect host/server metrics Cloud-based integrations As you refactor your application and integrate new cloud services, you can also use New Relic to monitor and report data about your cloud services, offering you a comprehensive view of your entire architecture in one place. Cloud-based integrations available through New Relic include Amazon Web Services (AWS) and Microsoft Azure. This tutorial describes a database migration and focuses on APM and Infrastructure. 2. Set deployment markers With New Relic, you can track deployments by setting deployment markers. Deployment tracking lets you quickly see how deployments affect your application’s performance and gauge its performance before and after you refactor. You can view deployments on the Deployments page in APM: rpm.newrelic.com/apm > (selected app) > Events > Deployments: Here is an example of the Deployments page and details about a selected deployment. 3. Establish baselines When you install the APM agent at the application layer, New Relic immediately starts collecting and displaying metrics. Use these metrics to set your pre-migration application baseline. APM agents collect performance metrics about outbound calls to databases. In the Monitoring section of the APM UI, click Databases to see a view of your database metrics. The following shows a database running on MySQL that will be refactored to use DynamoDB after migrating to AWS: one.newrelic.com > APM > (select an app) > Monitoring > Databases: Use this page to view and sort detailed information about database performance. 4. Refactor your applications To take advantage of the cloud, research what services are available from your cloud provider, and then re-architect and uncouple your applications. 5. Create dashboards to track refactoring your applications Apply your KPIs to your baseline measurements to validate cloud improvements, and, ideally, start seeing the impact of moving to the cloud. New Relic’s reporting for database interactions goes much deeper than high-level performance metrics about calls to the database layer in APM. You get access to metrics about slow queries so you can filter by database vendor and cache type. You can also see host and instance details for databases visually within Service Maps and within the context of transaction traces. Because all of your performance metrics are available in New Relic Insights, it is easy to build dashboards to show the performance of your database calls before, during, and after your refactoring in a single unified view. Here is an example of an Insights dashboard for an application that uses DynamoDB and was migrated to AWS: insights.newrelic.com: Build a dashboard that shows the performance of your database calls. 6. Create comparison dashboards To compare both the pre- and post-refactor baselines, create an Insights dashboard that displays the KPIs you baselined. The following dashboard shows the MySQL request query latency as compared with all of the operations for DynamoDB. You can see that, for this example, the request query latency for DynamoDB is too small to even register on the graph. Performance is clearly optimized with this cloud-based database. insights.newrelic.com: Use Insights dashboards to visualize pre- and post-refactor baselines. With APM agents and the integrations New Relic provides, you can measure the effectiveness of refactoring your applications using a broad spectrum of metrics.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.5912,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Cloud</em>-based integrations",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "At each step of your <em>cloud</em> <em>adoption</em> process, <em>New</em> <em>Relic</em> plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage <em>cloud</em> costs. <em>New</em> <em>Relic</em> can also help you refactor, or re-architect, your software and services when you migrate them"
      },
      "id": "60445da6e7b9d2bf265799ee"
    },
    {
      "sections": [
        "Optimize customer experience",
        "1. Identify applications scoped for improvement",
        "2. Deploy monitoring: Browser, mobile, and synthetics",
        "Deploy browser to monitor your front-end data",
        "Deploy mobile monitoring, if your company has a mobile app",
        "Tip",
        "Synthetics—it’s already there!",
        "3. Identify your relevant metrics",
        "KPIs for business performance",
        "KPIs that are specific to your company",
        "KPIs for application and infrastructure teams",
        "4. Create dashboards showing KPIs from before and after your migration"
      ],
      "title": "Optimize customer experience",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "2d4df116b6dedf8a3d0911b0ad0e7bbd11b991d9",
      "image": "https://docs.newrelic.com/static/b84aceb32c77eb0a35e93a26ea700075/c1b63/optimize_exp.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-customer-experience/",
      "published_at": "2021-07-09T10:50:42Z",
      "updated_at": "2021-07-09T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You have been running in the cloud for awhile now, or you just completed your migration from on-premise to the cloud. You have gone through your planning stages, identified your dependencies, tested your assumptions, and everything is looking great. But there are still some big questions: How are your customers experiencing your service? Did the performance of your front-end applications improve, or did performance stay the same? Or did it worsen in ways you did not expect? New Relic provides a suite of front-end monitoring—browser, mobile, and synthetic—to help you monitor and improve your front-end applications. With dashboards, you can bring together information from each one of these product to give you an overall view of what your customer is experiencing. Follow the steps in this doc to optimize your customer experience after you migrate to the cloud. 1. Identify applications scoped for improvement When you identify applications that you want to improve, start with applications where you have some clearly defined KPIs (Key Performance Indicators) that are relevant to the overall performance of your business. Selecting an application that tells a complete story of your performance, regarding key performance indicators, builds trust that you are doing the right level of monitoring and gathering the right metrics. When measuring front-end application performance, most companies think about these common KPIs: Availability percentage Average duration Page load time Throughput Apdex Response time Use those common KPIs as a guideline when identifying applications. Take each one of the metrics and consider it from the perspective of your company's CEO and business team. What is the actual impact on your company's business if your application becomes unavailable? How many users will your site lose if your page loads start to take over four seconds? How many dollars are lost if your applications are not able to handle throughput spikes and some users get no response during those spikes? These are serious questions to answer, and, if you are only measuring metrics on the server/application side, you are very likely not seeing what your customers are seeing on the frontend of the application. That is why browser, mobile, and synthetics are key to understanding the complete picture of your application performance. With dashboards, you bring all of these metrics together and give your company a single place to see every metric that is crucial to your success. 2. Deploy monitoring: Browser, mobile, and synthetics To start monitoring, you need to deploy browser, mobile, and synthetics agents. With browser, you gain deep insight into how your users are interacting with your application or website. Mobile monitoring allows you to monitor and manage the performance of your iOS and Android applications. Synthetics is a suite of automated, scriptable tools to monitor your websites and API endpoints. Just like with all of New Relic's agents, browser, mobile, and synthetics are quick to deploy. Here is a quick overview of each and links to documentation to help you get going: Deploy browser to monitor your front-end data In a nutshell, browser monitoring is a snippet of JavaScript that needs to appear in all of your application's webpages. It has no dependencies on other libraries, so it does not cause additional delays when bringing jQuery or other frameworks into the webpage. There are three ways to install the browser agent: Method When to use this method Enable via APM Typically, the quickest path is to let the APM agent dynamically inject the snippet into your pages on the server side. This works for many common web technologies, such as .NET, JSP, and other Java solutions. The documentation provides a complete reference for the languages and frameworks that allow this option. Copy/paste method If you are using an unsupported framework or are in an environment where you can instrument only the webpages but cannot install APM on the back-end, use the copy/paste method. New Relic presents a snippet directly in the UI, and you copy it and paste it into a global page template on your end. Just pick one that is used by all of your webpages and put it there, and then the snippet appears on all pages. Enable via the API You can perform a manual instrumentation, in which your developers can add instrumentation to your webpages using a server-side API. New Relic supports this for many server-side languages. Refer to the documentation for an example of how to do this in Java. Whichever method you choose, you quickly have front-end performance data from your web pages. Just like with APM and other New Relic products, the overview tells you the “big picture” story of your performance data—in this case, your front-end data: one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the browser apps index, the Summary page shows a summary of browser performance for that app. Set alert conditions on metrics like Page view load time and Throughput, as well as JS Errors and Ajax response time. This is not just about seeing a slowdown and fixing it—this is about real users having a frustrating experience and potentially walking away from your application, costing your company potential profits. If you do not already have SLAs defined for these kinds of metrics, now is the time to define them. If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your cloud metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with New Relic products. Deploy mobile monitoring, if your company has a mobile app If your company has a mobile application, install Mobile monitoring. Tip Monitoring performance metrics about your webpages as they work in mobile browsers is handled by the browser agent. If you do not have a native mobile application, you can skip this section. The mobile monitoring agents support most common devices running on iOS and Android. The install process for iOS and Android requires you to include the mobile SDK in your applications. The SDK is as low impact as possible in terms of resource consumption (CPU and memory) while simultaneously providing you a broad and deep spectrum of performance data about your mobile applications. Slow performance on your mobile apps can be just as impactful to your business as slow performance in webpages. Think of top-level metrics like crash occurrences, HTTP errors/network failures, and HTTP response times in terms of your business KPIs. What happens to your business objectives when your mobile app starts spiking in terms of crash rate? Do users get frustrated and give up when the app takes forever to pull down data from your back-end systems or from third-party resources? The mobile monitoring overview page pulls together a set of metrics that you should be setting SLAs and alert conditions on: one.newrelic.com > Mobile > (select an app) > Summary: Quickly view crash occurrences, app launches, and more with mobile monitoring. Once you get to know these top level metrics, you can quickly start using your mobile metrics to find root causes, so you can add new alert conditions on lower-level metrics and discover any regression problems down the road. You can also monitor the back-end systems and cloud services that support your mobile apps. Improving the back-end systems and cloud services has a direct result in their improvement. Check out Monitor your cloud services to gain more insight. Synthetics—it’s already there! With Synthetics, there is nothing to install—the agents are already installed at many global locations and are just waiting for you to start using them. Synthetics lets you quickly define monitors, which run on a schedule you pick and make automated calls from those global locations back into your systems. There are four different types of monitors, and they have the following functions: Type of monitor What this monitor can do for you Ping Point a ping monitor at one of your webpages, and New Relic tells you if that page is responding as expected. Think of Ping as a simple “up/down” test but with a few extra features that you will quickly get to know. Simple browser The job of a simple browser is to simulate all of the work that a real browser would do to build out one of your webpages. Where are the slow points? How can you quickly see a waterfall view of the page buildout? Simple browser quickly gets you all this data. Scripted browser This monitor lets you define a key workflow in your webpages (for example, registering, searching, or purchasing a product) as a script that the monitor runs for you on the frequency you select. If any step in the script fails, New Relic notifies you, with full details about where the failure happened and what it was. API test Testing your API endpoints is just as important as testing your webpages—if one of them stops working as expected, the downstream effects on your systems can be bad news for you and your customers. Define a script that pulls back data from one of your endpoints, tests what it gets back, and alerts you when it encounters a problem. Here are a few things to remember about Synthetics: You can alert on every metric recorded by the monitors, from “is it up/down?” to “what came back from my API endpoint?” All of your performance data from Synthetics can be quickly viewed in terms of SLAs and KPIs. Just like with the other areas of your instrumentation, it helps your entire team to start defining your SLAs for your KPIs. The metrics from Synthetics help you prove out the value of having moved to cloud-hosted services. For any test that you want to run on a resource inside your firewall, there are private minions that you can quickly and securely stand up in your own environment. They are available in the list of locations for your monitors, just like the the rest of the default global locations. 3. Identify your relevant metrics It is vital to identify which metrics are the most important to your business and use these metrics to define your KPIs. Answer the following questions to begin identifying the relevant metrics: What are your KPIs? Are you setting SLAs for them? Here is a look at some examples of KPIs: KPIs for business performance Here are some examples of KPIs that companies in many industries consider to be key to business performance: General DOM readiness Page render Apdex Mobile crash rate Web Session count Session duration Page views DOM readiness Page render Error % Apdex Mobile App launches User counts Load time Response time Crash rates Crash locations Error rates (HTTP, network) API errors Session duration Video Video play count Video play duration Video bit rate Video buffering time Video success rate Errors (video, advertisement) Trends Active users Product views Session duration Sales/Retail Cart value Abandon rate Funnels Click-throughs Revenue (made, loss) KPIs that are specific to your company You might start with KPIs from the business performance list and then build them out to be more specific to your own company’s performance: Geography Business unit Product Product name Device type Store/location Mobile platform Carrier Website name Page name Browser type Error type Application name Cloud provider Success/fail reason KPIs for application and infrastructure teams Here are some KPI ideas for your application and infrastructure teams for the server side: Application/Infrastructure Apdex Availability Throughput App/API/DB response times Error % Memory footprint CPU workload Disk workload Network throughput DevOps Builds Commits Deploys Errors Support incidents MTTR With New Relic products in place across your ecosystem, you can collect a large number of these metrics right out of the box. Once you have all of the data flowing, dashboards is the place where you start creating dashboards from before and after your migration to show your teams the value of moving to the cloud. 4. Create dashboards showing KPIs from before and after your migration So, what might a starter dashboard look like for this part of your migration project? Consider this example: one.newrelic.com > Dashboards: Create customizable dashboards to monitor performance and business data. The rows represent the “before” and “after” perspectives. The widgets in these rows get you answers to the key questions behind your KPIs: What is my site's availability? Which global locations are experiencing the slowest performance? How can I use Apdex scoring to measure customer satisfaction levels with my application's performance? How many are satisfied? How many are OK (tolerating)? How many are frustrated with my site? With just a few setup steps, you can get your monitors running, and then head over to New Relic dashboards and design your widgets. Check out the Introduction to New Relic One dashboards which shows you many examples of these kinds of queries, using data from your own account. You can quickly get a feel for how to start building queries, widgets, and dashboards. After you identify your SLAs and KPIs, browser and mobile monitoring let you quickly start collecting data from your webpages and mobile apps, and Synthetics lets you schedule the monitors you need so that you can find out about problems before your customers start telling you about them. Bringing it all together in dashboards, you can start building the before/after perspective you need to prove the value of moving to the cloud and gain information that will help you optimize your customer’s experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.0361,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": ". If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your <em>cloud</em> metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with <em>New</em> <em>Relic</em> products. Deploy mobile monitoring, if your company has"
      },
      "id": "60445c0064441f4b53378f00"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/identify-application-dependencies-inventory": [
    {
      "sections": [
        "Validate cloud improvements",
        "1. Identify KPIs",
        "2. Deploy monitoring tools",
        "Install New Relic APM",
        "Install New Relic Infrastructure",
        "Tip",
        "Install New Relic Infrastructure integrations",
        "3. Gather custom data",
        "4. Create baselines",
        "5. Validate improvements with Dashboards"
      ],
      "title": "Validate cloud improvements",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "e8083557674f0bd9a67aadade85517b9f5a517df",
      "image": "https://docs.newrelic.com/static/bd6f185deecee0d1735e167f1831d877/c1b63/KPIs-validate-improvement_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/validate-cloud-improvements/",
      "published_at": "2021-07-09T12:54:07Z",
      "updated_at": "2021-07-09T12:54:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you migrate your applications to the cloud and integrate cloud services, use New Relic to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the New Relic platform to measure KPIs helps you eliminate blind spots and see the connections between entities—from your application code to your cloud infrastructure (including containers running in highly distributed microservices), to your customer experience. Your goal is to create a collection of metrics in several categories that you can visualize in dashboards in New Relic Dashboards. To validate cloud improvements, group KPIs in the following categories, from least to most strong: Application and infrastructure performance End-user experience, including website and mobile application performance Audience and content trends DevOps productivity Application revenue analytics Future business goals 2. Deploy monitoring tools To start monitoring your KPIs, verify that the applications that you want to migrate are compatible with the requirements for the New Relic products you want to use. Then, install the New Relic agents: Install New Relic APM Review the compatibility and requirements and then install APM agents on your application stack. After installing the APM agents, review the architecture of the applications you instrumented with an APM agent. Take note of all hosts that are part of each tier of the application stack (database, application, web server, etc.), so you can install New Relic Infrastructure agents on each of those hosts. Install New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, install the Infrastructure agent on the hosts that you identified so you can start to gather data for your KPIs. Tip If you use Ansible, Chef, or Puppet for automation, you can use those tools to deploy Infrastructure agents to your hosts. Install New Relic Infrastructure integrations You can also monitor and report data about services that your code depends on using New Relic integrations. New Relic offers cloud integrations for Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform as well as on-host integrations. Tip If you are using AWS as a cloud provider, take advantage of New Relic’s AWS billing integrations to stay on top of your budget and prove the success of your migration. 3. Gather custom data To manage, search for, and filter resources, assign metadata to your cloud resources in the form of tags. Tags are labels that consist of key-value pairs that you use to annotate your Infrastructure data. Tag formats are different between AWS, Azure, and Google. Google, for example, has the shortest allowable lengths for keys and values. In addition, they all have different requirements for case sensitivity and allowable characters. To make sure that your tags are usable across most cloud providers: Use only lowercase letters, numbers, underscores, and dashes. Keep keys and values under 63 characters. New Relic reports data contained in specific events to your account as part of its “out-of-the-box” functionality. You can add additional data to those events by using custom attributes. If you determine that you need to collect custom data, review custom data requirements, and report custom event data. For more detailed information about sending custom data, check out these New Relic University tutorials: APM custom data overview Adding custom events using the API 4. Create baselines In order to validate the value of moving to the cloud, you need to get baselines for your applications before you move to the cloud. Define pre-migration baselines for applications and their underlying infrastructures that you have designated for cloud service improvements based on your KPIs. To stay on top of your KPIs as you are moving, create baseline alerts for applications monitored by APM and browser and use NRQL alerts to get notified on any spikes or drops in your KPIs. The following dashboard tracks key performance indicators for applications designated to move to the cloud: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs. After you migrate applications to the cloud, apply the same criteria to post-migration baselines so you can compare your results from before and after your migration. 5. Validate improvements with Dashboards Dashboards is a single location to view all the data that New Relic products gather. Use New Relic Dashboards to visualize your KPIs before and after your move: Transaction and TransactionError event types with APM PageView and PageAction event types with browser Default Infrastructure events and attributes for your systems, processes, events, storage, and network, Infrastructure integrations, and custom attributes Mobile event types with Mobile SyntheticCheck, SyntheticRequest, and SyntheticPrivateMinion event types with Synthetics The following dashboard shows KPI data used to validate cloud improvements: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs pre- and post-migration. Use dashboards to validate the value of adopting a new cloud service and to answer key questions about application performance and customer experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.6896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Validate <em>cloud</em> improvements",
        "sections": "Install <em>New</em> <em>Relic</em> APM",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "After you migrate your applications to the <em>cloud</em> and integrate <em>cloud</em> services, use <em>New</em> <em>Relic</em> to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key"
      },
      "id": "60445c48e7b9d2052c5799d4"
    },
    {
      "sections": [
        "Refactor your applications",
        "1. Deploy monitoring",
        "Cloud-based integrations",
        "2. Set deployment markers",
        "3. Establish baselines",
        "4. Refactor your applications",
        "5. Create dashboards to track refactoring your applications",
        "6. Create comparison dashboards"
      ],
      "title": "Refactor your applications",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "fcea859e043f6ff33898803636b9a7a6de04508a",
      "image": "https://docs.newrelic.com/static/fc360bb9af89fe16ea8351e90b16ec09/c1b63/screen-deployments-page.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/refactor-your-applications/",
      "published_at": "2021-07-09T11:32:22Z",
      "updated_at": "2021-07-09T11:32:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At each step of your cloud adoption process, New Relic plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage cloud costs. New Relic can also help you refactor, or re-architect, your software and services when you migrate them to the cloud. One key aspect of refactoring your software is splitting out your components into different services available from your cloud provider. For example, you might move your database component away from a traditional MySQL database to a cloud-hosted solution, like Amazon Relational Database (RDS) services such as DynamoDB or Aurora. If you move to the Azure cloud, you might adopt Azure SQL or Cosmos DB. When you move to solutions like those, you increase your database redundancy and resiliency. If you evaluate your overall ROI properly, you should start to see the cost/benefit ratio taking effect once you complete your refactoring. 1. Deploy monitoring New Relic is a true multi-tenant SaaS solution, meaning New Relic designed the agents to work at every layer of your application stack. To get started, deploy the agents: APM to collect application-tier performance metrics Browser monitoring to collect front-end web metrics Mobile monitoring to collect front-end mobile app metrics Infrastructure to collect host/server metrics Cloud-based integrations As you refactor your application and integrate new cloud services, you can also use New Relic to monitor and report data about your cloud services, offering you a comprehensive view of your entire architecture in one place. Cloud-based integrations available through New Relic include Amazon Web Services (AWS) and Microsoft Azure. This tutorial describes a database migration and focuses on APM and Infrastructure. 2. Set deployment markers With New Relic, you can track deployments by setting deployment markers. Deployment tracking lets you quickly see how deployments affect your application’s performance and gauge its performance before and after you refactor. You can view deployments on the Deployments page in APM: rpm.newrelic.com/apm > (selected app) > Events > Deployments: Here is an example of the Deployments page and details about a selected deployment. 3. Establish baselines When you install the APM agent at the application layer, New Relic immediately starts collecting and displaying metrics. Use these metrics to set your pre-migration application baseline. APM agents collect performance metrics about outbound calls to databases. In the Monitoring section of the APM UI, click Databases to see a view of your database metrics. The following shows a database running on MySQL that will be refactored to use DynamoDB after migrating to AWS: one.newrelic.com > APM > (select an app) > Monitoring > Databases: Use this page to view and sort detailed information about database performance. 4. Refactor your applications To take advantage of the cloud, research what services are available from your cloud provider, and then re-architect and uncouple your applications. 5. Create dashboards to track refactoring your applications Apply your KPIs to your baseline measurements to validate cloud improvements, and, ideally, start seeing the impact of moving to the cloud. New Relic’s reporting for database interactions goes much deeper than high-level performance metrics about calls to the database layer in APM. You get access to metrics about slow queries so you can filter by database vendor and cache type. You can also see host and instance details for databases visually within Service Maps and within the context of transaction traces. Because all of your performance metrics are available in New Relic Insights, it is easy to build dashboards to show the performance of your database calls before, during, and after your refactoring in a single unified view. Here is an example of an Insights dashboard for an application that uses DynamoDB and was migrated to AWS: insights.newrelic.com: Build a dashboard that shows the performance of your database calls. 6. Create comparison dashboards To compare both the pre- and post-refactor baselines, create an Insights dashboard that displays the KPIs you baselined. The following dashboard shows the MySQL request query latency as compared with all of the operations for DynamoDB. You can see that, for this example, the request query latency for DynamoDB is too small to even register on the graph. Performance is clearly optimized with this cloud-based database. insights.newrelic.com: Use Insights dashboards to visualize pre- and post-refactor baselines. With APM agents and the integrations New Relic provides, you can measure the effectiveness of refactoring your applications using a broad spectrum of metrics.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.5912,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Cloud</em>-based integrations",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "At each step of your <em>cloud</em> <em>adoption</em> process, <em>New</em> <em>Relic</em> plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage <em>cloud</em> costs. <em>New</em> <em>Relic</em> can also help you refactor, or re-architect, your software and services when you migrate them"
      },
      "id": "60445da6e7b9d2bf265799ee"
    },
    {
      "sections": [
        "Optimize customer experience",
        "1. Identify applications scoped for improvement",
        "2. Deploy monitoring: Browser, mobile, and synthetics",
        "Deploy browser to monitor your front-end data",
        "Deploy mobile monitoring, if your company has a mobile app",
        "Tip",
        "Synthetics—it’s already there!",
        "3. Identify your relevant metrics",
        "KPIs for business performance",
        "KPIs that are specific to your company",
        "KPIs for application and infrastructure teams",
        "4. Create dashboards showing KPIs from before and after your migration"
      ],
      "title": "Optimize customer experience",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "2d4df116b6dedf8a3d0911b0ad0e7bbd11b991d9",
      "image": "https://docs.newrelic.com/static/b84aceb32c77eb0a35e93a26ea700075/c1b63/optimize_exp.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-customer-experience/",
      "published_at": "2021-07-09T10:50:42Z",
      "updated_at": "2021-07-09T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You have been running in the cloud for awhile now, or you just completed your migration from on-premise to the cloud. You have gone through your planning stages, identified your dependencies, tested your assumptions, and everything is looking great. But there are still some big questions: How are your customers experiencing your service? Did the performance of your front-end applications improve, or did performance stay the same? Or did it worsen in ways you did not expect? New Relic provides a suite of front-end monitoring—browser, mobile, and synthetic—to help you monitor and improve your front-end applications. With dashboards, you can bring together information from each one of these product to give you an overall view of what your customer is experiencing. Follow the steps in this doc to optimize your customer experience after you migrate to the cloud. 1. Identify applications scoped for improvement When you identify applications that you want to improve, start with applications where you have some clearly defined KPIs (Key Performance Indicators) that are relevant to the overall performance of your business. Selecting an application that tells a complete story of your performance, regarding key performance indicators, builds trust that you are doing the right level of monitoring and gathering the right metrics. When measuring front-end application performance, most companies think about these common KPIs: Availability percentage Average duration Page load time Throughput Apdex Response time Use those common KPIs as a guideline when identifying applications. Take each one of the metrics and consider it from the perspective of your company's CEO and business team. What is the actual impact on your company's business if your application becomes unavailable? How many users will your site lose if your page loads start to take over four seconds? How many dollars are lost if your applications are not able to handle throughput spikes and some users get no response during those spikes? These are serious questions to answer, and, if you are only measuring metrics on the server/application side, you are very likely not seeing what your customers are seeing on the frontend of the application. That is why browser, mobile, and synthetics are key to understanding the complete picture of your application performance. With dashboards, you bring all of these metrics together and give your company a single place to see every metric that is crucial to your success. 2. Deploy monitoring: Browser, mobile, and synthetics To start monitoring, you need to deploy browser, mobile, and synthetics agents. With browser, you gain deep insight into how your users are interacting with your application or website. Mobile monitoring allows you to monitor and manage the performance of your iOS and Android applications. Synthetics is a suite of automated, scriptable tools to monitor your websites and API endpoints. Just like with all of New Relic's agents, browser, mobile, and synthetics are quick to deploy. Here is a quick overview of each and links to documentation to help you get going: Deploy browser to monitor your front-end data In a nutshell, browser monitoring is a snippet of JavaScript that needs to appear in all of your application's webpages. It has no dependencies on other libraries, so it does not cause additional delays when bringing jQuery or other frameworks into the webpage. There are three ways to install the browser agent: Method When to use this method Enable via APM Typically, the quickest path is to let the APM agent dynamically inject the snippet into your pages on the server side. This works for many common web technologies, such as .NET, JSP, and other Java solutions. The documentation provides a complete reference for the languages and frameworks that allow this option. Copy/paste method If you are using an unsupported framework or are in an environment where you can instrument only the webpages but cannot install APM on the back-end, use the copy/paste method. New Relic presents a snippet directly in the UI, and you copy it and paste it into a global page template on your end. Just pick one that is used by all of your webpages and put it there, and then the snippet appears on all pages. Enable via the API You can perform a manual instrumentation, in which your developers can add instrumentation to your webpages using a server-side API. New Relic supports this for many server-side languages. Refer to the documentation for an example of how to do this in Java. Whichever method you choose, you quickly have front-end performance data from your web pages. Just like with APM and other New Relic products, the overview tells you the “big picture” story of your performance data—in this case, your front-end data: one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the browser apps index, the Summary page shows a summary of browser performance for that app. Set alert conditions on metrics like Page view load time and Throughput, as well as JS Errors and Ajax response time. This is not just about seeing a slowdown and fixing it—this is about real users having a frustrating experience and potentially walking away from your application, costing your company potential profits. If you do not already have SLAs defined for these kinds of metrics, now is the time to define them. If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your cloud metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with New Relic products. Deploy mobile monitoring, if your company has a mobile app If your company has a mobile application, install Mobile monitoring. Tip Monitoring performance metrics about your webpages as they work in mobile browsers is handled by the browser agent. If you do not have a native mobile application, you can skip this section. The mobile monitoring agents support most common devices running on iOS and Android. The install process for iOS and Android requires you to include the mobile SDK in your applications. The SDK is as low impact as possible in terms of resource consumption (CPU and memory) while simultaneously providing you a broad and deep spectrum of performance data about your mobile applications. Slow performance on your mobile apps can be just as impactful to your business as slow performance in webpages. Think of top-level metrics like crash occurrences, HTTP errors/network failures, and HTTP response times in terms of your business KPIs. What happens to your business objectives when your mobile app starts spiking in terms of crash rate? Do users get frustrated and give up when the app takes forever to pull down data from your back-end systems or from third-party resources? The mobile monitoring overview page pulls together a set of metrics that you should be setting SLAs and alert conditions on: one.newrelic.com > Mobile > (select an app) > Summary: Quickly view crash occurrences, app launches, and more with mobile monitoring. Once you get to know these top level metrics, you can quickly start using your mobile metrics to find root causes, so you can add new alert conditions on lower-level metrics and discover any regression problems down the road. You can also monitor the back-end systems and cloud services that support your mobile apps. Improving the back-end systems and cloud services has a direct result in their improvement. Check out Monitor your cloud services to gain more insight. Synthetics—it’s already there! With Synthetics, there is nothing to install—the agents are already installed at many global locations and are just waiting for you to start using them. Synthetics lets you quickly define monitors, which run on a schedule you pick and make automated calls from those global locations back into your systems. There are four different types of monitors, and they have the following functions: Type of monitor What this monitor can do for you Ping Point a ping monitor at one of your webpages, and New Relic tells you if that page is responding as expected. Think of Ping as a simple “up/down” test but with a few extra features that you will quickly get to know. Simple browser The job of a simple browser is to simulate all of the work that a real browser would do to build out one of your webpages. Where are the slow points? How can you quickly see a waterfall view of the page buildout? Simple browser quickly gets you all this data. Scripted browser This monitor lets you define a key workflow in your webpages (for example, registering, searching, or purchasing a product) as a script that the monitor runs for you on the frequency you select. If any step in the script fails, New Relic notifies you, with full details about where the failure happened and what it was. API test Testing your API endpoints is just as important as testing your webpages—if one of them stops working as expected, the downstream effects on your systems can be bad news for you and your customers. Define a script that pulls back data from one of your endpoints, tests what it gets back, and alerts you when it encounters a problem. Here are a few things to remember about Synthetics: You can alert on every metric recorded by the monitors, from “is it up/down?” to “what came back from my API endpoint?” All of your performance data from Synthetics can be quickly viewed in terms of SLAs and KPIs. Just like with the other areas of your instrumentation, it helps your entire team to start defining your SLAs for your KPIs. The metrics from Synthetics help you prove out the value of having moved to cloud-hosted services. For any test that you want to run on a resource inside your firewall, there are private minions that you can quickly and securely stand up in your own environment. They are available in the list of locations for your monitors, just like the the rest of the default global locations. 3. Identify your relevant metrics It is vital to identify which metrics are the most important to your business and use these metrics to define your KPIs. Answer the following questions to begin identifying the relevant metrics: What are your KPIs? Are you setting SLAs for them? Here is a look at some examples of KPIs: KPIs for business performance Here are some examples of KPIs that companies in many industries consider to be key to business performance: General DOM readiness Page render Apdex Mobile crash rate Web Session count Session duration Page views DOM readiness Page render Error % Apdex Mobile App launches User counts Load time Response time Crash rates Crash locations Error rates (HTTP, network) API errors Session duration Video Video play count Video play duration Video bit rate Video buffering time Video success rate Errors (video, advertisement) Trends Active users Product views Session duration Sales/Retail Cart value Abandon rate Funnels Click-throughs Revenue (made, loss) KPIs that are specific to your company You might start with KPIs from the business performance list and then build them out to be more specific to your own company’s performance: Geography Business unit Product Product name Device type Store/location Mobile platform Carrier Website name Page name Browser type Error type Application name Cloud provider Success/fail reason KPIs for application and infrastructure teams Here are some KPI ideas for your application and infrastructure teams for the server side: Application/Infrastructure Apdex Availability Throughput App/API/DB response times Error % Memory footprint CPU workload Disk workload Network throughput DevOps Builds Commits Deploys Errors Support incidents MTTR With New Relic products in place across your ecosystem, you can collect a large number of these metrics right out of the box. Once you have all of the data flowing, dashboards is the place where you start creating dashboards from before and after your migration to show your teams the value of moving to the cloud. 4. Create dashboards showing KPIs from before and after your migration So, what might a starter dashboard look like for this part of your migration project? Consider this example: one.newrelic.com > Dashboards: Create customizable dashboards to monitor performance and business data. The rows represent the “before” and “after” perspectives. The widgets in these rows get you answers to the key questions behind your KPIs: What is my site's availability? Which global locations are experiencing the slowest performance? How can I use Apdex scoring to measure customer satisfaction levels with my application's performance? How many are satisfied? How many are OK (tolerating)? How many are frustrated with my site? With just a few setup steps, you can get your monitors running, and then head over to New Relic dashboards and design your widgets. Check out the Introduction to New Relic One dashboards which shows you many examples of these kinds of queries, using data from your own account. You can quickly get a feel for how to start building queries, widgets, and dashboards. After you identify your SLAs and KPIs, browser and mobile monitoring let you quickly start collecting data from your webpages and mobile apps, and Synthetics lets you schedule the monitors you need so that you can find out about problems before your customers start telling you about them. Bringing it all together in dashboards, you can start building the before/after perspective you need to prove the value of moving to the cloud and gain information that will help you optimize your customer’s experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.0361,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": ". If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your <em>cloud</em> metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with <em>New</em> <em>Relic</em> products. Deploy mobile monitoring, if your company has"
      },
      "id": "60445c0064441f4b53378f00"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/identify-issues-roadblocks": [
    {
      "sections": [
        "Validate cloud improvements",
        "1. Identify KPIs",
        "2. Deploy monitoring tools",
        "Install New Relic APM",
        "Install New Relic Infrastructure",
        "Tip",
        "Install New Relic Infrastructure integrations",
        "3. Gather custom data",
        "4. Create baselines",
        "5. Validate improvements with Dashboards"
      ],
      "title": "Validate cloud improvements",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "e8083557674f0bd9a67aadade85517b9f5a517df",
      "image": "https://docs.newrelic.com/static/bd6f185deecee0d1735e167f1831d877/c1b63/KPIs-validate-improvement_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/validate-cloud-improvements/",
      "published_at": "2021-07-09T12:54:07Z",
      "updated_at": "2021-07-09T12:54:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you migrate your applications to the cloud and integrate cloud services, use New Relic to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the New Relic platform to measure KPIs helps you eliminate blind spots and see the connections between entities—from your application code to your cloud infrastructure (including containers running in highly distributed microservices), to your customer experience. Your goal is to create a collection of metrics in several categories that you can visualize in dashboards in New Relic Dashboards. To validate cloud improvements, group KPIs in the following categories, from least to most strong: Application and infrastructure performance End-user experience, including website and mobile application performance Audience and content trends DevOps productivity Application revenue analytics Future business goals 2. Deploy monitoring tools To start monitoring your KPIs, verify that the applications that you want to migrate are compatible with the requirements for the New Relic products you want to use. Then, install the New Relic agents: Install New Relic APM Review the compatibility and requirements and then install APM agents on your application stack. After installing the APM agents, review the architecture of the applications you instrumented with an APM agent. Take note of all hosts that are part of each tier of the application stack (database, application, web server, etc.), so you can install New Relic Infrastructure agents on each of those hosts. Install New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, install the Infrastructure agent on the hosts that you identified so you can start to gather data for your KPIs. Tip If you use Ansible, Chef, or Puppet for automation, you can use those tools to deploy Infrastructure agents to your hosts. Install New Relic Infrastructure integrations You can also monitor and report data about services that your code depends on using New Relic integrations. New Relic offers cloud integrations for Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform as well as on-host integrations. Tip If you are using AWS as a cloud provider, take advantage of New Relic’s AWS billing integrations to stay on top of your budget and prove the success of your migration. 3. Gather custom data To manage, search for, and filter resources, assign metadata to your cloud resources in the form of tags. Tags are labels that consist of key-value pairs that you use to annotate your Infrastructure data. Tag formats are different between AWS, Azure, and Google. Google, for example, has the shortest allowable lengths for keys and values. In addition, they all have different requirements for case sensitivity and allowable characters. To make sure that your tags are usable across most cloud providers: Use only lowercase letters, numbers, underscores, and dashes. Keep keys and values under 63 characters. New Relic reports data contained in specific events to your account as part of its “out-of-the-box” functionality. You can add additional data to those events by using custom attributes. If you determine that you need to collect custom data, review custom data requirements, and report custom event data. For more detailed information about sending custom data, check out these New Relic University tutorials: APM custom data overview Adding custom events using the API 4. Create baselines In order to validate the value of moving to the cloud, you need to get baselines for your applications before you move to the cloud. Define pre-migration baselines for applications and their underlying infrastructures that you have designated for cloud service improvements based on your KPIs. To stay on top of your KPIs as you are moving, create baseline alerts for applications monitored by APM and browser and use NRQL alerts to get notified on any spikes or drops in your KPIs. The following dashboard tracks key performance indicators for applications designated to move to the cloud: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs. After you migrate applications to the cloud, apply the same criteria to post-migration baselines so you can compare your results from before and after your migration. 5. Validate improvements with Dashboards Dashboards is a single location to view all the data that New Relic products gather. Use New Relic Dashboards to visualize your KPIs before and after your move: Transaction and TransactionError event types with APM PageView and PageAction event types with browser Default Infrastructure events and attributes for your systems, processes, events, storage, and network, Infrastructure integrations, and custom attributes Mobile event types with Mobile SyntheticCheck, SyntheticRequest, and SyntheticPrivateMinion event types with Synthetics The following dashboard shows KPI data used to validate cloud improvements: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs pre- and post-migration. Use dashboards to validate the value of adopting a new cloud service and to answer key questions about application performance and customer experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.6894,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Validate <em>cloud</em> improvements",
        "sections": "Install <em>New</em> <em>Relic</em> APM",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "After you migrate your applications to the <em>cloud</em> and integrate <em>cloud</em> services, use <em>New</em> <em>Relic</em> to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key"
      },
      "id": "60445c48e7b9d2052c5799d4"
    },
    {
      "sections": [
        "Refactor your applications",
        "1. Deploy monitoring",
        "Cloud-based integrations",
        "2. Set deployment markers",
        "3. Establish baselines",
        "4. Refactor your applications",
        "5. Create dashboards to track refactoring your applications",
        "6. Create comparison dashboards"
      ],
      "title": "Refactor your applications",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "fcea859e043f6ff33898803636b9a7a6de04508a",
      "image": "https://docs.newrelic.com/static/fc360bb9af89fe16ea8351e90b16ec09/c1b63/screen-deployments-page.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/refactor-your-applications/",
      "published_at": "2021-07-09T11:32:22Z",
      "updated_at": "2021-07-09T11:32:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At each step of your cloud adoption process, New Relic plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage cloud costs. New Relic can also help you refactor, or re-architect, your software and services when you migrate them to the cloud. One key aspect of refactoring your software is splitting out your components into different services available from your cloud provider. For example, you might move your database component away from a traditional MySQL database to a cloud-hosted solution, like Amazon Relational Database (RDS) services such as DynamoDB or Aurora. If you move to the Azure cloud, you might adopt Azure SQL or Cosmos DB. When you move to solutions like those, you increase your database redundancy and resiliency. If you evaluate your overall ROI properly, you should start to see the cost/benefit ratio taking effect once you complete your refactoring. 1. Deploy monitoring New Relic is a true multi-tenant SaaS solution, meaning New Relic designed the agents to work at every layer of your application stack. To get started, deploy the agents: APM to collect application-tier performance metrics Browser monitoring to collect front-end web metrics Mobile monitoring to collect front-end mobile app metrics Infrastructure to collect host/server metrics Cloud-based integrations As you refactor your application and integrate new cloud services, you can also use New Relic to monitor and report data about your cloud services, offering you a comprehensive view of your entire architecture in one place. Cloud-based integrations available through New Relic include Amazon Web Services (AWS) and Microsoft Azure. This tutorial describes a database migration and focuses on APM and Infrastructure. 2. Set deployment markers With New Relic, you can track deployments by setting deployment markers. Deployment tracking lets you quickly see how deployments affect your application’s performance and gauge its performance before and after you refactor. You can view deployments on the Deployments page in APM: rpm.newrelic.com/apm > (selected app) > Events > Deployments: Here is an example of the Deployments page and details about a selected deployment. 3. Establish baselines When you install the APM agent at the application layer, New Relic immediately starts collecting and displaying metrics. Use these metrics to set your pre-migration application baseline. APM agents collect performance metrics about outbound calls to databases. In the Monitoring section of the APM UI, click Databases to see a view of your database metrics. The following shows a database running on MySQL that will be refactored to use DynamoDB after migrating to AWS: one.newrelic.com > APM > (select an app) > Monitoring > Databases: Use this page to view and sort detailed information about database performance. 4. Refactor your applications To take advantage of the cloud, research what services are available from your cloud provider, and then re-architect and uncouple your applications. 5. Create dashboards to track refactoring your applications Apply your KPIs to your baseline measurements to validate cloud improvements, and, ideally, start seeing the impact of moving to the cloud. New Relic’s reporting for database interactions goes much deeper than high-level performance metrics about calls to the database layer in APM. You get access to metrics about slow queries so you can filter by database vendor and cache type. You can also see host and instance details for databases visually within Service Maps and within the context of transaction traces. Because all of your performance metrics are available in New Relic Insights, it is easy to build dashboards to show the performance of your database calls before, during, and after your refactoring in a single unified view. Here is an example of an Insights dashboard for an application that uses DynamoDB and was migrated to AWS: insights.newrelic.com: Build a dashboard that shows the performance of your database calls. 6. Create comparison dashboards To compare both the pre- and post-refactor baselines, create an Insights dashboard that displays the KPIs you baselined. The following dashboard shows the MySQL request query latency as compared with all of the operations for DynamoDB. You can see that, for this example, the request query latency for DynamoDB is too small to even register on the graph. Performance is clearly optimized with this cloud-based database. insights.newrelic.com: Use Insights dashboards to visualize pre- and post-refactor baselines. With APM agents and the integrations New Relic provides, you can measure the effectiveness of refactoring your applications using a broad spectrum of metrics.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.59097,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Cloud</em>-based integrations",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "At each step of your <em>cloud</em> <em>adoption</em> process, <em>New</em> <em>Relic</em> plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage <em>cloud</em> costs. <em>New</em> <em>Relic</em> can also help you refactor, or re-architect, your software and services when you migrate them"
      },
      "id": "60445da6e7b9d2bf265799ee"
    },
    {
      "sections": [
        "Optimize customer experience",
        "1. Identify applications scoped for improvement",
        "2. Deploy monitoring: Browser, mobile, and synthetics",
        "Deploy browser to monitor your front-end data",
        "Deploy mobile monitoring, if your company has a mobile app",
        "Tip",
        "Synthetics—it’s already there!",
        "3. Identify your relevant metrics",
        "KPIs for business performance",
        "KPIs that are specific to your company",
        "KPIs for application and infrastructure teams",
        "4. Create dashboards showing KPIs from before and after your migration"
      ],
      "title": "Optimize customer experience",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "2d4df116b6dedf8a3d0911b0ad0e7bbd11b991d9",
      "image": "https://docs.newrelic.com/static/b84aceb32c77eb0a35e93a26ea700075/c1b63/optimize_exp.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-customer-experience/",
      "published_at": "2021-07-09T10:50:42Z",
      "updated_at": "2021-07-09T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You have been running in the cloud for awhile now, or you just completed your migration from on-premise to the cloud. You have gone through your planning stages, identified your dependencies, tested your assumptions, and everything is looking great. But there are still some big questions: How are your customers experiencing your service? Did the performance of your front-end applications improve, or did performance stay the same? Or did it worsen in ways you did not expect? New Relic provides a suite of front-end monitoring—browser, mobile, and synthetic—to help you monitor and improve your front-end applications. With dashboards, you can bring together information from each one of these product to give you an overall view of what your customer is experiencing. Follow the steps in this doc to optimize your customer experience after you migrate to the cloud. 1. Identify applications scoped for improvement When you identify applications that you want to improve, start with applications where you have some clearly defined KPIs (Key Performance Indicators) that are relevant to the overall performance of your business. Selecting an application that tells a complete story of your performance, regarding key performance indicators, builds trust that you are doing the right level of monitoring and gathering the right metrics. When measuring front-end application performance, most companies think about these common KPIs: Availability percentage Average duration Page load time Throughput Apdex Response time Use those common KPIs as a guideline when identifying applications. Take each one of the metrics and consider it from the perspective of your company's CEO and business team. What is the actual impact on your company's business if your application becomes unavailable? How many users will your site lose if your page loads start to take over four seconds? How many dollars are lost if your applications are not able to handle throughput spikes and some users get no response during those spikes? These are serious questions to answer, and, if you are only measuring metrics on the server/application side, you are very likely not seeing what your customers are seeing on the frontend of the application. That is why browser, mobile, and synthetics are key to understanding the complete picture of your application performance. With dashboards, you bring all of these metrics together and give your company a single place to see every metric that is crucial to your success. 2. Deploy monitoring: Browser, mobile, and synthetics To start monitoring, you need to deploy browser, mobile, and synthetics agents. With browser, you gain deep insight into how your users are interacting with your application or website. Mobile monitoring allows you to monitor and manage the performance of your iOS and Android applications. Synthetics is a suite of automated, scriptable tools to monitor your websites and API endpoints. Just like with all of New Relic's agents, browser, mobile, and synthetics are quick to deploy. Here is a quick overview of each and links to documentation to help you get going: Deploy browser to monitor your front-end data In a nutshell, browser monitoring is a snippet of JavaScript that needs to appear in all of your application's webpages. It has no dependencies on other libraries, so it does not cause additional delays when bringing jQuery or other frameworks into the webpage. There are three ways to install the browser agent: Method When to use this method Enable via APM Typically, the quickest path is to let the APM agent dynamically inject the snippet into your pages on the server side. This works for many common web technologies, such as .NET, JSP, and other Java solutions. The documentation provides a complete reference for the languages and frameworks that allow this option. Copy/paste method If you are using an unsupported framework or are in an environment where you can instrument only the webpages but cannot install APM on the back-end, use the copy/paste method. New Relic presents a snippet directly in the UI, and you copy it and paste it into a global page template on your end. Just pick one that is used by all of your webpages and put it there, and then the snippet appears on all pages. Enable via the API You can perform a manual instrumentation, in which your developers can add instrumentation to your webpages using a server-side API. New Relic supports this for many server-side languages. Refer to the documentation for an example of how to do this in Java. Whichever method you choose, you quickly have front-end performance data from your web pages. Just like with APM and other New Relic products, the overview tells you the “big picture” story of your performance data—in this case, your front-end data: one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the browser apps index, the Summary page shows a summary of browser performance for that app. Set alert conditions on metrics like Page view load time and Throughput, as well as JS Errors and Ajax response time. This is not just about seeing a slowdown and fixing it—this is about real users having a frustrating experience and potentially walking away from your application, costing your company potential profits. If you do not already have SLAs defined for these kinds of metrics, now is the time to define them. If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your cloud metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with New Relic products. Deploy mobile monitoring, if your company has a mobile app If your company has a mobile application, install Mobile monitoring. Tip Monitoring performance metrics about your webpages as they work in mobile browsers is handled by the browser agent. If you do not have a native mobile application, you can skip this section. The mobile monitoring agents support most common devices running on iOS and Android. The install process for iOS and Android requires you to include the mobile SDK in your applications. The SDK is as low impact as possible in terms of resource consumption (CPU and memory) while simultaneously providing you a broad and deep spectrum of performance data about your mobile applications. Slow performance on your mobile apps can be just as impactful to your business as slow performance in webpages. Think of top-level metrics like crash occurrences, HTTP errors/network failures, and HTTP response times in terms of your business KPIs. What happens to your business objectives when your mobile app starts spiking in terms of crash rate? Do users get frustrated and give up when the app takes forever to pull down data from your back-end systems or from third-party resources? The mobile monitoring overview page pulls together a set of metrics that you should be setting SLAs and alert conditions on: one.newrelic.com > Mobile > (select an app) > Summary: Quickly view crash occurrences, app launches, and more with mobile monitoring. Once you get to know these top level metrics, you can quickly start using your mobile metrics to find root causes, so you can add new alert conditions on lower-level metrics and discover any regression problems down the road. You can also monitor the back-end systems and cloud services that support your mobile apps. Improving the back-end systems and cloud services has a direct result in their improvement. Check out Monitor your cloud services to gain more insight. Synthetics—it’s already there! With Synthetics, there is nothing to install—the agents are already installed at many global locations and are just waiting for you to start using them. Synthetics lets you quickly define monitors, which run on a schedule you pick and make automated calls from those global locations back into your systems. There are four different types of monitors, and they have the following functions: Type of monitor What this monitor can do for you Ping Point a ping monitor at one of your webpages, and New Relic tells you if that page is responding as expected. Think of Ping as a simple “up/down” test but with a few extra features that you will quickly get to know. Simple browser The job of a simple browser is to simulate all of the work that a real browser would do to build out one of your webpages. Where are the slow points? How can you quickly see a waterfall view of the page buildout? Simple browser quickly gets you all this data. Scripted browser This monitor lets you define a key workflow in your webpages (for example, registering, searching, or purchasing a product) as a script that the monitor runs for you on the frequency you select. If any step in the script fails, New Relic notifies you, with full details about where the failure happened and what it was. API test Testing your API endpoints is just as important as testing your webpages—if one of them stops working as expected, the downstream effects on your systems can be bad news for you and your customers. Define a script that pulls back data from one of your endpoints, tests what it gets back, and alerts you when it encounters a problem. Here are a few things to remember about Synthetics: You can alert on every metric recorded by the monitors, from “is it up/down?” to “what came back from my API endpoint?” All of your performance data from Synthetics can be quickly viewed in terms of SLAs and KPIs. Just like with the other areas of your instrumentation, it helps your entire team to start defining your SLAs for your KPIs. The metrics from Synthetics help you prove out the value of having moved to cloud-hosted services. For any test that you want to run on a resource inside your firewall, there are private minions that you can quickly and securely stand up in your own environment. They are available in the list of locations for your monitors, just like the the rest of the default global locations. 3. Identify your relevant metrics It is vital to identify which metrics are the most important to your business and use these metrics to define your KPIs. Answer the following questions to begin identifying the relevant metrics: What are your KPIs? Are you setting SLAs for them? Here is a look at some examples of KPIs: KPIs for business performance Here are some examples of KPIs that companies in many industries consider to be key to business performance: General DOM readiness Page render Apdex Mobile crash rate Web Session count Session duration Page views DOM readiness Page render Error % Apdex Mobile App launches User counts Load time Response time Crash rates Crash locations Error rates (HTTP, network) API errors Session duration Video Video play count Video play duration Video bit rate Video buffering time Video success rate Errors (video, advertisement) Trends Active users Product views Session duration Sales/Retail Cart value Abandon rate Funnels Click-throughs Revenue (made, loss) KPIs that are specific to your company You might start with KPIs from the business performance list and then build them out to be more specific to your own company’s performance: Geography Business unit Product Product name Device type Store/location Mobile platform Carrier Website name Page name Browser type Error type Application name Cloud provider Success/fail reason KPIs for application and infrastructure teams Here are some KPI ideas for your application and infrastructure teams for the server side: Application/Infrastructure Apdex Availability Throughput App/API/DB response times Error % Memory footprint CPU workload Disk workload Network throughput DevOps Builds Commits Deploys Errors Support incidents MTTR With New Relic products in place across your ecosystem, you can collect a large number of these metrics right out of the box. Once you have all of the data flowing, dashboards is the place where you start creating dashboards from before and after your migration to show your teams the value of moving to the cloud. 4. Create dashboards showing KPIs from before and after your migration So, what might a starter dashboard look like for this part of your migration project? Consider this example: one.newrelic.com > Dashboards: Create customizable dashboards to monitor performance and business data. The rows represent the “before” and “after” perspectives. The widgets in these rows get you answers to the key questions behind your KPIs: What is my site's availability? Which global locations are experiencing the slowest performance? How can I use Apdex scoring to measure customer satisfaction levels with my application's performance? How many are satisfied? How many are OK (tolerating)? How many are frustrated with my site? With just a few setup steps, you can get your monitors running, and then head over to New Relic dashboards and design your widgets. Check out the Introduction to New Relic One dashboards which shows you many examples of these kinds of queries, using data from your own account. You can quickly get a feel for how to start building queries, widgets, and dashboards. After you identify your SLAs and KPIs, browser and mobile monitoring let you quickly start collecting data from your webpages and mobile apps, and Synthetics lets you schedule the monitors you need so that you can find out about problems before your customers start telling you about them. Bringing it all together in dashboards, you can start building the before/after perspective you need to prove the value of moving to the cloud and gain information that will help you optimize your customer’s experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.0359,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": ". If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your <em>cloud</em> metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with <em>New</em> <em>Relic</em> products. Deploy mobile monitoring, if your company has"
      },
      "id": "60445c0064441f4b53378f00"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-customer-experience": [
    {
      "sections": [
        "Validate cloud improvements",
        "1. Identify KPIs",
        "2. Deploy monitoring tools",
        "Install New Relic APM",
        "Install New Relic Infrastructure",
        "Tip",
        "Install New Relic Infrastructure integrations",
        "3. Gather custom data",
        "4. Create baselines",
        "5. Validate improvements with Dashboards"
      ],
      "title": "Validate cloud improvements",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "e8083557674f0bd9a67aadade85517b9f5a517df",
      "image": "https://docs.newrelic.com/static/bd6f185deecee0d1735e167f1831d877/c1b63/KPIs-validate-improvement_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/validate-cloud-improvements/",
      "published_at": "2021-07-09T12:54:07Z",
      "updated_at": "2021-07-09T12:54:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you migrate your applications to the cloud and integrate cloud services, use New Relic to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the New Relic platform to measure KPIs helps you eliminate blind spots and see the connections between entities—from your application code to your cloud infrastructure (including containers running in highly distributed microservices), to your customer experience. Your goal is to create a collection of metrics in several categories that you can visualize in dashboards in New Relic Dashboards. To validate cloud improvements, group KPIs in the following categories, from least to most strong: Application and infrastructure performance End-user experience, including website and mobile application performance Audience and content trends DevOps productivity Application revenue analytics Future business goals 2. Deploy monitoring tools To start monitoring your KPIs, verify that the applications that you want to migrate are compatible with the requirements for the New Relic products you want to use. Then, install the New Relic agents: Install New Relic APM Review the compatibility and requirements and then install APM agents on your application stack. After installing the APM agents, review the architecture of the applications you instrumented with an APM agent. Take note of all hosts that are part of each tier of the application stack (database, application, web server, etc.), so you can install New Relic Infrastructure agents on each of those hosts. Install New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, install the Infrastructure agent on the hosts that you identified so you can start to gather data for your KPIs. Tip If you use Ansible, Chef, or Puppet for automation, you can use those tools to deploy Infrastructure agents to your hosts. Install New Relic Infrastructure integrations You can also monitor and report data about services that your code depends on using New Relic integrations. New Relic offers cloud integrations for Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform as well as on-host integrations. Tip If you are using AWS as a cloud provider, take advantage of New Relic’s AWS billing integrations to stay on top of your budget and prove the success of your migration. 3. Gather custom data To manage, search for, and filter resources, assign metadata to your cloud resources in the form of tags. Tags are labels that consist of key-value pairs that you use to annotate your Infrastructure data. Tag formats are different between AWS, Azure, and Google. Google, for example, has the shortest allowable lengths for keys and values. In addition, they all have different requirements for case sensitivity and allowable characters. To make sure that your tags are usable across most cloud providers: Use only lowercase letters, numbers, underscores, and dashes. Keep keys and values under 63 characters. New Relic reports data contained in specific events to your account as part of its “out-of-the-box” functionality. You can add additional data to those events by using custom attributes. If you determine that you need to collect custom data, review custom data requirements, and report custom event data. For more detailed information about sending custom data, check out these New Relic University tutorials: APM custom data overview Adding custom events using the API 4. Create baselines In order to validate the value of moving to the cloud, you need to get baselines for your applications before you move to the cloud. Define pre-migration baselines for applications and their underlying infrastructures that you have designated for cloud service improvements based on your KPIs. To stay on top of your KPIs as you are moving, create baseline alerts for applications monitored by APM and browser and use NRQL alerts to get notified on any spikes or drops in your KPIs. The following dashboard tracks key performance indicators for applications designated to move to the cloud: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs. After you migrate applications to the cloud, apply the same criteria to post-migration baselines so you can compare your results from before and after your migration. 5. Validate improvements with Dashboards Dashboards is a single location to view all the data that New Relic products gather. Use New Relic Dashboards to visualize your KPIs before and after your move: Transaction and TransactionError event types with APM PageView and PageAction event types with browser Default Infrastructure events and attributes for your systems, processes, events, storage, and network, Infrastructure integrations, and custom attributes Mobile event types with Mobile SyntheticCheck, SyntheticRequest, and SyntheticPrivateMinion event types with Synthetics The following dashboard shows KPI data used to validate cloud improvements: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs pre- and post-migration. Use dashboards to validate the value of adopting a new cloud service and to answer key questions about application performance and customer experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.6894,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Validate <em>cloud</em> improvements",
        "sections": "Install <em>New</em> <em>Relic</em> APM",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "After you migrate your applications to the <em>cloud</em> and integrate <em>cloud</em> services, use <em>New</em> <em>Relic</em> to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key"
      },
      "id": "60445c48e7b9d2052c5799d4"
    },
    {
      "sections": [
        "Refactor your applications",
        "1. Deploy monitoring",
        "Cloud-based integrations",
        "2. Set deployment markers",
        "3. Establish baselines",
        "4. Refactor your applications",
        "5. Create dashboards to track refactoring your applications",
        "6. Create comparison dashboards"
      ],
      "title": "Refactor your applications",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "fcea859e043f6ff33898803636b9a7a6de04508a",
      "image": "https://docs.newrelic.com/static/fc360bb9af89fe16ea8351e90b16ec09/c1b63/screen-deployments-page.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/refactor-your-applications/",
      "published_at": "2021-07-09T11:32:22Z",
      "updated_at": "2021-07-09T11:32:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At each step of your cloud adoption process, New Relic plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage cloud costs. New Relic can also help you refactor, or re-architect, your software and services when you migrate them to the cloud. One key aspect of refactoring your software is splitting out your components into different services available from your cloud provider. For example, you might move your database component away from a traditional MySQL database to a cloud-hosted solution, like Amazon Relational Database (RDS) services such as DynamoDB or Aurora. If you move to the Azure cloud, you might adopt Azure SQL or Cosmos DB. When you move to solutions like those, you increase your database redundancy and resiliency. If you evaluate your overall ROI properly, you should start to see the cost/benefit ratio taking effect once you complete your refactoring. 1. Deploy monitoring New Relic is a true multi-tenant SaaS solution, meaning New Relic designed the agents to work at every layer of your application stack. To get started, deploy the agents: APM to collect application-tier performance metrics Browser monitoring to collect front-end web metrics Mobile monitoring to collect front-end mobile app metrics Infrastructure to collect host/server metrics Cloud-based integrations As you refactor your application and integrate new cloud services, you can also use New Relic to monitor and report data about your cloud services, offering you a comprehensive view of your entire architecture in one place. Cloud-based integrations available through New Relic include Amazon Web Services (AWS) and Microsoft Azure. This tutorial describes a database migration and focuses on APM and Infrastructure. 2. Set deployment markers With New Relic, you can track deployments by setting deployment markers. Deployment tracking lets you quickly see how deployments affect your application’s performance and gauge its performance before and after you refactor. You can view deployments on the Deployments page in APM: rpm.newrelic.com/apm > (selected app) > Events > Deployments: Here is an example of the Deployments page and details about a selected deployment. 3. Establish baselines When you install the APM agent at the application layer, New Relic immediately starts collecting and displaying metrics. Use these metrics to set your pre-migration application baseline. APM agents collect performance metrics about outbound calls to databases. In the Monitoring section of the APM UI, click Databases to see a view of your database metrics. The following shows a database running on MySQL that will be refactored to use DynamoDB after migrating to AWS: one.newrelic.com > APM > (select an app) > Monitoring > Databases: Use this page to view and sort detailed information about database performance. 4. Refactor your applications To take advantage of the cloud, research what services are available from your cloud provider, and then re-architect and uncouple your applications. 5. Create dashboards to track refactoring your applications Apply your KPIs to your baseline measurements to validate cloud improvements, and, ideally, start seeing the impact of moving to the cloud. New Relic’s reporting for database interactions goes much deeper than high-level performance metrics about calls to the database layer in APM. You get access to metrics about slow queries so you can filter by database vendor and cache type. You can also see host and instance details for databases visually within Service Maps and within the context of transaction traces. Because all of your performance metrics are available in New Relic Insights, it is easy to build dashboards to show the performance of your database calls before, during, and after your refactoring in a single unified view. Here is an example of an Insights dashboard for an application that uses DynamoDB and was migrated to AWS: insights.newrelic.com: Build a dashboard that shows the performance of your database calls. 6. Create comparison dashboards To compare both the pre- and post-refactor baselines, create an Insights dashboard that displays the KPIs you baselined. The following dashboard shows the MySQL request query latency as compared with all of the operations for DynamoDB. You can see that, for this example, the request query latency for DynamoDB is too small to even register on the graph. Performance is clearly optimized with this cloud-based database. insights.newrelic.com: Use Insights dashboards to visualize pre- and post-refactor baselines. With APM agents and the integrations New Relic provides, you can measure the effectiveness of refactoring your applications using a broad spectrum of metrics.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.59097,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Cloud</em>-based integrations",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "At each step of your <em>cloud</em> <em>adoption</em> process, <em>New</em> <em>Relic</em> plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage <em>cloud</em> costs. <em>New</em> <em>Relic</em> can also help you refactor, or re-architect, your software and services when you migrate them"
      },
      "id": "60445da6e7b9d2bf265799ee"
    },
    {
      "sections": [
        "Identify issues and roadblocks",
        "1. Identify components",
        "2. Identify KPIs",
        "3. Deploy monitoring tools",
        "Deploy New Relic APM",
        "Deploy browser monitoring",
        "Deploy New Relic Infrastructure",
        "Tip",
        "Set up alerts",
        "4. Set up cloud integrations",
        "5. Identify issues and roadblocks",
        "Expert tip for alerting on JavaScript errors"
      ],
      "title": "Identify issues and roadblocks",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "12c79f8e91e131ddf9015d1617760261d71660d1",
      "image": "https://docs.newrelic.com/static/cc629d8a7fe9dd09ac59711b669baedc/c1b63/screen-javascript-errors.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/identify-issues-roadblocks/",
      "published_at": "2021-07-09T10:46:00Z",
      "updated_at": "2021-07-09T10:46:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As you migrate your applications to the cloud, you want to catch and correct any unexpected behavior or outcomes as soon as possible. Detecting errors and issues related to your new cloud architecture, performance, and scale is critical—getting the right information at the right time can be the difference between success and failure. 1. Identify components Create a list all of applications, services, and their underlying server infrastructures in your application portfolio that you want to migrate to the cloud. 2. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the New Relic platform to measure KPIs helps you eliminate blindspots and see the connections between entities—from your application code, to your cloud infrastructure (including containers running in highly distributed microservices), to your customer experience. Your goal is to create a collection of metrics in several categories that you can visualize in our Dashboards. To validate cloud improvements, group KPIs in the following categories, from least to most strong: Application and infrastructure performance End-user experience, including website and mobile application performance Audience and content trends DevOps productivity Application revenue analytics Future business goals 3. Deploy monitoring tools To start monitoring your KPIs, verify that the applications that you want to migrate are compatible with the requirements for the New Relic products you will use. Then, install the New Relic agents: Deploy New Relic APM Review the compatibility and requirements and then install APM agents on your application stack. After installing the APM agents, review the architecture of the applications that you instrumented with an APM agent. Take note of all hosts that are part of each tier of the application stack (database, application, web server, etc.), so you can install New Relic Infrastructure monitoring agents on each of those hosts. Deploy browser monitoring In a nutshell, browser monitoring is a snippet of JavaScript that needs to appear in all of your application's webpages. It has no dependencies on other libraries, so it does not cause additional delays when bringing jQuery or other frameworks into the webpage. There are three ways to install the browser agent: Method When to use this method Enable via New Relic APM Typically, the quickest path is to let the APM agent dynamically inject the snippet into your pages on the server side. This works for many common web technologies, such as .NET, JSP, and other Java solutions. The documentation provides a complete reference for the languages and frameworks that allow this option. Copy/paste method If you are using an unsupported framework or are in an environment where you can instrument only the webpages but cannot install APM on the backend, use the copy-paste method. The UI generates a simple JavaScript snippet. Copy that snippet, and paste it into a global page template on your end to get browser monitoring deployed across your site. Enable via the API You can perform a manual instrumentation, in which your developers add instrumentation to your webpages using a server-side API. New Relic supports this for many server-side languages. Refer to the documentation for an example of how to do this in Java. Deploy New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, install the Infrastructure agent on the hosts that you identified so you can start to gather data for your KPIs. Tip If you use Ansible, Chef, or Puppet for automation, you can use those tools to deploy Infrastructure agents to your hosts. Set up alerts New Relic Alerts is a single integrated solution with a centralized UI to help you focus on the metrics that you care about most. When you set up New Relic Alerts and NRQL alerting, you establish flexible policies and conditions to receive alerts and notifications on multiple channels (email, Slack, OpsGenie, etc.). For more detailed information about creating, managing, and using alerts, check out the New Relic University tutorials. 4. Set up cloud integrations Tip Cloud-based integrations available through New Relic include Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. Once your applications are migrated to the cloud and you start to integrate new cloud services, you can use New Relic to monitor and report data about your cloud services, offering you a comprehensive view of your entire architecture in one place. For example, to capture and record AWS account activity for audit and governance purposes, use the New Relic AWS CloudTrail integration. Tracking error events gives you awareness about API calls and services that have failed, while console logins help you monitor console activity and potential intrusion attempts. New Relic collects this event data so you can display it in a Dashboard or alert on it with NRQL. To gain extended visibility into applications that your code depends on, you can also deploy on-host integrations for commonly used application components, such as MySQL, Apache, and NGINX. In addition, you can create your own custom on-host integration with the New Relic Integrations SDK. 5. Identify issues and roadblocks Once your applications are running in the cloud, they may generate new types of errors that are different from the errors that they generated when running on-premise. You can use New Relic APM and browser monitoring to view error events, error metrics, and detailed error traces for your applications. If an error or unhandled exception happens, the data appears on the JavaScript errors page and the APM Error analytics page. From these pages, you can quickly troubleshoot runtime errors. Then, further analyze errors by grouping them according to attributes, by filtering them, or by searching for keywords in the event data. Each unhandled exception generates a transaction error event in Insights, and the dashboards are updated in real-time. Event data is a record of a single event at a particular moment in time and consists of default attributes, like a timestamp, and an event type. You can also add custom attributes to provide more context. Tip Once you start capturing JavaScript errors as events in Insights, set up NRQL alerting so you can stay on top of your error data. Use the JavaScript errors page to get visibility into real-time user experience: one.newrelic.com > Browser > (select an app) > JS errors: Use the charts on this page to get visibility into the real-time user experience. Then, create a Dashboard that covers a longer period of time and aligns the error and unhandled exception data with your KPIs: one.newrelic.com > Dashboards > Create a dashboard: Use dashboards to align the error and unhandled exception data with your KPIs. Expert tip for alerting on JavaScript errors To get notifications for error spikes that are different from known or common JavaScript errors, use the following NRQL query for browser-monitored: SELECT count(*) FROM JavaScriptError WHERE appName = '<BrowserAppName>' AND errorClass NOT IN ('<ErrorClass1>','<ErrorClass2>') Copy Replace <BrowserAppName> with the browser app name that you want to monitor with this alert. Replace <ErrorClass1> and <ErrorClass2> with the on-premise error class names that you do not want New Relic to alert you about. Set the threshold based on your alerting needs. Using this query, New Relic alerts you every time a JavaScript error occurs when it has an error class that is not normally reported.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 358.97345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Deploy <em>New</em> <em>Relic</em> APM",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": " to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the <em>New</em> <em>Relic</em> platform to measure KPIs helps you eliminate blindspots and see the connections between entities—from your application code, to your <em>cloud</em> infrastructure (including containers running in highly"
      },
      "id": "60445b87196a67bb33960f21"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-your-cloud-spend": [
    {
      "sections": [
        "Validate cloud improvements",
        "1. Identify KPIs",
        "2. Deploy monitoring tools",
        "Install New Relic APM",
        "Install New Relic Infrastructure",
        "Tip",
        "Install New Relic Infrastructure integrations",
        "3. Gather custom data",
        "4. Create baselines",
        "5. Validate improvements with Dashboards"
      ],
      "title": "Validate cloud improvements",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "e8083557674f0bd9a67aadade85517b9f5a517df",
      "image": "https://docs.newrelic.com/static/bd6f185deecee0d1735e167f1831d877/c1b63/KPIs-validate-improvement_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/validate-cloud-improvements/",
      "published_at": "2021-07-09T12:54:07Z",
      "updated_at": "2021-07-09T12:54:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you migrate your applications to the cloud and integrate cloud services, use New Relic to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the New Relic platform to measure KPIs helps you eliminate blind spots and see the connections between entities—from your application code to your cloud infrastructure (including containers running in highly distributed microservices), to your customer experience. Your goal is to create a collection of metrics in several categories that you can visualize in dashboards in New Relic Dashboards. To validate cloud improvements, group KPIs in the following categories, from least to most strong: Application and infrastructure performance End-user experience, including website and mobile application performance Audience and content trends DevOps productivity Application revenue analytics Future business goals 2. Deploy monitoring tools To start monitoring your KPIs, verify that the applications that you want to migrate are compatible with the requirements for the New Relic products you want to use. Then, install the New Relic agents: Install New Relic APM Review the compatibility and requirements and then install APM agents on your application stack. After installing the APM agents, review the architecture of the applications you instrumented with an APM agent. Take note of all hosts that are part of each tier of the application stack (database, application, web server, etc.), so you can install New Relic Infrastructure agents on each of those hosts. Install New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, install the Infrastructure agent on the hosts that you identified so you can start to gather data for your KPIs. Tip If you use Ansible, Chef, or Puppet for automation, you can use those tools to deploy Infrastructure agents to your hosts. Install New Relic Infrastructure integrations You can also monitor and report data about services that your code depends on using New Relic integrations. New Relic offers cloud integrations for Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform as well as on-host integrations. Tip If you are using AWS as a cloud provider, take advantage of New Relic’s AWS billing integrations to stay on top of your budget and prove the success of your migration. 3. Gather custom data To manage, search for, and filter resources, assign metadata to your cloud resources in the form of tags. Tags are labels that consist of key-value pairs that you use to annotate your Infrastructure data. Tag formats are different between AWS, Azure, and Google. Google, for example, has the shortest allowable lengths for keys and values. In addition, they all have different requirements for case sensitivity and allowable characters. To make sure that your tags are usable across most cloud providers: Use only lowercase letters, numbers, underscores, and dashes. Keep keys and values under 63 characters. New Relic reports data contained in specific events to your account as part of its “out-of-the-box” functionality. You can add additional data to those events by using custom attributes. If you determine that you need to collect custom data, review custom data requirements, and report custom event data. For more detailed information about sending custom data, check out these New Relic University tutorials: APM custom data overview Adding custom events using the API 4. Create baselines In order to validate the value of moving to the cloud, you need to get baselines for your applications before you move to the cloud. Define pre-migration baselines for applications and their underlying infrastructures that you have designated for cloud service improvements based on your KPIs. To stay on top of your KPIs as you are moving, create baseline alerts for applications monitored by APM and browser and use NRQL alerts to get notified on any spikes or drops in your KPIs. The following dashboard tracks key performance indicators for applications designated to move to the cloud: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs. After you migrate applications to the cloud, apply the same criteria to post-migration baselines so you can compare your results from before and after your migration. 5. Validate improvements with Dashboards Dashboards is a single location to view all the data that New Relic products gather. Use New Relic Dashboards to visualize your KPIs before and after your move: Transaction and TransactionError event types with APM PageView and PageAction event types with browser Default Infrastructure events and attributes for your systems, processes, events, storage, and network, Infrastructure integrations, and custom attributes Mobile event types with Mobile SyntheticCheck, SyntheticRequest, and SyntheticPrivateMinion event types with Synthetics The following dashboard shows KPI data used to validate cloud improvements: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs pre- and post-migration. Use dashboards to validate the value of adopting a new cloud service and to answer key questions about application performance and customer experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.68915,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Validate <em>cloud</em> improvements",
        "sections": "Install <em>New</em> <em>Relic</em> APM",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "After you migrate your applications to the <em>cloud</em> and integrate <em>cloud</em> services, use <em>New</em> <em>Relic</em> to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key"
      },
      "id": "60445c48e7b9d2052c5799d4"
    },
    {
      "sections": [
        "Refactor your applications",
        "1. Deploy monitoring",
        "Cloud-based integrations",
        "2. Set deployment markers",
        "3. Establish baselines",
        "4. Refactor your applications",
        "5. Create dashboards to track refactoring your applications",
        "6. Create comparison dashboards"
      ],
      "title": "Refactor your applications",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "fcea859e043f6ff33898803636b9a7a6de04508a",
      "image": "https://docs.newrelic.com/static/fc360bb9af89fe16ea8351e90b16ec09/c1b63/screen-deployments-page.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/refactor-your-applications/",
      "published_at": "2021-07-09T11:32:22Z",
      "updated_at": "2021-07-09T11:32:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At each step of your cloud adoption process, New Relic plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage cloud costs. New Relic can also help you refactor, or re-architect, your software and services when you migrate them to the cloud. One key aspect of refactoring your software is splitting out your components into different services available from your cloud provider. For example, you might move your database component away from a traditional MySQL database to a cloud-hosted solution, like Amazon Relational Database (RDS) services such as DynamoDB or Aurora. If you move to the Azure cloud, you might adopt Azure SQL or Cosmos DB. When you move to solutions like those, you increase your database redundancy and resiliency. If you evaluate your overall ROI properly, you should start to see the cost/benefit ratio taking effect once you complete your refactoring. 1. Deploy monitoring New Relic is a true multi-tenant SaaS solution, meaning New Relic designed the agents to work at every layer of your application stack. To get started, deploy the agents: APM to collect application-tier performance metrics Browser monitoring to collect front-end web metrics Mobile monitoring to collect front-end mobile app metrics Infrastructure to collect host/server metrics Cloud-based integrations As you refactor your application and integrate new cloud services, you can also use New Relic to monitor and report data about your cloud services, offering you a comprehensive view of your entire architecture in one place. Cloud-based integrations available through New Relic include Amazon Web Services (AWS) and Microsoft Azure. This tutorial describes a database migration and focuses on APM and Infrastructure. 2. Set deployment markers With New Relic, you can track deployments by setting deployment markers. Deployment tracking lets you quickly see how deployments affect your application’s performance and gauge its performance before and after you refactor. You can view deployments on the Deployments page in APM: rpm.newrelic.com/apm > (selected app) > Events > Deployments: Here is an example of the Deployments page and details about a selected deployment. 3. Establish baselines When you install the APM agent at the application layer, New Relic immediately starts collecting and displaying metrics. Use these metrics to set your pre-migration application baseline. APM agents collect performance metrics about outbound calls to databases. In the Monitoring section of the APM UI, click Databases to see a view of your database metrics. The following shows a database running on MySQL that will be refactored to use DynamoDB after migrating to AWS: one.newrelic.com > APM > (select an app) > Monitoring > Databases: Use this page to view and sort detailed information about database performance. 4. Refactor your applications To take advantage of the cloud, research what services are available from your cloud provider, and then re-architect and uncouple your applications. 5. Create dashboards to track refactoring your applications Apply your KPIs to your baseline measurements to validate cloud improvements, and, ideally, start seeing the impact of moving to the cloud. New Relic’s reporting for database interactions goes much deeper than high-level performance metrics about calls to the database layer in APM. You get access to metrics about slow queries so you can filter by database vendor and cache type. You can also see host and instance details for databases visually within Service Maps and within the context of transaction traces. Because all of your performance metrics are available in New Relic Insights, it is easy to build dashboards to show the performance of your database calls before, during, and after your refactoring in a single unified view. Here is an example of an Insights dashboard for an application that uses DynamoDB and was migrated to AWS: insights.newrelic.com: Build a dashboard that shows the performance of your database calls. 6. Create comparison dashboards To compare both the pre- and post-refactor baselines, create an Insights dashboard that displays the KPIs you baselined. The following dashboard shows the MySQL request query latency as compared with all of the operations for DynamoDB. You can see that, for this example, the request query latency for DynamoDB is too small to even register on the graph. Performance is clearly optimized with this cloud-based database. insights.newrelic.com: Use Insights dashboards to visualize pre- and post-refactor baselines. With APM agents and the integrations New Relic provides, you can measure the effectiveness of refactoring your applications using a broad spectrum of metrics.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.59076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Cloud</em>-based integrations",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "At each step of your <em>cloud</em> <em>adoption</em> process, <em>New</em> <em>Relic</em> plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage <em>cloud</em> costs. <em>New</em> <em>Relic</em> can also help you refactor, or re-architect, your software and services when you migrate them"
      },
      "id": "60445da6e7b9d2bf265799ee"
    },
    {
      "sections": [
        "Optimize customer experience",
        "1. Identify applications scoped for improvement",
        "2. Deploy monitoring: Browser, mobile, and synthetics",
        "Deploy browser to monitor your front-end data",
        "Deploy mobile monitoring, if your company has a mobile app",
        "Tip",
        "Synthetics—it’s already there!",
        "3. Identify your relevant metrics",
        "KPIs for business performance",
        "KPIs that are specific to your company",
        "KPIs for application and infrastructure teams",
        "4. Create dashboards showing KPIs from before and after your migration"
      ],
      "title": "Optimize customer experience",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "2d4df116b6dedf8a3d0911b0ad0e7bbd11b991d9",
      "image": "https://docs.newrelic.com/static/b84aceb32c77eb0a35e93a26ea700075/c1b63/optimize_exp.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-customer-experience/",
      "published_at": "2021-07-09T10:50:42Z",
      "updated_at": "2021-07-09T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You have been running in the cloud for awhile now, or you just completed your migration from on-premise to the cloud. You have gone through your planning stages, identified your dependencies, tested your assumptions, and everything is looking great. But there are still some big questions: How are your customers experiencing your service? Did the performance of your front-end applications improve, or did performance stay the same? Or did it worsen in ways you did not expect? New Relic provides a suite of front-end monitoring—browser, mobile, and synthetic—to help you monitor and improve your front-end applications. With dashboards, you can bring together information from each one of these product to give you an overall view of what your customer is experiencing. Follow the steps in this doc to optimize your customer experience after you migrate to the cloud. 1. Identify applications scoped for improvement When you identify applications that you want to improve, start with applications where you have some clearly defined KPIs (Key Performance Indicators) that are relevant to the overall performance of your business. Selecting an application that tells a complete story of your performance, regarding key performance indicators, builds trust that you are doing the right level of monitoring and gathering the right metrics. When measuring front-end application performance, most companies think about these common KPIs: Availability percentage Average duration Page load time Throughput Apdex Response time Use those common KPIs as a guideline when identifying applications. Take each one of the metrics and consider it from the perspective of your company's CEO and business team. What is the actual impact on your company's business if your application becomes unavailable? How many users will your site lose if your page loads start to take over four seconds? How many dollars are lost if your applications are not able to handle throughput spikes and some users get no response during those spikes? These are serious questions to answer, and, if you are only measuring metrics on the server/application side, you are very likely not seeing what your customers are seeing on the frontend of the application. That is why browser, mobile, and synthetics are key to understanding the complete picture of your application performance. With dashboards, you bring all of these metrics together and give your company a single place to see every metric that is crucial to your success. 2. Deploy monitoring: Browser, mobile, and synthetics To start monitoring, you need to deploy browser, mobile, and synthetics agents. With browser, you gain deep insight into how your users are interacting with your application or website. Mobile monitoring allows you to monitor and manage the performance of your iOS and Android applications. Synthetics is a suite of automated, scriptable tools to monitor your websites and API endpoints. Just like with all of New Relic's agents, browser, mobile, and synthetics are quick to deploy. Here is a quick overview of each and links to documentation to help you get going: Deploy browser to monitor your front-end data In a nutshell, browser monitoring is a snippet of JavaScript that needs to appear in all of your application's webpages. It has no dependencies on other libraries, so it does not cause additional delays when bringing jQuery or other frameworks into the webpage. There are three ways to install the browser agent: Method When to use this method Enable via APM Typically, the quickest path is to let the APM agent dynamically inject the snippet into your pages on the server side. This works for many common web technologies, such as .NET, JSP, and other Java solutions. The documentation provides a complete reference for the languages and frameworks that allow this option. Copy/paste method If you are using an unsupported framework or are in an environment where you can instrument only the webpages but cannot install APM on the back-end, use the copy/paste method. New Relic presents a snippet directly in the UI, and you copy it and paste it into a global page template on your end. Just pick one that is used by all of your webpages and put it there, and then the snippet appears on all pages. Enable via the API You can perform a manual instrumentation, in which your developers can add instrumentation to your webpages using a server-side API. New Relic supports this for many server-side languages. Refer to the documentation for an example of how to do this in Java. Whichever method you choose, you quickly have front-end performance data from your web pages. Just like with APM and other New Relic products, the overview tells you the “big picture” story of your performance data—in this case, your front-end data: one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the browser apps index, the Summary page shows a summary of browser performance for that app. Set alert conditions on metrics like Page view load time and Throughput, as well as JS Errors and Ajax response time. This is not just about seeing a slowdown and fixing it—this is about real users having a frustrating experience and potentially walking away from your application, costing your company potential profits. If you do not already have SLAs defined for these kinds of metrics, now is the time to define them. If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your cloud metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with New Relic products. Deploy mobile monitoring, if your company has a mobile app If your company has a mobile application, install Mobile monitoring. Tip Monitoring performance metrics about your webpages as they work in mobile browsers is handled by the browser agent. If you do not have a native mobile application, you can skip this section. The mobile monitoring agents support most common devices running on iOS and Android. The install process for iOS and Android requires you to include the mobile SDK in your applications. The SDK is as low impact as possible in terms of resource consumption (CPU and memory) while simultaneously providing you a broad and deep spectrum of performance data about your mobile applications. Slow performance on your mobile apps can be just as impactful to your business as slow performance in webpages. Think of top-level metrics like crash occurrences, HTTP errors/network failures, and HTTP response times in terms of your business KPIs. What happens to your business objectives when your mobile app starts spiking in terms of crash rate? Do users get frustrated and give up when the app takes forever to pull down data from your back-end systems or from third-party resources? The mobile monitoring overview page pulls together a set of metrics that you should be setting SLAs and alert conditions on: one.newrelic.com > Mobile > (select an app) > Summary: Quickly view crash occurrences, app launches, and more with mobile monitoring. Once you get to know these top level metrics, you can quickly start using your mobile metrics to find root causes, so you can add new alert conditions on lower-level metrics and discover any regression problems down the road. You can also monitor the back-end systems and cloud services that support your mobile apps. Improving the back-end systems and cloud services has a direct result in their improvement. Check out Monitor your cloud services to gain more insight. Synthetics—it’s already there! With Synthetics, there is nothing to install—the agents are already installed at many global locations and are just waiting for you to start using them. Synthetics lets you quickly define monitors, which run on a schedule you pick and make automated calls from those global locations back into your systems. There are four different types of monitors, and they have the following functions: Type of monitor What this monitor can do for you Ping Point a ping monitor at one of your webpages, and New Relic tells you if that page is responding as expected. Think of Ping as a simple “up/down” test but with a few extra features that you will quickly get to know. Simple browser The job of a simple browser is to simulate all of the work that a real browser would do to build out one of your webpages. Where are the slow points? How can you quickly see a waterfall view of the page buildout? Simple browser quickly gets you all this data. Scripted browser This monitor lets you define a key workflow in your webpages (for example, registering, searching, or purchasing a product) as a script that the monitor runs for you on the frequency you select. If any step in the script fails, New Relic notifies you, with full details about where the failure happened and what it was. API test Testing your API endpoints is just as important as testing your webpages—if one of them stops working as expected, the downstream effects on your systems can be bad news for you and your customers. Define a script that pulls back data from one of your endpoints, tests what it gets back, and alerts you when it encounters a problem. Here are a few things to remember about Synthetics: You can alert on every metric recorded by the monitors, from “is it up/down?” to “what came back from my API endpoint?” All of your performance data from Synthetics can be quickly viewed in terms of SLAs and KPIs. Just like with the other areas of your instrumentation, it helps your entire team to start defining your SLAs for your KPIs. The metrics from Synthetics help you prove out the value of having moved to cloud-hosted services. For any test that you want to run on a resource inside your firewall, there are private minions that you can quickly and securely stand up in your own environment. They are available in the list of locations for your monitors, just like the the rest of the default global locations. 3. Identify your relevant metrics It is vital to identify which metrics are the most important to your business and use these metrics to define your KPIs. Answer the following questions to begin identifying the relevant metrics: What are your KPIs? Are you setting SLAs for them? Here is a look at some examples of KPIs: KPIs for business performance Here are some examples of KPIs that companies in many industries consider to be key to business performance: General DOM readiness Page render Apdex Mobile crash rate Web Session count Session duration Page views DOM readiness Page render Error % Apdex Mobile App launches User counts Load time Response time Crash rates Crash locations Error rates (HTTP, network) API errors Session duration Video Video play count Video play duration Video bit rate Video buffering time Video success rate Errors (video, advertisement) Trends Active users Product views Session duration Sales/Retail Cart value Abandon rate Funnels Click-throughs Revenue (made, loss) KPIs that are specific to your company You might start with KPIs from the business performance list and then build them out to be more specific to your own company’s performance: Geography Business unit Product Product name Device type Store/location Mobile platform Carrier Website name Page name Browser type Error type Application name Cloud provider Success/fail reason KPIs for application and infrastructure teams Here are some KPI ideas for your application and infrastructure teams for the server side: Application/Infrastructure Apdex Availability Throughput App/API/DB response times Error % Memory footprint CPU workload Disk workload Network throughput DevOps Builds Commits Deploys Errors Support incidents MTTR With New Relic products in place across your ecosystem, you can collect a large number of these metrics right out of the box. Once you have all of the data flowing, dashboards is the place where you start creating dashboards from before and after your migration to show your teams the value of moving to the cloud. 4. Create dashboards showing KPIs from before and after your migration So, what might a starter dashboard look like for this part of your migration project? Consider this example: one.newrelic.com > Dashboards: Create customizable dashboards to monitor performance and business data. The rows represent the “before” and “after” perspectives. The widgets in these rows get you answers to the key questions behind your KPIs: What is my site's availability? Which global locations are experiencing the slowest performance? How can I use Apdex scoring to measure customer satisfaction levels with my application's performance? How many are satisfied? How many are OK (tolerating)? How many are frustrated with my site? With just a few setup steps, you can get your monitors running, and then head over to New Relic dashboards and design your widgets. Check out the Introduction to New Relic One dashboards which shows you many examples of these kinds of queries, using data from your own account. You can quickly get a feel for how to start building queries, widgets, and dashboards. After you identify your SLAs and KPIs, browser and mobile monitoring let you quickly start collecting data from your webpages and mobile apps, and Synthetics lets you schedule the monitors you need so that you can find out about problems before your customers start telling you about them. Bringing it all together in dashboards, you can start building the before/after perspective you need to prove the value of moving to the cloud and gain information that will help you optimize your customer’s experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.03564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": ". If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your <em>cloud</em> metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with <em>New</em> <em>Relic</em> products. Deploy mobile monitoring, if your company has"
      },
      "id": "60445c0064441f4b53378f00"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/perform-migration-acceptance-testing": [
    {
      "sections": [
        "Validate cloud improvements",
        "1. Identify KPIs",
        "2. Deploy monitoring tools",
        "Install New Relic APM",
        "Install New Relic Infrastructure",
        "Tip",
        "Install New Relic Infrastructure integrations",
        "3. Gather custom data",
        "4. Create baselines",
        "5. Validate improvements with Dashboards"
      ],
      "title": "Validate cloud improvements",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "e8083557674f0bd9a67aadade85517b9f5a517df",
      "image": "https://docs.newrelic.com/static/bd6f185deecee0d1735e167f1831d877/c1b63/KPIs-validate-improvement_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/validate-cloud-improvements/",
      "published_at": "2021-07-09T12:54:07Z",
      "updated_at": "2021-07-09T12:54:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you migrate your applications to the cloud and integrate cloud services, use New Relic to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the New Relic platform to measure KPIs helps you eliminate blind spots and see the connections between entities—from your application code to your cloud infrastructure (including containers running in highly distributed microservices), to your customer experience. Your goal is to create a collection of metrics in several categories that you can visualize in dashboards in New Relic Dashboards. To validate cloud improvements, group KPIs in the following categories, from least to most strong: Application and infrastructure performance End-user experience, including website and mobile application performance Audience and content trends DevOps productivity Application revenue analytics Future business goals 2. Deploy monitoring tools To start monitoring your KPIs, verify that the applications that you want to migrate are compatible with the requirements for the New Relic products you want to use. Then, install the New Relic agents: Install New Relic APM Review the compatibility and requirements and then install APM agents on your application stack. After installing the APM agents, review the architecture of the applications you instrumented with an APM agent. Take note of all hosts that are part of each tier of the application stack (database, application, web server, etc.), so you can install New Relic Infrastructure agents on each of those hosts. Install New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, install the Infrastructure agent on the hosts that you identified so you can start to gather data for your KPIs. Tip If you use Ansible, Chef, or Puppet for automation, you can use those tools to deploy Infrastructure agents to your hosts. Install New Relic Infrastructure integrations You can also monitor and report data about services that your code depends on using New Relic integrations. New Relic offers cloud integrations for Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform as well as on-host integrations. Tip If you are using AWS as a cloud provider, take advantage of New Relic’s AWS billing integrations to stay on top of your budget and prove the success of your migration. 3. Gather custom data To manage, search for, and filter resources, assign metadata to your cloud resources in the form of tags. Tags are labels that consist of key-value pairs that you use to annotate your Infrastructure data. Tag formats are different between AWS, Azure, and Google. Google, for example, has the shortest allowable lengths for keys and values. In addition, they all have different requirements for case sensitivity and allowable characters. To make sure that your tags are usable across most cloud providers: Use only lowercase letters, numbers, underscores, and dashes. Keep keys and values under 63 characters. New Relic reports data contained in specific events to your account as part of its “out-of-the-box” functionality. You can add additional data to those events by using custom attributes. If you determine that you need to collect custom data, review custom data requirements, and report custom event data. For more detailed information about sending custom data, check out these New Relic University tutorials: APM custom data overview Adding custom events using the API 4. Create baselines In order to validate the value of moving to the cloud, you need to get baselines for your applications before you move to the cloud. Define pre-migration baselines for applications and their underlying infrastructures that you have designated for cloud service improvements based on your KPIs. To stay on top of your KPIs as you are moving, create baseline alerts for applications monitored by APM and browser and use NRQL alerts to get notified on any spikes or drops in your KPIs. The following dashboard tracks key performance indicators for applications designated to move to the cloud: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs. After you migrate applications to the cloud, apply the same criteria to post-migration baselines so you can compare your results from before and after your migration. 5. Validate improvements with Dashboards Dashboards is a single location to view all the data that New Relic products gather. Use New Relic Dashboards to visualize your KPIs before and after your move: Transaction and TransactionError event types with APM PageView and PageAction event types with browser Default Infrastructure events and attributes for your systems, processes, events, storage, and network, Infrastructure integrations, and custom attributes Mobile event types with Mobile SyntheticCheck, SyntheticRequest, and SyntheticPrivateMinion event types with Synthetics The following dashboard shows KPI data used to validate cloud improvements: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs pre- and post-migration. Use dashboards to validate the value of adopting a new cloud service and to answer key questions about application performance and customer experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.68915,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Validate <em>cloud</em> improvements",
        "sections": "Install <em>New</em> <em>Relic</em> APM",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "After you migrate your applications to the <em>cloud</em> and integrate <em>cloud</em> services, use <em>New</em> <em>Relic</em> to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key"
      },
      "id": "60445c48e7b9d2052c5799d4"
    },
    {
      "sections": [
        "Refactor your applications",
        "1. Deploy monitoring",
        "Cloud-based integrations",
        "2. Set deployment markers",
        "3. Establish baselines",
        "4. Refactor your applications",
        "5. Create dashboards to track refactoring your applications",
        "6. Create comparison dashboards"
      ],
      "title": "Refactor your applications",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "fcea859e043f6ff33898803636b9a7a6de04508a",
      "image": "https://docs.newrelic.com/static/fc360bb9af89fe16ea8351e90b16ec09/c1b63/screen-deployments-page.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/refactor-your-applications/",
      "published_at": "2021-07-09T11:32:22Z",
      "updated_at": "2021-07-09T11:32:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At each step of your cloud adoption process, New Relic plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage cloud costs. New Relic can also help you refactor, or re-architect, your software and services when you migrate them to the cloud. One key aspect of refactoring your software is splitting out your components into different services available from your cloud provider. For example, you might move your database component away from a traditional MySQL database to a cloud-hosted solution, like Amazon Relational Database (RDS) services such as DynamoDB or Aurora. If you move to the Azure cloud, you might adopt Azure SQL or Cosmos DB. When you move to solutions like those, you increase your database redundancy and resiliency. If you evaluate your overall ROI properly, you should start to see the cost/benefit ratio taking effect once you complete your refactoring. 1. Deploy monitoring New Relic is a true multi-tenant SaaS solution, meaning New Relic designed the agents to work at every layer of your application stack. To get started, deploy the agents: APM to collect application-tier performance metrics Browser monitoring to collect front-end web metrics Mobile monitoring to collect front-end mobile app metrics Infrastructure to collect host/server metrics Cloud-based integrations As you refactor your application and integrate new cloud services, you can also use New Relic to monitor and report data about your cloud services, offering you a comprehensive view of your entire architecture in one place. Cloud-based integrations available through New Relic include Amazon Web Services (AWS) and Microsoft Azure. This tutorial describes a database migration and focuses on APM and Infrastructure. 2. Set deployment markers With New Relic, you can track deployments by setting deployment markers. Deployment tracking lets you quickly see how deployments affect your application’s performance and gauge its performance before and after you refactor. You can view deployments on the Deployments page in APM: rpm.newrelic.com/apm > (selected app) > Events > Deployments: Here is an example of the Deployments page and details about a selected deployment. 3. Establish baselines When you install the APM agent at the application layer, New Relic immediately starts collecting and displaying metrics. Use these metrics to set your pre-migration application baseline. APM agents collect performance metrics about outbound calls to databases. In the Monitoring section of the APM UI, click Databases to see a view of your database metrics. The following shows a database running on MySQL that will be refactored to use DynamoDB after migrating to AWS: one.newrelic.com > APM > (select an app) > Monitoring > Databases: Use this page to view and sort detailed information about database performance. 4. Refactor your applications To take advantage of the cloud, research what services are available from your cloud provider, and then re-architect and uncouple your applications. 5. Create dashboards to track refactoring your applications Apply your KPIs to your baseline measurements to validate cloud improvements, and, ideally, start seeing the impact of moving to the cloud. New Relic’s reporting for database interactions goes much deeper than high-level performance metrics about calls to the database layer in APM. You get access to metrics about slow queries so you can filter by database vendor and cache type. You can also see host and instance details for databases visually within Service Maps and within the context of transaction traces. Because all of your performance metrics are available in New Relic Insights, it is easy to build dashboards to show the performance of your database calls before, during, and after your refactoring in a single unified view. Here is an example of an Insights dashboard for an application that uses DynamoDB and was migrated to AWS: insights.newrelic.com: Build a dashboard that shows the performance of your database calls. 6. Create comparison dashboards To compare both the pre- and post-refactor baselines, create an Insights dashboard that displays the KPIs you baselined. The following dashboard shows the MySQL request query latency as compared with all of the operations for DynamoDB. You can see that, for this example, the request query latency for DynamoDB is too small to even register on the graph. Performance is clearly optimized with this cloud-based database. insights.newrelic.com: Use Insights dashboards to visualize pre- and post-refactor baselines. With APM agents and the integrations New Relic provides, you can measure the effectiveness of refactoring your applications using a broad spectrum of metrics.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.59076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Cloud</em>-based integrations",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "At each step of your <em>cloud</em> <em>adoption</em> process, <em>New</em> <em>Relic</em> plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage <em>cloud</em> costs. <em>New</em> <em>Relic</em> can also help you refactor, or re-architect, your software and services when you migrate them"
      },
      "id": "60445da6e7b9d2bf265799ee"
    },
    {
      "sections": [
        "Optimize customer experience",
        "1. Identify applications scoped for improvement",
        "2. Deploy monitoring: Browser, mobile, and synthetics",
        "Deploy browser to monitor your front-end data",
        "Deploy mobile monitoring, if your company has a mobile app",
        "Tip",
        "Synthetics—it’s already there!",
        "3. Identify your relevant metrics",
        "KPIs for business performance",
        "KPIs that are specific to your company",
        "KPIs for application and infrastructure teams",
        "4. Create dashboards showing KPIs from before and after your migration"
      ],
      "title": "Optimize customer experience",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "2d4df116b6dedf8a3d0911b0ad0e7bbd11b991d9",
      "image": "https://docs.newrelic.com/static/b84aceb32c77eb0a35e93a26ea700075/c1b63/optimize_exp.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-customer-experience/",
      "published_at": "2021-07-09T10:50:42Z",
      "updated_at": "2021-07-09T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You have been running in the cloud for awhile now, or you just completed your migration from on-premise to the cloud. You have gone through your planning stages, identified your dependencies, tested your assumptions, and everything is looking great. But there are still some big questions: How are your customers experiencing your service? Did the performance of your front-end applications improve, or did performance stay the same? Or did it worsen in ways you did not expect? New Relic provides a suite of front-end monitoring—browser, mobile, and synthetic—to help you monitor and improve your front-end applications. With dashboards, you can bring together information from each one of these product to give you an overall view of what your customer is experiencing. Follow the steps in this doc to optimize your customer experience after you migrate to the cloud. 1. Identify applications scoped for improvement When you identify applications that you want to improve, start with applications where you have some clearly defined KPIs (Key Performance Indicators) that are relevant to the overall performance of your business. Selecting an application that tells a complete story of your performance, regarding key performance indicators, builds trust that you are doing the right level of monitoring and gathering the right metrics. When measuring front-end application performance, most companies think about these common KPIs: Availability percentage Average duration Page load time Throughput Apdex Response time Use those common KPIs as a guideline when identifying applications. Take each one of the metrics and consider it from the perspective of your company's CEO and business team. What is the actual impact on your company's business if your application becomes unavailable? How many users will your site lose if your page loads start to take over four seconds? How many dollars are lost if your applications are not able to handle throughput spikes and some users get no response during those spikes? These are serious questions to answer, and, if you are only measuring metrics on the server/application side, you are very likely not seeing what your customers are seeing on the frontend of the application. That is why browser, mobile, and synthetics are key to understanding the complete picture of your application performance. With dashboards, you bring all of these metrics together and give your company a single place to see every metric that is crucial to your success. 2. Deploy monitoring: Browser, mobile, and synthetics To start monitoring, you need to deploy browser, mobile, and synthetics agents. With browser, you gain deep insight into how your users are interacting with your application or website. Mobile monitoring allows you to monitor and manage the performance of your iOS and Android applications. Synthetics is a suite of automated, scriptable tools to monitor your websites and API endpoints. Just like with all of New Relic's agents, browser, mobile, and synthetics are quick to deploy. Here is a quick overview of each and links to documentation to help you get going: Deploy browser to monitor your front-end data In a nutshell, browser monitoring is a snippet of JavaScript that needs to appear in all of your application's webpages. It has no dependencies on other libraries, so it does not cause additional delays when bringing jQuery or other frameworks into the webpage. There are three ways to install the browser agent: Method When to use this method Enable via APM Typically, the quickest path is to let the APM agent dynamically inject the snippet into your pages on the server side. This works for many common web technologies, such as .NET, JSP, and other Java solutions. The documentation provides a complete reference for the languages and frameworks that allow this option. Copy/paste method If you are using an unsupported framework or are in an environment where you can instrument only the webpages but cannot install APM on the back-end, use the copy/paste method. New Relic presents a snippet directly in the UI, and you copy it and paste it into a global page template on your end. Just pick one that is used by all of your webpages and put it there, and then the snippet appears on all pages. Enable via the API You can perform a manual instrumentation, in which your developers can add instrumentation to your webpages using a server-side API. New Relic supports this for many server-side languages. Refer to the documentation for an example of how to do this in Java. Whichever method you choose, you quickly have front-end performance data from your web pages. Just like with APM and other New Relic products, the overview tells you the “big picture” story of your performance data—in this case, your front-end data: one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the browser apps index, the Summary page shows a summary of browser performance for that app. Set alert conditions on metrics like Page view load time and Throughput, as well as JS Errors and Ajax response time. This is not just about seeing a slowdown and fixing it—this is about real users having a frustrating experience and potentially walking away from your application, costing your company potential profits. If you do not already have SLAs defined for these kinds of metrics, now is the time to define them. If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your cloud metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with New Relic products. Deploy mobile monitoring, if your company has a mobile app If your company has a mobile application, install Mobile monitoring. Tip Monitoring performance metrics about your webpages as they work in mobile browsers is handled by the browser agent. If you do not have a native mobile application, you can skip this section. The mobile monitoring agents support most common devices running on iOS and Android. The install process for iOS and Android requires you to include the mobile SDK in your applications. The SDK is as low impact as possible in terms of resource consumption (CPU and memory) while simultaneously providing you a broad and deep spectrum of performance data about your mobile applications. Slow performance on your mobile apps can be just as impactful to your business as slow performance in webpages. Think of top-level metrics like crash occurrences, HTTP errors/network failures, and HTTP response times in terms of your business KPIs. What happens to your business objectives when your mobile app starts spiking in terms of crash rate? Do users get frustrated and give up when the app takes forever to pull down data from your back-end systems or from third-party resources? The mobile monitoring overview page pulls together a set of metrics that you should be setting SLAs and alert conditions on: one.newrelic.com > Mobile > (select an app) > Summary: Quickly view crash occurrences, app launches, and more with mobile monitoring. Once you get to know these top level metrics, you can quickly start using your mobile metrics to find root causes, so you can add new alert conditions on lower-level metrics and discover any regression problems down the road. You can also monitor the back-end systems and cloud services that support your mobile apps. Improving the back-end systems and cloud services has a direct result in their improvement. Check out Monitor your cloud services to gain more insight. Synthetics—it’s already there! With Synthetics, there is nothing to install—the agents are already installed at many global locations and are just waiting for you to start using them. Synthetics lets you quickly define monitors, which run on a schedule you pick and make automated calls from those global locations back into your systems. There are four different types of monitors, and they have the following functions: Type of monitor What this monitor can do for you Ping Point a ping monitor at one of your webpages, and New Relic tells you if that page is responding as expected. Think of Ping as a simple “up/down” test but with a few extra features that you will quickly get to know. Simple browser The job of a simple browser is to simulate all of the work that a real browser would do to build out one of your webpages. Where are the slow points? How can you quickly see a waterfall view of the page buildout? Simple browser quickly gets you all this data. Scripted browser This monitor lets you define a key workflow in your webpages (for example, registering, searching, or purchasing a product) as a script that the monitor runs for you on the frequency you select. If any step in the script fails, New Relic notifies you, with full details about where the failure happened and what it was. API test Testing your API endpoints is just as important as testing your webpages—if one of them stops working as expected, the downstream effects on your systems can be bad news for you and your customers. Define a script that pulls back data from one of your endpoints, tests what it gets back, and alerts you when it encounters a problem. Here are a few things to remember about Synthetics: You can alert on every metric recorded by the monitors, from “is it up/down?” to “what came back from my API endpoint?” All of your performance data from Synthetics can be quickly viewed in terms of SLAs and KPIs. Just like with the other areas of your instrumentation, it helps your entire team to start defining your SLAs for your KPIs. The metrics from Synthetics help you prove out the value of having moved to cloud-hosted services. For any test that you want to run on a resource inside your firewall, there are private minions that you can quickly and securely stand up in your own environment. They are available in the list of locations for your monitors, just like the the rest of the default global locations. 3. Identify your relevant metrics It is vital to identify which metrics are the most important to your business and use these metrics to define your KPIs. Answer the following questions to begin identifying the relevant metrics: What are your KPIs? Are you setting SLAs for them? Here is a look at some examples of KPIs: KPIs for business performance Here are some examples of KPIs that companies in many industries consider to be key to business performance: General DOM readiness Page render Apdex Mobile crash rate Web Session count Session duration Page views DOM readiness Page render Error % Apdex Mobile App launches User counts Load time Response time Crash rates Crash locations Error rates (HTTP, network) API errors Session duration Video Video play count Video play duration Video bit rate Video buffering time Video success rate Errors (video, advertisement) Trends Active users Product views Session duration Sales/Retail Cart value Abandon rate Funnels Click-throughs Revenue (made, loss) KPIs that are specific to your company You might start with KPIs from the business performance list and then build them out to be more specific to your own company’s performance: Geography Business unit Product Product name Device type Store/location Mobile platform Carrier Website name Page name Browser type Error type Application name Cloud provider Success/fail reason KPIs for application and infrastructure teams Here are some KPI ideas for your application and infrastructure teams for the server side: Application/Infrastructure Apdex Availability Throughput App/API/DB response times Error % Memory footprint CPU workload Disk workload Network throughput DevOps Builds Commits Deploys Errors Support incidents MTTR With New Relic products in place across your ecosystem, you can collect a large number of these metrics right out of the box. Once you have all of the data flowing, dashboards is the place where you start creating dashboards from before and after your migration to show your teams the value of moving to the cloud. 4. Create dashboards showing KPIs from before and after your migration So, what might a starter dashboard look like for this part of your migration project? Consider this example: one.newrelic.com > Dashboards: Create customizable dashboards to monitor performance and business data. The rows represent the “before” and “after” perspectives. The widgets in these rows get you answers to the key questions behind your KPIs: What is my site's availability? Which global locations are experiencing the slowest performance? How can I use Apdex scoring to measure customer satisfaction levels with my application's performance? How many are satisfied? How many are OK (tolerating)? How many are frustrated with my site? With just a few setup steps, you can get your monitors running, and then head over to New Relic dashboards and design your widgets. Check out the Introduction to New Relic One dashboards which shows you many examples of these kinds of queries, using data from your own account. You can quickly get a feel for how to start building queries, widgets, and dashboards. After you identify your SLAs and KPIs, browser and mobile monitoring let you quickly start collecting data from your webpages and mobile apps, and Synthetics lets you schedule the monitors you need so that you can find out about problems before your customers start telling you about them. Bringing it all together in dashboards, you can start building the before/after perspective you need to prove the value of moving to the cloud and gain information that will help you optimize your customer’s experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.03564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": ". If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your <em>cloud</em> metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with <em>New</em> <em>Relic</em> products. Deploy mobile monitoring, if your company has"
      },
      "id": "60445c0064441f4b53378f00"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/prioritize-migration-order": [
    {
      "sections": [
        "Validate cloud improvements",
        "1. Identify KPIs",
        "2. Deploy monitoring tools",
        "Install New Relic APM",
        "Install New Relic Infrastructure",
        "Tip",
        "Install New Relic Infrastructure integrations",
        "3. Gather custom data",
        "4. Create baselines",
        "5. Validate improvements with Dashboards"
      ],
      "title": "Validate cloud improvements",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "e8083557674f0bd9a67aadade85517b9f5a517df",
      "image": "https://docs.newrelic.com/static/bd6f185deecee0d1735e167f1831d877/c1b63/KPIs-validate-improvement_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/validate-cloud-improvements/",
      "published_at": "2021-07-09T12:54:07Z",
      "updated_at": "2021-07-09T12:54:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you migrate your applications to the cloud and integrate cloud services, use New Relic to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the New Relic platform to measure KPIs helps you eliminate blind spots and see the connections between entities—from your application code to your cloud infrastructure (including containers running in highly distributed microservices), to your customer experience. Your goal is to create a collection of metrics in several categories that you can visualize in dashboards in New Relic Dashboards. To validate cloud improvements, group KPIs in the following categories, from least to most strong: Application and infrastructure performance End-user experience, including website and mobile application performance Audience and content trends DevOps productivity Application revenue analytics Future business goals 2. Deploy monitoring tools To start monitoring your KPIs, verify that the applications that you want to migrate are compatible with the requirements for the New Relic products you want to use. Then, install the New Relic agents: Install New Relic APM Review the compatibility and requirements and then install APM agents on your application stack. After installing the APM agents, review the architecture of the applications you instrumented with an APM agent. Take note of all hosts that are part of each tier of the application stack (database, application, web server, etc.), so you can install New Relic Infrastructure agents on each of those hosts. Install New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, install the Infrastructure agent on the hosts that you identified so you can start to gather data for your KPIs. Tip If you use Ansible, Chef, or Puppet for automation, you can use those tools to deploy Infrastructure agents to your hosts. Install New Relic Infrastructure integrations You can also monitor and report data about services that your code depends on using New Relic integrations. New Relic offers cloud integrations for Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform as well as on-host integrations. Tip If you are using AWS as a cloud provider, take advantage of New Relic’s AWS billing integrations to stay on top of your budget and prove the success of your migration. 3. Gather custom data To manage, search for, and filter resources, assign metadata to your cloud resources in the form of tags. Tags are labels that consist of key-value pairs that you use to annotate your Infrastructure data. Tag formats are different between AWS, Azure, and Google. Google, for example, has the shortest allowable lengths for keys and values. In addition, they all have different requirements for case sensitivity and allowable characters. To make sure that your tags are usable across most cloud providers: Use only lowercase letters, numbers, underscores, and dashes. Keep keys and values under 63 characters. New Relic reports data contained in specific events to your account as part of its “out-of-the-box” functionality. You can add additional data to those events by using custom attributes. If you determine that you need to collect custom data, review custom data requirements, and report custom event data. For more detailed information about sending custom data, check out these New Relic University tutorials: APM custom data overview Adding custom events using the API 4. Create baselines In order to validate the value of moving to the cloud, you need to get baselines for your applications before you move to the cloud. Define pre-migration baselines for applications and their underlying infrastructures that you have designated for cloud service improvements based on your KPIs. To stay on top of your KPIs as you are moving, create baseline alerts for applications monitored by APM and browser and use NRQL alerts to get notified on any spikes or drops in your KPIs. The following dashboard tracks key performance indicators for applications designated to move to the cloud: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs. After you migrate applications to the cloud, apply the same criteria to post-migration baselines so you can compare your results from before and after your migration. 5. Validate improvements with Dashboards Dashboards is a single location to view all the data that New Relic products gather. Use New Relic Dashboards to visualize your KPIs before and after your move: Transaction and TransactionError event types with APM PageView and PageAction event types with browser Default Infrastructure events and attributes for your systems, processes, events, storage, and network, Infrastructure integrations, and custom attributes Mobile event types with Mobile SyntheticCheck, SyntheticRequest, and SyntheticPrivateMinion event types with Synthetics The following dashboard shows KPI data used to validate cloud improvements: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs pre- and post-migration. Use dashboards to validate the value of adopting a new cloud service and to answer key questions about application performance and customer experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.6889,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Validate <em>cloud</em> improvements",
        "sections": "Install <em>New</em> <em>Relic</em> APM",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "After you migrate your applications to the <em>cloud</em> and integrate <em>cloud</em> services, use <em>New</em> <em>Relic</em> to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key"
      },
      "id": "60445c48e7b9d2052c5799d4"
    },
    {
      "sections": [
        "Refactor your applications",
        "1. Deploy monitoring",
        "Cloud-based integrations",
        "2. Set deployment markers",
        "3. Establish baselines",
        "4. Refactor your applications",
        "5. Create dashboards to track refactoring your applications",
        "6. Create comparison dashboards"
      ],
      "title": "Refactor your applications",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "fcea859e043f6ff33898803636b9a7a6de04508a",
      "image": "https://docs.newrelic.com/static/fc360bb9af89fe16ea8351e90b16ec09/c1b63/screen-deployments-page.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/refactor-your-applications/",
      "published_at": "2021-07-09T11:32:22Z",
      "updated_at": "2021-07-09T11:32:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At each step of your cloud adoption process, New Relic plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage cloud costs. New Relic can also help you refactor, or re-architect, your software and services when you migrate them to the cloud. One key aspect of refactoring your software is splitting out your components into different services available from your cloud provider. For example, you might move your database component away from a traditional MySQL database to a cloud-hosted solution, like Amazon Relational Database (RDS) services such as DynamoDB or Aurora. If you move to the Azure cloud, you might adopt Azure SQL or Cosmos DB. When you move to solutions like those, you increase your database redundancy and resiliency. If you evaluate your overall ROI properly, you should start to see the cost/benefit ratio taking effect once you complete your refactoring. 1. Deploy monitoring New Relic is a true multi-tenant SaaS solution, meaning New Relic designed the agents to work at every layer of your application stack. To get started, deploy the agents: APM to collect application-tier performance metrics Browser monitoring to collect front-end web metrics Mobile monitoring to collect front-end mobile app metrics Infrastructure to collect host/server metrics Cloud-based integrations As you refactor your application and integrate new cloud services, you can also use New Relic to monitor and report data about your cloud services, offering you a comprehensive view of your entire architecture in one place. Cloud-based integrations available through New Relic include Amazon Web Services (AWS) and Microsoft Azure. This tutorial describes a database migration and focuses on APM and Infrastructure. 2. Set deployment markers With New Relic, you can track deployments by setting deployment markers. Deployment tracking lets you quickly see how deployments affect your application’s performance and gauge its performance before and after you refactor. You can view deployments on the Deployments page in APM: rpm.newrelic.com/apm > (selected app) > Events > Deployments: Here is an example of the Deployments page and details about a selected deployment. 3. Establish baselines When you install the APM agent at the application layer, New Relic immediately starts collecting and displaying metrics. Use these metrics to set your pre-migration application baseline. APM agents collect performance metrics about outbound calls to databases. In the Monitoring section of the APM UI, click Databases to see a view of your database metrics. The following shows a database running on MySQL that will be refactored to use DynamoDB after migrating to AWS: one.newrelic.com > APM > (select an app) > Monitoring > Databases: Use this page to view and sort detailed information about database performance. 4. Refactor your applications To take advantage of the cloud, research what services are available from your cloud provider, and then re-architect and uncouple your applications. 5. Create dashboards to track refactoring your applications Apply your KPIs to your baseline measurements to validate cloud improvements, and, ideally, start seeing the impact of moving to the cloud. New Relic’s reporting for database interactions goes much deeper than high-level performance metrics about calls to the database layer in APM. You get access to metrics about slow queries so you can filter by database vendor and cache type. You can also see host and instance details for databases visually within Service Maps and within the context of transaction traces. Because all of your performance metrics are available in New Relic Insights, it is easy to build dashboards to show the performance of your database calls before, during, and after your refactoring in a single unified view. Here is an example of an Insights dashboard for an application that uses DynamoDB and was migrated to AWS: insights.newrelic.com: Build a dashboard that shows the performance of your database calls. 6. Create comparison dashboards To compare both the pre- and post-refactor baselines, create an Insights dashboard that displays the KPIs you baselined. The following dashboard shows the MySQL request query latency as compared with all of the operations for DynamoDB. You can see that, for this example, the request query latency for DynamoDB is too small to even register on the graph. Performance is clearly optimized with this cloud-based database. insights.newrelic.com: Use Insights dashboards to visualize pre- and post-refactor baselines. With APM agents and the integrations New Relic provides, you can measure the effectiveness of refactoring your applications using a broad spectrum of metrics.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.5905,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Cloud</em>-based integrations",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "At each step of your <em>cloud</em> <em>adoption</em> process, <em>New</em> <em>Relic</em> plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage <em>cloud</em> costs. <em>New</em> <em>Relic</em> can also help you refactor, or re-architect, your software and services when you migrate them"
      },
      "id": "60445da6e7b9d2bf265799ee"
    },
    {
      "sections": [
        "Optimize customer experience",
        "1. Identify applications scoped for improvement",
        "2. Deploy monitoring: Browser, mobile, and synthetics",
        "Deploy browser to monitor your front-end data",
        "Deploy mobile monitoring, if your company has a mobile app",
        "Tip",
        "Synthetics—it’s already there!",
        "3. Identify your relevant metrics",
        "KPIs for business performance",
        "KPIs that are specific to your company",
        "KPIs for application and infrastructure teams",
        "4. Create dashboards showing KPIs from before and after your migration"
      ],
      "title": "Optimize customer experience",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "2d4df116b6dedf8a3d0911b0ad0e7bbd11b991d9",
      "image": "https://docs.newrelic.com/static/b84aceb32c77eb0a35e93a26ea700075/c1b63/optimize_exp.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-customer-experience/",
      "published_at": "2021-07-09T10:50:42Z",
      "updated_at": "2021-07-09T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You have been running in the cloud for awhile now, or you just completed your migration from on-premise to the cloud. You have gone through your planning stages, identified your dependencies, tested your assumptions, and everything is looking great. But there are still some big questions: How are your customers experiencing your service? Did the performance of your front-end applications improve, or did performance stay the same? Or did it worsen in ways you did not expect? New Relic provides a suite of front-end monitoring—browser, mobile, and synthetic—to help you monitor and improve your front-end applications. With dashboards, you can bring together information from each one of these product to give you an overall view of what your customer is experiencing. Follow the steps in this doc to optimize your customer experience after you migrate to the cloud. 1. Identify applications scoped for improvement When you identify applications that you want to improve, start with applications where you have some clearly defined KPIs (Key Performance Indicators) that are relevant to the overall performance of your business. Selecting an application that tells a complete story of your performance, regarding key performance indicators, builds trust that you are doing the right level of monitoring and gathering the right metrics. When measuring front-end application performance, most companies think about these common KPIs: Availability percentage Average duration Page load time Throughput Apdex Response time Use those common KPIs as a guideline when identifying applications. Take each one of the metrics and consider it from the perspective of your company's CEO and business team. What is the actual impact on your company's business if your application becomes unavailable? How many users will your site lose if your page loads start to take over four seconds? How many dollars are lost if your applications are not able to handle throughput spikes and some users get no response during those spikes? These are serious questions to answer, and, if you are only measuring metrics on the server/application side, you are very likely not seeing what your customers are seeing on the frontend of the application. That is why browser, mobile, and synthetics are key to understanding the complete picture of your application performance. With dashboards, you bring all of these metrics together and give your company a single place to see every metric that is crucial to your success. 2. Deploy monitoring: Browser, mobile, and synthetics To start monitoring, you need to deploy browser, mobile, and synthetics agents. With browser, you gain deep insight into how your users are interacting with your application or website. Mobile monitoring allows you to monitor and manage the performance of your iOS and Android applications. Synthetics is a suite of automated, scriptable tools to monitor your websites and API endpoints. Just like with all of New Relic's agents, browser, mobile, and synthetics are quick to deploy. Here is a quick overview of each and links to documentation to help you get going: Deploy browser to monitor your front-end data In a nutshell, browser monitoring is a snippet of JavaScript that needs to appear in all of your application's webpages. It has no dependencies on other libraries, so it does not cause additional delays when bringing jQuery or other frameworks into the webpage. There are three ways to install the browser agent: Method When to use this method Enable via APM Typically, the quickest path is to let the APM agent dynamically inject the snippet into your pages on the server side. This works for many common web technologies, such as .NET, JSP, and other Java solutions. The documentation provides a complete reference for the languages and frameworks that allow this option. Copy/paste method If you are using an unsupported framework or are in an environment where you can instrument only the webpages but cannot install APM on the back-end, use the copy/paste method. New Relic presents a snippet directly in the UI, and you copy it and paste it into a global page template on your end. Just pick one that is used by all of your webpages and put it there, and then the snippet appears on all pages. Enable via the API You can perform a manual instrumentation, in which your developers can add instrumentation to your webpages using a server-side API. New Relic supports this for many server-side languages. Refer to the documentation for an example of how to do this in Java. Whichever method you choose, you quickly have front-end performance data from your web pages. Just like with APM and other New Relic products, the overview tells you the “big picture” story of your performance data—in this case, your front-end data: one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the browser apps index, the Summary page shows a summary of browser performance for that app. Set alert conditions on metrics like Page view load time and Throughput, as well as JS Errors and Ajax response time. This is not just about seeing a slowdown and fixing it—this is about real users having a frustrating experience and potentially walking away from your application, costing your company potential profits. If you do not already have SLAs defined for these kinds of metrics, now is the time to define them. If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your cloud metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with New Relic products. Deploy mobile monitoring, if your company has a mobile app If your company has a mobile application, install Mobile monitoring. Tip Monitoring performance metrics about your webpages as they work in mobile browsers is handled by the browser agent. If you do not have a native mobile application, you can skip this section. The mobile monitoring agents support most common devices running on iOS and Android. The install process for iOS and Android requires you to include the mobile SDK in your applications. The SDK is as low impact as possible in terms of resource consumption (CPU and memory) while simultaneously providing you a broad and deep spectrum of performance data about your mobile applications. Slow performance on your mobile apps can be just as impactful to your business as slow performance in webpages. Think of top-level metrics like crash occurrences, HTTP errors/network failures, and HTTP response times in terms of your business KPIs. What happens to your business objectives when your mobile app starts spiking in terms of crash rate? Do users get frustrated and give up when the app takes forever to pull down data from your back-end systems or from third-party resources? The mobile monitoring overview page pulls together a set of metrics that you should be setting SLAs and alert conditions on: one.newrelic.com > Mobile > (select an app) > Summary: Quickly view crash occurrences, app launches, and more with mobile monitoring. Once you get to know these top level metrics, you can quickly start using your mobile metrics to find root causes, so you can add new alert conditions on lower-level metrics and discover any regression problems down the road. You can also monitor the back-end systems and cloud services that support your mobile apps. Improving the back-end systems and cloud services has a direct result in their improvement. Check out Monitor your cloud services to gain more insight. Synthetics—it’s already there! With Synthetics, there is nothing to install—the agents are already installed at many global locations and are just waiting for you to start using them. Synthetics lets you quickly define monitors, which run on a schedule you pick and make automated calls from those global locations back into your systems. There are four different types of monitors, and they have the following functions: Type of monitor What this monitor can do for you Ping Point a ping monitor at one of your webpages, and New Relic tells you if that page is responding as expected. Think of Ping as a simple “up/down” test but with a few extra features that you will quickly get to know. Simple browser The job of a simple browser is to simulate all of the work that a real browser would do to build out one of your webpages. Where are the slow points? How can you quickly see a waterfall view of the page buildout? Simple browser quickly gets you all this data. Scripted browser This monitor lets you define a key workflow in your webpages (for example, registering, searching, or purchasing a product) as a script that the monitor runs for you on the frequency you select. If any step in the script fails, New Relic notifies you, with full details about where the failure happened and what it was. API test Testing your API endpoints is just as important as testing your webpages—if one of them stops working as expected, the downstream effects on your systems can be bad news for you and your customers. Define a script that pulls back data from one of your endpoints, tests what it gets back, and alerts you when it encounters a problem. Here are a few things to remember about Synthetics: You can alert on every metric recorded by the monitors, from “is it up/down?” to “what came back from my API endpoint?” All of your performance data from Synthetics can be quickly viewed in terms of SLAs and KPIs. Just like with the other areas of your instrumentation, it helps your entire team to start defining your SLAs for your KPIs. The metrics from Synthetics help you prove out the value of having moved to cloud-hosted services. For any test that you want to run on a resource inside your firewall, there are private minions that you can quickly and securely stand up in your own environment. They are available in the list of locations for your monitors, just like the the rest of the default global locations. 3. Identify your relevant metrics It is vital to identify which metrics are the most important to your business and use these metrics to define your KPIs. Answer the following questions to begin identifying the relevant metrics: What are your KPIs? Are you setting SLAs for them? Here is a look at some examples of KPIs: KPIs for business performance Here are some examples of KPIs that companies in many industries consider to be key to business performance: General DOM readiness Page render Apdex Mobile crash rate Web Session count Session duration Page views DOM readiness Page render Error % Apdex Mobile App launches User counts Load time Response time Crash rates Crash locations Error rates (HTTP, network) API errors Session duration Video Video play count Video play duration Video bit rate Video buffering time Video success rate Errors (video, advertisement) Trends Active users Product views Session duration Sales/Retail Cart value Abandon rate Funnels Click-throughs Revenue (made, loss) KPIs that are specific to your company You might start with KPIs from the business performance list and then build them out to be more specific to your own company’s performance: Geography Business unit Product Product name Device type Store/location Mobile platform Carrier Website name Page name Browser type Error type Application name Cloud provider Success/fail reason KPIs for application and infrastructure teams Here are some KPI ideas for your application and infrastructure teams for the server side: Application/Infrastructure Apdex Availability Throughput App/API/DB response times Error % Memory footprint CPU workload Disk workload Network throughput DevOps Builds Commits Deploys Errors Support incidents MTTR With New Relic products in place across your ecosystem, you can collect a large number of these metrics right out of the box. Once you have all of the data flowing, dashboards is the place where you start creating dashboards from before and after your migration to show your teams the value of moving to the cloud. 4. Create dashboards showing KPIs from before and after your migration So, what might a starter dashboard look like for this part of your migration project? Consider this example: one.newrelic.com > Dashboards: Create customizable dashboards to monitor performance and business data. The rows represent the “before” and “after” perspectives. The widgets in these rows get you answers to the key questions behind your KPIs: What is my site's availability? Which global locations are experiencing the slowest performance? How can I use Apdex scoring to measure customer satisfaction levels with my application's performance? How many are satisfied? How many are OK (tolerating)? How many are frustrated with my site? With just a few setup steps, you can get your monitors running, and then head over to New Relic dashboards and design your widgets. Check out the Introduction to New Relic One dashboards which shows you many examples of these kinds of queries, using data from your own account. You can quickly get a feel for how to start building queries, widgets, and dashboards. After you identify your SLAs and KPIs, browser and mobile monitoring let you quickly start collecting data from your webpages and mobile apps, and Synthetics lets you schedule the monitors you need so that you can find out about problems before your customers start telling you about them. Bringing it all together in dashboards, you can start building the before/after perspective you need to prove the value of moving to the cloud and gain information that will help you optimize your customer’s experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.03546,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": ". If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your <em>cloud</em> metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with <em>New</em> <em>Relic</em> products. Deploy mobile monitoring, if your company has"
      },
      "id": "60445c0064441f4b53378f00"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/refactor-your-applications": [
    {
      "sections": [
        "Validate cloud improvements",
        "1. Identify KPIs",
        "2. Deploy monitoring tools",
        "Install New Relic APM",
        "Install New Relic Infrastructure",
        "Tip",
        "Install New Relic Infrastructure integrations",
        "3. Gather custom data",
        "4. Create baselines",
        "5. Validate improvements with Dashboards"
      ],
      "title": "Validate cloud improvements",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "e8083557674f0bd9a67aadade85517b9f5a517df",
      "image": "https://docs.newrelic.com/static/bd6f185deecee0d1735e167f1831d877/c1b63/KPIs-validate-improvement_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/validate-cloud-improvements/",
      "published_at": "2021-07-09T12:54:07Z",
      "updated_at": "2021-07-09T12:54:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you migrate your applications to the cloud and integrate cloud services, use New Relic to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the New Relic platform to measure KPIs helps you eliminate blind spots and see the connections between entities—from your application code to your cloud infrastructure (including containers running in highly distributed microservices), to your customer experience. Your goal is to create a collection of metrics in several categories that you can visualize in dashboards in New Relic Dashboards. To validate cloud improvements, group KPIs in the following categories, from least to most strong: Application and infrastructure performance End-user experience, including website and mobile application performance Audience and content trends DevOps productivity Application revenue analytics Future business goals 2. Deploy monitoring tools To start monitoring your KPIs, verify that the applications that you want to migrate are compatible with the requirements for the New Relic products you want to use. Then, install the New Relic agents: Install New Relic APM Review the compatibility and requirements and then install APM agents on your application stack. After installing the APM agents, review the architecture of the applications you instrumented with an APM agent. Take note of all hosts that are part of each tier of the application stack (database, application, web server, etc.), so you can install New Relic Infrastructure agents on each of those hosts. Install New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, install the Infrastructure agent on the hosts that you identified so you can start to gather data for your KPIs. Tip If you use Ansible, Chef, or Puppet for automation, you can use those tools to deploy Infrastructure agents to your hosts. Install New Relic Infrastructure integrations You can also monitor and report data about services that your code depends on using New Relic integrations. New Relic offers cloud integrations for Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform as well as on-host integrations. Tip If you are using AWS as a cloud provider, take advantage of New Relic’s AWS billing integrations to stay on top of your budget and prove the success of your migration. 3. Gather custom data To manage, search for, and filter resources, assign metadata to your cloud resources in the form of tags. Tags are labels that consist of key-value pairs that you use to annotate your Infrastructure data. Tag formats are different between AWS, Azure, and Google. Google, for example, has the shortest allowable lengths for keys and values. In addition, they all have different requirements for case sensitivity and allowable characters. To make sure that your tags are usable across most cloud providers: Use only lowercase letters, numbers, underscores, and dashes. Keep keys and values under 63 characters. New Relic reports data contained in specific events to your account as part of its “out-of-the-box” functionality. You can add additional data to those events by using custom attributes. If you determine that you need to collect custom data, review custom data requirements, and report custom event data. For more detailed information about sending custom data, check out these New Relic University tutorials: APM custom data overview Adding custom events using the API 4. Create baselines In order to validate the value of moving to the cloud, you need to get baselines for your applications before you move to the cloud. Define pre-migration baselines for applications and their underlying infrastructures that you have designated for cloud service improvements based on your KPIs. To stay on top of your KPIs as you are moving, create baseline alerts for applications monitored by APM and browser and use NRQL alerts to get notified on any spikes or drops in your KPIs. The following dashboard tracks key performance indicators for applications designated to move to the cloud: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs. After you migrate applications to the cloud, apply the same criteria to post-migration baselines so you can compare your results from before and after your migration. 5. Validate improvements with Dashboards Dashboards is a single location to view all the data that New Relic products gather. Use New Relic Dashboards to visualize your KPIs before and after your move: Transaction and TransactionError event types with APM PageView and PageAction event types with browser Default Infrastructure events and attributes for your systems, processes, events, storage, and network, Infrastructure integrations, and custom attributes Mobile event types with Mobile SyntheticCheck, SyntheticRequest, and SyntheticPrivateMinion event types with Synthetics The following dashboard shows KPI data used to validate cloud improvements: one.newrelic.com > Dashboards > Create a dashboard: Create dashboards to track your KPIs pre- and post-migration. Use dashboards to validate the value of adopting a new cloud service and to answer key questions about application performance and customer experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 360.6889,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Validate <em>cloud</em> improvements",
        "sections": "Install <em>New</em> <em>Relic</em> APM",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "After you migrate your applications to the <em>cloud</em> and integrate <em>cloud</em> services, use <em>New</em> <em>Relic</em> to measure and validate improvements to your applications. 1. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key"
      },
      "id": "60445c48e7b9d2052c5799d4"
    },
    {
      "sections": [
        "Optimize customer experience",
        "1. Identify applications scoped for improvement",
        "2. Deploy monitoring: Browser, mobile, and synthetics",
        "Deploy browser to monitor your front-end data",
        "Deploy mobile monitoring, if your company has a mobile app",
        "Tip",
        "Synthetics—it’s already there!",
        "3. Identify your relevant metrics",
        "KPIs for business performance",
        "KPIs that are specific to your company",
        "KPIs for application and infrastructure teams",
        "4. Create dashboards showing KPIs from before and after your migration"
      ],
      "title": "Optimize customer experience",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "2d4df116b6dedf8a3d0911b0ad0e7bbd11b991d9",
      "image": "https://docs.newrelic.com/static/b84aceb32c77eb0a35e93a26ea700075/c1b63/optimize_exp.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-customer-experience/",
      "published_at": "2021-07-09T10:50:42Z",
      "updated_at": "2021-07-09T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You have been running in the cloud for awhile now, or you just completed your migration from on-premise to the cloud. You have gone through your planning stages, identified your dependencies, tested your assumptions, and everything is looking great. But there are still some big questions: How are your customers experiencing your service? Did the performance of your front-end applications improve, or did performance stay the same? Or did it worsen in ways you did not expect? New Relic provides a suite of front-end monitoring—browser, mobile, and synthetic—to help you monitor and improve your front-end applications. With dashboards, you can bring together information from each one of these product to give you an overall view of what your customer is experiencing. Follow the steps in this doc to optimize your customer experience after you migrate to the cloud. 1. Identify applications scoped for improvement When you identify applications that you want to improve, start with applications where you have some clearly defined KPIs (Key Performance Indicators) that are relevant to the overall performance of your business. Selecting an application that tells a complete story of your performance, regarding key performance indicators, builds trust that you are doing the right level of monitoring and gathering the right metrics. When measuring front-end application performance, most companies think about these common KPIs: Availability percentage Average duration Page load time Throughput Apdex Response time Use those common KPIs as a guideline when identifying applications. Take each one of the metrics and consider it from the perspective of your company's CEO and business team. What is the actual impact on your company's business if your application becomes unavailable? How many users will your site lose if your page loads start to take over four seconds? How many dollars are lost if your applications are not able to handle throughput spikes and some users get no response during those spikes? These are serious questions to answer, and, if you are only measuring metrics on the server/application side, you are very likely not seeing what your customers are seeing on the frontend of the application. That is why browser, mobile, and synthetics are key to understanding the complete picture of your application performance. With dashboards, you bring all of these metrics together and give your company a single place to see every metric that is crucial to your success. 2. Deploy monitoring: Browser, mobile, and synthetics To start monitoring, you need to deploy browser, mobile, and synthetics agents. With browser, you gain deep insight into how your users are interacting with your application or website. Mobile monitoring allows you to monitor and manage the performance of your iOS and Android applications. Synthetics is a suite of automated, scriptable tools to monitor your websites and API endpoints. Just like with all of New Relic's agents, browser, mobile, and synthetics are quick to deploy. Here is a quick overview of each and links to documentation to help you get going: Deploy browser to monitor your front-end data In a nutshell, browser monitoring is a snippet of JavaScript that needs to appear in all of your application's webpages. It has no dependencies on other libraries, so it does not cause additional delays when bringing jQuery or other frameworks into the webpage. There are three ways to install the browser agent: Method When to use this method Enable via APM Typically, the quickest path is to let the APM agent dynamically inject the snippet into your pages on the server side. This works for many common web technologies, such as .NET, JSP, and other Java solutions. The documentation provides a complete reference for the languages and frameworks that allow this option. Copy/paste method If you are using an unsupported framework or are in an environment where you can instrument only the webpages but cannot install APM on the back-end, use the copy/paste method. New Relic presents a snippet directly in the UI, and you copy it and paste it into a global page template on your end. Just pick one that is used by all of your webpages and put it there, and then the snippet appears on all pages. Enable via the API You can perform a manual instrumentation, in which your developers can add instrumentation to your webpages using a server-side API. New Relic supports this for many server-side languages. Refer to the documentation for an example of how to do this in Java. Whichever method you choose, you quickly have front-end performance data from your web pages. Just like with APM and other New Relic products, the overview tells you the “big picture” story of your performance data—in this case, your front-end data: one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the browser apps index, the Summary page shows a summary of browser performance for that app. Set alert conditions on metrics like Page view load time and Throughput, as well as JS Errors and Ajax response time. This is not just about seeing a slowdown and fixing it—this is about real users having a frustrating experience and potentially walking away from your application, costing your company potential profits. If you do not already have SLAs defined for these kinds of metrics, now is the time to define them. If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your cloud metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with New Relic products. Deploy mobile monitoring, if your company has a mobile app If your company has a mobile application, install Mobile monitoring. Tip Monitoring performance metrics about your webpages as they work in mobile browsers is handled by the browser agent. If you do not have a native mobile application, you can skip this section. The mobile monitoring agents support most common devices running on iOS and Android. The install process for iOS and Android requires you to include the mobile SDK in your applications. The SDK is as low impact as possible in terms of resource consumption (CPU and memory) while simultaneously providing you a broad and deep spectrum of performance data about your mobile applications. Slow performance on your mobile apps can be just as impactful to your business as slow performance in webpages. Think of top-level metrics like crash occurrences, HTTP errors/network failures, and HTTP response times in terms of your business KPIs. What happens to your business objectives when your mobile app starts spiking in terms of crash rate? Do users get frustrated and give up when the app takes forever to pull down data from your back-end systems or from third-party resources? The mobile monitoring overview page pulls together a set of metrics that you should be setting SLAs and alert conditions on: one.newrelic.com > Mobile > (select an app) > Summary: Quickly view crash occurrences, app launches, and more with mobile monitoring. Once you get to know these top level metrics, you can quickly start using your mobile metrics to find root causes, so you can add new alert conditions on lower-level metrics and discover any regression problems down the road. You can also monitor the back-end systems and cloud services that support your mobile apps. Improving the back-end systems and cloud services has a direct result in their improvement. Check out Monitor your cloud services to gain more insight. Synthetics—it’s already there! With Synthetics, there is nothing to install—the agents are already installed at many global locations and are just waiting for you to start using them. Synthetics lets you quickly define monitors, which run on a schedule you pick and make automated calls from those global locations back into your systems. There are four different types of monitors, and they have the following functions: Type of monitor What this monitor can do for you Ping Point a ping monitor at one of your webpages, and New Relic tells you if that page is responding as expected. Think of Ping as a simple “up/down” test but with a few extra features that you will quickly get to know. Simple browser The job of a simple browser is to simulate all of the work that a real browser would do to build out one of your webpages. Where are the slow points? How can you quickly see a waterfall view of the page buildout? Simple browser quickly gets you all this data. Scripted browser This monitor lets you define a key workflow in your webpages (for example, registering, searching, or purchasing a product) as a script that the monitor runs for you on the frequency you select. If any step in the script fails, New Relic notifies you, with full details about where the failure happened and what it was. API test Testing your API endpoints is just as important as testing your webpages—if one of them stops working as expected, the downstream effects on your systems can be bad news for you and your customers. Define a script that pulls back data from one of your endpoints, tests what it gets back, and alerts you when it encounters a problem. Here are a few things to remember about Synthetics: You can alert on every metric recorded by the monitors, from “is it up/down?” to “what came back from my API endpoint?” All of your performance data from Synthetics can be quickly viewed in terms of SLAs and KPIs. Just like with the other areas of your instrumentation, it helps your entire team to start defining your SLAs for your KPIs. The metrics from Synthetics help you prove out the value of having moved to cloud-hosted services. For any test that you want to run on a resource inside your firewall, there are private minions that you can quickly and securely stand up in your own environment. They are available in the list of locations for your monitors, just like the the rest of the default global locations. 3. Identify your relevant metrics It is vital to identify which metrics are the most important to your business and use these metrics to define your KPIs. Answer the following questions to begin identifying the relevant metrics: What are your KPIs? Are you setting SLAs for them? Here is a look at some examples of KPIs: KPIs for business performance Here are some examples of KPIs that companies in many industries consider to be key to business performance: General DOM readiness Page render Apdex Mobile crash rate Web Session count Session duration Page views DOM readiness Page render Error % Apdex Mobile App launches User counts Load time Response time Crash rates Crash locations Error rates (HTTP, network) API errors Session duration Video Video play count Video play duration Video bit rate Video buffering time Video success rate Errors (video, advertisement) Trends Active users Product views Session duration Sales/Retail Cart value Abandon rate Funnels Click-throughs Revenue (made, loss) KPIs that are specific to your company You might start with KPIs from the business performance list and then build them out to be more specific to your own company’s performance: Geography Business unit Product Product name Device type Store/location Mobile platform Carrier Website name Page name Browser type Error type Application name Cloud provider Success/fail reason KPIs for application and infrastructure teams Here are some KPI ideas for your application and infrastructure teams for the server side: Application/Infrastructure Apdex Availability Throughput App/API/DB response times Error % Memory footprint CPU workload Disk workload Network throughput DevOps Builds Commits Deploys Errors Support incidents MTTR With New Relic products in place across your ecosystem, you can collect a large number of these metrics right out of the box. Once you have all of the data flowing, dashboards is the place where you start creating dashboards from before and after your migration to show your teams the value of moving to the cloud. 4. Create dashboards showing KPIs from before and after your migration So, what might a starter dashboard look like for this part of your migration project? Consider this example: one.newrelic.com > Dashboards: Create customizable dashboards to monitor performance and business data. The rows represent the “before” and “after” perspectives. The widgets in these rows get you answers to the key questions behind your KPIs: What is my site's availability? Which global locations are experiencing the slowest performance? How can I use Apdex scoring to measure customer satisfaction levels with my application's performance? How many are satisfied? How many are OK (tolerating)? How many are frustrated with my site? With just a few setup steps, you can get your monitors running, and then head over to New Relic dashboards and design your widgets. Check out the Introduction to New Relic One dashboards which shows you many examples of these kinds of queries, using data from your own account. You can quickly get a feel for how to start building queries, widgets, and dashboards. After you identify your SLAs and KPIs, browser and mobile monitoring let you quickly start collecting data from your webpages and mobile apps, and Synthetics lets you schedule the monitors you need so that you can find out about problems before your customers start telling you about them. Bringing it all together in dashboards, you can start building the before/after perspective you need to prove the value of moving to the cloud and gain information that will help you optimize your customer’s experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.03546,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": ". If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your <em>cloud</em> metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with <em>New</em> <em>Relic</em> products. Deploy mobile monitoring, if your company has"
      },
      "id": "60445c0064441f4b53378f00"
    },
    {
      "sections": [
        "Identify issues and roadblocks",
        "1. Identify components",
        "2. Identify KPIs",
        "3. Deploy monitoring tools",
        "Deploy New Relic APM",
        "Deploy browser monitoring",
        "Deploy New Relic Infrastructure",
        "Tip",
        "Set up alerts",
        "4. Set up cloud integrations",
        "5. Identify issues and roadblocks",
        "Expert tip for alerting on JavaScript errors"
      ],
      "title": "Identify issues and roadblocks",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "12c79f8e91e131ddf9015d1617760261d71660d1",
      "image": "https://docs.newrelic.com/static/cc629d8a7fe9dd09ac59711b669baedc/c1b63/screen-javascript-errors.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/identify-issues-roadblocks/",
      "published_at": "2021-07-09T10:46:00Z",
      "updated_at": "2021-07-09T10:46:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As you migrate your applications to the cloud, you want to catch and correct any unexpected behavior or outcomes as soon as possible. Detecting errors and issues related to your new cloud architecture, performance, and scale is critical—getting the right information at the right time can be the difference between success and failure. 1. Identify components Create a list all of applications, services, and their underlying server infrastructures in your application portfolio that you want to migrate to the cloud. 2. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the New Relic platform to measure KPIs helps you eliminate blindspots and see the connections between entities—from your application code, to your cloud infrastructure (including containers running in highly distributed microservices), to your customer experience. Your goal is to create a collection of metrics in several categories that you can visualize in our Dashboards. To validate cloud improvements, group KPIs in the following categories, from least to most strong: Application and infrastructure performance End-user experience, including website and mobile application performance Audience and content trends DevOps productivity Application revenue analytics Future business goals 3. Deploy monitoring tools To start monitoring your KPIs, verify that the applications that you want to migrate are compatible with the requirements for the New Relic products you will use. Then, install the New Relic agents: Deploy New Relic APM Review the compatibility and requirements and then install APM agents on your application stack. After installing the APM agents, review the architecture of the applications that you instrumented with an APM agent. Take note of all hosts that are part of each tier of the application stack (database, application, web server, etc.), so you can install New Relic Infrastructure monitoring agents on each of those hosts. Deploy browser monitoring In a nutshell, browser monitoring is a snippet of JavaScript that needs to appear in all of your application's webpages. It has no dependencies on other libraries, so it does not cause additional delays when bringing jQuery or other frameworks into the webpage. There are three ways to install the browser agent: Method When to use this method Enable via New Relic APM Typically, the quickest path is to let the APM agent dynamically inject the snippet into your pages on the server side. This works for many common web technologies, such as .NET, JSP, and other Java solutions. The documentation provides a complete reference for the languages and frameworks that allow this option. Copy/paste method If you are using an unsupported framework or are in an environment where you can instrument only the webpages but cannot install APM on the backend, use the copy-paste method. The UI generates a simple JavaScript snippet. Copy that snippet, and paste it into a global page template on your end to get browser monitoring deployed across your site. Enable via the API You can perform a manual instrumentation, in which your developers add instrumentation to your webpages using a server-side API. New Relic supports this for many server-side languages. Refer to the documentation for an example of how to do this in Java. Deploy New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, install the Infrastructure agent on the hosts that you identified so you can start to gather data for your KPIs. Tip If you use Ansible, Chef, or Puppet for automation, you can use those tools to deploy Infrastructure agents to your hosts. Set up alerts New Relic Alerts is a single integrated solution with a centralized UI to help you focus on the metrics that you care about most. When you set up New Relic Alerts and NRQL alerting, you establish flexible policies and conditions to receive alerts and notifications on multiple channels (email, Slack, OpsGenie, etc.). For more detailed information about creating, managing, and using alerts, check out the New Relic University tutorials. 4. Set up cloud integrations Tip Cloud-based integrations available through New Relic include Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. Once your applications are migrated to the cloud and you start to integrate new cloud services, you can use New Relic to monitor and report data about your cloud services, offering you a comprehensive view of your entire architecture in one place. For example, to capture and record AWS account activity for audit and governance purposes, use the New Relic AWS CloudTrail integration. Tracking error events gives you awareness about API calls and services that have failed, while console logins help you monitor console activity and potential intrusion attempts. New Relic collects this event data so you can display it in a Dashboard or alert on it with NRQL. To gain extended visibility into applications that your code depends on, you can also deploy on-host integrations for commonly used application components, such as MySQL, Apache, and NGINX. In addition, you can create your own custom on-host integration with the New Relic Integrations SDK. 5. Identify issues and roadblocks Once your applications are running in the cloud, they may generate new types of errors that are different from the errors that they generated when running on-premise. You can use New Relic APM and browser monitoring to view error events, error metrics, and detailed error traces for your applications. If an error or unhandled exception happens, the data appears on the JavaScript errors page and the APM Error analytics page. From these pages, you can quickly troubleshoot runtime errors. Then, further analyze errors by grouping them according to attributes, by filtering them, or by searching for keywords in the event data. Each unhandled exception generates a transaction error event in Insights, and the dashboards are updated in real-time. Event data is a record of a single event at a particular moment in time and consists of default attributes, like a timestamp, and an event type. You can also add custom attributes to provide more context. Tip Once you start capturing JavaScript errors as events in Insights, set up NRQL alerting so you can stay on top of your error data. Use the JavaScript errors page to get visibility into real-time user experience: one.newrelic.com > Browser > (select an app) > JS errors: Use the charts on this page to get visibility into the real-time user experience. Then, create a Dashboard that covers a longer period of time and aligns the error and unhandled exception data with your KPIs: one.newrelic.com > Dashboards > Create a dashboard: Use dashboards to align the error and unhandled exception data with your KPIs. Expert tip for alerting on JavaScript errors To get notifications for error spikes that are different from known or common JavaScript errors, use the following NRQL query for browser-monitored: SELECT count(*) FROM JavaScriptError WHERE appName = '<BrowserAppName>' AND errorClass NOT IN ('<ErrorClass1>','<ErrorClass2>') Copy Replace <BrowserAppName> with the browser app name that you want to monitor with this alert. Replace <ErrorClass1> and <ErrorClass2> with the on-premise error class names that you do not want New Relic to alert you about. Set the threshold based on your alerting needs. Using this query, New Relic alerts you every time a JavaScript error occurs when it has an error class that is not normally reported.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 358.97302,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Deploy <em>New</em> <em>Relic</em> APM",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": " to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the <em>New</em> <em>Relic</em> platform to measure KPIs helps you eliminate blindspots and see the connections between entities—from your application code, to your <em>cloud</em> infrastructure (including containers running in highly"
      },
      "id": "60445b87196a67bb33960f21"
    }
  ],
  "/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/validate-cloud-improvements": [
    {
      "sections": [
        "Refactor your applications",
        "1. Deploy monitoring",
        "Cloud-based integrations",
        "2. Set deployment markers",
        "3. Establish baselines",
        "4. Refactor your applications",
        "5. Create dashboards to track refactoring your applications",
        "6. Create comparison dashboards"
      ],
      "title": "Refactor your applications",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "fcea859e043f6ff33898803636b9a7a6de04508a",
      "image": "https://docs.newrelic.com/static/fc360bb9af89fe16ea8351e90b16ec09/c1b63/screen-deployments-page.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/refactor-your-applications/",
      "published_at": "2021-07-09T11:32:22Z",
      "updated_at": "2021-07-09T11:32:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At each step of your cloud adoption process, New Relic plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage cloud costs. New Relic can also help you refactor, or re-architect, your software and services when you migrate them to the cloud. One key aspect of refactoring your software is splitting out your components into different services available from your cloud provider. For example, you might move your database component away from a traditional MySQL database to a cloud-hosted solution, like Amazon Relational Database (RDS) services such as DynamoDB or Aurora. If you move to the Azure cloud, you might adopt Azure SQL or Cosmos DB. When you move to solutions like those, you increase your database redundancy and resiliency. If you evaluate your overall ROI properly, you should start to see the cost/benefit ratio taking effect once you complete your refactoring. 1. Deploy monitoring New Relic is a true multi-tenant SaaS solution, meaning New Relic designed the agents to work at every layer of your application stack. To get started, deploy the agents: APM to collect application-tier performance metrics Browser monitoring to collect front-end web metrics Mobile monitoring to collect front-end mobile app metrics Infrastructure to collect host/server metrics Cloud-based integrations As you refactor your application and integrate new cloud services, you can also use New Relic to monitor and report data about your cloud services, offering you a comprehensive view of your entire architecture in one place. Cloud-based integrations available through New Relic include Amazon Web Services (AWS) and Microsoft Azure. This tutorial describes a database migration and focuses on APM and Infrastructure. 2. Set deployment markers With New Relic, you can track deployments by setting deployment markers. Deployment tracking lets you quickly see how deployments affect your application’s performance and gauge its performance before and after you refactor. You can view deployments on the Deployments page in APM: rpm.newrelic.com/apm > (selected app) > Events > Deployments: Here is an example of the Deployments page and details about a selected deployment. 3. Establish baselines When you install the APM agent at the application layer, New Relic immediately starts collecting and displaying metrics. Use these metrics to set your pre-migration application baseline. APM agents collect performance metrics about outbound calls to databases. In the Monitoring section of the APM UI, click Databases to see a view of your database metrics. The following shows a database running on MySQL that will be refactored to use DynamoDB after migrating to AWS: one.newrelic.com > APM > (select an app) > Monitoring > Databases: Use this page to view and sort detailed information about database performance. 4. Refactor your applications To take advantage of the cloud, research what services are available from your cloud provider, and then re-architect and uncouple your applications. 5. Create dashboards to track refactoring your applications Apply your KPIs to your baseline measurements to validate cloud improvements, and, ideally, start seeing the impact of moving to the cloud. New Relic’s reporting for database interactions goes much deeper than high-level performance metrics about calls to the database layer in APM. You get access to metrics about slow queries so you can filter by database vendor and cache type. You can also see host and instance details for databases visually within Service Maps and within the context of transaction traces. Because all of your performance metrics are available in New Relic Insights, it is easy to build dashboards to show the performance of your database calls before, during, and after your refactoring in a single unified view. Here is an example of an Insights dashboard for an application that uses DynamoDB and was migrated to AWS: insights.newrelic.com: Build a dashboard that shows the performance of your database calls. 6. Create comparison dashboards To compare both the pre- and post-refactor baselines, create an Insights dashboard that displays the KPIs you baselined. The following dashboard shows the MySQL request query latency as compared with all of the operations for DynamoDB. You can see that, for this example, the request query latency for DynamoDB is too small to even register on the graph. Performance is clearly optimized with this cloud-based database. insights.newrelic.com: Use Insights dashboards to visualize pre- and post-refactor baselines. With APM agents and the integrations New Relic provides, you can measure the effectiveness of refactoring your applications using a broad spectrum of metrics.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.5903,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Cloud</em>-based integrations",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": "At each step of your <em>cloud</em> <em>adoption</em> process, <em>New</em> <em>Relic</em> plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage <em>cloud</em> costs. <em>New</em> <em>Relic</em> can also help you refactor, or re-architect, your software and services when you migrate them"
      },
      "id": "60445da6e7b9d2bf265799ee"
    },
    {
      "sections": [
        "Optimize customer experience",
        "1. Identify applications scoped for improvement",
        "2. Deploy monitoring: Browser, mobile, and synthetics",
        "Deploy browser to monitor your front-end data",
        "Deploy mobile monitoring, if your company has a mobile app",
        "Tip",
        "Synthetics—it’s already there!",
        "3. Identify your relevant metrics",
        "KPIs for business performance",
        "KPIs that are specific to your company",
        "KPIs for application and infrastructure teams",
        "4. Create dashboards showing KPIs from before and after your migration"
      ],
      "title": "Optimize customer experience",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "2d4df116b6dedf8a3d0911b0ad0e7bbd11b991d9",
      "image": "https://docs.newrelic.com/static/b84aceb32c77eb0a35e93a26ea700075/c1b63/optimize_exp.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-customer-experience/",
      "published_at": "2021-07-09T10:50:42Z",
      "updated_at": "2021-07-09T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You have been running in the cloud for awhile now, or you just completed your migration from on-premise to the cloud. You have gone through your planning stages, identified your dependencies, tested your assumptions, and everything is looking great. But there are still some big questions: How are your customers experiencing your service? Did the performance of your front-end applications improve, or did performance stay the same? Or did it worsen in ways you did not expect? New Relic provides a suite of front-end monitoring—browser, mobile, and synthetic—to help you monitor and improve your front-end applications. With dashboards, you can bring together information from each one of these product to give you an overall view of what your customer is experiencing. Follow the steps in this doc to optimize your customer experience after you migrate to the cloud. 1. Identify applications scoped for improvement When you identify applications that you want to improve, start with applications where you have some clearly defined KPIs (Key Performance Indicators) that are relevant to the overall performance of your business. Selecting an application that tells a complete story of your performance, regarding key performance indicators, builds trust that you are doing the right level of monitoring and gathering the right metrics. When measuring front-end application performance, most companies think about these common KPIs: Availability percentage Average duration Page load time Throughput Apdex Response time Use those common KPIs as a guideline when identifying applications. Take each one of the metrics and consider it from the perspective of your company's CEO and business team. What is the actual impact on your company's business if your application becomes unavailable? How many users will your site lose if your page loads start to take over four seconds? How many dollars are lost if your applications are not able to handle throughput spikes and some users get no response during those spikes? These are serious questions to answer, and, if you are only measuring metrics on the server/application side, you are very likely not seeing what your customers are seeing on the frontend of the application. That is why browser, mobile, and synthetics are key to understanding the complete picture of your application performance. With dashboards, you bring all of these metrics together and give your company a single place to see every metric that is crucial to your success. 2. Deploy monitoring: Browser, mobile, and synthetics To start monitoring, you need to deploy browser, mobile, and synthetics agents. With browser, you gain deep insight into how your users are interacting with your application or website. Mobile monitoring allows you to monitor and manage the performance of your iOS and Android applications. Synthetics is a suite of automated, scriptable tools to monitor your websites and API endpoints. Just like with all of New Relic's agents, browser, mobile, and synthetics are quick to deploy. Here is a quick overview of each and links to documentation to help you get going: Deploy browser to monitor your front-end data In a nutshell, browser monitoring is a snippet of JavaScript that needs to appear in all of your application's webpages. It has no dependencies on other libraries, so it does not cause additional delays when bringing jQuery or other frameworks into the webpage. There are three ways to install the browser agent: Method When to use this method Enable via APM Typically, the quickest path is to let the APM agent dynamically inject the snippet into your pages on the server side. This works for many common web technologies, such as .NET, JSP, and other Java solutions. The documentation provides a complete reference for the languages and frameworks that allow this option. Copy/paste method If you are using an unsupported framework or are in an environment where you can instrument only the webpages but cannot install APM on the back-end, use the copy/paste method. New Relic presents a snippet directly in the UI, and you copy it and paste it into a global page template on your end. Just pick one that is used by all of your webpages and put it there, and then the snippet appears on all pages. Enable via the API You can perform a manual instrumentation, in which your developers can add instrumentation to your webpages using a server-side API. New Relic supports this for many server-side languages. Refer to the documentation for an example of how to do this in Java. Whichever method you choose, you quickly have front-end performance data from your web pages. Just like with APM and other New Relic products, the overview tells you the “big picture” story of your performance data—in this case, your front-end data: one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the browser apps index, the Summary page shows a summary of browser performance for that app. Set alert conditions on metrics like Page view load time and Throughput, as well as JS Errors and Ajax response time. This is not just about seeing a slowdown and fixing it—this is about real users having a frustrating experience and potentially walking away from your application, costing your company potential profits. If you do not already have SLAs defined for these kinds of metrics, now is the time to define them. If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your cloud metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with New Relic products. Deploy mobile monitoring, if your company has a mobile app If your company has a mobile application, install Mobile monitoring. Tip Monitoring performance metrics about your webpages as they work in mobile browsers is handled by the browser agent. If you do not have a native mobile application, you can skip this section. The mobile monitoring agents support most common devices running on iOS and Android. The install process for iOS and Android requires you to include the mobile SDK in your applications. The SDK is as low impact as possible in terms of resource consumption (CPU and memory) while simultaneously providing you a broad and deep spectrum of performance data about your mobile applications. Slow performance on your mobile apps can be just as impactful to your business as slow performance in webpages. Think of top-level metrics like crash occurrences, HTTP errors/network failures, and HTTP response times in terms of your business KPIs. What happens to your business objectives when your mobile app starts spiking in terms of crash rate? Do users get frustrated and give up when the app takes forever to pull down data from your back-end systems or from third-party resources? The mobile monitoring overview page pulls together a set of metrics that you should be setting SLAs and alert conditions on: one.newrelic.com > Mobile > (select an app) > Summary: Quickly view crash occurrences, app launches, and more with mobile monitoring. Once you get to know these top level metrics, you can quickly start using your mobile metrics to find root causes, so you can add new alert conditions on lower-level metrics and discover any regression problems down the road. You can also monitor the back-end systems and cloud services that support your mobile apps. Improving the back-end systems and cloud services has a direct result in their improvement. Check out Monitor your cloud services to gain more insight. Synthetics—it’s already there! With Synthetics, there is nothing to install—the agents are already installed at many global locations and are just waiting for you to start using them. Synthetics lets you quickly define monitors, which run on a schedule you pick and make automated calls from those global locations back into your systems. There are four different types of monitors, and they have the following functions: Type of monitor What this monitor can do for you Ping Point a ping monitor at one of your webpages, and New Relic tells you if that page is responding as expected. Think of Ping as a simple “up/down” test but with a few extra features that you will quickly get to know. Simple browser The job of a simple browser is to simulate all of the work that a real browser would do to build out one of your webpages. Where are the slow points? How can you quickly see a waterfall view of the page buildout? Simple browser quickly gets you all this data. Scripted browser This monitor lets you define a key workflow in your webpages (for example, registering, searching, or purchasing a product) as a script that the monitor runs for you on the frequency you select. If any step in the script fails, New Relic notifies you, with full details about where the failure happened and what it was. API test Testing your API endpoints is just as important as testing your webpages—if one of them stops working as expected, the downstream effects on your systems can be bad news for you and your customers. Define a script that pulls back data from one of your endpoints, tests what it gets back, and alerts you when it encounters a problem. Here are a few things to remember about Synthetics: You can alert on every metric recorded by the monitors, from “is it up/down?” to “what came back from my API endpoint?” All of your performance data from Synthetics can be quickly viewed in terms of SLAs and KPIs. Just like with the other areas of your instrumentation, it helps your entire team to start defining your SLAs for your KPIs. The metrics from Synthetics help you prove out the value of having moved to cloud-hosted services. For any test that you want to run on a resource inside your firewall, there are private minions that you can quickly and securely stand up in your own environment. They are available in the list of locations for your monitors, just like the the rest of the default global locations. 3. Identify your relevant metrics It is vital to identify which metrics are the most important to your business and use these metrics to define your KPIs. Answer the following questions to begin identifying the relevant metrics: What are your KPIs? Are you setting SLAs for them? Here is a look at some examples of KPIs: KPIs for business performance Here are some examples of KPIs that companies in many industries consider to be key to business performance: General DOM readiness Page render Apdex Mobile crash rate Web Session count Session duration Page views DOM readiness Page render Error % Apdex Mobile App launches User counts Load time Response time Crash rates Crash locations Error rates (HTTP, network) API errors Session duration Video Video play count Video play duration Video bit rate Video buffering time Video success rate Errors (video, advertisement) Trends Active users Product views Session duration Sales/Retail Cart value Abandon rate Funnels Click-throughs Revenue (made, loss) KPIs that are specific to your company You might start with KPIs from the business performance list and then build them out to be more specific to your own company’s performance: Geography Business unit Product Product name Device type Store/location Mobile platform Carrier Website name Page name Browser type Error type Application name Cloud provider Success/fail reason KPIs for application and infrastructure teams Here are some KPI ideas for your application and infrastructure teams for the server side: Application/Infrastructure Apdex Availability Throughput App/API/DB response times Error % Memory footprint CPU workload Disk workload Network throughput DevOps Builds Commits Deploys Errors Support incidents MTTR With New Relic products in place across your ecosystem, you can collect a large number of these metrics right out of the box. Once you have all of the data flowing, dashboards is the place where you start creating dashboards from before and after your migration to show your teams the value of moving to the cloud. 4. Create dashboards showing KPIs from before and after your migration So, what might a starter dashboard look like for this part of your migration project? Consider this example: one.newrelic.com > Dashboards: Create customizable dashboards to monitor performance and business data. The rows represent the “before” and “after” perspectives. The widgets in these rows get you answers to the key questions behind your KPIs: What is my site's availability? Which global locations are experiencing the slowest performance? How can I use Apdex scoring to measure customer satisfaction levels with my application's performance? How many are satisfied? How many are OK (tolerating)? How many are frustrated with my site? With just a few setup steps, you can get your monitors running, and then head over to New Relic dashboards and design your widgets. Check out the Introduction to New Relic One dashboards which shows you many examples of these kinds of queries, using data from your own account. You can quickly get a feel for how to start building queries, widgets, and dashboards. After you identify your SLAs and KPIs, browser and mobile monitoring let you quickly start collecting data from your webpages and mobile apps, and Synthetics lets you schedule the monitors you need so that you can find out about problems before your customers start telling you about them. Bringing it all together in dashboards, you can start building the before/after perspective you need to prove the value of moving to the cloud and gain information that will help you optimize your customer’s experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.03522,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": ". If you do have SLAs, but they were based on your on-premise performance metrics, now is the time to capture your <em>cloud</em> metric baselines. Check out the Application Baseline tutorial for more information on establishing baselines with <em>New</em> <em>Relic</em> products. Deploy mobile monitoring, if your company has"
      },
      "id": "60445c0064441f4b53378f00"
    },
    {
      "sections": [
        "Identify issues and roadblocks",
        "1. Identify components",
        "2. Identify KPIs",
        "3. Deploy monitoring tools",
        "Deploy New Relic APM",
        "Deploy browser monitoring",
        "Deploy New Relic Infrastructure",
        "Tip",
        "Set up alerts",
        "4. Set up cloud integrations",
        "5. Identify issues and roadblocks",
        "Expert tip for alerting on JavaScript errors"
      ],
      "title": "Identify issues and roadblocks",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "12c79f8e91e131ddf9015d1617760261d71660d1",
      "image": "https://docs.newrelic.com/static/cc629d8a7fe9dd09ac59711b669baedc/c1b63/screen-javascript-errors.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/identify-issues-roadblocks/",
      "published_at": "2021-07-09T10:46:00Z",
      "updated_at": "2021-07-09T10:46:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As you migrate your applications to the cloud, you want to catch and correct any unexpected behavior or outcomes as soon as possible. Detecting errors and issues related to your new cloud architecture, performance, and scale is critical—getting the right information at the right time can be the difference between success and failure. 1. Identify components Create a list all of applications, services, and their underlying server infrastructures in your application portfolio that you want to migrate to the cloud. 2. Identify KPIs To provide quantifiable measures that your teams can use to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the New Relic platform to measure KPIs helps you eliminate blindspots and see the connections between entities—from your application code, to your cloud infrastructure (including containers running in highly distributed microservices), to your customer experience. Your goal is to create a collection of metrics in several categories that you can visualize in our Dashboards. To validate cloud improvements, group KPIs in the following categories, from least to most strong: Application and infrastructure performance End-user experience, including website and mobile application performance Audience and content trends DevOps productivity Application revenue analytics Future business goals 3. Deploy monitoring tools To start monitoring your KPIs, verify that the applications that you want to migrate are compatible with the requirements for the New Relic products you will use. Then, install the New Relic agents: Deploy New Relic APM Review the compatibility and requirements and then install APM agents on your application stack. After installing the APM agents, review the architecture of the applications that you instrumented with an APM agent. Take note of all hosts that are part of each tier of the application stack (database, application, web server, etc.), so you can install New Relic Infrastructure monitoring agents on each of those hosts. Deploy browser monitoring In a nutshell, browser monitoring is a snippet of JavaScript that needs to appear in all of your application's webpages. It has no dependencies on other libraries, so it does not cause additional delays when bringing jQuery or other frameworks into the webpage. There are three ways to install the browser agent: Method When to use this method Enable via New Relic APM Typically, the quickest path is to let the APM agent dynamically inject the snippet into your pages on the server side. This works for many common web technologies, such as .NET, JSP, and other Java solutions. The documentation provides a complete reference for the languages and frameworks that allow this option. Copy/paste method If you are using an unsupported framework or are in an environment where you can instrument only the webpages but cannot install APM on the backend, use the copy-paste method. The UI generates a simple JavaScript snippet. Copy that snippet, and paste it into a global page template on your end to get browser monitoring deployed across your site. Enable via the API You can perform a manual instrumentation, in which your developers add instrumentation to your webpages using a server-side API. New Relic supports this for many server-side languages. Refer to the documentation for an example of how to do this in Java. Deploy New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, install the Infrastructure agent on the hosts that you identified so you can start to gather data for your KPIs. Tip If you use Ansible, Chef, or Puppet for automation, you can use those tools to deploy Infrastructure agents to your hosts. Set up alerts New Relic Alerts is a single integrated solution with a centralized UI to help you focus on the metrics that you care about most. When you set up New Relic Alerts and NRQL alerting, you establish flexible policies and conditions to receive alerts and notifications on multiple channels (email, Slack, OpsGenie, etc.). For more detailed information about creating, managing, and using alerts, check out the New Relic University tutorials. 4. Set up cloud integrations Tip Cloud-based integrations available through New Relic include Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. Once your applications are migrated to the cloud and you start to integrate new cloud services, you can use New Relic to monitor and report data about your cloud services, offering you a comprehensive view of your entire architecture in one place. For example, to capture and record AWS account activity for audit and governance purposes, use the New Relic AWS CloudTrail integration. Tracking error events gives you awareness about API calls and services that have failed, while console logins help you monitor console activity and potential intrusion attempts. New Relic collects this event data so you can display it in a Dashboard or alert on it with NRQL. To gain extended visibility into applications that your code depends on, you can also deploy on-host integrations for commonly used application components, such as MySQL, Apache, and NGINX. In addition, you can create your own custom on-host integration with the New Relic Integrations SDK. 5. Identify issues and roadblocks Once your applications are running in the cloud, they may generate new types of errors that are different from the errors that they generated when running on-premise. You can use New Relic APM and browser monitoring to view error events, error metrics, and detailed error traces for your applications. If an error or unhandled exception happens, the data appears on the JavaScript errors page and the APM Error analytics page. From these pages, you can quickly troubleshoot runtime errors. Then, further analyze errors by grouping them according to attributes, by filtering them, or by searching for keywords in the event data. Each unhandled exception generates a transaction error event in Insights, and the dashboards are updated in real-time. Event data is a record of a single event at a particular moment in time and consists of default attributes, like a timestamp, and an event type. You can also add custom attributes to provide more context. Tip Once you start capturing JavaScript errors as events in Insights, set up NRQL alerting so you can stay on top of your error data. Use the JavaScript errors page to get visibility into real-time user experience: one.newrelic.com > Browser > (select an app) > JS errors: Use the charts on this page to get visibility into the real-time user experience. Then, create a Dashboard that covers a longer period of time and aligns the error and unhandled exception data with your KPIs: one.newrelic.com > Dashboards > Create a dashboard: Use dashboards to align the error and unhandled exception data with your KPIs. Expert tip for alerting on JavaScript errors To get notifications for error spikes that are different from known or common JavaScript errors, use the following NRQL query for browser-monitored: SELECT count(*) FROM JavaScriptError WHERE appName = '<BrowserAppName>' AND errorClass NOT IN ('<ErrorClass1>','<ErrorClass2>') Copy Replace <BrowserAppName> with the browser app name that you want to monitor with this alert. Replace <ErrorClass1> and <ErrorClass2> with the on-premise error class names that you do not want New Relic to alert you about. Set the threshold based on your alerting needs. Using this query, New Relic alerts you every time a JavaScript error occurs when it has an error class that is not normally reported.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 358.9728,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Deploy <em>New</em> <em>Relic</em> APM",
        "tags": "<em>New</em> <em>Relic</em> <em>solutions</em>",
        "body": " to assess your migration, identify a list of corporate KPIs (key performance indicators). Using the <em>New</em> <em>Relic</em> platform to measure KPIs helps you eliminate blindspots and see the connections between entities—from your application code, to your <em>cloud</em> infrastructure (including containers running in highly"
      },
      "id": "60445b87196a67bb33960f21"
    }
  ],
  "/docs/plugins/plugins-new-relic/custom-dashboards-custom-views/custom-dashboards-v2-legacy": [
    {
      "sections": [
        "Custom views (deprecated)",
        "Important",
        "Custom views in Liquid",
        "Account drops",
        "Methods",
        "Application drops",
        "Application metric drops",
        "Examples",
        "Value methods",
        "Filters",
        "Arithmetic filters",
        "Tags",
        "Chart tags",
        "Referencing metrics",
        "Blocks"
      ],
      "title": "Custom views (deprecated)",
      "type": "docs",
      "tags": [
        "Plugins",
        "Plugins New Relic",
        "Custom dashboards and custom views"
      ],
      "external_id": "f463c45abafd9dfd5c6ff8f62d834d6125cc4ba1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/plugins/plugins-new-relic/custom-dashboards-custom-views/custom-views-deprecated/",
      "published_at": "2021-07-09T23:44:17Z",
      "updated_at": "2021-03-13T02:57:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In 2012, custom dashboards (v1) replaced the deprecated custom views feature. Then, in February 2014, custom dashboards (v2) replaced our original custom dashboards feature (v1). Custom dashboards (v2) are part of a legacy feature and are being retained only for use with our legacy plugins tool. In addition, plugins in Plugin Central are not supported with accounts that host data in the EU region data center. Important For an even better experience than plugins, custom dashboards, and custom views, go to: newrelic.com/integrations: Integrate the on-host and cloud systems you already use with New Relic, so you can filter and analyze data, create dashboards, and set alerts within a single platform. developer.newrelic.com: Use developer tools to collect data from any source, automate workflows, build apps, and use our APIs. Custom views in Liquid New Relic custom views allow users to visualize custom metric data in charts and HTML tables. Custom Views are written using a custom version of Liquid, a templating language created for Shopify. Custom view code looks like normal HTML interspersed with small blocks of code. The Liquid Wiki has additional information about how to write templates. Every Liquid custom view has access to four context variables, account, application, metrics, and applications. The account variable is an Account drop for the current account, and the application variable points to the current application selection. The metrics variable allows access to metrics for the current application and the applications variable can be used to access the applications belonging to the current account. Drops are secure wrappers around New Relic objects and methods accessible from Liquid templates. Drops expose a limited number of method calls available on each object in a Liquid template, as specified below. Account drops Methods id: The integer id of the account name: The name of the account applications: A collection proxy for the account applications. Applications can be looked up using this syntax: app = account.applications['The app name'] Copy The return value of the lookup is an Application drop. Application drops An application drop represents an application. Methods id: The integer id of the application name: The name of the application health_status: Returns a 1, 2 or 3 which indicates the overall health of the application. The traffic_light filter can be used to render a traffic light from the health_status integer value. metrics: An ApplicationMetrics drop which can be used to look up metrics. Application metric drops An application metrics drop is a collection proxy that can be used to find metrics. {{ application.metrics['metric name'] }} Copy You can also access the metrics for the current account selection with just the metrics variable. {{ metrics['metric name'] }} Copy You can use the application metrics drop to look up a specific metric like in the above sample. You can also use it to retrieve multiple metrics using a regular expression match: {% assign metrics = application.metrics.find_by_regexp['account'] %} Copy The return value of a single metric lookup is an application metric drop. The return value of a find_by_regexp invocation is an array of application metric drops. You can use the metric selector to browse all available metrics and insert metric names or regexp values into your custom view for use in chart tags or filters. If you have added custom metrics via custom metrics, you will see them in the metric selector. An ApplicationMetric drop represents a single application metric and can be used to fetch metric values. Metric value functions like call_count, time_percentage_by_host, and average_value_by_host can be directly invoked on this drop. Metric value functions are also used as a parameter for chart tags to specify the value to display in the chart. The return value of a value function invocation is a MetricValue. Methods id: The integer id of the metric name: The name of the metric Examples {{ application.metrics['Memory/Physical'].average_value_by_host.value }} Copy {{ metrics['CPU/User Time'].time_percentage_by_host.value }} Copy Value methods Some of the value methods return the same data for a given metric, but with different units. Units, if any, are listed in parentheses after the value method. total_value (ms): The total value of the metric for each period within the time window. Use the value_suffix attribute to set the suffix average_value, average_response_time (ms): The average value of the metric for each period within the time window. count, call_count: The number of data points for the metric value (e.g. # of method invocations) requests_per_minute (rpm), calls_per_minute (cpm), errors_per_minute (epm): The number of requests per minute min_value, min_call_time (ms): The smallest metric value collected during the period. max_value, max_call_time (ms): The largest metric value collected during the period. time_percentage (%): Useful for DB and CPU percentage utilization, added across all applicable hosts. time_percentage_by_host (%): Time percentage averaged across the # of hosts. average_value_by_host: The raw value averaged across the # of hosts. score: The value of a scoring method, currently used with Apdex metrics. Filters Filters are methods in Liquid. They always take their first parameter as the output of the left side of the filter (before the '|'). For more information about using filters, see the Liquid Wiki on Filters. Examples traffic_light(input, caution_threshold = 1, danger_threshold = 2) This filter renders a traffic light image by comparing the input value against upper and lower thresholds. If the danger threshold is exceeded, the light will be red. If the caution threshold is exceeded, the light will be yellow. Otherwise it will be green. {{ application.health_status | traffic_light }} {{ application.metrics['Memory/Physical'].average_value_by_host.value | traffic_light:800,1300 }} link_to_application(input, application) This filter generates a link to an application. The input value is the link text. {{ 'current application' | link_to_application:application }} link_to_custom_view(input, custom view name or id) This filter generates a link to a custom view. The input value is the link text. {{ 'For more detail see this custom view' | link_to_custom_view:'My Custom View' }} round(input, places = 0) This filter rounds a value. {{ 109.45 | round:1 }} percentage(input) This filter turns a value to a percentage by multiplying it by 100 and rounding to two places. {{ 0.87 | percentage }} Arithmetic filters These filters are core features of Liquid: # addition plus(input, operand) # subtraction minus(input, operand) # multiplication times(input, operand) # division divided_by(input, operand) Copy sort_table(table_id, column, order = 'asc') This filter sorts a table identified by DOM id \"tableid\", with a default sort on the column numbered \"column\" in the order specified. The order is an optional parameter. Once invoked, the table can be re-sorted dynamically by clicking on the table headers. Here is an example: { % assign metrics = application.metrics.find_by_regexp [ '._Controller/.'] %} <table id=\"metrics_table\"> <thead> <tr> <th></th> <th>Resp. time (300,1000)</th> <th></th> <th>RPM(10,50)</th> <th>Action</th> </tr> </thead> <tbody> {% for metric in metrics %} <tr> <td>{{metric.average_response_time.value | traffic_light:300, 1000}}</td> <td>{{metric.average_response_time.value}}</td> <td>{{metric.requests_per_minute.value | traffic_light:10, 50}}</td> <td>{{metric.requests_per_minute.value}}</td> <td>{{metric.name}}</td> </tr> {% endfor %} </tbody> </table> {{ 'metrics_table' | sort_table:2, 'desc' }} Copy The last line calls the table sort, sorting on the second column in descending order. For more information, see Liquid Filters. Tags Tags in Liquid are used to create logic and other custom behavior in your custom views. For more information about built-in tags, see The Liquid Wiki page on Tags. The New Relic custom tags listed below are used to display charts and alter the time window. Chart tags New Relic custom views support chart rendering using a set of custom tags. Common chart attributes include: title: The chart title subtitle: The subtitle value: A metric value function label: A function on the metric name that returns the label for each metric's timeseries. Possible values are ui_name (default), long_ui_name, last_segment (returns the last '/'-separated segment of the metric name), or segment_N (returns the Nth segment of the metric name). application: Either an application id or a name. This can be used to override the selected application. since: Changes the time window used for the metric data query. See the since block. hide_legend: Hides the graph legend when set to true limit: Limits the number of metrics matched by a regular expression metric match link_to: A url that will become the drilldown link for the chart link_to_custom_view: A custom view name or id. The chart will hyperlink to the given custom view. caution_threshold: A number value representing a caution threshold. A yellow horizontal line will be drawn on the graph at this value. danger_threshold: A number value representing a danger threshold. A red horizontal line will be drawn on the graph at this value. value_suffix: A suffix to be appended to all metric values simple_tooltip: when true, the tooltip is just the value and suffix Referencing metrics Metric data can be referenced in two ways: either by using the name of a specific metric, or by providing a regular expression that matches multiple metrics. Use either the metric or the regexp attribute (but not both) in each chart tag to set the metric source. metric: A string that matches a single metric. The value should be in single quotes and it should not be escaped. regexp: A regular expression that matches metrics. This expression should be wrapped in quotes and it should not be escaped. The following values are provided for informational purposes, for customers who created custom views using these values prior to June 2012. You can access your old custom views and create new custom dashboards from the New Relic Custom dashboards menu. line_chart {% line_chart value:time_percentage metric:'CPU/User Time' title:'CPU' %} pie_chart {% pie_chart regexp:'ActiveRecord/(save|find|destroy)' title:'Active Record' value:time_percentage %} horizontal_bar_chart {% horizontal_bar_chart value:call_count title:'Active Record' regexp:'ActiveRecord/(save|find|destroy)' %} compare_with_last_week_chart {% compare_with_last_week_chart metric:'ActiveRecord/all' title:'Week to Week Comparison' value:time_percentage %} compare_with_yesterday_chart {% compare_with_yesterday_chart metric:'ActiveRecord/all' title:'ActiveRecord' value:time_percentage %} Similar to the compare_with_last_week_chart but uses a 24 hour time period for comparison rather than 7 day. compare_with_yesterday_and_last_week_chart {% compare_with_yesterday_and_last_week_chart metric:'ActiveRecord/all' title:'ActiveRecord' value:time_percentage %} A combination of compare_with_yesterday_chart and compare_with_last_week_chart. daily_summary_chart {% daily_summary_chart metric:'Controller' title:'Daily Summary Chart' value:call_count %} weekly_summary_chart {% weekly_summary_chart metric:'Controller' title:'Weekly Summary Chart' value:call_count %} Blocks Blocks in Liquid are tags that are used to create logic in your custom view. There are many blocks built into Liquid, as well as the custom New Relic 'since' block. since New Relic's since block tag is used to specify a time window for a set of queries. This tag must be followed by a matching endsince tag. All metric data value and chart data queries occurring within a since tag will be scoped to the given time range. Charts will override this time window if the since attribute is specified, but this tag is useful for scoping an entire custom view to a particular time window. It is also the only way to change the time window scope of a metric value query. Examples {% since midnight %} {{ application.metrics['Memory/Physical'].average_value_by_host.value }} {% endsince %} {% since 3.hours.ago %} {% line_chart value:time_percentage metric:'CPU/User Time' title:'CPU Last 3 hours' %} {% endsince %} Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 281.7871,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> <em>views</em> (deprecated)",
        "sections": "<em>Custom</em> <em>views</em> (deprecated)",
        "tags": "<em>Custom</em> <em>dashboards</em> <em>and</em> <em>custom</em> <em>views</em>",
        "body": ". In addition, <em>plugins</em> in <em>Plugin</em> Central are not supported with accounts that host data in the EU region data center. Important For an even better experience than <em>plugins</em>, <em>custom</em> <em>dashboards</em>, and <em>custom</em> <em>views</em>, go to: newrelic.com&#x2F;integrations: Integrate the on-host and cloud systems you already use"
      },
      "id": "60445cdb196a678ea2960f21"
    },
    {
      "sections": [
        "Data privacy with New Relic",
        "Tip",
        "Personal data transfer (Privacy Shield and SCC)",
        "Compliance with legal requirements",
        "Privacy by design and by default",
        "Personal data requests (GDPR, CCPA, etc.)",
        "Events and attributes",
        "Dropping data at ingest",
        "Technical security controls",
        "Organizational security controls",
        "Account security",
        "Retention of your data",
        "New Relic account emails",
        "Account changes (NrAuditEvent)",
        "Account usage (NrDailyUsage)",
        "Security for products and services",
        "Alerts and Applied Intelligence",
        "APIs",
        "APM",
        "Browser monitoring",
        "Diagnostics",
        "Infrastructure monitoring",
        "Insights",
        "Integrations and serverless monitoring",
        "Logs management",
        "Mobile monitoring",
        "New Relic One",
        "Plugins",
        "Synthetic monitoring"
      ],
      "title": "Data privacy with New Relic",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Data privacy"
      ],
      "external_id": "d46953520476285467540433180d483815efecc6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/data-privacy/data-privacy-new-relic/",
      "published_at": "2021-07-10T01:16:15Z",
      "updated_at": "2021-07-10T01:16:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic takes your data privacy seriously. Our principles-based approach aims to go beyond the legal requirements for consent. We understand your concerns when you entrust us with your data, and we always strive to embrace your expectations and preferences. This document provides links to detailed information about the privacy and security measures we take to protect you and your customers' data privacy. Our monitoring tools are data-agnostic; they don't require sensitive materials, and many of them don't require any personal data. You are responsible for ensuring that your systems are appropriately set up and configured so that they don't send inappropriate personal data or sensitive materials to New Relic monitoring tools. For additional information about policies, credentials, audits, and other resources, see our New Relic security website. Tip New Relic now offers the option of HIPPA-enabled accounts for customers meeting certain requirements. To learn more, see HIPAA readiness at New Relic. Personal data transfer (Privacy Shield and SCC) The Schrems case ruling invalidates Privacy Shield. However, it explicitly reaffirms the validity of Standard Contractual Clauses (SCC) as an appropriate legal mechanism to transfer personal data outside of the European Union. You can find more information in How the Demise of Privacy Shield Affects Your New Relic Account. If you want to send personal data from the EU, we offer an appropriate data processing agreement (DPA) with SCC to govern the transfer of that data in accordance with the Schrems decision. For more information, consult our Data Processing Addendum FAQ, or download our pre-signed DPA (PDF|697 KB). Compliance with legal requirements We always strive to comply with all applicable laws as they take effect. This includes the European Union's General Data Protection Regulation (GDPR) and all relevant US State laws, such as the California Consumer Privacy Act (CCPA). Our disk-based encryption provides additional security while your data is at rest (FIPS 140-2 compliant). In addition, we are authorized for Moderate Impact SaaS Services (FedRAMP Authorized Moderate) for accounts that meet specific criteria. For privacy-related details about New Relic's contractual and regulatory commitments for services, see: Terms of Service or Master Subscription Agreement Data Protection Agreement Services Privacy Notice For more information about annual audits, see Regulatory audits for New Relic services. Privacy by design and by default New Relic follows \"privacy by design\" principles as part of our overarching security program. For example, when New Relic agents capture a webpage or referrer URL, all query parameters are stripped by default. Here are examples of how we incorporate privacy considerations into our data and security practices. Personal data requests (GDPR, CCPA, etc.) New Relic strives to comply with all applicable laws as they take effect. This includes the European Union's GDPR and ePrivacy Directive and all applicable privacy laws, such as the California Consumer Privacy Act (CCPA) in the US. For more information about our process when responding to requests to access or delete personal data, see New Relic personal data requests. Events and attributes You can query events and attributes, as well as create charts and alert conditions about this data. For a complete list of all events and attributes tracked by New Relic agents, see our data dictionary. Events and attributes example: If you use the Infrastructure ProcessSample event's commandLine attribute, by default we strip options and arguments from the full command line to prevent accidental leakage of sensitive information. Dropping data at ingest Dropping data gives you control over the data that you send to New Relic, including any personal data that you configured to be collected. By dropping specific events or attributes from events, you determine what data New Relic ultimately stores so that you can query, alert on, and analyze it. For more information, see Drop data using NerdGraph. When our agents refer to data obfuscation, the agent actually removes the data before sending it to New Relic. The data cannot be recovered. For example, with APM queries, the Record SQL? value defaults to obfuscated. This strips the string literals and numeric sequences and then replaces them with the ? character. You can mask sensitive information in HTTP or HTTPS requests. For example, queries about distributed traces and transaction traces are obfuscated by default, in which case they cannot be recovered. For more information, see the documentation for specific New Relic services, including: APM transaction traces Distributed tracing Technical security controls We use a comprehensive set of technical controls to support general security needs as well as security for data we receive. For more information, see our documentation about data security, data encryption, and high security mode for APM agents. Organizational security controls New Relic maintains a number of internal policies and procedures to guide employees in privacy-related subjects such as data classification and handling, data retention, handling of personal data, fulfilling personal data requests, incident response, etc. All employees must complete the security and privacy training upon hiring and renew this training annually. Account security Our role-based account structure gives you direct control over who can access or change your account settings. For more information, see Users and roles. Retention of your data Our Telemetry Data Platform is the single source of truth for all your operational data, empowering you to ask and answer any question in milliseconds. This platform stores different types of data for different periods of time. The Data retention page in our UI provides information on how long your data will be stored in the New Relic database (NRDB). For more information, see Manage data retention. New Relic account emails By default, we communicate with you for a variety of purposes related to your status as New Relic subscribers. This includes product engagement, support, alert notifications, updates, billings, etc. Individual users can unsubscribe from certain communications. General email preferences are managed through the account user interface. For more information, see Account email settings. Alert notification emails are managed through the alerting UI. Account changes (NrAuditEvent) To view changes made to your account's users or to record configuration changes, query NrAuditEvent events. To be notified about account changes, create NRQL alert conditions. For more information about available NrAuditEvent attributes, see our data dictionary. Account usage (NrDailyUsage) To view daily usage of New Relic for your selected account for billing purposes, query NrDailyUsage events. For more information about available NrDailyUsageattributes, see our data dictionary. Security for products and services We publish security bulletins with detailed information about vulnerabilities, remediation strategies, and applicable updates for affected software. To receive notifications for future advisories, use either of these options: Subscribe to our security bulletins RSS feed. Select the Watching option in our Explorers Hub's Security notifications community channel to receive email alerts. The following summarizes how individual New Relic products and components ensure security, with links to additional details. Alerts and Applied Intelligence By default, our alerting services do not record any personal data. In addition, they automatically set default permissions for individual account users and access levels within account structures. For more information, see our documentation about Applied Intelligence, as well as our rules and limits for alerts. APIs APIs simply are interfaces for data exchange automation. APIs have no knowledge of the content being transferred. We require authorized users to provide their API keys to monitor subscription usage, manage account user permissions, query data, and perform other automated tasks. For more information, see Introduction to New Relic APIs. APM APM agents monitor your applications' performance. By default, APM agents do not record any personal data. For more information, see our APM security documentation. Browser monitoring Our browser monitoring agent allows you to monitor the performance of their websites. For more information, see: Browser security documentation Visitor's IP address New Relic cookies used by browser Enabling or disabling cookie collection for session tracking Diagnostics The New Relic Diagnostics service inspects relevant system information and any other necessary information (such as logs and config files) to perform diagnostic checks that assess configuration and operability. By default, this data is not transmitted to New Relic. You do have the option to upload this information to a support ticket over HTTPS. For more information, see the Diagnostics security documentation. Infrastructure monitoring The Infrastructure agent allows you to monitor the performance of components in your ecosystem, such as servers, platforms, operating systems, databases, etc. Infrastructure may record the userID and username of users connecting to Infrastructure resources. For more information, see the security documentation for infrastructure monitoring. Insights The Insights service reports on data recorded by other New Relic products and services. It doesn’t record data on its own. For more information, see the Insights documentation about default data from other products and services. Integrations and serverless monitoring Our integrations services allow you to retrieve and load data into the New Relic database from a variety of sources, including: Cloud-based integrations On-host integrations in containerized environments, such as Kubernetes On-host integrations built by New Relic On-host integrations built by the open-source community On-host integrations built by you Depending on the integration, different types of data may be recorded so that you can monitor the integrations in New Relic. The integration services are data agnostic. They will have no knowledge of whether the imported data contains any personal information. For more information, see the documentation for the specific integration, including: Amazon Web Services (AWS) Google Cloud Platform (GCP) Kubernetes Microsoft Azure On-host integrations Open source on-host integrations Serverless function monitoring Logs management Due to the nature of our Logs management service, you have direct control over what data is reported to New Relic. To ensure data privacy and to limit the types of information New Relic receives, no customer data is captured except what you supply in your API calls or log forwarder configuration. All data for the Logs service is then reported to New Relic over HTTPS. The Logs service does mask number patterns that appear to be for items such as credit cards or Social Security numbers. For more information, see the Logs security documentation. Mobile monitoring By default, our mobile monitoring service collects two pieces of personal data: The IP address is used to derive high-level geographical data, and then is discarded. A device ID is generated by New Relic and is used for billing purposes. For more information, see our security documentation for mobile monitoring. New Relic One New Relic One is a connected, unified UI that gathers all the data you already monitor with New Relic in one place. It is not a product, but rather, it's a way to interact with all your New Relic data more easily. For more information, see the introduction and security documentation for New Relic One. Plugins The plugins service allows you to publish publicly accessible plugins within (Plugin Central. Anyone who has a New Relic account can install and use these plugins through their New Relic user interface. For some plugins, New Relic, Inc. is the publisher, and will be clearly identified as the publisher in Plugin Central. For plugins in Plugin Central that are not created by New Relic, the plugin publisher must follow specific guidelines. For more information, see the Plugins security documentation. Synthetic monitoring The synthetic monitoring service uses monitors distributed throughout data centers around the world. It captures what is essentially performance data of simulated traffic. By default, it does not capture any personal data. For more information, see the data privacy and security documentation for synthetic monitoring. If you configure the synthetic service to monitor areas of websites that are located behind a login page, take care to create a non-personal login dedicated to this purpose. This will reduce the risk of unintended personal data exposure. For example, to securely store sensitive information, such as passwords, API keys, and user names, you can use secured credentials for scripted browsers and API tests. The synthetic monitoring service also supports a variety of authentication mechanisms. Depending on the type of monitor you choose, this includes Basic, Digest, NTLM, and NTLMv2. You can also control which of your users can access your monitors and private locations. For more information, see our documentation about user role-based permissions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.09898,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data privacy with <em>New</em> <em>Relic</em>",
        "sections": "Data privacy with <em>New</em> <em>Relic</em>",
        "tags": "Security <em>and</em> Privacy",
        "body": " <em>Relic</em> data more easily. For more information, see the introduction and security documentation for <em>New</em> <em>Relic</em> One. <em>Plugins</em> The <em>plugins</em> service allows you to publish publicly accessible <em>plugins</em> within (<em>Plugin</em> Central. Anyone who has a <em>New</em> <em>Relic</em> account can install and use these <em>plugins</em> through their <em>New</em>"
      },
      "id": "603ec2d4e7b9d22fba2a07c6"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Tip",
        "Setup",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2021-07-09T15:08:21Z",
      "updated_at": "2021-07-09T15:08:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Tip To use APIs and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following for example REST API use cases: APM examples (how to retrieve metric timeslice data from New Relic APM) Browser examples (how to retrieve metric timeslice data from browser monitoring) Infrastructure alert examples Plugin examples (how to retrieve information and metric timeslice data about plugins from New Relic Plugin Central) Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 64.65309,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> REST API (v2)",
        "sections": "Introduction to <em>New</em> <em>Relic</em> REST API (v2)",
        "body": " Examples See the following for example REST API use cases: APM examples (how to retrieve metric timeslice data from <em>New</em> <em>Relic</em> APM) Browser examples (how to retrieve metric timeslice data from browser monitoring) Infrastructure alert examples <em>Plugin</em> examples (how to retrieve information and metric timeslice data about <em>plugins</em> from <em>New</em> <em>Relic</em> <em>Plugin</em> Central) Alerts examples (create alert conditions and configure notification channels, and more)"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/plugins/plugins-new-relic/custom-dashboards-custom-views/custom-views-deprecated": [
    {
      "sections": [
        "Custom dashboards v2 (legacy)",
        "Important",
        "Limited access to legacy plugins"
      ],
      "title": "Custom dashboards v2 (legacy)",
      "type": "docs",
      "tags": [
        "Plugins",
        "Plugins New Relic",
        "Custom dashboards and custom views"
      ],
      "external_id": "f122ddf1c7bcc4c1efb449838eafa63d79d5753c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/plugins/plugins-new-relic/custom-dashboards-custom-views/custom-dashboards-v2-legacy/",
      "published_at": "2021-07-09T12:56:56Z",
      "updated_at": "2021-03-13T01:30:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In February 2014, custom dashboards (v2) replaced our original custom dashboards feature (v1). Custom dashboards (v2) are part of a legacy feature and are being retained only for use with our legacy plugins tool. In addition, plugins in Plugin Central are not supported with accounts that host data in the EU region data center. Important For an even better experience than plugins, go to: newrelic.com/integrations: Integrate the on-host and cloud systems you already use with New Relic, so you can filter and analyze data, create dashboards, and set alerts within a single platform. developer.newrelic.com: Use developer tools to collect data from any source, automate workflows, build apps, and use our APIs. Limited access to legacy plugins As of December 2, 2020, plugin access has been limited to accounts that have accessed a legacy plugin in the past 30 days. The legacy plugin experience will reach end of life (EoL) as of June 16, 2021. For more information, see our Explorers Hub post.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 281.77658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> <em>dashboards</em> v2 (legacy)",
        "sections": "<em>Custom</em> <em>dashboards</em> v2 (legacy)",
        "tags": "<em>Custom</em> <em>dashboards</em> <em>and</em> <em>custom</em> <em>views</em>",
        "body": "In February 2014, <em>custom</em> <em>dashboards</em> (v2) replaced our original <em>custom</em> <em>dashboards</em> feature (v1). <em>Custom</em> <em>dashboards</em> (v2) are part of a legacy feature and are being retained only for use with our legacy <em>plugins</em> tool. In addition, <em>plugins</em> in <em>Plugin</em> Central are not supported with accounts that host data"
      },
      "id": "60445cde28ccbc04a2311239"
    },
    {
      "sections": [
        "Data privacy with New Relic",
        "Tip",
        "Personal data transfer (Privacy Shield and SCC)",
        "Compliance with legal requirements",
        "Privacy by design and by default",
        "Personal data requests (GDPR, CCPA, etc.)",
        "Events and attributes",
        "Dropping data at ingest",
        "Technical security controls",
        "Organizational security controls",
        "Account security",
        "Retention of your data",
        "New Relic account emails",
        "Account changes (NrAuditEvent)",
        "Account usage (NrDailyUsage)",
        "Security for products and services",
        "Alerts and Applied Intelligence",
        "APIs",
        "APM",
        "Browser monitoring",
        "Diagnostics",
        "Infrastructure monitoring",
        "Insights",
        "Integrations and serverless monitoring",
        "Logs management",
        "Mobile monitoring",
        "New Relic One",
        "Plugins",
        "Synthetic monitoring"
      ],
      "title": "Data privacy with New Relic",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Data privacy"
      ],
      "external_id": "d46953520476285467540433180d483815efecc6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/data-privacy/data-privacy-new-relic/",
      "published_at": "2021-07-10T01:16:15Z",
      "updated_at": "2021-07-10T01:16:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic takes your data privacy seriously. Our principles-based approach aims to go beyond the legal requirements for consent. We understand your concerns when you entrust us with your data, and we always strive to embrace your expectations and preferences. This document provides links to detailed information about the privacy and security measures we take to protect you and your customers' data privacy. Our monitoring tools are data-agnostic; they don't require sensitive materials, and many of them don't require any personal data. You are responsible for ensuring that your systems are appropriately set up and configured so that they don't send inappropriate personal data or sensitive materials to New Relic monitoring tools. For additional information about policies, credentials, audits, and other resources, see our New Relic security website. Tip New Relic now offers the option of HIPPA-enabled accounts for customers meeting certain requirements. To learn more, see HIPAA readiness at New Relic. Personal data transfer (Privacy Shield and SCC) The Schrems case ruling invalidates Privacy Shield. However, it explicitly reaffirms the validity of Standard Contractual Clauses (SCC) as an appropriate legal mechanism to transfer personal data outside of the European Union. You can find more information in How the Demise of Privacy Shield Affects Your New Relic Account. If you want to send personal data from the EU, we offer an appropriate data processing agreement (DPA) with SCC to govern the transfer of that data in accordance with the Schrems decision. For more information, consult our Data Processing Addendum FAQ, or download our pre-signed DPA (PDF|697 KB). Compliance with legal requirements We always strive to comply with all applicable laws as they take effect. This includes the European Union's General Data Protection Regulation (GDPR) and all relevant US State laws, such as the California Consumer Privacy Act (CCPA). Our disk-based encryption provides additional security while your data is at rest (FIPS 140-2 compliant). In addition, we are authorized for Moderate Impact SaaS Services (FedRAMP Authorized Moderate) for accounts that meet specific criteria. For privacy-related details about New Relic's contractual and regulatory commitments for services, see: Terms of Service or Master Subscription Agreement Data Protection Agreement Services Privacy Notice For more information about annual audits, see Regulatory audits for New Relic services. Privacy by design and by default New Relic follows \"privacy by design\" principles as part of our overarching security program. For example, when New Relic agents capture a webpage or referrer URL, all query parameters are stripped by default. Here are examples of how we incorporate privacy considerations into our data and security practices. Personal data requests (GDPR, CCPA, etc.) New Relic strives to comply with all applicable laws as they take effect. This includes the European Union's GDPR and ePrivacy Directive and all applicable privacy laws, such as the California Consumer Privacy Act (CCPA) in the US. For more information about our process when responding to requests to access or delete personal data, see New Relic personal data requests. Events and attributes You can query events and attributes, as well as create charts and alert conditions about this data. For a complete list of all events and attributes tracked by New Relic agents, see our data dictionary. Events and attributes example: If you use the Infrastructure ProcessSample event's commandLine attribute, by default we strip options and arguments from the full command line to prevent accidental leakage of sensitive information. Dropping data at ingest Dropping data gives you control over the data that you send to New Relic, including any personal data that you configured to be collected. By dropping specific events or attributes from events, you determine what data New Relic ultimately stores so that you can query, alert on, and analyze it. For more information, see Drop data using NerdGraph. When our agents refer to data obfuscation, the agent actually removes the data before sending it to New Relic. The data cannot be recovered. For example, with APM queries, the Record SQL? value defaults to obfuscated. This strips the string literals and numeric sequences and then replaces them with the ? character. You can mask sensitive information in HTTP or HTTPS requests. For example, queries about distributed traces and transaction traces are obfuscated by default, in which case they cannot be recovered. For more information, see the documentation for specific New Relic services, including: APM transaction traces Distributed tracing Technical security controls We use a comprehensive set of technical controls to support general security needs as well as security for data we receive. For more information, see our documentation about data security, data encryption, and high security mode for APM agents. Organizational security controls New Relic maintains a number of internal policies and procedures to guide employees in privacy-related subjects such as data classification and handling, data retention, handling of personal data, fulfilling personal data requests, incident response, etc. All employees must complete the security and privacy training upon hiring and renew this training annually. Account security Our role-based account structure gives you direct control over who can access or change your account settings. For more information, see Users and roles. Retention of your data Our Telemetry Data Platform is the single source of truth for all your operational data, empowering you to ask and answer any question in milliseconds. This platform stores different types of data for different periods of time. The Data retention page in our UI provides information on how long your data will be stored in the New Relic database (NRDB). For more information, see Manage data retention. New Relic account emails By default, we communicate with you for a variety of purposes related to your status as New Relic subscribers. This includes product engagement, support, alert notifications, updates, billings, etc. Individual users can unsubscribe from certain communications. General email preferences are managed through the account user interface. For more information, see Account email settings. Alert notification emails are managed through the alerting UI. Account changes (NrAuditEvent) To view changes made to your account's users or to record configuration changes, query NrAuditEvent events. To be notified about account changes, create NRQL alert conditions. For more information about available NrAuditEvent attributes, see our data dictionary. Account usage (NrDailyUsage) To view daily usage of New Relic for your selected account for billing purposes, query NrDailyUsage events. For more information about available NrDailyUsageattributes, see our data dictionary. Security for products and services We publish security bulletins with detailed information about vulnerabilities, remediation strategies, and applicable updates for affected software. To receive notifications for future advisories, use either of these options: Subscribe to our security bulletins RSS feed. Select the Watching option in our Explorers Hub's Security notifications community channel to receive email alerts. The following summarizes how individual New Relic products and components ensure security, with links to additional details. Alerts and Applied Intelligence By default, our alerting services do not record any personal data. In addition, they automatically set default permissions for individual account users and access levels within account structures. For more information, see our documentation about Applied Intelligence, as well as our rules and limits for alerts. APIs APIs simply are interfaces for data exchange automation. APIs have no knowledge of the content being transferred. We require authorized users to provide their API keys to monitor subscription usage, manage account user permissions, query data, and perform other automated tasks. For more information, see Introduction to New Relic APIs. APM APM agents monitor your applications' performance. By default, APM agents do not record any personal data. For more information, see our APM security documentation. Browser monitoring Our browser monitoring agent allows you to monitor the performance of their websites. For more information, see: Browser security documentation Visitor's IP address New Relic cookies used by browser Enabling or disabling cookie collection for session tracking Diagnostics The New Relic Diagnostics service inspects relevant system information and any other necessary information (such as logs and config files) to perform diagnostic checks that assess configuration and operability. By default, this data is not transmitted to New Relic. You do have the option to upload this information to a support ticket over HTTPS. For more information, see the Diagnostics security documentation. Infrastructure monitoring The Infrastructure agent allows you to monitor the performance of components in your ecosystem, such as servers, platforms, operating systems, databases, etc. Infrastructure may record the userID and username of users connecting to Infrastructure resources. For more information, see the security documentation for infrastructure monitoring. Insights The Insights service reports on data recorded by other New Relic products and services. It doesn’t record data on its own. For more information, see the Insights documentation about default data from other products and services. Integrations and serverless monitoring Our integrations services allow you to retrieve and load data into the New Relic database from a variety of sources, including: Cloud-based integrations On-host integrations in containerized environments, such as Kubernetes On-host integrations built by New Relic On-host integrations built by the open-source community On-host integrations built by you Depending on the integration, different types of data may be recorded so that you can monitor the integrations in New Relic. The integration services are data agnostic. They will have no knowledge of whether the imported data contains any personal information. For more information, see the documentation for the specific integration, including: Amazon Web Services (AWS) Google Cloud Platform (GCP) Kubernetes Microsoft Azure On-host integrations Open source on-host integrations Serverless function monitoring Logs management Due to the nature of our Logs management service, you have direct control over what data is reported to New Relic. To ensure data privacy and to limit the types of information New Relic receives, no customer data is captured except what you supply in your API calls or log forwarder configuration. All data for the Logs service is then reported to New Relic over HTTPS. The Logs service does mask number patterns that appear to be for items such as credit cards or Social Security numbers. For more information, see the Logs security documentation. Mobile monitoring By default, our mobile monitoring service collects two pieces of personal data: The IP address is used to derive high-level geographical data, and then is discarded. A device ID is generated by New Relic and is used for billing purposes. For more information, see our security documentation for mobile monitoring. New Relic One New Relic One is a connected, unified UI that gathers all the data you already monitor with New Relic in one place. It is not a product, but rather, it's a way to interact with all your New Relic data more easily. For more information, see the introduction and security documentation for New Relic One. Plugins The plugins service allows you to publish publicly accessible plugins within (Plugin Central. Anyone who has a New Relic account can install and use these plugins through their New Relic user interface. For some plugins, New Relic, Inc. is the publisher, and will be clearly identified as the publisher in Plugin Central. For plugins in Plugin Central that are not created by New Relic, the plugin publisher must follow specific guidelines. For more information, see the Plugins security documentation. Synthetic monitoring The synthetic monitoring service uses monitors distributed throughout data centers around the world. It captures what is essentially performance data of simulated traffic. By default, it does not capture any personal data. For more information, see the data privacy and security documentation for synthetic monitoring. If you configure the synthetic service to monitor areas of websites that are located behind a login page, take care to create a non-personal login dedicated to this purpose. This will reduce the risk of unintended personal data exposure. For example, to securely store sensitive information, such as passwords, API keys, and user names, you can use secured credentials for scripted browsers and API tests. The synthetic monitoring service also supports a variety of authentication mechanisms. Depending on the type of monitor you choose, this includes Basic, Digest, NTLM, and NTLMv2. You can also control which of your users can access your monitors and private locations. For more information, see our documentation about user role-based permissions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.09892,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data privacy with <em>New</em> <em>Relic</em>",
        "sections": "Data privacy with <em>New</em> <em>Relic</em>",
        "tags": "Security <em>and</em> Privacy",
        "body": " <em>Relic</em> data more easily. For more information, see the introduction and security documentation for <em>New</em> <em>Relic</em> One. <em>Plugins</em> The <em>plugins</em> service allows you to publish publicly accessible <em>plugins</em> within (<em>Plugin</em> Central. Anyone who has a <em>New</em> <em>Relic</em> account can install and use these <em>plugins</em> through their <em>New</em>"
      },
      "id": "603ec2d4e7b9d22fba2a07c6"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Tip",
        "Setup",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2021-07-09T15:08:21Z",
      "updated_at": "2021-07-09T15:08:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Tip To use APIs and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following for example REST API use cases: APM examples (how to retrieve metric timeslice data from New Relic APM) Browser examples (how to retrieve metric timeslice data from browser monitoring) Infrastructure alert examples Plugin examples (how to retrieve information and metric timeslice data about plugins from New Relic Plugin Central) Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 64.65305,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> REST API (v2)",
        "sections": "Introduction to <em>New</em> <em>Relic</em> REST API (v2)",
        "body": " Examples See the following for example REST API use cases: APM examples (how to retrieve metric timeslice data from <em>New</em> <em>Relic</em> APM) Browser examples (how to retrieve metric timeslice data from browser monitoring) Infrastructure alert examples <em>Plugin</em> examples (how to retrieve information and metric timeslice data about <em>plugins</em> from <em>New</em> <em>Relic</em> <em>Plugin</em> Central) Alerts examples (create alert conditions and configure notification channels, and more)"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/query-your-data/explore-query-data/browse-data/introduction-data-explorer": [
    {
      "sections": [
        "Query builder: Basic mode",
        "Important",
        "Data type",
        "Example of using basic mode",
        "Step 1: Select the source of the data for a chart",
        "Step 2: Filter the data",
        "Step 3: Adjust time range and limits",
        "Step 4: Customize the chart"
      ],
      "title": "Query builder: Basic mode",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Query builder"
      ],
      "external_id": "7f076b3909c9462829453bc59f0dae0f5d5501fd",
      "image": "https://docs.newrelic.com/static/6be4a8d2af5e02259c01e180d7f43326/58213/crop-basic-example-chart_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/query-builder/query-builder-basic-mode/",
      "published_at": "2021-07-10T03:13:37Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the New Relic One query builder in basic mode to create a chart without having to use NRQL, our querying language. The basic mode helps guides you through a query-creation process. You can choose the source of the raw data, apply filters, and use other techniques to narrow the scope of the data in the chart. Important As of September 1, 2021, we are discontinuing support of the query builder's basic mode. Instead, you can use our data explorer's user-friendly and intuitive functionality in New Relic One. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Data type The query builder basic mode has a Data type selector with two options: Events: In this context, this refers to all our non-Metric-type data, including events, logs, and trace data. Metrics: This refers to our dimensional Metric data type. You can also use this to query some types of metric timeslice data. For more on other types of metrics, see Data types. Example of using basic mode This example shows how to create a chart in basic mode. Step 1: Select the source of the data for a chart Begin by specifying what data you want to view in your chart. Click in the View a chart with box to select the event type, an attribute, and a function to perform on the attribute. You can use the event data dictionary to view information about an event type and its attributes on a single page. To see a tooltip with information about an event or attribute, hover over any term that has a dotted line underneath it. Here are the results of using the event data dictionary to specify the data: Event type. The Transaction event type measures a variety of data that describes what happens while a user is on a website, such as that user clicking on a button on a page. Attribute. The name attribute stores information on all transactions. Function. Select the unique_count function to get a count of all the transactions that occurred during the time frame. Basic mode now shows the selection: one.newrelic.com > Query builder > Basic > (event and attribute specified) As you specify data, the chart updates to show you the results from the data you specified. Based on the information specified so far, you can see a chart that shows the total number of transactions during the default time frame of 30 minutes. This total includes all transactions, whether the transaction was completed successfully or had errors. one.newrelic.com > Query builder > Basic > (event and attribute specified) Step 2: Filter the data Your next step is to determine which of those transactions got a 404 page not found error. If you look in the event data dictionary for the Transaction event type, you'll find this event also includes an attribute called httpResponseCode. Narrow the results to show only those transactions where a page not found error occurred. Use the Narrow results to box to create this filter: httpResponseCode = 404 . Because you want to be able to see the names of the apps that are resulting in the 404 errors, you use the Facet by box to see the results by appName (which is also an attribute for the Transaction event type). Faceting by appName updates the chart to break down the total number of 404 errors by the application names. This lets you know which apps are experiencing 404 errors. Your chart now shows the line chart with a line for each app, each with its own color. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) Step 3: Adjust time range and limits You decide to focus on the five apps with the most page not found errors. The default value for the Limit field is 10, meaning that your chart will show the ten most relevant returns. You change that value to 5. Customer support told you that they had been getting calls about these errors for a little over two hours. You decide to change the time range from the last 30 minutes to the last three hours so that you can view the errors during the time when the customers were calling support. Now that you have the data set so that you are seeing exactly what you need, you can turn your attention to the appearance of the chart. Step 4: Customize the chart Because you are more interested in the total number of errors than a timeline view, you change the chart type to a bar chart. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) > (time range and limit customized) > (chart type customized) When you're finished with your chart, you can add it to a dashboard or share it. This table contains notes about using basic mode. Item Description Prompts You can start typing directly in an empty box; a list of items that match the information you type will display. You can also click on an empty box to view a list of all of the items that are appropriate for the field, based on your earlier choices. Saving a basic mode data specification Every time you run a query, that query is saved in the My recent queries dropdown in advanced (NRQL) mode. Events Basic mode only supports data for one event and attribute. If you want to use more than one event and/or attribute, use the SELECT statement in advanced (NRQL) mode. Shortcuts Basic mode contains shortcuts that can display more complex events and attributes that aren't generally supported, as in this example (which shows the tooltip for the shortcut). Example of the Response time histogram shortcut, showing a tooltip. Tooltips Any time you see a dotted line under a term, you can hover over that term to see a tooltip with an explanation of the term. Narrow by You can use more than one Narrow by definition in basic mode filter; the conditions will be joined by AND. The WHERE clause in advanced (NRQL) allows OR in addition to AND. Important If your query was started using basic mode and if you make changes to that query using advanced (NRQL) mode, you cannot return to basic mode to edit that query. Any additional changes may only be made in advanced (NRQL) mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 315.68878,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> builder: Basic mode",
        "sections": "<em>Query</em> builder: Basic mode",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " was completed successfully or had errors. one.newrelic.com &gt; <em>Query</em> builder &gt; Basic &gt; (event and attribute specified) Step 2: Filter the <em>data</em> <em>Your</em> next step is to determine which of those transactions got a 404 page not found error. If you look in the event <em>data</em> dictionary for the Transaction event type"
      },
      "id": "603ec319e7b9d2008c2a07e0"
    },
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-09T23:45:11Z",
      "updated_at": "2021-07-07T10:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also clone your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 276.9124,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, add, <em>and</em> share dashboards <em>and</em> charts",
        "sections": "Add <em>and</em> share charts <em>and</em> content from <em>your</em> dashboards",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " on the &lt; &#x2F; &gt; icon on the right corner. Export <em>your</em> dashboard as a pdf file clicking the icon. You can also clone <em>your</em> dashboard. Add and share charts and content from <em>your</em> dashboards Add new content to a dashboard You can add new content to any dashboard from the <em>data</em> explorer and <em>query</em> builder"
      },
      "id": "60e5877828ccbc77861881cc"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Clone your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-10T03:14:27Z",
      "updated_at": "2021-07-02T20:16:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Clone your dashboard You can clone your dashboard clicking the clone icon regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. The clone has Public - Read and write permissions. Access the new, cloned dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word “copy”. For example, if you clone a dashboard named This is my dashboard, the clone is called This is my dashboard copy. You can change the name when you clone it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 264.72882,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> dashboard",
        "sections": "Export <em>and</em> share <em>your</em> <em>data</em>",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " to search <em>data</em> across New Relic One. Add new content to <em>your</em> dashboard There are multiple ways to add new content to <em>your</em> dashboard: From the <em>data</em> explorer and <em>query</em> builder features. Use the + Add to <em>your</em> dashboard button (accessible from the main dashboard page or in the edit mode) to access"
      },
      "id": "603ec235196a67206fa83dde"
    }
  ],
  "/docs/query-your-data/explore-query-data/dashboards/add-custom-visualizations-your-dashboards": [
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-09T23:45:11Z",
      "updated_at": "2021-07-07T10:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also clone your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.03845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, add, <em>and</em> share <em>dashboards</em> <em>and</em> charts",
        "sections": "Add <em>and</em> share charts <em>and</em> content from <em>your</em> <em>dashboards</em>",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " on the &lt; &#x2F; &gt; icon on the right corner. Export <em>your</em> <em>dashboard</em> as a pdf file clicking the icon. You can also clone <em>your</em> <em>dashboard</em>. Add and share charts and content from <em>your</em> <em>dashboards</em> Add new content to a <em>dashboard</em> You can add new content to any <em>dashboard</em> from the <em>data</em> explorer and <em>query</em> builder"
      },
      "id": "60e5877828ccbc77861881cc"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Clone your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-10T03:14:27Z",
      "updated_at": "2021-07-02T20:16:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Clone your dashboard You can clone your dashboard clicking the clone icon regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. The clone has Public - Read and write permissions. Access the new, cloned dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word “copy”. For example, if you clone a dashboard named This is my dashboard, the clone is called This is my dashboard copy. You can change the name when you clone it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.888,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> <em>dashboard</em>",
        "sections": "Organize <em>your</em> <em>dashboards</em> with pages",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": "Access any of <em>your</em> New Relic One <em>dashboards</em> to create or manage <em>your</em> charts directly from the chart menu, customize <em>your</em> <em>dashboard</em>&#x27;s layout, adjust display modes, or export <em>your</em> <em>data</em>. Once you have customized <em>your</em> <em>dashboard</em> and built <em>your</em> charts, use our advanced visualization features and tools"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Query builder: Basic mode",
        "Important",
        "Data type",
        "Example of using basic mode",
        "Step 1: Select the source of the data for a chart",
        "Step 2: Filter the data",
        "Step 3: Adjust time range and limits",
        "Step 4: Customize the chart"
      ],
      "title": "Query builder: Basic mode",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Query builder"
      ],
      "external_id": "7f076b3909c9462829453bc59f0dae0f5d5501fd",
      "image": "https://docs.newrelic.com/static/6be4a8d2af5e02259c01e180d7f43326/58213/crop-basic-example-chart_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/query-builder/query-builder-basic-mode/",
      "published_at": "2021-07-10T03:13:37Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the New Relic One query builder in basic mode to create a chart without having to use NRQL, our querying language. The basic mode helps guides you through a query-creation process. You can choose the source of the raw data, apply filters, and use other techniques to narrow the scope of the data in the chart. Important As of September 1, 2021, we are discontinuing support of the query builder's basic mode. Instead, you can use our data explorer's user-friendly and intuitive functionality in New Relic One. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Data type The query builder basic mode has a Data type selector with two options: Events: In this context, this refers to all our non-Metric-type data, including events, logs, and trace data. Metrics: This refers to our dimensional Metric data type. You can also use this to query some types of metric timeslice data. For more on other types of metrics, see Data types. Example of using basic mode This example shows how to create a chart in basic mode. Step 1: Select the source of the data for a chart Begin by specifying what data you want to view in your chart. Click in the View a chart with box to select the event type, an attribute, and a function to perform on the attribute. You can use the event data dictionary to view information about an event type and its attributes on a single page. To see a tooltip with information about an event or attribute, hover over any term that has a dotted line underneath it. Here are the results of using the event data dictionary to specify the data: Event type. The Transaction event type measures a variety of data that describes what happens while a user is on a website, such as that user clicking on a button on a page. Attribute. The name attribute stores information on all transactions. Function. Select the unique_count function to get a count of all the transactions that occurred during the time frame. Basic mode now shows the selection: one.newrelic.com > Query builder > Basic > (event and attribute specified) As you specify data, the chart updates to show you the results from the data you specified. Based on the information specified so far, you can see a chart that shows the total number of transactions during the default time frame of 30 minutes. This total includes all transactions, whether the transaction was completed successfully or had errors. one.newrelic.com > Query builder > Basic > (event and attribute specified) Step 2: Filter the data Your next step is to determine which of those transactions got a 404 page not found error. If you look in the event data dictionary for the Transaction event type, you'll find this event also includes an attribute called httpResponseCode. Narrow the results to show only those transactions where a page not found error occurred. Use the Narrow results to box to create this filter: httpResponseCode = 404 . Because you want to be able to see the names of the apps that are resulting in the 404 errors, you use the Facet by box to see the results by appName (which is also an attribute for the Transaction event type). Faceting by appName updates the chart to break down the total number of 404 errors by the application names. This lets you know which apps are experiencing 404 errors. Your chart now shows the line chart with a line for each app, each with its own color. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) Step 3: Adjust time range and limits You decide to focus on the five apps with the most page not found errors. The default value for the Limit field is 10, meaning that your chart will show the ten most relevant returns. You change that value to 5. Customer support told you that they had been getting calls about these errors for a little over two hours. You decide to change the time range from the last 30 minutes to the last three hours so that you can view the errors during the time when the customers were calling support. Now that you have the data set so that you are seeing exactly what you need, you can turn your attention to the appearance of the chart. Step 4: Customize the chart Because you are more interested in the total number of errors than a timeline view, you change the chart type to a bar chart. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) > (time range and limit customized) > (chart type customized) When you're finished with your chart, you can add it to a dashboard or share it. This table contains notes about using basic mode. Item Description Prompts You can start typing directly in an empty box; a list of items that match the information you type will display. You can also click on an empty box to view a list of all of the items that are appropriate for the field, based on your earlier choices. Saving a basic mode data specification Every time you run a query, that query is saved in the My recent queries dropdown in advanced (NRQL) mode. Events Basic mode only supports data for one event and attribute. If you want to use more than one event and/or attribute, use the SELECT statement in advanced (NRQL) mode. Shortcuts Basic mode contains shortcuts that can display more complex events and attributes that aren't generally supported, as in this example (which shows the tooltip for the shortcut). Example of the Response time histogram shortcut, showing a tooltip. Tooltips Any time you see a dotted line under a term, you can hover over that term to see a tooltip with an explanation of the term. Narrow by You can use more than one Narrow by definition in basic mode filter; the conditions will be joined by AND. The WHERE clause in advanced (NRQL) allows OR in addition to AND. Important If your query was started using basic mode and if you make changes to that query using advanced (NRQL) mode, you cannot return to basic mode to edit that query. Any additional changes may only be made in advanced (NRQL) mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.3531,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> builder: Basic mode",
        "sections": "<em>Query</em> builder: Basic mode",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " was completed successfully or had errors. one.newrelic.com &gt; <em>Query</em> builder &gt; Basic &gt; (event and attribute specified) Step 2: Filter the <em>data</em> <em>Your</em> next step is to determine which of those transactions got a 404 page not found error. If you look in the event <em>data</em> dictionary for the Transaction event type"
      },
      "id": "603ec319e7b9d2008c2a07e0"
    }
  ],
  "/docs/query-your-data/explore-query-data/dashboards/dashboards-api": [
    {
      "sections": [
        "Dashboard API migration: from Insights API to NerdGraph",
        "Why a new dashboards API?",
        "Starting out with NerdGraph",
        "Operations mapping table",
        "Dashboard properties mapping table",
        "Widget properties mapping table",
        "Tip",
        "Visualizations mapping table",
        "Examples: from REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "List all dashboard entities you have access to",
        "List all dashboards by name",
        "List all dashboards by creator’s email",
        "List all dashboards by creator’s user id",
        "Show (GET) -> entity query",
        "Get dashboard info given its entity guid",
        "Create (POST) -> dashboardCreate mutation",
        "Create dashboard with two pages and two widgets per page",
        "Update (PUT) -> dashboardUpdate mutation",
        "Update previously created dashboard to 1 page and 1 widget per page",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Delete previously created dashboard"
      ],
      "title": "Dashboard API migration: from Insights API to NerdGraph",
      "type": "docs",
      "tags": [
        "NerdGraph",
        "Dashboards",
        "Dashboards API"
      ],
      "external_id": "7a1a086f45b7aefccb5d2cd5f42b3a0f0dd526c2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph/",
      "published_at": "2021-07-09T09:31:53Z",
      "updated_at": "2021-07-02T15:10:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Insights Dashboard API is deprecated, but you can use NerdGraph (our GraphQL API) to create and configure dashboards. If you are not migrating from the old Insights API, you can skip this and discover the new Dashboards API. Why a new dashboards API? Our Insights product, which was a way to query data and create charts and dashboards, has been deprecated and its set of features moved over to be a core part of the New Relic One platform. To learn more about this transition and new features, see the Insights to New Relic One migration guide. The Insights Dashboard API will be deprecated in July of 2021. Until then, if you are using Insights Dashboard API, you should attempt to switch over to using NerdGraph. Some details on this deprecation: You can continue to use your Insights insert API key with the Dashboards API, or you can create a new user API key (read more about API keys). Every user who wants to use NerdGraph needs their own user API key. The REST API for Insights queries is not affected by this change and won't be deprecated. For more information about which key to use with our APIs, see our documentation about . When using NerdGraph, it helps to understand that our dashboards are entities that report data from other entities, such as monitored apps, hosts and services. Starting out with NerdGraph If you're new to NerdGraph and GraphQL, you may want to first read our Introduction to NerdGraph and some of Create dashboards with NerdGraph. The NerdGraph API explorer is located at api.newrelic.com/graphiql. Operations mapping table The table below maps every Insights API operation to the new dashboards API. Insights API operation NerdGraph API query/mutation Notes List (GET) entitySearch() View a paginated list of dashboards that match the filter. Show (GET) entity() View an existing dashboard given its entity guid. Create (POST) dashboardCreate() Create a new dashboard. Update (PUT) dashboardUpdate() Update an existing dashboard given its entity guid. Delete (DELETE) dashboardDelete() Delete an existing dashboard given its entity guid. Dashboard properties mapping table For more information about all the fields in the new dashboards GraphQL schema, have a look at NerdGraph's GraphiQL explorer. The table below maps dashboard properties from the Insights API to the new dashboards API. Insights API dashboard property NerdGraph API dashboard property Notes id guid ID of the New Relic entity the dashboard now represents createdAt createdAt updatedAt updatedAt title name editable permissions editable and visibility merged in the same concept visibility permissions editable and visibility merged in the same concept description description metadata - No need of versioning in GraphQL APIs icon - Not translated to New Relic One grid_column_count - 12 column dashboards by default in New Relic One filter - Not translated to New Relic One yet Widget properties mapping table For more information about all the fields in the new dashboards GraphQL schema, have a look at NerdGraph's GraphiQL explorer. The table below maps widget properties from the Insights API to the new dashboards API. Insights API dashboard property NerdGraph API dashboard property Notes id id account_id - Translated into widget configuration for those that require one visualization visualization presentation.title title presentation.drilldown_dashboard_id linkedEntities Used to link a widget to a dashboard for the facet linking feature presentation.notes - Not translated to New Relic One yet layout layout data configuration + rawConfiguration Tip To learn how to build every type of widget, see Create dashboard widgets. Visualizations mapping table We have simplified our widget visualizations by grouping the ones that were in fact the same but obtained through different types of queries. For instance, a line widget is plotted the same way regardless of the type of query: old line_chart vs. comparison_line_chart in Insights. Insights API visualization NerdGraph API visualization uniques_list viz.table single_event viz.table facet_table viz.table event_table viz.table faceted_area_chart viz.area predefined_metric_chart.application_breakdown viz.area predefined_metric_chart.scope_breakdown viz.area predefined_metric_chart.browser_breakdown viz.area predefined_metric_chart.background_breakdown viz.area predefined_metric_chart.solr_breakdown viz.area predefined_metric_chart.gc_runs_breakdown viz.area facet_bar_chart viz.bar billboard viz.billboard attribute_sheet viz.billboard billboard_comparison viz.billboard gauge viz.bullet event_feed viz.event-feed funnel viz.funnel heatmap viz.heatmap histogram viz.histogram inventory infra.inventory raw_json viz.json line_chart viz.line comparison_line_chart viz.line faceted_line_chart viz.line metric_line_chart viz.line markdown viz.markdown facet_pie_chart viz.pie Examples: from REST endpoints to GraphQL queries/mutations One of the main benefits of NerdGraph being a GraphQL-format API is that it provides a complete and understandable description of the APIs' data. By using the NerdGraph API explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. Try it out using the NerdGraph GraphiQL explorer. List all dashboard entities you have access to { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy List all dashboards by name { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy List all dashboards by creator’s email { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy List all dashboards by creator’s user id { actor { entitySearch(query: \"type ='DASHBOARD' and ownerId = '2357322'\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity guid. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. Try it out using the NerdGraph GraphiQL explorer. Get dashboard info given its entity guid { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid accountId name createdAt updatedAt permissions description owner { email userId } pages { guid name createdAt updatedAt description owner { email userId } widgets { id visualization { id } title layout { row column height width } rawConfiguration linkedEntities { guid } } } } } } } Copy Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. Try it out using the NerdGraph GraphiQL explorer. Create dashboard with two pages and two widgets per page mutation { dashboardCreate(accountId: 1, dashboard: { name: \"My awesome dashboard\", permissions: PUBLIC_READ_WRITE, pages: [{ name: \"My first page\", widgets: [{ visualization: { id: \"viz.markdown\" }, title: \"My markdown widget\", layout: { row: 1, column: 1, width: 4, height: 3 }, rawConfiguration: { text: \"#My markdown\" } }, { visualization: { id: \"viz.line\" }, title: \"My line widget\", layout: { row: 1, column: 5, width: 4, height: 3 }, rawConfiguration: { nrqlQueries: [{ accountId: 1, query: \"SELECT count(*) FROM Transaction FACET appName TIMESERIES\" }] } }] }, { name: \"My second page\", widgets: [{ visualization: { id: \"viz.billboard\" }, title: \"My billboard widget with thresholds\", layout: { row: 1, column: 1, width: 4, height: 3 }, rawConfiguration: { nrqlQueries: [{ accountId: 1, query: \"SELECT count(*) FROM Transaction\" }], thresholds: [{ alertSeverity: WARNING, value: 650 }, { alertSeverity: CRITICAL, value: 1500 }] } }, { visualization: { id: \"viz.table\" }, title: \"My table widget\", layout: { row: 1, column: 5, width: 4, height: 3 }, rawConfiguration: { nrqlQueries: [{ query: \"SELECT * FROM Transaction\", accountId: 1 }] } }] }] }) { errors { description type } entityResult { guid accountId name createdAt updatedAt permissions description owner { email userId } pages { guid name createdAt updatedAt description owner { email userId } widgets { id visualization { id } title layout { row column height width } rawConfiguration linkedEntities { guid } } } } } } Copy Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard guid and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. Try it out using the NerdGraph GraphiQL explorer. Update previously created dashboard to 1 page and 1 widget per page mutation { dashboardUpdate(guid: \"MY_DASHBOARD_GUID\" dashboard: { name: \"My awesome dashboard\", permissions: PUBLIC_READ_WRITE, pages: [{ name: \"My first page\", widgets: [{ visualization: { id: \"viz.line\" }, title: \"My line widget\", layout: { row: 1, column: 1, width: 4, height: 3 }, rawConfiguration: { nrqlQueries: [{ accountId: 1, query: \"SELECT count(*) FROM Transaction FACET appName TIMESERIES\" }] } }] }, { name: \"My second page\", widgets: [{ visualization: { id: \"viz.table\" }, title: \"My table widget\", layout: { row: 1, column: 1, width: 4, height: 3 }, rawConfiguration: { nrqlQueries: [{ query: \"SELECT * FROM Transaction\", accountId: 1 }] } }] }] }) { errors { description type } entityResult { guid accountId name createdAt updatedAt permissions description owner { email userId } pages { guid name createdAt updatedAt description owner { email userId } widgets { id visualization { id } title layout { row column height width } rawConfiguration linkedEntities { guid } } } } } } Copy Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity guid. Try it out using the NerdGraph GraphiQL explorer. Delete previously created dashboard mutation { dashboardDelete(guid:\"MY_DASHBOARD_GUID\") { status errors { type description } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.4714,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Dashboard</em> <em>API</em> migration: from Insights <em>API</em> to NerdGraph",
        "sections": "<em>Dashboard</em> <em>API</em> migration: from Insights <em>API</em> to NerdGraph",
        "tags": "<em>Dashboards</em> <em>API</em>",
        "body": "The Insights <em>Dashboard</em> <em>API</em> is deprecated, but you can use NerdGraph (our GraphQL <em>API</em>) to create and configure <em>dashboards</em>. If you are not migrating from the old Insights <em>API</em>, you can skip this and discover the new <em>Dashboards</em> <em>API</em>. Why a new <em>dashboards</em> <em>API</em>? Our Insights product, which was a way"
      },
      "id": "60441442e7b9d2020b5799b9"
    },
    {
      "sections": [
        "Insights Dashboard API",
        "End of life notice",
        "Requirements",
        "Overview",
        "Example use cases",
        "Account and data security",
        "Use the API Explorer",
        "View Dashboard API video",
        "Use API endpoints",
        "Dashboard API schema",
        "Important",
        "Caution",
        "Example dashboard schema",
        "Dashboard data definitions",
        "Widget data definitions",
        "Supported visualizations"
      ],
      "title": "Insights Dashboard API",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Insights API"
      ],
      "external_id": "71a0104d88a3a8859513802e853850d8b0456606",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/insights-apis/insights-dashboard-api/",
      "published_at": "2021-07-08T23:10:09Z",
      "updated_at": "2021-07-08T23:10:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Do not use the Insights Dashboards API. Instead, use the New Relic One Dashboards API with NerdGraph, our GraphQL API. End of life notice The Insights Dashboard API reaches end of life in 2021. As of July 28, 2021, the CREATE and UPDATE endpoints are not available. As of August 30, 2021, the GET and DELETE endpoints are not available. To make the transition from the Insights Dashboard API to the New Relic One Dashboards API, see our migration guide. For more information, see the NerdGraph dashboards tutorial and Explorers Hub post. Requirements If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Overview The Insights Dashboard API allows you to list, create, read, update, and delete new or existing dashboards. New Relic's API Explorer includes the cURL request format, available parameters, response status codes, and JSON response structure for available API calls. Example use cases The Insights Dashboard API is a flexible solution for many different use cases. Here are a few examples of how you can leverage the Dashboard API to solve problems: Automatically create dashboards for new teams or services pre-populated with standard organization metrics and charts. Use the API to view dashboard schemas, and save them in a central repository for source control and backups. Create widget and dashboard templates to allow teams to self-service. For detailed examples and use cases, see this New Relic blog post. Account and data security The Dashboard API includes safeguards to help ensure account and data security. Requirements Comments User key and permissions Required: This API requires a user key. You cannot use your account-level REST API key to manage dashboards. Cross-account widgets You can view cross-account widgets on a dashboard by using the Insights or New Relic One dashboards UI. However, the ability to view cross-account widgets when using the Dashboard API has these restrictions: To view the list of widgets on a specific dashboard with the Dashboard API, you must use the SHOW endpoint. To view a widget in the API payload, the widget's account ID must be the same as the account ID for the payload. If the account ID is not the same, the widget's details will not be listed. Instead, the widget's payload will show: \"visualization\": \"inaccessible\" Copy Use the API Explorer To view the Dashboard API options in the API Explorer: Log in to your New Relic account. Go to rpm.newrelic.com/api/explore. From the API Explorer's Select an account and key dropdown, select a user key. Select Dashboards, then select the API function. To use API functions with existing dashboards, include the dashboard id. To find the dashboard id, select the LIST endpoint, and apply filtering options. View Dashboard API video Follow along with this step-by-step tutorial to learn how to find your API keys, create new dashboards, view and update existing dashboards via the REST API. For a step-by-step guide to using the New Relic API Explorer to manage Insights dashboards, watch this video (approximately 6 minutes). Or, go directly to the full online course about New Relic APIs. Use API endpoints The API supports the following functions for Insights dashboards only. The API does not support these functions for data apps (collections of linked dashboards). API endpoints Comments CREATE POST /v2/dashboards Create a new dashboard. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to POST more than 300 widgets will produce an error. To add more widgets to the dashboard, use the Insights UI. UPDATE PUT /v2/dashboards/:id: Update an existing dashboard for the dashboard id. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to PUT more than 300 widgets will produce an error. To add more or edit existing widgets on the dashboard, use the Insights UI. SHOW GET /v2/dashboards/:id: View an existing dashboard and all accessible widgets for the dashboard id. To help ensure data security, the SHOW function returns only the dashboard widgets that the user has permission to view. If a dashboard includes widgets that the user is not authorized to view, the API will provide a placeholder with the visualization field set to inaccessible. LIST GET /v2/dashboards?page=:page:&per_page=:count: View a paginated list of dashboards. The list shows filterable dashboard metadata only; no widgets will appear in the list. Search options include: filter[title] as substring search filter[category] (all / favorites / mine} filter[created_after] as ISO date filter[created_before] as ISO date filter[updated_after] as ISO date filter[updated_before] as ISO date Sort options include: name recently_viewed last_edited If no sort option is provided, results will be ordered by id. Pagination options include the page and per_page fields. The per_page field controls the number of results per page with a default and maximum of 100 results. The response will include a pagination Link header, which provides next page and last page links. DELETE DELETE /v2/dashboards/:id: Delete an existing dashboard indicated by the dashboard id. Dashboard API schema JSON is the only supported format. When using API functions, be sure to add .json to the end of the request URL, as shown in the API Explorer. Important Widgets have a size limit of 3x3 (height and width may not exceed 3). Caution The Dashboard API 3-column restriction also applies to the dashboards you upload to New Relic One dashboards. If you update a dashboard with a different layout using the API, the uploaded dashboard will revert to the 3-column configuration. Example dashboard schema { \"dashboard\": { \"metadata\": { \"version\": 1 }, \"title\": \"API Widget Sample\", \"icon\":\"none|archive|bar-chart|line-chart|bullseye|user|usd|money|thumbs-up|thumbs-down|cloud|bell|bullhorn|comments-o|envelope|globe|shopping-cart|sitemap|clock-o|crosshairs|rocket|users|mobile|tablet|adjust|dashboard|flag|flask|road|bolt|cog|leaf|magic|puzzle-piece|bug|fire|legal|trophy|pie-chart|sliders|paper-plane|life-ring|heart\", \"grid_column_count\": 3|12, \"visibility\": \"owner|all\", \"editable\": \"read_only|editable_by_owner|editable_by_all\", \"filter\": { \"event_types\": [ \"Transaction\" ], \"attributes\": [ \"appName\" ] }, \"widgets\": [ { \"visualization\": \"billboard|gauge|billboard_comparison\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Threshold Event Chart\", \"notes\": null, \"threshold\": { \"red\": 18000000, \"yellow\": 8000000 } }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 1 } }, { \"visualization\": \"facet_bar_chart|faceted_line_chart|facet_pie_chart|facet_table|faceted_area_chart|heatmap\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago facet appName\" } ], \"presentation\": { \"title\": \"Facet Chart\", \"notes\": null, \"drilldown_dashboard_id\": 64 }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 2 } }, { \"visualization\": \"attribute_sheet|single_event|histogram|funnel|raw_json|event_feed|event_table|uniques_list|line_chart|comparison_line_chart\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT latest(appName), latest(duration) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Simple Event Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 3 } }, { \"visualization\": \"markdown\", \"account_id\": 12345, \"data\": [ { \"source\": \"# Dashboard Note\\n\\n[link goes here](https://www.newrelic.com)\" } ], \"presentation\": { \"title\": \"\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 1 } }, { \"visualization\": \"metric_line_chart\", \"account_id\": 12345, \"data\": [ { \"duration\": 1800000, \"end_time\": null, \"entity_ids\": [ 238575 ], \"metrics\": [ { \"name\": \"Apdex\", \"units\": null, \"scope\": \"\", \"values\": [ \"score\" ] } ], \"order_by\": \"score\", \"limit\": 10 } ], \"presentation\": { \"title\": \"Metric Line Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 2 } }, ] } } Copy Dashboard data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Dashboard data element Description metadata Object Specifies the version of the dashboard schema. The version must be 1. icon String Name of an icon from the Insights icon library. grid_column_count Integer Specifies the number of columns in the grid layout. title String User-supplied title of the dashboard. filter Object Specifies configuration of the smart filter on the dashboard. visibility String Specifies who can view the dashboard in the Insights UI and the API. editable String Specifies who can edit the dashboard in the Insights UI and the API. widgets Array Array of widget data element objects. Widget data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Widget data element Description visualization String What sort of visualization to place in the widget; for example, billboard, line_chart, area chart, etc. data Array Array of objects with chart-specific information needed to query necessary data. Currently only one data object is supported. account_id Long Source account to fetch data from, if not the current account. presentation Object Object with chart title and notes, plus chart-specific customization. layout Object Object with column, row, width, and height to determine chart layout in the dashboard. Supported visualizations The Dashboard API supports: event_table line_chart facet_table facet_bar_chart facet_pie_chart billboard faceted_area_chart faceted_line_chart event_table comparison_line_chart heatmap histogram billboard_comparison attribute_sheet funnel gauge json list Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.60687,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Insights <em>Dashboard</em> <em>API</em>",
        "sections": "Insights <em>Dashboard</em> <em>API</em>",
        "tags": "Insights <em>API</em>",
        "body": "Do not use the Insights <em>Dashboards</em> <em>API</em>. Instead, use the New Relic One <em>Dashboards</em> <em>API</em> with NerdGraph, our GraphQL <em>API</em>. End of life notice The Insights <em>Dashboard</em> <em>API</em> reaches end of life in 2021. As of July 28, 2021, the CREATE and UPDATE endpoints are not available. As of August 30, 2021, the GET"
      },
      "id": "609f9c8664441fc63fd2a1f9"
    },
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-09T23:45:11Z",
      "updated_at": "2021-07-07T10:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also clone your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.820114,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, add, and share <em>dashboards</em> and charts",
        "sections": "Import, export, add, and share <em>dashboards</em> and charts",
        "tags": "<em>Dashboards</em>",
        "body": " and share charts (or other content) in a <em>dashboard</em>. Import, share, and export <em>dashboards</em> At the <em>dashboards</em> index, you can import a <em>dashboard</em> as JSON. From any <em>dashboard</em>, share it with one of these options: Copy the <em>dashboard</em>&#x27;s permalink. Copy your <em>dashboard</em> as JSON and add it to the clipboard by clicking"
      },
      "id": "60e5877828ccbc77861881cc"
    }
  ],
  "/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data": [
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Clone your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-10T03:14:27Z",
      "updated_at": "2021-07-02T20:16:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Clone your dashboard You can clone your dashboard clicking the clone icon regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. The clone has Public - Read and write permissions. Access the new, cloned dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word “copy”. For example, if you clone a dashboard named This is my dashboard, the clone is called This is my dashboard copy. You can change the name when you clone it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 335.41345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> <em>dashboard</em>",
        "sections": "Manage <em>your</em> <em>charts</em> <em>and</em> markdown content",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": "Access any of <em>your</em> New Relic One <em>dashboards</em> to create or manage <em>your</em> <em>charts</em> directly from the <em>chart</em> menu, customize <em>your</em> <em>dashboard</em>&#x27;s layout, adjust display modes, or export <em>your</em> <em>data</em>. Once you have customized <em>your</em> <em>dashboard</em> and built <em>your</em> <em>charts</em>, use our advanced visualization features and tools"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Query builder: Basic mode",
        "Important",
        "Data type",
        "Example of using basic mode",
        "Step 1: Select the source of the data for a chart",
        "Step 2: Filter the data",
        "Step 3: Adjust time range and limits",
        "Step 4: Customize the chart"
      ],
      "title": "Query builder: Basic mode",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Query builder"
      ],
      "external_id": "7f076b3909c9462829453bc59f0dae0f5d5501fd",
      "image": "https://docs.newrelic.com/static/6be4a8d2af5e02259c01e180d7f43326/58213/crop-basic-example-chart_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/query-builder/query-builder-basic-mode/",
      "published_at": "2021-07-10T03:13:37Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the New Relic One query builder in basic mode to create a chart without having to use NRQL, our querying language. The basic mode helps guides you through a query-creation process. You can choose the source of the raw data, apply filters, and use other techniques to narrow the scope of the data in the chart. Important As of September 1, 2021, we are discontinuing support of the query builder's basic mode. Instead, you can use our data explorer's user-friendly and intuitive functionality in New Relic One. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Data type The query builder basic mode has a Data type selector with two options: Events: In this context, this refers to all our non-Metric-type data, including events, logs, and trace data. Metrics: This refers to our dimensional Metric data type. You can also use this to query some types of metric timeslice data. For more on other types of metrics, see Data types. Example of using basic mode This example shows how to create a chart in basic mode. Step 1: Select the source of the data for a chart Begin by specifying what data you want to view in your chart. Click in the View a chart with box to select the event type, an attribute, and a function to perform on the attribute. You can use the event data dictionary to view information about an event type and its attributes on a single page. To see a tooltip with information about an event or attribute, hover over any term that has a dotted line underneath it. Here are the results of using the event data dictionary to specify the data: Event type. The Transaction event type measures a variety of data that describes what happens while a user is on a website, such as that user clicking on a button on a page. Attribute. The name attribute stores information on all transactions. Function. Select the unique_count function to get a count of all the transactions that occurred during the time frame. Basic mode now shows the selection: one.newrelic.com > Query builder > Basic > (event and attribute specified) As you specify data, the chart updates to show you the results from the data you specified. Based on the information specified so far, you can see a chart that shows the total number of transactions during the default time frame of 30 minutes. This total includes all transactions, whether the transaction was completed successfully or had errors. one.newrelic.com > Query builder > Basic > (event and attribute specified) Step 2: Filter the data Your next step is to determine which of those transactions got a 404 page not found error. If you look in the event data dictionary for the Transaction event type, you'll find this event also includes an attribute called httpResponseCode. Narrow the results to show only those transactions where a page not found error occurred. Use the Narrow results to box to create this filter: httpResponseCode = 404 . Because you want to be able to see the names of the apps that are resulting in the 404 errors, you use the Facet by box to see the results by appName (which is also an attribute for the Transaction event type). Faceting by appName updates the chart to break down the total number of 404 errors by the application names. This lets you know which apps are experiencing 404 errors. Your chart now shows the line chart with a line for each app, each with its own color. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) Step 3: Adjust time range and limits You decide to focus on the five apps with the most page not found errors. The default value for the Limit field is 10, meaning that your chart will show the ten most relevant returns. You change that value to 5. Customer support told you that they had been getting calls about these errors for a little over two hours. You decide to change the time range from the last 30 minutes to the last three hours so that you can view the errors during the time when the customers were calling support. Now that you have the data set so that you are seeing exactly what you need, you can turn your attention to the appearance of the chart. Step 4: Customize the chart Because you are more interested in the total number of errors than a timeline view, you change the chart type to a bar chart. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) > (time range and limit customized) > (chart type customized) When you're finished with your chart, you can add it to a dashboard or share it. This table contains notes about using basic mode. Item Description Prompts You can start typing directly in an empty box; a list of items that match the information you type will display. You can also click on an empty box to view a list of all of the items that are appropriate for the field, based on your earlier choices. Saving a basic mode data specification Every time you run a query, that query is saved in the My recent queries dropdown in advanced (NRQL) mode. Events Basic mode only supports data for one event and attribute. If you want to use more than one event and/or attribute, use the SELECT statement in advanced (NRQL) mode. Shortcuts Basic mode contains shortcuts that can display more complex events and attributes that aren't generally supported, as in this example (which shows the tooltip for the shortcut). Example of the Response time histogram shortcut, showing a tooltip. Tooltips Any time you see a dotted line under a term, you can hover over that term to see a tooltip with an explanation of the term. Narrow by You can use more than one Narrow by definition in basic mode filter; the conditions will be joined by AND. The WHERE clause in advanced (NRQL) allows OR in addition to AND. Important If your query was started using basic mode and if you make changes to that query using advanced (NRQL) mode, you cannot return to basic mode to edit that query. Any additional changes may only be made in advanced (NRQL) mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.3529,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> builder: Basic mode",
        "sections": "Step 1: Select the source of the <em>data</em> for a <em>chart</em>",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": "Use the New Relic One <em>query</em> builder in basic mode to create a <em>chart</em> without having to use NRQL, our querying language. The basic mode helps guides you through a <em>query</em>-creation process. You can choose the source of the raw <em>data</em>, apply filters, and use other techniques to narrow the scope of the <em>data</em>"
      },
      "id": "603ec319e7b9d2008c2a07e0"
    },
    {
      "sections": [
        "Explore the Public API Performance dashboard",
        "Important",
        "Add the dashboard in New Relic",
        "Explore the dashboard",
        "More about dashboards and data"
      ],
      "title": "Explore the Public API Performance dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "71646dd30d63a0c7e343f4d81061bbb27eceeb86",
      "image": "https://docs.newrelic.com/static/2c9a2621107e0114a2c345fcbb22356f/8c557/Public-API-Performance-Dash-for-GPD.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/explore-public-api-performance-dashboard/",
      "published_at": "2021-07-09T22:51:43Z",
      "updated_at": "2021-05-16T10:24:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Public API Performance dashboard is a dashboard supported by New Relic’s Global Performance data sets. It’s an out-of-the-box dashboard included as part of your New Relic account. It provides both actionable general insights about the performance of public APIs and an opportunity for new customers to test-drive New Relic’s dashboarding capabilities before adding their own data. The dashboard works by showing real latencies experienced by an anonymized sampling of New Relic customers when accessing popular public APIs. Important Global Performance data sets are presented as-is. Global Performance data sets represent an aggregate of samples across a range of sources, and New Relic makes no effort to attempt to confirm the correctness, completeness, or veracity of the data. This data should not be relied on as the sole source of information for any purpose you may use it, and New Relic is not responsible for decisions made in reliance on this data. Global Performance data sets should not be viewed as either an endorsement or a recommendation by New Relic of the technologies represented in the data sets. Add the dashboard in New Relic If the Public API Performance dashboard isn't already visible in your UI, you can add it easily. Enable the dashboard from one.newrelic.com/: New customers: The dashboard is enabled by default and added to the favorites list for all new accounts. Existing customers: If the dashboard hasn't already been enabled, you can add it by clicking your avatar and selecting Add your data. Click the Public API Performance tile to open the account selector, then click Add and view pre-built dashboard On the Public API Performance dashboard page, start exploring! Click the ... at the corner of any pane to expand charts, view queries, and more. Public API Performance dashboard Explore the dashboard Below are some suggestions for how to explore the Public API Performance dashboard. Click … in the corner of any of the charts and select View query to view the NRQL query used to create the chart. Click … in the corner of any of the charts and select Get as image to view or download any chart as an image. Select specific domains from the bar chart or add a filter by clicking the text field along the at the top of the page. If you’ve already added your own data, experiment with copying queries and modifying them for your own use. Important The Public API Performance dashboard is not currently available to EU customers. Important The Public API Performance dashboard does not currently support alerts. More about dashboards and data For more information about the Global Performance data sets that power the Public Performance API dashboard, see New Relic Global Performance data sets. For more information about New Relic dashboards, see our dashboards introduction. Customers can also dive into this data set in greater depth using our new data explorer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.68176,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Explore</em> the Public API Performance <em>dashboard</em>",
        "sections": "More about <em>dashboards</em> <em>and</em> <em>data</em>",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " API Performance <em>dashboard</em> <em>Explore</em> the <em>dashboard</em> Below are some suggestions for how to <em>explore</em> the Public API Performance <em>dashboard</em>. Click … in the corner of any of the <em>charts</em> and select View <em>query</em> to view the NRQL <em>query</em> used to create the <em>chart</em>. Click … in the corner of any of the <em>charts</em> and select"
      },
      "id": "603e97fa28ccbc013ceba7c1"
    }
  ],
  "/docs/query-your-data/explore-query-data/dashboards/explore-public-api-performance-dashboard": [
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-09T23:45:11Z",
      "updated_at": "2021-07-07T10:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also clone your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.03815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, add, <em>and</em> share <em>dashboards</em> <em>and</em> charts",
        "sections": "Add <em>and</em> share charts <em>and</em> content from <em>your</em> <em>dashboards</em>",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " on the &lt; &#x2F; &gt; icon on the right corner. Export <em>your</em> <em>dashboard</em> as a pdf file clicking the icon. You can also clone <em>your</em> <em>dashboard</em>. Add and share charts and content from <em>your</em> <em>dashboards</em> Add new content to a <em>dashboard</em> You can add new content to any <em>dashboard</em> from the <em>data</em> explorer and <em>query</em> builder"
      },
      "id": "60e5877828ccbc77861881cc"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Clone your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-10T03:14:27Z",
      "updated_at": "2021-07-02T20:16:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Clone your dashboard You can clone your dashboard clicking the clone icon regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. The clone has Public - Read and write permissions. Access the new, cloned dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word “copy”. For example, if you clone a dashboard named This is my dashboard, the clone is called This is my dashboard copy. You can change the name when you clone it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.88785,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> <em>dashboard</em>",
        "sections": "Organize <em>your</em> <em>dashboards</em> with pages",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": "Access any of <em>your</em> New Relic One <em>dashboards</em> to create or manage <em>your</em> charts directly from the chart menu, customize <em>your</em> <em>dashboard</em>&#x27;s layout, adjust display modes, or export <em>your</em> <em>data</em>. Once you have customized <em>your</em> <em>dashboard</em> and built <em>your</em> charts, use our advanced visualization features and tools"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Query builder: Basic mode",
        "Important",
        "Data type",
        "Example of using basic mode",
        "Step 1: Select the source of the data for a chart",
        "Step 2: Filter the data",
        "Step 3: Adjust time range and limits",
        "Step 4: Customize the chart"
      ],
      "title": "Query builder: Basic mode",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Query builder"
      ],
      "external_id": "7f076b3909c9462829453bc59f0dae0f5d5501fd",
      "image": "https://docs.newrelic.com/static/6be4a8d2af5e02259c01e180d7f43326/58213/crop-basic-example-chart_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/query-builder/query-builder-basic-mode/",
      "published_at": "2021-07-10T03:13:37Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the New Relic One query builder in basic mode to create a chart without having to use NRQL, our querying language. The basic mode helps guides you through a query-creation process. You can choose the source of the raw data, apply filters, and use other techniques to narrow the scope of the data in the chart. Important As of September 1, 2021, we are discontinuing support of the query builder's basic mode. Instead, you can use our data explorer's user-friendly and intuitive functionality in New Relic One. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Data type The query builder basic mode has a Data type selector with two options: Events: In this context, this refers to all our non-Metric-type data, including events, logs, and trace data. Metrics: This refers to our dimensional Metric data type. You can also use this to query some types of metric timeslice data. For more on other types of metrics, see Data types. Example of using basic mode This example shows how to create a chart in basic mode. Step 1: Select the source of the data for a chart Begin by specifying what data you want to view in your chart. Click in the View a chart with box to select the event type, an attribute, and a function to perform on the attribute. You can use the event data dictionary to view information about an event type and its attributes on a single page. To see a tooltip with information about an event or attribute, hover over any term that has a dotted line underneath it. Here are the results of using the event data dictionary to specify the data: Event type. The Transaction event type measures a variety of data that describes what happens while a user is on a website, such as that user clicking on a button on a page. Attribute. The name attribute stores information on all transactions. Function. Select the unique_count function to get a count of all the transactions that occurred during the time frame. Basic mode now shows the selection: one.newrelic.com > Query builder > Basic > (event and attribute specified) As you specify data, the chart updates to show you the results from the data you specified. Based on the information specified so far, you can see a chart that shows the total number of transactions during the default time frame of 30 minutes. This total includes all transactions, whether the transaction was completed successfully or had errors. one.newrelic.com > Query builder > Basic > (event and attribute specified) Step 2: Filter the data Your next step is to determine which of those transactions got a 404 page not found error. If you look in the event data dictionary for the Transaction event type, you'll find this event also includes an attribute called httpResponseCode. Narrow the results to show only those transactions where a page not found error occurred. Use the Narrow results to box to create this filter: httpResponseCode = 404 . Because you want to be able to see the names of the apps that are resulting in the 404 errors, you use the Facet by box to see the results by appName (which is also an attribute for the Transaction event type). Faceting by appName updates the chart to break down the total number of 404 errors by the application names. This lets you know which apps are experiencing 404 errors. Your chart now shows the line chart with a line for each app, each with its own color. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) Step 3: Adjust time range and limits You decide to focus on the five apps with the most page not found errors. The default value for the Limit field is 10, meaning that your chart will show the ten most relevant returns. You change that value to 5. Customer support told you that they had been getting calls about these errors for a little over two hours. You decide to change the time range from the last 30 minutes to the last three hours so that you can view the errors during the time when the customers were calling support. Now that you have the data set so that you are seeing exactly what you need, you can turn your attention to the appearance of the chart. Step 4: Customize the chart Because you are more interested in the total number of errors than a timeline view, you change the chart type to a bar chart. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) > (time range and limit customized) > (chart type customized) When you're finished with your chart, you can add it to a dashboard or share it. This table contains notes about using basic mode. Item Description Prompts You can start typing directly in an empty box; a list of items that match the information you type will display. You can also click on an empty box to view a list of all of the items that are appropriate for the field, based on your earlier choices. Saving a basic mode data specification Every time you run a query, that query is saved in the My recent queries dropdown in advanced (NRQL) mode. Events Basic mode only supports data for one event and attribute. If you want to use more than one event and/or attribute, use the SELECT statement in advanced (NRQL) mode. Shortcuts Basic mode contains shortcuts that can display more complex events and attributes that aren't generally supported, as in this example (which shows the tooltip for the shortcut). Example of the Response time histogram shortcut, showing a tooltip. Tooltips Any time you see a dotted line under a term, you can hover over that term to see a tooltip with an explanation of the term. Narrow by You can use more than one Narrow by definition in basic mode filter; the conditions will be joined by AND. The WHERE clause in advanced (NRQL) allows OR in addition to AND. Important If your query was started using basic mode and if you make changes to that query using advanced (NRQL) mode, you cannot return to basic mode to edit that query. Any additional changes may only be made in advanced (NRQL) mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.35272,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> builder: Basic mode",
        "sections": "<em>Query</em> builder: Basic mode",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " was completed successfully or had errors. one.newrelic.com &gt; <em>Query</em> builder &gt; Basic &gt; (event and attribute specified) Step 2: Filter the <em>data</em> <em>Your</em> next step is to determine which of those transactions got a 404 page not found error. If you look in the event <em>data</em> dictionary for the Transaction event type"
      },
      "id": "603ec319e7b9d2008c2a07e0"
    }
  ],
  "/docs/query-your-data/explore-query-data/dashboards/filter-new-relic-one-dashboards-facets": [
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-09T23:45:11Z",
      "updated_at": "2021-07-07T10:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also clone your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.03815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, add, <em>and</em> share <em>dashboards</em> <em>and</em> charts",
        "sections": "Add <em>and</em> share charts <em>and</em> content from <em>your</em> <em>dashboards</em>",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " on the &lt; &#x2F; &gt; icon on the right corner. Export <em>your</em> <em>dashboard</em> as a pdf file clicking the icon. You can also clone <em>your</em> <em>dashboard</em>. Add and share charts and content from <em>your</em> <em>dashboards</em> Add new content to a <em>dashboard</em> You can add new content to any <em>dashboard</em> from the <em>data</em> explorer and <em>query</em> builder"
      },
      "id": "60e5877828ccbc77861881cc"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Clone your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-10T03:14:27Z",
      "updated_at": "2021-07-02T20:16:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Clone your dashboard You can clone your dashboard clicking the clone icon regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. The clone has Public - Read and write permissions. Access the new, cloned dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word “copy”. For example, if you clone a dashboard named This is my dashboard, the clone is called This is my dashboard copy. You can change the name when you clone it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.88785,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> <em>dashboard</em>",
        "sections": "Organize <em>your</em> <em>dashboards</em> with pages",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": "Access any of <em>your</em> New Relic One <em>dashboards</em> to create or manage <em>your</em> charts directly from the chart menu, customize <em>your</em> <em>dashboard</em>&#x27;s layout, adjust display modes, or export <em>your</em> <em>data</em>. Once you have customized <em>your</em> <em>dashboard</em> and built <em>your</em> charts, use our advanced visualization features and tools"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Query builder: Basic mode",
        "Important",
        "Data type",
        "Example of using basic mode",
        "Step 1: Select the source of the data for a chart",
        "Step 2: Filter the data",
        "Step 3: Adjust time range and limits",
        "Step 4: Customize the chart"
      ],
      "title": "Query builder: Basic mode",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Query builder"
      ],
      "external_id": "7f076b3909c9462829453bc59f0dae0f5d5501fd",
      "image": "https://docs.newrelic.com/static/6be4a8d2af5e02259c01e180d7f43326/58213/crop-basic-example-chart_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/query-builder/query-builder-basic-mode/",
      "published_at": "2021-07-10T03:13:37Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the New Relic One query builder in basic mode to create a chart without having to use NRQL, our querying language. The basic mode helps guides you through a query-creation process. You can choose the source of the raw data, apply filters, and use other techniques to narrow the scope of the data in the chart. Important As of September 1, 2021, we are discontinuing support of the query builder's basic mode. Instead, you can use our data explorer's user-friendly and intuitive functionality in New Relic One. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Data type The query builder basic mode has a Data type selector with two options: Events: In this context, this refers to all our non-Metric-type data, including events, logs, and trace data. Metrics: This refers to our dimensional Metric data type. You can also use this to query some types of metric timeslice data. For more on other types of metrics, see Data types. Example of using basic mode This example shows how to create a chart in basic mode. Step 1: Select the source of the data for a chart Begin by specifying what data you want to view in your chart. Click in the View a chart with box to select the event type, an attribute, and a function to perform on the attribute. You can use the event data dictionary to view information about an event type and its attributes on a single page. To see a tooltip with information about an event or attribute, hover over any term that has a dotted line underneath it. Here are the results of using the event data dictionary to specify the data: Event type. The Transaction event type measures a variety of data that describes what happens while a user is on a website, such as that user clicking on a button on a page. Attribute. The name attribute stores information on all transactions. Function. Select the unique_count function to get a count of all the transactions that occurred during the time frame. Basic mode now shows the selection: one.newrelic.com > Query builder > Basic > (event and attribute specified) As you specify data, the chart updates to show you the results from the data you specified. Based on the information specified so far, you can see a chart that shows the total number of transactions during the default time frame of 30 minutes. This total includes all transactions, whether the transaction was completed successfully or had errors. one.newrelic.com > Query builder > Basic > (event and attribute specified) Step 2: Filter the data Your next step is to determine which of those transactions got a 404 page not found error. If you look in the event data dictionary for the Transaction event type, you'll find this event also includes an attribute called httpResponseCode. Narrow the results to show only those transactions where a page not found error occurred. Use the Narrow results to box to create this filter: httpResponseCode = 404 . Because you want to be able to see the names of the apps that are resulting in the 404 errors, you use the Facet by box to see the results by appName (which is also an attribute for the Transaction event type). Faceting by appName updates the chart to break down the total number of 404 errors by the application names. This lets you know which apps are experiencing 404 errors. Your chart now shows the line chart with a line for each app, each with its own color. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) Step 3: Adjust time range and limits You decide to focus on the five apps with the most page not found errors. The default value for the Limit field is 10, meaning that your chart will show the ten most relevant returns. You change that value to 5. Customer support told you that they had been getting calls about these errors for a little over two hours. You decide to change the time range from the last 30 minutes to the last three hours so that you can view the errors during the time when the customers were calling support. Now that you have the data set so that you are seeing exactly what you need, you can turn your attention to the appearance of the chart. Step 4: Customize the chart Because you are more interested in the total number of errors than a timeline view, you change the chart type to a bar chart. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) > (time range and limit customized) > (chart type customized) When you're finished with your chart, you can add it to a dashboard or share it. This table contains notes about using basic mode. Item Description Prompts You can start typing directly in an empty box; a list of items that match the information you type will display. You can also click on an empty box to view a list of all of the items that are appropriate for the field, based on your earlier choices. Saving a basic mode data specification Every time you run a query, that query is saved in the My recent queries dropdown in advanced (NRQL) mode. Events Basic mode only supports data for one event and attribute. If you want to use more than one event and/or attribute, use the SELECT statement in advanced (NRQL) mode. Shortcuts Basic mode contains shortcuts that can display more complex events and attributes that aren't generally supported, as in this example (which shows the tooltip for the shortcut). Example of the Response time histogram shortcut, showing a tooltip. Tooltips Any time you see a dotted line under a term, you can hover over that term to see a tooltip with an explanation of the term. Narrow by You can use more than one Narrow by definition in basic mode filter; the conditions will be joined by AND. The WHERE clause in advanced (NRQL) allows OR in addition to AND. Important If your query was started using basic mode and if you make changes to that query using advanced (NRQL) mode, you cannot return to basic mode to edit that query. Any additional changes may only be made in advanced (NRQL) mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.35272,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> builder: Basic mode",
        "sections": "<em>Query</em> builder: Basic mode",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " was completed successfully or had errors. one.newrelic.com &gt; <em>Query</em> builder &gt; Basic &gt; (event and attribute specified) Step 2: Filter the <em>data</em> <em>Your</em> next step is to determine which of those transactions got a 404 page not found error. If you look in the event <em>data</em> dictionary for the Transaction event type"
      },
      "id": "603ec319e7b9d2008c2a07e0"
    }
  ],
  "/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards": [
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-09T23:45:11Z",
      "updated_at": "2021-07-07T10:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also clone your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.03802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, add, <em>and</em> share <em>dashboards</em> <em>and</em> charts",
        "sections": "Add <em>and</em> share charts <em>and</em> content from <em>your</em> <em>dashboards</em>",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " on the &lt; &#x2F; &gt; icon on the right corner. Export <em>your</em> <em>dashboard</em> as a pdf file clicking the icon. You can also clone <em>your</em> <em>dashboard</em>. Add and share charts and content from <em>your</em> <em>dashboards</em> Add new content to a <em>dashboard</em> You can add new content to any <em>dashboard</em> from the <em>data</em> explorer and <em>query</em> builder"
      },
      "id": "60e5877828ccbc77861881cc"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Clone your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-10T03:14:27Z",
      "updated_at": "2021-07-02T20:16:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Clone your dashboard You can clone your dashboard clicking the clone icon regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. The clone has Public - Read and write permissions. Access the new, cloned dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word “copy”. For example, if you clone a dashboard named This is my dashboard, the clone is called This is my dashboard copy. You can change the name when you clone it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.8878,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> <em>dashboard</em>",
        "sections": "Organize <em>your</em> <em>dashboards</em> with pages",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": "Access any of <em>your</em> New Relic One <em>dashboards</em> to create or manage <em>your</em> charts directly from the chart menu, customize <em>your</em> <em>dashboard</em>&#x27;s layout, adjust display modes, or export <em>your</em> <em>data</em>. Once you have customized <em>your</em> <em>dashboard</em> and built <em>your</em> charts, use our advanced visualization features and tools"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Query builder: Basic mode",
        "Important",
        "Data type",
        "Example of using basic mode",
        "Step 1: Select the source of the data for a chart",
        "Step 2: Filter the data",
        "Step 3: Adjust time range and limits",
        "Step 4: Customize the chart"
      ],
      "title": "Query builder: Basic mode",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Query builder"
      ],
      "external_id": "7f076b3909c9462829453bc59f0dae0f5d5501fd",
      "image": "https://docs.newrelic.com/static/6be4a8d2af5e02259c01e180d7f43326/58213/crop-basic-example-chart_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/query-builder/query-builder-basic-mode/",
      "published_at": "2021-07-10T03:13:37Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the New Relic One query builder in basic mode to create a chart without having to use NRQL, our querying language. The basic mode helps guides you through a query-creation process. You can choose the source of the raw data, apply filters, and use other techniques to narrow the scope of the data in the chart. Important As of September 1, 2021, we are discontinuing support of the query builder's basic mode. Instead, you can use our data explorer's user-friendly and intuitive functionality in New Relic One. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Data type The query builder basic mode has a Data type selector with two options: Events: In this context, this refers to all our non-Metric-type data, including events, logs, and trace data. Metrics: This refers to our dimensional Metric data type. You can also use this to query some types of metric timeslice data. For more on other types of metrics, see Data types. Example of using basic mode This example shows how to create a chart in basic mode. Step 1: Select the source of the data for a chart Begin by specifying what data you want to view in your chart. Click in the View a chart with box to select the event type, an attribute, and a function to perform on the attribute. You can use the event data dictionary to view information about an event type and its attributes on a single page. To see a tooltip with information about an event or attribute, hover over any term that has a dotted line underneath it. Here are the results of using the event data dictionary to specify the data: Event type. The Transaction event type measures a variety of data that describes what happens while a user is on a website, such as that user clicking on a button on a page. Attribute. The name attribute stores information on all transactions. Function. Select the unique_count function to get a count of all the transactions that occurred during the time frame. Basic mode now shows the selection: one.newrelic.com > Query builder > Basic > (event and attribute specified) As you specify data, the chart updates to show you the results from the data you specified. Based on the information specified so far, you can see a chart that shows the total number of transactions during the default time frame of 30 minutes. This total includes all transactions, whether the transaction was completed successfully or had errors. one.newrelic.com > Query builder > Basic > (event and attribute specified) Step 2: Filter the data Your next step is to determine which of those transactions got a 404 page not found error. If you look in the event data dictionary for the Transaction event type, you'll find this event also includes an attribute called httpResponseCode. Narrow the results to show only those transactions where a page not found error occurred. Use the Narrow results to box to create this filter: httpResponseCode = 404 . Because you want to be able to see the names of the apps that are resulting in the 404 errors, you use the Facet by box to see the results by appName (which is also an attribute for the Transaction event type). Faceting by appName updates the chart to break down the total number of 404 errors by the application names. This lets you know which apps are experiencing 404 errors. Your chart now shows the line chart with a line for each app, each with its own color. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) Step 3: Adjust time range and limits You decide to focus on the five apps with the most page not found errors. The default value for the Limit field is 10, meaning that your chart will show the ten most relevant returns. You change that value to 5. Customer support told you that they had been getting calls about these errors for a little over two hours. You decide to change the time range from the last 30 minutes to the last three hours so that you can view the errors during the time when the customers were calling support. Now that you have the data set so that you are seeing exactly what you need, you can turn your attention to the appearance of the chart. Step 4: Customize the chart Because you are more interested in the total number of errors than a timeline view, you change the chart type to a bar chart. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) > (time range and limit customized) > (chart type customized) When you're finished with your chart, you can add it to a dashboard or share it. This table contains notes about using basic mode. Item Description Prompts You can start typing directly in an empty box; a list of items that match the information you type will display. You can also click on an empty box to view a list of all of the items that are appropriate for the field, based on your earlier choices. Saving a basic mode data specification Every time you run a query, that query is saved in the My recent queries dropdown in advanced (NRQL) mode. Events Basic mode only supports data for one event and attribute. If you want to use more than one event and/or attribute, use the SELECT statement in advanced (NRQL) mode. Shortcuts Basic mode contains shortcuts that can display more complex events and attributes that aren't generally supported, as in this example (which shows the tooltip for the shortcut). Example of the Response time histogram shortcut, showing a tooltip. Tooltips Any time you see a dotted line under a term, you can hover over that term to see a tooltip with an explanation of the term. Narrow by You can use more than one Narrow by definition in basic mode filter; the conditions will be joined by AND. The WHERE clause in advanced (NRQL) allows OR in addition to AND. Important If your query was started using basic mode and if you make changes to that query using advanced (NRQL) mode, you cannot return to basic mode to edit that query. Any additional changes may only be made in advanced (NRQL) mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.35254,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> builder: Basic mode",
        "sections": "<em>Query</em> builder: Basic mode",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " was completed successfully or had errors. one.newrelic.com &gt; <em>Query</em> builder &gt; Basic &gt; (event and attribute specified) Step 2: Filter the <em>data</em> <em>Your</em> next step is to determine which of those transactions got a 404 page not found error. If you look in the event <em>data</em> dictionary for the Transaction event type"
      },
      "id": "603ec319e7b9d2008c2a07e0"
    }
  ],
  "/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard": [
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-09T23:45:11Z",
      "updated_at": "2021-07-07T10:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also clone your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.03802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, add, <em>and</em> share <em>dashboards</em> <em>and</em> charts",
        "sections": "Add <em>and</em> share charts <em>and</em> content from <em>your</em> <em>dashboards</em>",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " on the &lt; &#x2F; &gt; icon on the right corner. Export <em>your</em> <em>dashboard</em> as a pdf file clicking the icon. You can also clone <em>your</em> <em>dashboard</em>. Add and share charts and content from <em>your</em> <em>dashboards</em> Add new content to a <em>dashboard</em> You can add new content to any <em>dashboard</em> from the <em>data</em> explorer and <em>query</em> builder"
      },
      "id": "60e5877828ccbc77861881cc"
    },
    {
      "sections": [
        "Query builder: Basic mode",
        "Important",
        "Data type",
        "Example of using basic mode",
        "Step 1: Select the source of the data for a chart",
        "Step 2: Filter the data",
        "Step 3: Adjust time range and limits",
        "Step 4: Customize the chart"
      ],
      "title": "Query builder: Basic mode",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Query builder"
      ],
      "external_id": "7f076b3909c9462829453bc59f0dae0f5d5501fd",
      "image": "https://docs.newrelic.com/static/6be4a8d2af5e02259c01e180d7f43326/58213/crop-basic-example-chart_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/query-builder/query-builder-basic-mode/",
      "published_at": "2021-07-10T03:13:37Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the New Relic One query builder in basic mode to create a chart without having to use NRQL, our querying language. The basic mode helps guides you through a query-creation process. You can choose the source of the raw data, apply filters, and use other techniques to narrow the scope of the data in the chart. Important As of September 1, 2021, we are discontinuing support of the query builder's basic mode. Instead, you can use our data explorer's user-friendly and intuitive functionality in New Relic One. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Data type The query builder basic mode has a Data type selector with two options: Events: In this context, this refers to all our non-Metric-type data, including events, logs, and trace data. Metrics: This refers to our dimensional Metric data type. You can also use this to query some types of metric timeslice data. For more on other types of metrics, see Data types. Example of using basic mode This example shows how to create a chart in basic mode. Step 1: Select the source of the data for a chart Begin by specifying what data you want to view in your chart. Click in the View a chart with box to select the event type, an attribute, and a function to perform on the attribute. You can use the event data dictionary to view information about an event type and its attributes on a single page. To see a tooltip with information about an event or attribute, hover over any term that has a dotted line underneath it. Here are the results of using the event data dictionary to specify the data: Event type. The Transaction event type measures a variety of data that describes what happens while a user is on a website, such as that user clicking on a button on a page. Attribute. The name attribute stores information on all transactions. Function. Select the unique_count function to get a count of all the transactions that occurred during the time frame. Basic mode now shows the selection: one.newrelic.com > Query builder > Basic > (event and attribute specified) As you specify data, the chart updates to show you the results from the data you specified. Based on the information specified so far, you can see a chart that shows the total number of transactions during the default time frame of 30 minutes. This total includes all transactions, whether the transaction was completed successfully or had errors. one.newrelic.com > Query builder > Basic > (event and attribute specified) Step 2: Filter the data Your next step is to determine which of those transactions got a 404 page not found error. If you look in the event data dictionary for the Transaction event type, you'll find this event also includes an attribute called httpResponseCode. Narrow the results to show only those transactions where a page not found error occurred. Use the Narrow results to box to create this filter: httpResponseCode = 404 . Because you want to be able to see the names of the apps that are resulting in the 404 errors, you use the Facet by box to see the results by appName (which is also an attribute for the Transaction event type). Faceting by appName updates the chart to break down the total number of 404 errors by the application names. This lets you know which apps are experiencing 404 errors. Your chart now shows the line chart with a line for each app, each with its own color. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) Step 3: Adjust time range and limits You decide to focus on the five apps with the most page not found errors. The default value for the Limit field is 10, meaning that your chart will show the ten most relevant returns. You change that value to 5. Customer support told you that they had been getting calls about these errors for a little over two hours. You decide to change the time range from the last 30 minutes to the last three hours so that you can view the errors during the time when the customers were calling support. Now that you have the data set so that you are seeing exactly what you need, you can turn your attention to the appearance of the chart. Step 4: Customize the chart Because you are more interested in the total number of errors than a timeline view, you change the chart type to a bar chart. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) > (time range and limit customized) > (chart type customized) When you're finished with your chart, you can add it to a dashboard or share it. This table contains notes about using basic mode. Item Description Prompts You can start typing directly in an empty box; a list of items that match the information you type will display. You can also click on an empty box to view a list of all of the items that are appropriate for the field, based on your earlier choices. Saving a basic mode data specification Every time you run a query, that query is saved in the My recent queries dropdown in advanced (NRQL) mode. Events Basic mode only supports data for one event and attribute. If you want to use more than one event and/or attribute, use the SELECT statement in advanced (NRQL) mode. Shortcuts Basic mode contains shortcuts that can display more complex events and attributes that aren't generally supported, as in this example (which shows the tooltip for the shortcut). Example of the Response time histogram shortcut, showing a tooltip. Tooltips Any time you see a dotted line under a term, you can hover over that term to see a tooltip with an explanation of the term. Narrow by You can use more than one Narrow by definition in basic mode filter; the conditions will be joined by AND. The WHERE clause in advanced (NRQL) allows OR in addition to AND. Important If your query was started using basic mode and if you make changes to that query using advanced (NRQL) mode, you cannot return to basic mode to edit that query. Any additional changes may only be made in advanced (NRQL) mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.35254,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> builder: Basic mode",
        "sections": "<em>Query</em> builder: Basic mode",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " was completed successfully or had errors. one.newrelic.com &gt; <em>Query</em> builder &gt; Basic &gt; (event and attribute specified) Step 2: Filter the <em>data</em> <em>Your</em> next step is to determine which of those transactions got a 404 page not found error. If you look in the event <em>data</em> dictionary for the Transaction event type"
      },
      "id": "603ec319e7b9d2008c2a07e0"
    },
    {
      "sections": [
        "Introduction to dashboards",
        "Tip",
        "Why it matters",
        "Transitioning from Insights",
        "Get started with dashboards",
        "Create a dashboard",
        "Import a dashboard",
        "Clone a dashboard",
        "Delete a dashboard",
        "Mark a dashboard as favorite",
        "Search and sort dashboards",
        "Dashboard permissions",
        "Organize your dashboards with tags",
        "Key visual tools",
        "Consistent chart coloring",
        "Correlated needle",
        "Data scrubber",
        "Brush to zoom",
        "Custom visualizations"
      ],
      "title": "Introduction to dashboards",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "caf20070eae1529315d1e0642bd2f853e2872b77",
      "image": "https://docs.newrelic.com/static/c9724f76b9c3ad86f9a22abab501a2af/c1b63/dashboards_intro.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/introduction-dashboards/",
      "published_at": "2021-07-09T22:38:51Z",
      "updated_at": "2021-05-22T05:25:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Envision your data as a complex system of roads: you need to navigate the signs and signals along the way to quickly see and make meaning of the information you collect. New Relic One dashboards gather and chart the specific data you want to see, the way you want to see it, from anywhere in the New Relic platform. Tip To use dashboards and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters With New Relic One dashboards you can customize and understand the data you collect. Explore your data and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of your system and applications for faster, more efficient troubleshooting. Use dashboards to: Drive insight with custom, high-density interactive visualizations with a consistent UI. View dashboards across your organization using cross-account search. Chart all the events and attributes from everywhere across our platform. For more information, see Data collection. Add custom attributes or send custom event types to most events in order to better understand your business, and see specific details about how your customers interact with your platform, such as page views, host transactions, etc. Manage your charts and dashboards easily using our quick-access CRUD menus and editing options. Explore and contextualize data with advanced tooltips and zoom-in functions to monitor what your systems are doing in real time. Search your dashboards for attributes and metrics. Send data to your dashboards using our APIs. Transitioning from Insights Switching to using New Relic One dashboards from our deprecated Insights dashboards? See our transition guide. If you're using the Insights Dashboard API, we have have a migration guide that will help you transition to using the new API. Get started with dashboards To access dashboards, go to one.newrelic.com and click on Dashboards on the top navigation menu. In the dashboards index, you can view all the dashboards and data apps associated with your New Relic account. This includes the dashboards you've created within the New Relic One platform as well as the dashboards built in Insights. From the top bar, quickly access our explorer as well as all New Relic capabilities, such as APM, Browser and Infrastructure monitoring, Logs, or Applied Intelligence. You can also use the core New Relic One features such as Search or Query your data that are available across the platform. For each dashboard, the index displays the following information: Favorite status, indicated by a star Name: The name of the dashboard Account: The account the dashboard belongs to Created by: The user who created the dashboard Last edited: When the dashboard was last modified Created on: When the dashboard was created Here you can carry out the following actions: Create a dashboard You can easily create a dashboard in New Relic One from the dashboards index by selecting the + Create a dashboard button located at the top-right corner of the dashboards index. Name your dashboard. Names are searchable, so we recommend giving it a meaningful name (your service or application, for instance) using words that will help you locate your dashboard easily. Select the account the dashboard belongs to. Choose carefully because this action cannot be modified. Press Create to continue, or Cancel to return to the index. Tip By default a dashboard is created with Public - Read and write permissions. You can edit them from the settings menu once you access the dashboard. Alternatively, you can also create a new dashboard: By cloning an existing dashboard. From any chart: Copy any chart from any dashboard to a new or an existing dashboard. From the data explorer or the query builder: Add any chart you create from our querying features to a new or an existing dashboard. From the explorer: Take any custom view from the entity manager over to dashboards. To organize dashboards with multiple pages, see Add pages to a dashboard. Import a dashboard You can import a dashboard as JSON by selecting the Import a dashboard button located at the top-right corner of the dashboards index: Paste the JSON code. By default, the dashboard belongs to the same account as the original dashboard you’re importing. Select a different account if you want to change it. By default, the new dashboard has the same rights as the original dashboard you’re importing. Select different rights if you want to change them. Tip See how to obtain a dashboard’s JSON. Clone a dashboard Clone any dashboard by clicking the Clone dashboard button that appears when you hover over any dashboard row in the index. You can clone any dashboard regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. Access the new dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word \"copy\". For example, if you clone a dashboard named this is my dashboard, the clone will be created as this is my dashboard copy. The clone has Public - Read and write permissions. You can edit the name and other properties of the dashboard, like the permissions, at any time. Tip The index displays dashboards according to sorting. To quickly find your cloned dashboard, sort the dashboards by creation date. The new dashboard appears on top. Delete a dashboard To delete a dashboard, hover over the dashboard row at the index until the Delete button appears. You can only delete a dashboard if you created it, or if it has Public - Read and write permissions. For more information, see the permissions information. You can also delete a dashboard from the settings panel of the dashboard. Mark a dashboard as favorite Clicking the star icon next to a dashboard toggles on or off the favorites. When you favorite a dashboard, it’s grouped with other favorite dashboards at the top of the list, and appears on the New Relic One home page. To remove a dashboard from your favorites, select the star icon again. New Relic One doesn’t retrieve favorited dashboards from Insights. Learn how to make the transition from Insights to New Relic One. Search and sort dashboards You can search dashboards by dashboard name and author using the search box above the index. You can also sort the dashboards in the index. By default, dashboards you edited recently are at the top of the index in both the favorited and non-favorited sections. To change this order, you can sort both sections by any of the columns in the index, your most recent sort is displayed next time you access New Relic One. Dashboard permissions Dashboards have three types of permissions: Public - Read and write: All users have full rights to the dashboard. Public - Read only: All users are able to see the dashboard, but only you have full rights to work with the dashboard. Other users can access the dashboard but are not able to edit or delete it, although they can clone it. Private: Only you can see the dashboard. When you create a dashboard using the Create a dashboard button or by cloning another dashboard, it will have Public - Read and write rights by default. Access the new dashboard to change this setting. Organize your dashboards with tags You can add tags using our NerdGraph, our tagging API. You can also filter your dashboards by tags, which you can use to identify users, accounts, locations, etc. Click on the tag filter to see the available tags, you can easily select one or more tags from the list to narrow down the dashboards in the index. Key visual tools Dashboards offer intuitive visualization features and tools for advanced data exploration and fast troubleshooting. Consistent chart coloring So that you can quickly see and correlate your data, facets that you apply to more than one chart in a dashboard have a consistent facet color across all the charts. Correlated needle When you mouse over one chart, the correlated needle overlays across all charts or data points in the dashboard at the same time. The tooltip provides the relevant data points from the selected facet, such as maximum and minimum values in a line chart. It also highlights the selected attribute in a pie chart. Data scrubber The chart scrubber helps you select a data point or facet in a chart when the chart is too crowded and facets are too close to each other. Mouse along the needle to smoothly select the adjacent facets and view their associated data points. You can also lighten a heavily populated chart by unselecting one or more of the attributes that appear in the UI. Brush to zoom Drag to select a time segment on any chart and you automatically zoom to that time period on all the charts in the dashboard. The time picker reflects the new period on display in the dashboard. You can return to the default or any other time settings at any time. Custom visualizations You can also make custom visualizations for your dashboards. These enable you to include information from any data source. To learn more about working with custom visualizations, see Build a custom visualization for dashboards and Add custom visualizations to your dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.86462,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>dashboards</em>",
        "sections": "Organize <em>your</em> <em>dashboards</em> with tags",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " and understand the <em>data</em> you collect. <em>Explore</em> <em>your</em> <em>data</em> and correlate connected sources with tailored, user-friendly charts, and quickly learn the state of <em>your</em> system and applications for faster, more efficient troubleshooting. Use <em>dashboards</em> to: Drive insight with custom, high-density interactive"
      },
      "id": "603ec16028ccbc8d07eba78d"
    }
  ],
  "/docs/query-your-data/explore-query-data/dashboards/new-relic-global-performance-data-sets": [
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-09T23:45:11Z",
      "updated_at": "2021-07-07T10:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also clone your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.03787,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, add, <em>and</em> share <em>dashboards</em> <em>and</em> charts",
        "sections": "Add <em>and</em> share charts <em>and</em> content from <em>your</em> <em>dashboards</em>",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " on the &lt; &#x2F; &gt; icon on the right corner. Export <em>your</em> <em>dashboard</em> as a pdf file clicking the icon. You can also clone <em>your</em> <em>dashboard</em>. Add and share charts and content from <em>your</em> <em>dashboards</em> Add new content to a <em>dashboard</em> You can add new content to any <em>dashboard</em> from the <em>data</em> explorer and <em>query</em> builder"
      },
      "id": "60e5877828ccbc77861881cc"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Clone your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-10T03:14:27Z",
      "updated_at": "2021-07-02T20:16:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Clone your dashboard You can clone your dashboard clicking the clone icon regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. The clone has Public - Read and write permissions. Access the new, cloned dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word “copy”. For example, if you clone a dashboard named This is my dashboard, the clone is called This is my dashboard copy. You can change the name when you clone it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.8877,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> <em>dashboard</em>",
        "sections": "Organize <em>your</em> <em>dashboards</em> with pages",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": "Access any of <em>your</em> New Relic One <em>dashboards</em> to create or manage <em>your</em> charts directly from the chart menu, customize <em>your</em> <em>dashboard</em>&#x27;s layout, adjust display modes, or export <em>your</em> <em>data</em>. Once you have customized <em>your</em> <em>dashboard</em> and built <em>your</em> charts, use our advanced visualization features and tools"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Query builder: Basic mode",
        "Important",
        "Data type",
        "Example of using basic mode",
        "Step 1: Select the source of the data for a chart",
        "Step 2: Filter the data",
        "Step 3: Adjust time range and limits",
        "Step 4: Customize the chart"
      ],
      "title": "Query builder: Basic mode",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Query builder"
      ],
      "external_id": "7f076b3909c9462829453bc59f0dae0f5d5501fd",
      "image": "https://docs.newrelic.com/static/6be4a8d2af5e02259c01e180d7f43326/58213/crop-basic-example-chart_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/query-builder/query-builder-basic-mode/",
      "published_at": "2021-07-10T03:13:37Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the New Relic One query builder in basic mode to create a chart without having to use NRQL, our querying language. The basic mode helps guides you through a query-creation process. You can choose the source of the raw data, apply filters, and use other techniques to narrow the scope of the data in the chart. Important As of September 1, 2021, we are discontinuing support of the query builder's basic mode. Instead, you can use our data explorer's user-friendly and intuitive functionality in New Relic One. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Data type The query builder basic mode has a Data type selector with two options: Events: In this context, this refers to all our non-Metric-type data, including events, logs, and trace data. Metrics: This refers to our dimensional Metric data type. You can also use this to query some types of metric timeslice data. For more on other types of metrics, see Data types. Example of using basic mode This example shows how to create a chart in basic mode. Step 1: Select the source of the data for a chart Begin by specifying what data you want to view in your chart. Click in the View a chart with box to select the event type, an attribute, and a function to perform on the attribute. You can use the event data dictionary to view information about an event type and its attributes on a single page. To see a tooltip with information about an event or attribute, hover over any term that has a dotted line underneath it. Here are the results of using the event data dictionary to specify the data: Event type. The Transaction event type measures a variety of data that describes what happens while a user is on a website, such as that user clicking on a button on a page. Attribute. The name attribute stores information on all transactions. Function. Select the unique_count function to get a count of all the transactions that occurred during the time frame. Basic mode now shows the selection: one.newrelic.com > Query builder > Basic > (event and attribute specified) As you specify data, the chart updates to show you the results from the data you specified. Based on the information specified so far, you can see a chart that shows the total number of transactions during the default time frame of 30 minutes. This total includes all transactions, whether the transaction was completed successfully or had errors. one.newrelic.com > Query builder > Basic > (event and attribute specified) Step 2: Filter the data Your next step is to determine which of those transactions got a 404 page not found error. If you look in the event data dictionary for the Transaction event type, you'll find this event also includes an attribute called httpResponseCode. Narrow the results to show only those transactions where a page not found error occurred. Use the Narrow results to box to create this filter: httpResponseCode = 404 . Because you want to be able to see the names of the apps that are resulting in the 404 errors, you use the Facet by box to see the results by appName (which is also an attribute for the Transaction event type). Faceting by appName updates the chart to break down the total number of 404 errors by the application names. This lets you know which apps are experiencing 404 errors. Your chart now shows the line chart with a line for each app, each with its own color. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) Step 3: Adjust time range and limits You decide to focus on the five apps with the most page not found errors. The default value for the Limit field is 10, meaning that your chart will show the ten most relevant returns. You change that value to 5. Customer support told you that they had been getting calls about these errors for a little over two hours. You decide to change the time range from the last 30 minutes to the last three hours so that you can view the errors during the time when the customers were calling support. Now that you have the data set so that you are seeing exactly what you need, you can turn your attention to the appearance of the chart. Step 4: Customize the chart Because you are more interested in the total number of errors than a timeline view, you change the chart type to a bar chart. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) > (time range and limit customized) > (chart type customized) When you're finished with your chart, you can add it to a dashboard or share it. This table contains notes about using basic mode. Item Description Prompts You can start typing directly in an empty box; a list of items that match the information you type will display. You can also click on an empty box to view a list of all of the items that are appropriate for the field, based on your earlier choices. Saving a basic mode data specification Every time you run a query, that query is saved in the My recent queries dropdown in advanced (NRQL) mode. Events Basic mode only supports data for one event and attribute. If you want to use more than one event and/or attribute, use the SELECT statement in advanced (NRQL) mode. Shortcuts Basic mode contains shortcuts that can display more complex events and attributes that aren't generally supported, as in this example (which shows the tooltip for the shortcut). Example of the Response time histogram shortcut, showing a tooltip. Tooltips Any time you see a dotted line under a term, you can hover over that term to see a tooltip with an explanation of the term. Narrow by You can use more than one Narrow by definition in basic mode filter; the conditions will be joined by AND. The WHERE clause in advanced (NRQL) allows OR in addition to AND. Important If your query was started using basic mode and if you make changes to that query using advanced (NRQL) mode, you cannot return to basic mode to edit that query. Any additional changes may only be made in advanced (NRQL) mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.35233,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> builder: Basic mode",
        "sections": "<em>Query</em> builder: Basic mode",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " was completed successfully or had errors. one.newrelic.com &gt; <em>Query</em> builder &gt; Basic &gt; (event and attribute specified) Step 2: Filter the <em>data</em> <em>Your</em> next step is to determine which of those transactions got a 404 page not found error. If you look in the event <em>data</em> dictionary for the Transaction event type"
      },
      "id": "603ec319e7b9d2008c2a07e0"
    }
  ],
  "/docs/query-your-data/explore-query-data/get-started/introduction-querying-new-relic-data": [
    {
      "sections": [
        "New Relic data types",
        "Get started",
        "Tip",
        "Metrics",
        "Metrics in the monitoring industry",
        "Metrics at New Relic",
        "Dimensional metrics (used by Metric API and many integrations)",
        "Metric timeslice data (used by APM, browser, mobile)",
        "Metric timeslice examples",
        "Metrics attached to events (used by Infrastructure, other products)",
        "Metrics as a computation of events (used in some charts and queries)",
        "Event data",
        "Events in the monitoring industry",
        "Events at New Relic",
        "Log data",
        "Logs in the monitoring industry",
        "Logs at New Relic",
        "Trace data",
        "Tracing in the monitoring industry",
        "Tracing at New Relic",
        "Query and send data",
        "Learn more"
      ],
      "title": "New Relic data types",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Understand data"
      ],
      "external_id": "0953dd677c1ed3c5a7f477f7b7872f89580df53c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/understand-data/new-relic-data-types/",
      "published_at": "2021-07-09T03:40:24Z",
      "updated_at": "2021-07-09T03:40:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic platform is built around the four fundamental telemetry data types we believe are necessary for complete and effective system monitoring: metrics, events, logs, and traces. Get started This doc will give you a fairly technical explanation of our core data types, their structure, and how they're used in our features. You can use most of our features without needing to understand the underlying data structure. But having a better understanding of this can help you get data into New Relic, understand the data you see in our UI, and query your data. For a simpler explanation of these data types using real-world examples, see Introduction to essential telemetry data types. Another good way to understand your data is to just start querying it. Tip Access your data easily on one.newrelic.com: Click the Browse data dropdown menu and select the data type (metrics, events, logs, and traces) you want to explore. Metrics First, we’ll explain the definition of metrics from a monitoring industry perspective, and then we’ll explain how New Relic handles metrics. For a list of the metrics we collect, see our documentation on metrics. Metrics in the monitoring industry In the software monitoring industry, a metric means a numeric measurement of an application or system. Metrics are typically reported on a regular schedule. Two major types of metrics are: Aggregated data. For example: a count of events over one minute’s time, or the rate of some event per minute. A numeric status at a moment in time. For example: a CPU temperature reading, or a “CPU% used” status. Metrics are relatively easy to report and store because a single record can represent a range of time. They can also be aggregated more and more over time. For example, per-minute data may be “rolled up” to per-hour aggregations after some amount of time, and eventually may be rolled up to a per-day aggregation. This approach is efficient for long-term data storage. Metrics are a strong solution for storing data long-term, and understanding trends over time. One potential downside is that it can be difficult to do detailed analysis of older data that has been aggregated over time; when high detail is required about specific important actions, event data can be used. Metrics at New Relic Conceptually, \"metrics\" is a broad, general category. There are various ways New Relic measures and reports metrics but, in practice, when using the New Relic UI, you usually won't have to understand how exactly this happens. In our documentation, we typically will just refer to \"metrics,\" regardless of how that data is reported, unless there's a reason you need to know more (like understanding how to query your data). Here are some of the ways metrics are reported and stored across the New Relic platform: Dimensional metrics (used by Metric API and many integrations) In the monitoring industry, \"dimensional\" metrics refer to metric data that has a variety of attributes (dimensions) attached, such as duration-related attributes (start time, end time), entity ID, region, host, etc. This amount of detail allows for in-depth analysis and querying. At New Relic, this metric data is attached to the Metric data type and is sent from several sources: Some open-source integrations, like our Prometheus and OpenCensus exporters Our Telemetry SDKs Infrastructure services The Metric API (the underlying API used by the above tools) The events-to-metrics service To query this data and see its attributes (\"dimensions\"), you could use a NRQL query like: Select * from Metric Copy As time passes, these metrics are increasingly aggregated into larger time buckets. This is done to optimize your ability to query data over a long period of time. For more details about the metric data type, see our docs. To learn how this data is ingested and stored, see the Metric API documentation. For tips on querying, see Metric query examples. Metric timeslice data (used by APM, browser, mobile) New Relic's APM, browser, and mobile report and display metrics in a simple data format that we refer to as metric timeslice data. A metric timeslice consists of three parts: a metric name, the segment of time the metric represents (the \"timeslice\"), and a numeric value (the measurement). For example: an APM metric timeslice for time spent in a particular transaction is named WebTransaction/URI/foo, and might have a response time of 0.793 for a one-minute time slice from 10:20am to 10:21am. These metrics usually follow a pattern like <category>/<class>/<method>. Our agents (APM, browser, and mobile) can collect thousands of metric timeslices per minute for a variety of performance metrics. For example: error rate, bandwidth usage, and garbage collection time. You also have the ability to create custom metrics. Metric timeslice data is a lightweight data type and lacks the detail that dimensional metrics have. Ways to explore and query metric timeslice data: For APM: metric timeslice data is converted to dimensional metrics and can be queried via NRQL Use the REST API If you want to learn more about the structure of metric timeslice data and see some examples, expand the collapser below. Metric timeslice examples Here are some common metric timeslice data examples, with a focus on common ones used by Ruby applications. ActiveMerchant New Relic tracks a variety of metrics on ActiveMerchant transactions which can be used for business analytics as well as performance monitoring. The metrics are summarized by operation as well as by gateway. regex sample metric legend name ActiveMerchant/. * ActiveMerchant/PayJunctionGateway ActiveMerchant/gateway/. * ActiveMerchant/gateway/PayJunctionGateway/purchase PayJunctionGateway ActiveMerchant/operation/. * ActiveMerchant/operation/purchase purchase For more information, see the ActiveMerchant website. ActiveRecord ActiveRecord is the Object-Relational Mapping API used by Ruby on Rails applications. The metrics shown here measure the performance of ActiveRecord's find and save methods. regex sample metric legend name ActiveRecord/. * /find ActiveRecord/User/find User#find ActiveRecord/. * /save ActiveRecord/Product/save Product#save For more information, see the API documentation for ActiveRecord. Apdex Apdex is a measure of user satisfaction with page load times. Controller In Ruby on Rails applications, HTTP requests are handled by Controller actions. A Rails application has many controllers, each of which has one or more actions. When your rails application receives an http request, that request is routed to the appropriate controller and action, based on the URL of that request. That action then does whatever processing is neccesary to generate an http response, which is most often a web page, but could also be a page fragment, an xml document, or any other kind of data that is requested by the client. The following metrics track the performance of controller actions, regardless of routing, and without taking into account any network or web server effects. regex sample metric legend name Controller/. * Controller/Users/show /Users/show Controller/. * /(?! \\ (other \\ )). * Controller/Users/show /Users/show Controller$ Controller All Controller Actions ControllerCPU/ ControllerCPU/Users/Show /Users/show For more information, see the API documentation for ActionController. Errors This metric tracks the number of errors or exceptions raised while processing requests. regex sample metric legend name Errors/all Errors/all External services External service instrumentation captures calls to out-of-process services such as web services, resources in the cloud and any other network calls. It does not include other first class back-end components such as MemCache and the database. In Ruby applications we instrument the Net::Http library to capture all HTTP services. regex sample metric legend name External/ [ ^/]+/all$ External/service.example.com/all All service.example.com calls External/ External/host.aws.com/Net::Http : :POST Net::Http : :POST [ host.aws.com] External/all$ External/all External Services External/ [ ^/]+/(?!all)/ External/service.example.com/all All service.example.com calls HTTP dispatcher This metric represents a summary of the throughput and response time of all web requests. regex sample metric legend name ^HttpDispatcher$ HttpDispatcher HttpDispatcher MemCache MemCache is a popular technology that enables applications to access shared memory provided by any number of physical machines as a global cache. Applications that heavily use the database often use MemCache for performance and scalability benefits. These metrics measure the frequency and response time of calls to MemCache to read and write data from the cache. Response times should be low (less than 5 ms) for a well performing MemCache deployment. regex sample metric legend name MemCache/. * MemCache/read MemCache read operations MemCache/read MemCache/read MemCache read operations MemCache/write MemCache/write MemCache write operations Mongrel This metric measures the length of the mongrel queue, which holds pending http requests to be processed by mongrel. The HTTP Activity graph overlays the maximimum queue length for a given period. The value is zero if mongrel is processing a request but has no other requests waiting in its queue. When looking at this value across an aggregate cluster of mongrels, the queue lengths of all mongrels is added together, showing the sum of all queue lengths. A mongrel queue length should be at or near zero; if it is consistently at a higher level, then it indicates that your rails application is having trouble keeping up with its load requirements. regex sample metric legend name Mongrel/Queue Length Mongrel/Queue Length Queue Length View ActionView is a package in Rails that is used to render the output that is the response to an http request, such as an html page or an xml document. The View is rendered by the controller that is handling the request. If View metrics represent a large portion of your controller's response time, it could mean you are doing a lot of database operations inside the view template itself. regex sample metric legend name View/. * View/Users/ _ child.html.erb/Partial Users/ _ child.html.erb View/. * /Partial View/Users/ _ child.html.erb/Partial Users/ _ child.html.erb View/. * /Rendering View/Users/show.html.erb/Rendering Users/show.html.erb For more information, see the API documentation for ActionView. Metrics attached to events (used by Infrastructure, other products) Because event-type data can have any type of key-value pair data attached to it, one way metrics can be reported is as attributes attached to an event. A couple examples of this at New Relic: Our infrastructure monitoring reports many metrics that are attached to events. For example, we report a ProcessSample event, which has various sample-based metrics attached to it, like CPU percentage. To learn more about infrastructure monitoring data, see Infrastructure data. In APM, the Transaction event has several metrics attached to it, including databaseDuration. To learn more about this data and how to query it, see Events. Metrics as a computation of events (used in some charts and queries) Metrics can be formed by counting New Relic events, or doing some other mathematical calculation on those events. For example, if you wanted to measure the total number of Transaction events over the last half hour, you might run this NRQL query: Select count(*) from Transaction since 30 minutes ago Copy Another example: if you wanted to compute the average response time for your service, you might run a query like: FROM Transaction SELECT average(duration) SINCE 30 minutes ago Copy Some New Relic charts are generated with these kinds of queries. The downside of this approach is that there are limits on how many events a monitoring system (including ours) can report. This means that sometimes, for high-throughput systems, the count may not accurately represent the total activity on that system. To learn more about how this can be addressed, see Event limits and sampling. Want to report custom metrics? See Get data into New Relic. Event data First, we’ll explain the definition of events from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles event data. Events in the monitoring industry In the software industry, events can be thought of as simply “things that occur in a system.” For example, a server setting being changed would be an event. Another example: a website user clicking a mouse. Some events will generate a stored record, and that record is typically also called an event. Event data represents discrete occurrences and typically will have a high level of detail, so event data is suited for detailed analysis and querying. The downside to the use of event data is that there are typically so many events reported that it can become difficult to query that large dataset over longer time ranges. Events at New Relic At New Relic, we report events to data objects also called events. These events have multiple attributes (key-value pairs) attached. Event data is used in some UI charts and tables, and you can also query it. How long event data remains available is determined by data retention rules. One example of an event: APM reports an event type named Transaction, which represents a logical unit of work in an application. To see the attributes attached to this event, you could use a NRQL query like: Select * from Transaction Copy For examples of querying event data, see Introduction to NRQL. Other details about New Relic event data: Events can have any type of attributes attached. Some events have attributes that report metric data. You can report custom events. To increase the availability of your event data for querying/charting, you can turn events into metrics. Some systems generate a large number of events that exceeds collection limits and results in incomplete query results. For more on this, see Event sampling. Because event is a general term, in some New Relic contexts it will refer to any data type that can be queried via NRQL. For example, when you run a NRQL query, it returns a count of inspected events: this is a count of all data types queried. Log data First, we’ll explain the definition of logs from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles log reporting. Logs in the monitoring industry A log is a message about a system used to understand the activity of the system and to diagnose problems. Logs at New Relic New Relic's Logs gives you a centralized log management platform that connects your log data with other New Relic-monitored data. For example, you can see logs alongside your APM data. In New Relic, log data is reported with multiple attributes (key-value data) attached. To query your log data, you could use a NRQL query like: Select * from Log Copy To report custom log data, see the Log API. Trace data First, we’ll explain the definition of traces from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles tracing. Tracing in the monitoring industry In the application/infrastructure-monitoring world, tracing is a general term used to refer to various ways to report information about how a program or system is operating. For example, a stack trace provides in-depth information about a program’s subroutines. For large modern systems, which are often distributed across many services and micro-services, “tracing” often refers to distributed tracing, which is a way to monitor requests as they propagate through a complex, distributed environment. Tracing at New Relic New Relic offers a distributed tracing feature that tracks requests across a distributed system, and provides a dedicated UI for understanding and analyzing your traces. In New Relic, trace data is reported as Span objects, with multiple attributes (key-value pairs) attached. To query your tracing data, you could use a NRQL query like: Select * from Span Copy To learn more about how distributed tracing works, see Understand distributed tracing. To report custom distributed tracing data, see the Trace API. Query and send data Understanding New Relic data types can help you: Query data in New Relic Send data to New Relic Learn more For a simpler explanation of these data types using real-world examples, see Introduction to essential telemetry data types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 372.77808,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>data</em> types",
        "sections": "Query <em>and</em> send <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "The New Relic <em>platform</em> is built around the four fundamental <em>telemetry</em> <em>data</em> types we believe are necessary for complete and effective system monitoring: metrics, events, logs, and traces. Get started This doc will give you a fairly technical explanation of our core <em>data</em> types, their structure"
      },
      "id": "6045280de7b9d266e1579a0f"
    },
    {
      "sections": [
        "View system limits",
        "Responses to limit violations",
        "System limits UI",
        "Troubleshooting limits",
        "For more information"
      ],
      "title": "View system limits",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "d6ff940e92c5d1a3ae34f391e9fa3be5dfa21c2f",
      "image": "https://docs.newrelic.com/static/8ee61e3091f6e044202cff92026afada/8c557/limits-graph.png",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/view-system-limits/",
      "published_at": "2021-07-09T03:40:25Z",
      "updated_at": "2021-07-09T03:40:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure our systems are always up and ready to support you, and to keep you from unintended use, we place limits on the amount of data you can send, query, and store. Responses to limit violations Limits are enforced per sub-account, and across our APIs. You might reach a limit if you start monitoring a new high-traffic application, or have a sudden data spike. When you do reach a limit, New Relic responds according to the type of data and the limit that’s reached. For example: We place a limit on the number of ingested requests per minute (RPM) per data type. When this limit is reached, we stop accepting data and return a 429 status code for the duration of the minute. For queries, we place limits on the number of queries per minute and the number of records inspected (see query limits). When the number of queries per minute limit is reached, New Relic will begin rejecting queries until the number of queries is below the limit. When the records inspected limit is reached, New Relic will reject traffic from the source scanning the largest number of records and attempt to allow traffic from other sources. For metrics, we place a limit on the number of unique timeseries (cardinality) per account and per metric. When this limit is reached, aggregated data is turned off for the rest of the UTC day. For every major limit violation, New Relic creates an NrIntegrationError event for that account, which have these limit-related attributes: Attribute Description category 'RateLimit' or 'ApiLimit'. The 'RateLimit' category is used for limits based on a unit of time such as the number of requests ingested per minute. The 'ApiLimit' is used for constant limits, such as the number of attributes on a record. limitName The name of the limit. message Describes the limit and the impact. limitValue The limit reached. System limits UI The system Limits page (from the account dropdown, click Manage your data and click Limits on the left) displays when your account has encountered a rate limit in the specified time period. The page displays a default period of 24 hours; you can set a custom range from the top-right of the page. Non-limit-related NrIntegrationError events are not displayed here. In addition, this page does not display information about limits you have not hit, or how close you are to reaching a limit. For more on creating queries and alerts for data ingest and billing metrics, see Query billing/usage data. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a chart on the Limits UI page displaying a cardinality violation limit issue. To add more detail, or build a dashboard, click the View NRQL button on the chart to see the NRQL powering this view. The graph displays each unique limit type that was reached during the selected time-period. This can help you find any trends based on time. The Limits page also provides a table where you can find the limit name, the limit event message associated with it, and last occurrence time and date. If you click a limit in the table, you see more about what happened, and when. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a limit events table on the Limits UI page. Troubleshooting limits To troubleshoot limits when you reach them, click the limit info in the table, and then follow the docs link that's provided. Different limits have different solutions. For more information See Troubleshoot Metric API with NRIntegrationError events",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.32758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": " and the impact. limitValue The limit reached. System limits UI The system Limits page (from the account dropdown, click <em>Manage</em> your <em>data</em> and click Limits on the left) displays when your account has encountered a rate limit in the specified time period. The page displays a default period of 24 hours; you can set"
      },
      "id": "60446a7c64441f48d7378f2b"
    },
    {
      "sections": [
        "Manage your data",
        "Important",
        "Where to find the Data management hub",
        "Better cost, performance, and compliance",
        "Cost management",
        "Performance management",
        "Ingest and retention strategies"
      ],
      "title": "Manage your data",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "1938512af1fd477b8cd587cc85a4a1522cd62e9e",
      "image": "https://docs.newrelic.com/static/8a553ce9643c8513be3200af5d924250/c1b63/datamanagement_overview.png",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/manage-your-data/",
      "published_at": "2021-07-09T03:38:47Z",
      "updated_at": "2021-07-09T03:38:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At New Relic, we're super proud of NRDB, the New Relic database where we store your data. It gathers all your telemetry data in one place, gives you a connected view of all your data, and scales as your business grows. We invite you to send all your metrics, events, logs, and traces to NRDB, including those from third-party sources. We also recognize that some data might not be necessary for your business goals. You shouldn’t have to wade through data you don’t need to get to the data you do. And you definitely shouldn’t have to pay for it. That’s where our data management tools come in: they let you decide what data you send to New Relic and how long it should be stored. Data management hub: from the user profile drop down, select Manage your data. Coupled with user management tools, data management helps you get maximum value from your investment in New Relic, all while safeguarding your data. Important Not yet a New Relic customer? Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Where to find the Data management hub To locate the data management UI: From one.newrelic.com select the account dropdown, and select Manage your data. If you're on the New Relic One user model, you can also find the Data management hub by selecting Administration > Manage data. Better cost, performance, and compliance Collecting and storing data in New Relic allows you to analyze, visualize, and alert on all your metrics, events, logs, and traces from across all of your sources. However, it’s important to manage that data for cost, performance, and in some cases, compliance reasons. The data management hub provides the tools you need to understand and control where your data is coming from, and adjust what’s stored and for how long. Important If you're on our original product-based pricing plan, you'll see your data ingest, retention, and limits in the Data management hub. The primary difference is that you're not billed on ingest, as with our New Relic One pricing plan. Not sure which plan you're on? See Overview of pricing and account/user structure. Cost management The cost of data storage continually decreases, but storage is still an expense. The amount of data you process and store is closely related to the value you receive from New Relic, because it’s a key component of how you’re charged. Our ingest process helps you hone your data. For example, data might arrive at our processing front door compressed and of varying quality. Through ingest, that data is uncompressed, decorated with queryable attributes, and evaluated. Elements are dropped or trimmed, all before we write it to NRDB. That way, the data you store is only the data you want most. Performance management While NRDB is a phenomenally scalable database, it’s also a reality that queries across huge datasets might not return results in a timely enough fashion for your needs. You get better performance if you limit the data we store, or convert it into a format that keeps it easily queryable. Drop data to improve performance by reducing the amount of data that’s stored. Ingest and retention strategies Depending on your goals, whether to reduce costs, increase specific retention rates, or pare down your data to what’s most essential, we have a strategy for you. Learn about reducing the amount of data that comes into NRDB in Manage data coming into New Relic. Learn about customizing storage so you only store the data you want, for the period you want in Manage data stored in New Relic. Learn about dropping data in Drop data using NerdGraph. And for dropping log data, see Drop data with drop filter rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.3106,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> your <em>data</em>",
        "sections": "<em>Manage</em> your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", events, logs, and traces from across all of your sources. However, it’s important to <em>manage</em> that <em>data</em> for cost, performance, and in some cases, compliance reasons. The <em>data</em> management hub provides the tools you need to <em>understand</em> and control where your <em>data</em> is coming from, and adjust what’s stored"
      },
      "id": "603e96ff28ccbcf8bceba796"
    }
  ],
  "/docs/query-your-data/explore-query-data/query-builder/introduction-query-builder": [
    {
      "sections": [
        "Query builder: Basic mode",
        "Important",
        "Data type",
        "Example of using basic mode",
        "Step 1: Select the source of the data for a chart",
        "Step 2: Filter the data",
        "Step 3: Adjust time range and limits",
        "Step 4: Customize the chart"
      ],
      "title": "Query builder: Basic mode",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Query builder"
      ],
      "external_id": "7f076b3909c9462829453bc59f0dae0f5d5501fd",
      "image": "https://docs.newrelic.com/static/6be4a8d2af5e02259c01e180d7f43326/58213/crop-basic-example-chart_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/query-builder/query-builder-basic-mode/",
      "published_at": "2021-07-10T03:13:37Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the New Relic One query builder in basic mode to create a chart without having to use NRQL, our querying language. The basic mode helps guides you through a query-creation process. You can choose the source of the raw data, apply filters, and use other techniques to narrow the scope of the data in the chart. Important As of September 1, 2021, we are discontinuing support of the query builder's basic mode. Instead, you can use our data explorer's user-friendly and intuitive functionality in New Relic One. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Data type The query builder basic mode has a Data type selector with two options: Events: In this context, this refers to all our non-Metric-type data, including events, logs, and trace data. Metrics: This refers to our dimensional Metric data type. You can also use this to query some types of metric timeslice data. For more on other types of metrics, see Data types. Example of using basic mode This example shows how to create a chart in basic mode. Step 1: Select the source of the data for a chart Begin by specifying what data you want to view in your chart. Click in the View a chart with box to select the event type, an attribute, and a function to perform on the attribute. You can use the event data dictionary to view information about an event type and its attributes on a single page. To see a tooltip with information about an event or attribute, hover over any term that has a dotted line underneath it. Here are the results of using the event data dictionary to specify the data: Event type. The Transaction event type measures a variety of data that describes what happens while a user is on a website, such as that user clicking on a button on a page. Attribute. The name attribute stores information on all transactions. Function. Select the unique_count function to get a count of all the transactions that occurred during the time frame. Basic mode now shows the selection: one.newrelic.com > Query builder > Basic > (event and attribute specified) As you specify data, the chart updates to show you the results from the data you specified. Based on the information specified so far, you can see a chart that shows the total number of transactions during the default time frame of 30 minutes. This total includes all transactions, whether the transaction was completed successfully or had errors. one.newrelic.com > Query builder > Basic > (event and attribute specified) Step 2: Filter the data Your next step is to determine which of those transactions got a 404 page not found error. If you look in the event data dictionary for the Transaction event type, you'll find this event also includes an attribute called httpResponseCode. Narrow the results to show only those transactions where a page not found error occurred. Use the Narrow results to box to create this filter: httpResponseCode = 404 . Because you want to be able to see the names of the apps that are resulting in the 404 errors, you use the Facet by box to see the results by appName (which is also an attribute for the Transaction event type). Faceting by appName updates the chart to break down the total number of 404 errors by the application names. This lets you know which apps are experiencing 404 errors. Your chart now shows the line chart with a line for each app, each with its own color. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) Step 3: Adjust time range and limits You decide to focus on the five apps with the most page not found errors. The default value for the Limit field is 10, meaning that your chart will show the ten most relevant returns. You change that value to 5. Customer support told you that they had been getting calls about these errors for a little over two hours. You decide to change the time range from the last 30 minutes to the last three hours so that you can view the errors during the time when the customers were calling support. Now that you have the data set so that you are seeing exactly what you need, you can turn your attention to the appearance of the chart. Step 4: Customize the chart Because you are more interested in the total number of errors than a timeline view, you change the chart type to a bar chart. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) > (time range and limit customized) > (chart type customized) When you're finished with your chart, you can add it to a dashboard or share it. This table contains notes about using basic mode. Item Description Prompts You can start typing directly in an empty box; a list of items that match the information you type will display. You can also click on an empty box to view a list of all of the items that are appropriate for the field, based on your earlier choices. Saving a basic mode data specification Every time you run a query, that query is saved in the My recent queries dropdown in advanced (NRQL) mode. Events Basic mode only supports data for one event and attribute. If you want to use more than one event and/or attribute, use the SELECT statement in advanced (NRQL) mode. Shortcuts Basic mode contains shortcuts that can display more complex events and attributes that aren't generally supported, as in this example (which shows the tooltip for the shortcut). Example of the Response time histogram shortcut, showing a tooltip. Tooltips Any time you see a dotted line under a term, you can hover over that term to see a tooltip with an explanation of the term. Narrow by You can use more than one Narrow by definition in basic mode filter; the conditions will be joined by AND. The WHERE clause in advanced (NRQL) allows OR in addition to AND. Important If your query was started using basic mode and if you make changes to that query using advanced (NRQL) mode, you cannot return to basic mode to edit that query. Any additional changes may only be made in advanced (NRQL) mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 399.7658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> <em>builder</em>: Basic mode",
        "sections": "<em>Query</em> <em>builder</em>: Basic mode",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " was completed successfully or had errors. one.newrelic.com &gt; <em>Query</em> <em>builder</em> &gt; Basic &gt; (event and attribute specified) Step 2: Filter the <em>data</em> <em>Your</em> next step is to determine which of those transactions got a 404 page not found error. If you look in the event <em>data</em> dictionary for the Transaction event type"
      },
      "id": "603ec319e7b9d2008c2a07e0"
    },
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-09T23:45:11Z",
      "updated_at": "2021-07-07T10:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also clone your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.3373,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, add, <em>and</em> share dashboards <em>and</em> charts",
        "sections": "Add <em>and</em> share charts <em>and</em> content from <em>your</em> dashboards",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " on the &lt; &#x2F; &gt; icon on the right corner. Export <em>your</em> dashboard as a pdf file clicking the icon. You can also clone <em>your</em> dashboard. Add and share charts and content from <em>your</em> dashboards Add new content to a dashboard You can add new content to any dashboard from the <em>data</em> explorer and <em>query</em> <em>builder</em>"
      },
      "id": "60e5877828ccbc77861881cc"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Clone your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-10T03:14:27Z",
      "updated_at": "2021-07-02T20:16:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Clone your dashboard You can clone your dashboard clicking the clone icon regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. The clone has Public - Read and write permissions. Access the new, cloned dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word “copy”. For example, if you clone a dashboard named This is my dashboard, the clone is called This is my dashboard copy. You can change the name when you clone it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 306.9159,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> dashboard",
        "sections": "Export <em>and</em> share <em>your</em> <em>data</em>",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " to search <em>data</em> across New Relic One. Add new content to <em>your</em> dashboard There are multiple ways to add new content to <em>your</em> dashboard: From the <em>data</em> explorer and <em>query</em> <em>builder</em> features. Use the + Add to <em>your</em> dashboard button (accessible from the main dashboard page or in the edit mode) to access"
      },
      "id": "603ec235196a67206fa83dde"
    }
  ],
  "/docs/query-your-data/explore-query-data/query-builder/query-builder-basic-mode": [
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-09T23:45:11Z",
      "updated_at": "2021-07-07T10:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also clone your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.3373,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, add, <em>and</em> share dashboards <em>and</em> charts",
        "sections": "Add <em>and</em> share charts <em>and</em> content from <em>your</em> dashboards",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " on the &lt; &#x2F; &gt; icon on the right corner. Export <em>your</em> dashboard as a pdf file clicking the icon. You can also clone <em>your</em> dashboard. Add and share charts and content from <em>your</em> dashboards Add new content to a dashboard You can add new content to any dashboard from the <em>data</em> explorer and <em>query</em> <em>builder</em>"
      },
      "id": "60e5877828ccbc77861881cc"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Clone your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-10T03:14:27Z",
      "updated_at": "2021-07-02T20:16:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Clone your dashboard You can clone your dashboard clicking the clone icon regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. The clone has Public - Read and write permissions. Access the new, cloned dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word “copy”. For example, if you clone a dashboard named This is my dashboard, the clone is called This is my dashboard copy. You can change the name when you clone it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 306.9159,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> dashboard",
        "sections": "Export <em>and</em> share <em>your</em> <em>data</em>",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " to search <em>data</em> across New Relic One. Add new content to <em>your</em> dashboard There are multiple ways to add new content to <em>your</em> dashboard: From the <em>data</em> explorer and <em>query</em> <em>builder</em> features. Use the + Add to <em>your</em> dashboard button (accessible from the main dashboard page or in the edit mode) to access"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Introduction to the query builder",
        "Important",
        "Why it matters",
        "Get started",
        "Use the query builder: basic and advanced modes",
        "Tip",
        "Basic mode",
        "Advanced (NRQL) mode",
        "Advanced (PromQL-style) mode",
        "Use your charts"
      ],
      "title": "Introduction to the query builder",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Query builder"
      ],
      "external_id": "5d862557e0e3f4ef89dbd7da6ffdbe0d358790d2",
      "image": "https://docs.newrelic.com/static/60469c8066759d569577ab290af977a6/c1b63/intro_query_builder.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/query-builder/introduction-query-builder/",
      "published_at": "2021-07-10T03:20:10Z",
      "updated_at": "2021-06-03T06:59:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the query builder, you can run queries of your data to create custom charts and other visualizations. You can also build custom dashboards containing multiple charts. Important Are you a New Relic Insights user? See our transition guide. Why it matters Modern business systems are a complex maze of data-generating elements. You need an easy, solid way to fetch, analyze, and visualize the never-ending stream of data flowing from your daily working activities. Use the query builder to: Quickly access your data and build customized charts to learn and understand the health of your infrastructure, applications, and other services. Add charts to your dashboards to obtain a complete real-time view of the state of your system. Share your charts with colleagues or users in just two clicks. Get acquainted with querying by using basic mode, then switch to advanced mode to refine your charts using NRQL. Create NRQL alerts from the queries you build and run. one.newrelic.com > Query your data: Run queries of your data to create custom charts, other visualizations, and NRQL alerts. Get started Before querying, you may want to read Introduction to querying and how to explore your data. To find the query builder, go to one.newrelic.com and click Query your data. Use the query builder: basic and advanced modes The query builder has several modes: Basic mode Advanced (NRQL) mode Advanced (PromQL-style) mode Tip You can also switch to the Data explorer tab at any time to browse your data and create charts visually, without performing queries. Basic mode Basic mode doesn't require a query language, and so it's useful if you aren't familiar with NRQL or SQL. It's also a quick way to answer one-off questions, such as how many cities outside of the United States are accessing the shopping site for your company. one.newrelic.com > Query your data > Query builder > Basic mode Use basic mode to guide you through the process to specify data for a chart. With basic mode you can: Choose your data source. In basic mode, you start by selecting an event and then picking the attribute that corresponds to the information to show in your chart. Specify (filter) the data for your chart. You can narrow the results and choose an attribute to facet by. Select the time range to present in the chart. You can select a time range from the menu or use the custom option to create your own time range. See Use basic mode for more information about this feature. Advanced (NRQL) mode With the advanced (NRQL) mode you can create your own queries using the NRQL query language. NRQL queries may be simple or complex, depending on what data you want to use and how to display it in your chart. This example of the advanced mode shows the NRQL query with the same data as used in basic mode. one.newrelic.com > Query your data > Query builder > Advanced (NRQL). Use advanced (NRQL) mode to write a query that specifies data for a chart. Tip With APM's real time streaming, you can query and visualize your data for transactions, errors, and custom events in dashboards. See Use advanced (NRQL) mode for more information about using this feature. Advanced (PromQL-style) mode With the advanced (PromQL-style) mode you can run basic PromQL-style queries. You can switch between basic and advanced modes while defining your query in order to: customize some of the values. learn how NRQL queries are structured using the data you specified in basic mode. Important If you build your query in basic mode and update it using advanced mode, you cannot return to basic mode to edit that query. You must make any additional changes in advanced (NRQL) mode. Once you specify the data you want, your chart is ready to view. Your query automatically runs in basic mode as you make changes to the inputs. If using advanced (NRQL or PromQL-style) mode, run your query. Use your charts Once you have built your chart you can: Change the type of chart. Based on the data you specified, the query builder selects the chart type that displays your results most effectively. However, you can choose from other available chart types to present your data in the visual format that you want to use. Share your chart. Add your chart to a dashboard. Create a NRQL alert condition from your chart.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.70303,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the <em>query</em> <em>builder</em>",
        "sections": "Use the <em>query</em> <em>builder</em>: basic <em>and</em> advanced modes",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": "With the <em>query</em> <em>builder</em>, you can run queries of <em>your</em> <em>data</em> to create custom charts and other visualizations. You can also build custom dashboards containing multiple charts. Important Are you a New Relic Insights user? See our transition guide. Why it matters Modern business systems are a complex"
      },
      "id": "603ec08f196a67f7b7a83dd2"
    }
  ],
  "/docs/query-your-data/explore-query-data/query-builder/use-advanced-nrql-mode-query-data": [
    {
      "sections": [
        "Query builder: Basic mode",
        "Important",
        "Data type",
        "Example of using basic mode",
        "Step 1: Select the source of the data for a chart",
        "Step 2: Filter the data",
        "Step 3: Adjust time range and limits",
        "Step 4: Customize the chart"
      ],
      "title": "Query builder: Basic mode",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Query builder"
      ],
      "external_id": "7f076b3909c9462829453bc59f0dae0f5d5501fd",
      "image": "https://docs.newrelic.com/static/6be4a8d2af5e02259c01e180d7f43326/58213/crop-basic-example-chart_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/query-builder/query-builder-basic-mode/",
      "published_at": "2021-07-10T03:13:37Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the New Relic One query builder in basic mode to create a chart without having to use NRQL, our querying language. The basic mode helps guides you through a query-creation process. You can choose the source of the raw data, apply filters, and use other techniques to narrow the scope of the data in the chart. Important As of September 1, 2021, we are discontinuing support of the query builder's basic mode. Instead, you can use our data explorer's user-friendly and intuitive functionality in New Relic One. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Data type The query builder basic mode has a Data type selector with two options: Events: In this context, this refers to all our non-Metric-type data, including events, logs, and trace data. Metrics: This refers to our dimensional Metric data type. You can also use this to query some types of metric timeslice data. For more on other types of metrics, see Data types. Example of using basic mode This example shows how to create a chart in basic mode. Step 1: Select the source of the data for a chart Begin by specifying what data you want to view in your chart. Click in the View a chart with box to select the event type, an attribute, and a function to perform on the attribute. You can use the event data dictionary to view information about an event type and its attributes on a single page. To see a tooltip with information about an event or attribute, hover over any term that has a dotted line underneath it. Here are the results of using the event data dictionary to specify the data: Event type. The Transaction event type measures a variety of data that describes what happens while a user is on a website, such as that user clicking on a button on a page. Attribute. The name attribute stores information on all transactions. Function. Select the unique_count function to get a count of all the transactions that occurred during the time frame. Basic mode now shows the selection: one.newrelic.com > Query builder > Basic > (event and attribute specified) As you specify data, the chart updates to show you the results from the data you specified. Based on the information specified so far, you can see a chart that shows the total number of transactions during the default time frame of 30 minutes. This total includes all transactions, whether the transaction was completed successfully or had errors. one.newrelic.com > Query builder > Basic > (event and attribute specified) Step 2: Filter the data Your next step is to determine which of those transactions got a 404 page not found error. If you look in the event data dictionary for the Transaction event type, you'll find this event also includes an attribute called httpResponseCode. Narrow the results to show only those transactions where a page not found error occurred. Use the Narrow results to box to create this filter: httpResponseCode = 404 . Because you want to be able to see the names of the apps that are resulting in the 404 errors, you use the Facet by box to see the results by appName (which is also an attribute for the Transaction event type). Faceting by appName updates the chart to break down the total number of 404 errors by the application names. This lets you know which apps are experiencing 404 errors. Your chart now shows the line chart with a line for each app, each with its own color. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) Step 3: Adjust time range and limits You decide to focus on the five apps with the most page not found errors. The default value for the Limit field is 10, meaning that your chart will show the ten most relevant returns. You change that value to 5. Customer support told you that they had been getting calls about these errors for a little over two hours. You decide to change the time range from the last 30 minutes to the last three hours so that you can view the errors during the time when the customers were calling support. Now that you have the data set so that you are seeing exactly what you need, you can turn your attention to the appearance of the chart. Step 4: Customize the chart Because you are more interested in the total number of errors than a timeline view, you change the chart type to a bar chart. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) > (time range and limit customized) > (chart type customized) When you're finished with your chart, you can add it to a dashboard or share it. This table contains notes about using basic mode. Item Description Prompts You can start typing directly in an empty box; a list of items that match the information you type will display. You can also click on an empty box to view a list of all of the items that are appropriate for the field, based on your earlier choices. Saving a basic mode data specification Every time you run a query, that query is saved in the My recent queries dropdown in advanced (NRQL) mode. Events Basic mode only supports data for one event and attribute. If you want to use more than one event and/or attribute, use the SELECT statement in advanced (NRQL) mode. Shortcuts Basic mode contains shortcuts that can display more complex events and attributes that aren't generally supported, as in this example (which shows the tooltip for the shortcut). Example of the Response time histogram shortcut, showing a tooltip. Tooltips Any time you see a dotted line under a term, you can hover over that term to see a tooltip with an explanation of the term. Narrow by You can use more than one Narrow by definition in basic mode filter; the conditions will be joined by AND. The WHERE clause in advanced (NRQL) allows OR in addition to AND. Important If your query was started using basic mode and if you make changes to that query using advanced (NRQL) mode, you cannot return to basic mode to edit that query. Any additional changes may only be made in advanced (NRQL) mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 399.7655,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> <em>builder</em>: Basic mode",
        "sections": "<em>Query</em> <em>builder</em>: Basic mode",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " was completed successfully or had errors. one.newrelic.com &gt; <em>Query</em> <em>builder</em> &gt; Basic &gt; (event and attribute specified) Step 2: Filter the <em>data</em> <em>Your</em> next step is to determine which of those transactions got a 404 page not found error. If you look in the event <em>data</em> dictionary for the Transaction event type"
      },
      "id": "603ec319e7b9d2008c2a07e0"
    },
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-09T23:45:11Z",
      "updated_at": "2021-07-07T10:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also clone your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.33716,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, add, <em>and</em> share dashboards <em>and</em> charts",
        "sections": "Add <em>and</em> share charts <em>and</em> content from <em>your</em> dashboards",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " on the &lt; &#x2F; &gt; icon on the right corner. Export <em>your</em> dashboard as a pdf file clicking the icon. You can also clone <em>your</em> dashboard. Add and share charts and content from <em>your</em> dashboards Add new content to a dashboard You can add new content to any dashboard from the <em>data</em> explorer and <em>query</em> <em>builder</em>"
      },
      "id": "60e5877828ccbc77861881cc"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Clone your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-10T03:14:27Z",
      "updated_at": "2021-07-02T20:16:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Clone your dashboard You can clone your dashboard clicking the clone icon regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. The clone has Public - Read and write permissions. Access the new, cloned dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word “copy”. For example, if you clone a dashboard named This is my dashboard, the clone is called This is my dashboard copy. You can change the name when you clone it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 306.91577,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> dashboard",
        "sections": "Export <em>and</em> share <em>your</em> <em>data</em>",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " to search <em>data</em> across New Relic One. Add new content to <em>your</em> dashboard There are multiple ways to add new content to <em>your</em> dashboard: From the <em>data</em> explorer and <em>query</em> <em>builder</em> features. Use the + Add to <em>your</em> dashboard button (accessible from the main dashboard page or in the edit mode) to access"
      },
      "id": "603ec235196a67206fa83dde"
    }
  ],
  "/docs/query-your-data/explore-query-data/query-builder/use-advanced-promql-style-mode-query-data": [
    {
      "sections": [
        "Query builder: Basic mode",
        "Important",
        "Data type",
        "Example of using basic mode",
        "Step 1: Select the source of the data for a chart",
        "Step 2: Filter the data",
        "Step 3: Adjust time range and limits",
        "Step 4: Customize the chart"
      ],
      "title": "Query builder: Basic mode",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Query builder"
      ],
      "external_id": "7f076b3909c9462829453bc59f0dae0f5d5501fd",
      "image": "https://docs.newrelic.com/static/6be4a8d2af5e02259c01e180d7f43326/58213/crop-basic-example-chart_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/query-builder/query-builder-basic-mode/",
      "published_at": "2021-07-10T03:13:37Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the New Relic One query builder in basic mode to create a chart without having to use NRQL, our querying language. The basic mode helps guides you through a query-creation process. You can choose the source of the raw data, apply filters, and use other techniques to narrow the scope of the data in the chart. Important As of September 1, 2021, we are discontinuing support of the query builder's basic mode. Instead, you can use our data explorer's user-friendly and intuitive functionality in New Relic One. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Data type The query builder basic mode has a Data type selector with two options: Events: In this context, this refers to all our non-Metric-type data, including events, logs, and trace data. Metrics: This refers to our dimensional Metric data type. You can also use this to query some types of metric timeslice data. For more on other types of metrics, see Data types. Example of using basic mode This example shows how to create a chart in basic mode. Step 1: Select the source of the data for a chart Begin by specifying what data you want to view in your chart. Click in the View a chart with box to select the event type, an attribute, and a function to perform on the attribute. You can use the event data dictionary to view information about an event type and its attributes on a single page. To see a tooltip with information about an event or attribute, hover over any term that has a dotted line underneath it. Here are the results of using the event data dictionary to specify the data: Event type. The Transaction event type measures a variety of data that describes what happens while a user is on a website, such as that user clicking on a button on a page. Attribute. The name attribute stores information on all transactions. Function. Select the unique_count function to get a count of all the transactions that occurred during the time frame. Basic mode now shows the selection: one.newrelic.com > Query builder > Basic > (event and attribute specified) As you specify data, the chart updates to show you the results from the data you specified. Based on the information specified so far, you can see a chart that shows the total number of transactions during the default time frame of 30 minutes. This total includes all transactions, whether the transaction was completed successfully or had errors. one.newrelic.com > Query builder > Basic > (event and attribute specified) Step 2: Filter the data Your next step is to determine which of those transactions got a 404 page not found error. If you look in the event data dictionary for the Transaction event type, you'll find this event also includes an attribute called httpResponseCode. Narrow the results to show only those transactions where a page not found error occurred. Use the Narrow results to box to create this filter: httpResponseCode = 404 . Because you want to be able to see the names of the apps that are resulting in the 404 errors, you use the Facet by box to see the results by appName (which is also an attribute for the Transaction event type). Faceting by appName updates the chart to break down the total number of 404 errors by the application names. This lets you know which apps are experiencing 404 errors. Your chart now shows the line chart with a line for each app, each with its own color. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) Step 3: Adjust time range and limits You decide to focus on the five apps with the most page not found errors. The default value for the Limit field is 10, meaning that your chart will show the ten most relevant returns. You change that value to 5. Customer support told you that they had been getting calls about these errors for a little over two hours. You decide to change the time range from the last 30 minutes to the last three hours so that you can view the errors during the time when the customers were calling support. Now that you have the data set so that you are seeing exactly what you need, you can turn your attention to the appearance of the chart. Step 4: Customize the chart Because you are more interested in the total number of errors than a timeline view, you change the chart type to a bar chart. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) > (time range and limit customized) > (chart type customized) When you're finished with your chart, you can add it to a dashboard or share it. This table contains notes about using basic mode. Item Description Prompts You can start typing directly in an empty box; a list of items that match the information you type will display. You can also click on an empty box to view a list of all of the items that are appropriate for the field, based on your earlier choices. Saving a basic mode data specification Every time you run a query, that query is saved in the My recent queries dropdown in advanced (NRQL) mode. Events Basic mode only supports data for one event and attribute. If you want to use more than one event and/or attribute, use the SELECT statement in advanced (NRQL) mode. Shortcuts Basic mode contains shortcuts that can display more complex events and attributes that aren't generally supported, as in this example (which shows the tooltip for the shortcut). Example of the Response time histogram shortcut, showing a tooltip. Tooltips Any time you see a dotted line under a term, you can hover over that term to see a tooltip with an explanation of the term. Narrow by You can use more than one Narrow by definition in basic mode filter; the conditions will be joined by AND. The WHERE clause in advanced (NRQL) allows OR in addition to AND. Important If your query was started using basic mode and if you make changes to that query using advanced (NRQL) mode, you cannot return to basic mode to edit that query. Any additional changes may only be made in advanced (NRQL) mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 399.7655,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> <em>builder</em>: Basic mode",
        "sections": "<em>Query</em> <em>builder</em>: Basic mode",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " was completed successfully or had errors. one.newrelic.com &gt; <em>Query</em> <em>builder</em> &gt; Basic &gt; (event and attribute specified) Step 2: Filter the <em>data</em> <em>Your</em> next step is to determine which of those transactions got a 404 page not found error. If you look in the event <em>data</em> dictionary for the Transaction event type"
      },
      "id": "603ec319e7b9d2008c2a07e0"
    },
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-09T23:45:11Z",
      "updated_at": "2021-07-07T10:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also clone your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.33716,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, add, <em>and</em> share dashboards <em>and</em> charts",
        "sections": "Add <em>and</em> share charts <em>and</em> content from <em>your</em> dashboards",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " on the &lt; &#x2F; &gt; icon on the right corner. Export <em>your</em> dashboard as a pdf file clicking the icon. You can also clone <em>your</em> dashboard. Add and share charts and content from <em>your</em> dashboards Add new content to a dashboard You can add new content to any dashboard from the <em>data</em> explorer and <em>query</em> <em>builder</em>"
      },
      "id": "60e5877828ccbc77861881cc"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Clone your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-10T03:14:27Z",
      "updated_at": "2021-07-02T20:16:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Clone your dashboard You can clone your dashboard clicking the clone icon regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. The clone has Public - Read and write permissions. Access the new, cloned dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word “copy”. For example, if you clone a dashboard named This is my dashboard, the clone is called This is my dashboard copy. You can change the name when you clone it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 306.91577,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> dashboard",
        "sections": "Export <em>and</em> share <em>your</em> <em>data</em>",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " to search <em>data</em> across New Relic One. Add new content to <em>your</em> dashboard There are multiple ways to add new content to <em>your</em> dashboard: From the <em>data</em> explorer and <em>query</em> <em>builder</em> features. Use the + Add to <em>your</em> dashboard button (accessible from the main dashboard page or in the edit mode) to access"
      },
      "id": "603ec235196a67206fa83dde"
    }
  ],
  "/docs/query-your-data/explore-query-data/use-charts/chart-refresh-rates": [
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-07-09T04:49:12Z",
      "updated_at": "2021-06-02T17:39:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the query builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.39574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create real time streaming <em>charts</em>",
        "body": " second <em>chart</em> <em>refresh</em> interval. This is because the <em>chart</em>&#x27;s <em>refresh</em> interval is based on the time window. TIMESERIES bucket To set the <em>refresh</em> interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Alerts page for mobile apps",
        "Alerts page details"
      ],
      "title": "Alerts page for mobile apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile app pages"
      ],
      "external_id": "fdf5bb4237b15f6ad350f8d4e2c41656dda53b52",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/alerts-page-mobile-apps/",
      "published_at": "2021-07-09T11:16:44Z",
      "updated_at": "2021-07-09T11:16:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When the alert conditions you set for your mobile app's error rates and response times cross a threshold for an extended period, the mobile monitoring agent will create a Warning (yellow) or Critical (red) problem event. If a Critical (red) event has been open for several minutes, mobile will send an alert notification to users who have been set up to receive alert notifications. It will also send a notification when all Critical events close. To view the Alerts page: Go to one.newrelic.com > Mobile > (select an app) > App > Alerts. Alerts page details Each alert notification includes the alert icon and summary information. Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. In addition, use any of these options: If you want to... Do this View details about a specific alert From the Alerts page, select the alert's link. View details about errors Select the alert's Event link. View details about HTTP requests Mouse over the HTTP response time chart. View details about network errors Mouse over the HTTP/network errors chart. Change the alert settings From the Alerts page, select the Change alert thresholds link. OR From the selected alert, select the Configure link. Search for alerts From the Alerts page, use the Filter text box. View the Alerts page for your other applications (not just mobile apps) From the Alerts page, select the All alerts link. To go directly to this page: Go to one.newrelic.com > Alerts > Alert history.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.30133,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "When the alert conditions you set for your mobile app&#x27;s error <em>rates</em> and response times cross a threshold for an extended period, the mobile monitoring agent will create a Warning (yellow) or Critical (red) problem event. If a Critical (red) event has been open for several minutes, mobile will send"
      },
      "id": "60450de064441fd024378ec7"
    },
    {
      "sections": [
        "AJAX page: Identify time-consuming calls",
        "What to troubleshoot",
        "How to do it",
        "Start with AJAX summary charts",
        "Get details by calls or page views",
        "Trace your requests from start to finish",
        "Time percentage example",
        "What's next"
      ],
      "title": "AJAX page: Identify time-consuming calls",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "613e5ebce427fa39879146e9ee80cd17d8e69adf",
      "image": "https://docs.newrelic.com/static/4ef0afbde5020a014143696d2c2bc075/8c557/nr-one-ajax-browser.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/browser-pro-features/ajax-page-identify-time-consuming-calls/",
      "published_at": "2021-07-09T23:32:23Z",
      "updated_at": "2021-07-09T23:32:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our browser monitoring's AJAX UI shows recent AJAX requests from browsers to external endpoints, such as HTTP or HTTPS domains. This information helps identify problems with the end user experience when you have time-consuming or failing AJAX calls that update parts of a webpage on your site. What to troubleshoot Here are some troubleshooting tips for identifying performance problems with your app: Troubleshooting AJAX calls Examples Problems across the entire request If you're not sure where the problem is, or if you want to trace your requests from start to finish, click the distributed tracing link in the AJAX UI. Timing problems Total time percentages, throughput requests per minute (rpm), and average data transfer rates per request can help identify timing problems. Look for large spikes in the AJAX summary page's Average data transfer per request chart. From the individual call's AJAX performance tab, look for correlations between high callback time values and data transfer rates. Endpoint problems Look for any outlier endpoints, and investigate individual requests made from them. The Status codes chart on the AJAX summary page provides information about the return behavior from the call. If you see a large number of status codes outside the 200 range, this may indicate a problem with your AJAX endpoints. Specific webpage location problems Examine potential AJAX problems within the context of the page where they load. Select an AJAX transaction, then select any trace from the Session traces with AJAX table. How to do it To troubleshoot problems with AJAX requests for your app: Go to one.newrelic.com > Browser > (select an app) > AJAX. OR Go directly to the selected app's Browser summary page, then click the AJAX response time chart's title. one.newrelic.com > Browser > (select an app) > AJAX: Identify problems due to time-consuming or failing AJAX calls that update parts of a webpage on your site. Start with AJAX summary charts The summary page provides several charts to help you troubleshoot AJAX calls. AJAX summary page Comments Groups and filters Use any of the available Sort by or filter options in the UI. All AJAX requests that take longer than two minutes are filtered out automatically. You can also group your browser metrics by URLs. For example, this is useful with allow lists and deny lists. Endpoints The Throughput chart shows the five endpoints with the highest throughput. If the call has more than five endpoints, they are consolidated on the chart as Other. Calls from New Relic You may see our own browser monitoring AJAX calls to your app. This is normal, because all activity is captured during the browser session. Missing browser data AJAX timing details are not available from IE 7, IE 8, or Chrome for iOS browsers. If you do not see expected data from other browsers, follow our AJAX troubleshooting procedures. Get details by calls or page views After selecting a specific call from the AJAX summary page, you can drill down into detailed information with the AJAX performance tab. This includes a direct link to session trace details. From here you can also select the tab to get performance data by page views. (If your app server requests greatly outnumber your browser PageView transactions, this is because some requests to your back end are made through AJAX. For more information, see our troubleshooting procedures.) one.newrelic.com > Browser > (select an app) > AJAX > (select an AJAX call): This example shows performance details for a specific AJAX call. You can also view performance details by page views. AJAX endpoints on the Average response time chart appear either as four or two time periods. This depends on whether there are cross application tracing headers. Four time periods (Application time, Queue time, Network time, and Callback time): These AJAX calls are made against apps monitored by APM agents that provide cross application tracing headers. Two time periods (Response time and Callback time): These AJAX calls are made against apps that either are not monitored by APM agents, or they are monitored by agents that do not provide cross application tracing headers. Trace your requests from start to finish To trace your requests from start to finish, you can also click the distributed tracing link in the AJAX UI. To view a list of distributed traces, click the link in the AJAX UI at the AJAX summary level. To view all traces filtered by your application and a specific request type, click the distributed tracing link for the request you select in the AJAX UI. Time percentage example When you sort the AJAX category list by Total time percentage, the list shows the percentage for each AJAX category. Also, the chart shows the top requests with the highest time percentages. To present this information, browser takes the cumulative request time for each AJAX category and divides it by the cumulative request time for all AJAX requests. This helps identify where to optimize response times, because high throughput requests will be favored over low throughput requests. Example: Calculating time percentages for two AJAX categories This example uses two AJAX categories: api1.example.com and api2.example.com. Your api1.example.com is hit 1 time, and it takes 1 second (1000ms) to respond (1 x 1 second = 1 second). Your api2.example.com is hit 500 times, and it takes 1ms to respond (500 x 1ms = 500ms, or 0.5 second). The cumulative request time for all of your AJAX categories is 1500 ms, or 1.5 seconds. To get the time percentages, divide each AJAX category by the cumulative request time, and then multiply by 100 for the percentage. So api1.example.com is 67% (1000 divided by 1500, times 100) and api2.example.com is 33% (500 divided by 1500, times 100) of the total time percentage. Time calculations api1 api2 Number of hits 1 500 Time to respond 1 second (1000ms) 1 hit x 1000ms = 1000ms (1 second) 1 millisecond (1ms) 500 hits x 1ms = 500ms (.5 second) Cumulative request time for all AJAX categories 1000ms + 500ms = 1500ms (1.5 seconds) 1000ms + 500ms = 1500ms (1.5 seconds) Time percentage = Category / 1500ms cumulative request time x 100 for percentage 1000ms / 1500 x 100 = 67% 500ms / 1500 x 100 = 33% What's next In addition to the AJAX UI, you can also use these resources: Help prevent problems from occurring by using alerts and Applied Intelligence for your key performance indicators. Use single-page app (SPA) monitoring. This is valuable for any app that uses AJAX requests to pull content dynamically and create a fluid user experience. Query your data in the UI or by API. For example, you can query with default browser events, use SPA AjaxRequest for geographic and browser data, or get your own custom data into New Relic. Visualize and share your data with charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.93338,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Start with AJAX summary <em>charts</em>",
        "body": " tracing link in the AJAX UI. Timing problems Total time percentages, throughput requests per minute (rpm), and average data transfer <em>rates</em> per request can help identify timing problems. Look for large spikes in the AJAX summary page&#x27;s Average data transfer per request <em>chart</em>. From the individual call"
      },
      "id": "60442974e7b9d246115799c8"
    }
  ],
  "/docs/query-your-data/explore-query-data/use-charts/chart-types": [
    {
      "sections": [
        "Use your charts",
        "Change the appearance of your chart",
        "Customize your charts",
        "Tip",
        "Format date and time",
        "Customize the Y axis",
        "Enable or disable the legend",
        "Remove the other groups facet",
        "More chart-specific features",
        "Chart share and view options"
      ],
      "title": "Use  your charts ",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Use charts"
      ],
      "external_id": "947a92d0243924f412fedb47bcb95dc40ec953fb",
      "image": "https://docs.newrelic.com/static/9bd74f30a31df0cb0ab112a325296b92/59415/crop-cb-chart-menu-tooltip_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/use-charts/use-your-charts/",
      "published_at": "2021-07-09T22:39:48Z",
      "updated_at": "2021-05-15T21:00:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Once you've created a chart, you can customize the appearance of it to best present the data. You can share a chart in different formats and add a chart to a new or existing dashboard. Change the appearance of your chart When you run your query in advanced (NRQL) mode or view your chart while using basic mode to specify data, the query builder analyzes your data and applies a chart type that fits your data. For some queries, you'll have several options of chart types to choose from. To change chart type, use the Chart type menu to the right of the current chart. Each type in the list has a tooltip with information about using that type. Example of the chart type menu, showing a tooltip. Customize your charts While we try our best to optimize how we display your data, sometimes you may have other needs. To this end, you can customize charts to display information at your convenience. Tip Customizations are available depending on the chart type. Format date and time Tip For table and billboard charts. Customize the date and time format for tables and billboards: for each type of data, you can select if you want to leave it as it is, or modify the format as Numeric or Date. If data is a timestamp, you can choose how to represent the date and time: For numbers, select if you want us to auto-format them, or chose the number of decimals you want to see. Customize the Y axis Tip For line and area charts. On line charts and area charts you can adjust the Y axis to display the data within certain values by setting a minimum and maximum value for the axis. If no customization option is selected, dashboards automatically displays the full Y axis from 0 to the top value plus a margin. Enable or disable the legend Tip For line and area charts, and histograms. For line charts, area charts, and histograms, you can disable or enable the legend. Remove the other groups facet Tip For bar and pie charts, and tables. When faceting on bar charts, pie charts, or tables, and if the number of faceting on queries is larger than 2,000, the Other groups facet aggregates the rest of facets. With this customization you can select whether to see Other groups, or remove it. More chart-specific features For more chart type-specific features, see Chart types. Chart share and view options Most charts have various options, including a chart-embed option, getting a chart as an image, and adding a chart to a dashboard. To read about general chart options, see Basic UI features.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 423.5573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use  your <em>charts</em> ",
        "sections": "Use your <em>charts</em>",
        "tags": "Use <em>charts</em>",
        "body": " basic mode to specify data, the query builder analyzes your data and applies a <em>chart</em> <em>type</em> that fits your data. For some queries, you&#x27;ll have several options of <em>chart</em> <em>types</em> to choose from. To change <em>chart</em> <em>type</em>, use the <em>Chart</em> <em>type</em> menu to the right of the current <em>chart</em>. Each <em>type</em> in the list has"
      },
      "id": "603ec29a196a67ef5da83d82"
    },
    {
      "sections": [
        "Customize your visualization with configuration options",
        "Course",
        "Tip",
        "Add a new configuration option",
        "Replace your SegmentedControl with the configurable property",
        "Summary"
      ],
      "title": "Customize your visualization with configuration options",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "visualizations"
      ],
      "external_id": "9028e58f383ea362d2c9d3a7ecd6404dbfeac87c",
      "image": "https://developer.newrelic.com/static/64ef0a5585a2f035fdd69ab5ff628375/ba3ac/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/customize-visualizations-with-configuration/",
      "published_at": "2021-07-11T01:44:13Z",
      "updated_at": "2021-05-05T01:51:53Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization using configuration",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Each lesson in the course builds upon the last, so make sure you've completed the last lesson, Custom visualizations and the New Relic One SDK, before starting this one. In the previous lesson, you built a custom visualization that shows queried data in one of two chart types: RadarChart Treemap You used a SegmentedControl to switch between the two chart types in the visualization UI. This implementation takes up space in the visualization, but it offers your users the choice to switch between two chart types even after you've created an instance of your chart. But what if you only need to be able to select an option once, when initializing the visualization? In this lesson you'll learn how to add a configuration option to your visualization which replaces the SegmentedControl. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Add a new configuration option Step 1 of 8 In your visualization's nr1.json file, add an enum configuration object for selectedChart: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Step 2 of 8 Navigate to the root of your Nerdpack at alternate-viz. Step 3 of 8 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve If you're still serving your Nerdpack from the last lesson, you need to stop it with CTRL-X and serve it again to reflect changes to nr1.json. Step 4 of 8 Go to https://one.newrelic.com/?nerdpacks=local. The nerdpacks=local query string directs the UI to load your visualization from the local server. Step 5 of 8 Open the Apps page: Step 6 of 8 Go to Custom Visualizations, which is favorited by default: Step 7 of 8 In Custom Visualizations, find and click your visualization: Step 8 of 8 Notice the new Select chart configuration option: Selecting a chart type doesn't effect your visualization. This is because you first need to introduce the selectedChart property to the visualization component. Then, you use selectedChart to determine the chart type to render. Replace your SegmentedControl with the configurable property Step 1 of 5 Open your visualization's index.js file. You'll be working here for the rest of the guide. Step 2 of 5 In render(), include selectedChart as a constant you get from destructuring props, and remove your component's state: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 /** 55 * Restructure the data for a non-time-series, facet-based NRQL query into a 56 * form accepted by the Recharts library's RadarChart. 57 * (https://recharts.org/api/RadarChart). 58 */ 59 transformData = (rawData) => { 60 return rawData.map((entry) => ({ 61 name: entry.metadata.name, 62 // Only grabbing the first data value because this is not time-series data. 63 value: entry.data[0].y, 64 })); 65 }; 66 67 /** 68 * Format the given axis tick's numeric value into a string for display. 69 */ 70 formatTick = (value) => { 71 return value.toLocaleString(); 72 }; 73 74 render() { 75 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 76 77 const nrqlQueryPropsAvailable = 78 nrqlQueries && 79 nrqlQueries[0] && 80 nrqlQueries[0].accountId && 81 nrqlQueries[0].query; 82 83 if (!nrqlQueryPropsAvailable) { 84 return <EmptyState />; 85 } 86 87 return ( 88 <AutoSizer> 89 {({width, height}) => ( 90 <NrqlQuery 91 query={nrqlQueries[0].query} 92 accountId={parseInt(nrqlQueries[0].accountId)} 93 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 94 > 95 {({data, loading, error}) => { 96 if (loading) { 97 return <Spinner />; 98 } 99 100 if (error) { 101 return <ErrorState />; 102 } 103 104 const transformedData = this.transformData(data); 105 106 return ( 107 <React.Fragment> 108 <SegmentedControl> 109 <SegmentedControlItem 110 value={CHART_TYPES.Radar} 111 label=\"Radar chart\" 112 /> 113 <SegmentedControlItem 114 value={CHART_TYPES.Treemap} 115 label=\"Treemap chart\" 116 /> 117 </SegmentedControl> 118 {selectedChart === CHART_TYPES.Radar ? ( 119 <RadarChart 120 width={width} 121 height={height} 122 data={transformedData} 123 > 124 <PolarGrid /> 125 <PolarAngleAxis dataKey=\"name\" /> 126 <PolarRadiusAxis tickFormatter={this.formatTick} /> 127 <Radar 128 dataKey=\"value\" 129 stroke={stroke || '#51C9B7'} 130 fill={fill || '#51C9B7'} 131 fillOpacity={0.6} 132 /> 133 </RadarChart> 134 ) : ( 135 <Treemap 136 width={width} 137 height={height} 138 data={transformedData} 139 dataKey=\"value\" 140 ratio={4 / 3} 141 stroke={stroke || '#000000'} 142 fill={fill || '#51C9B7'} 143 /> 144 )} 145 </React.Fragment> 146 ); 147 }} 148 </NrqlQuery> 149 )} 150 </AutoSizer> 151 ); 152 } 153 } 154 155 const EmptyState = () => ( 156 <Card className=\"EmptyState\"> 157 <CardBody className=\"EmptyState-cardBody\"> 158 <HeadingText 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Please provide at least one NRQL query & account ID pair 163 </HeadingText> 164 <HeadingText 165 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 166 type={HeadingText.TYPE.HEADING_4} 167 > 168 An example NRQL query you can try is: 169 </HeadingText> 170 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 171 </CardBody> 172 </Card> 173 ); 174 175 const ErrorState = () => ( 176 <Card className=\"ErrorState\"> 177 <CardBody className=\"ErrorState-cardBody\"> 178 <HeadingText 179 className=\"ErrorState-headingText\" 180 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 181 type={HeadingText.TYPE.HEADING_3} 182 > 183 Oops! Something went wrong. 184 </HeadingText> 185 </CardBody> 186 </Card> 187 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Now that you're using selectedChart from the configuration options instead of component state, you can select a chart in the configuration panel and watch the visualization change. Unfortunately, there's a bug. The default chart option is Radar, but the initial render shows a Treemap. Step 3 of 5 Update your ternary expression to account for the case where there is no selectedChart: index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 /** 55 * Restructure the data for a non-time-series, facet-based NRQL query into a 56 * form accepted by the Recharts library's RadarChart. 57 * (https://recharts.org/api/RadarChart). 58 */ 59 transformData = (rawData) => { 60 return rawData.map((entry) => ({ 61 name: entry.metadata.name, 62 // Only grabbing the first data value because this is not time-series data. 63 value: entry.data[0].y, 64 })); 65 }; 66 67 /** 68 * Format the given axis tick's numeric value into a string for display. 69 */ 70 formatTick = (value) => { 71 return value.toLocaleString(); 72 }; 73 74 render() { 75 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 76 77 const nrqlQueryPropsAvailable = 78 nrqlQueries && 79 nrqlQueries[0] && 80 nrqlQueries[0].accountId && 81 nrqlQueries[0].query; 82 83 if (!nrqlQueryPropsAvailable) { 84 return <EmptyState />; 85 } 86 87 return ( 88 <AutoSizer> 89 {({width, height}) => ( 90 <NrqlQuery 91 query={nrqlQueries[0].query} 92 accountId={parseInt(nrqlQueries[0].accountId)} 93 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 94 > 95 {({data, loading, error}) => { 96 if (loading) { 97 return <Spinner />; 98 } 99 100 if (error) { 101 return <ErrorState />; 102 } 103 104 const transformedData = this.transformData(data); 105 106 return ( 107 <React.Fragment> 108 <SegmentedControl> 109 <SegmentedControlItem 110 value={CHART_TYPES.Radar} 111 label=\"Radar chart\" 112 /> 113 <SegmentedControlItem 114 value={CHART_TYPES.Treemap} 115 label=\"Treemap chart\" 116 /> 117 </SegmentedControl> 118 {!selectedChart || selectedChart === CHART_TYPES.Radar ? ( 119 <RadarChart 120 width={width} 121 height={height} 122 data={transformedData} 123 > 124 <PolarGrid /> 125 <PolarAngleAxis dataKey=\"name\" /> 126 <PolarRadiusAxis tickFormatter={this.formatTick} /> 127 <Radar 128 dataKey=\"value\" 129 stroke={stroke || '#51C9B7'} 130 fill={fill || '#51C9B7'} 131 fillOpacity={0.6} 132 /> 133 </RadarChart> 134 ) : ( 135 <Treemap 136 width={width} 137 height={height} 138 data={transformedData} 139 dataKey=\"value\" 140 ratio={4 / 3} 141 stroke={stroke || '#000000'} 142 fill={fill || '#51C9B7'} 143 /> 144 )} 145 </React.Fragment> 146 ); 147 }} 148 </NrqlQuery> 149 )} 150 </AutoSizer> 151 ); 152 } 153 } 154 155 const EmptyState = () => ( 156 <Card className=\"EmptyState\"> 157 <CardBody className=\"EmptyState-cardBody\"> 158 <HeadingText 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Please provide at least one NRQL query & account ID pair 163 </HeadingText> 164 <HeadingText 165 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 166 type={HeadingText.TYPE.HEADING_4} 167 > 168 An example NRQL query you can try is: 169 </HeadingText> 170 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 171 </CardBody> 172 </Card> 173 ); 174 175 const ErrorState = () => ( 176 <Card className=\"ErrorState\"> 177 <CardBody className=\"ErrorState-cardBody\"> 178 <HeadingText 179 className=\"ErrorState-headingText\" 180 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 181 type={HeadingText.TYPE.HEADING_3} 182 > 183 Oops! Something went wrong. 184 </HeadingText> 185 </CardBody> 186 </Card> 187 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Now, your data is rendered in a RadarChart if you haven't yet configured the option. Step 4 of 5 Remove SegmentedControl from render(): index.js nr1.json 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 Spinner, 18 } from 'nr1'; 19 20 const CHART_TYPES = { 21 'Radar': 'radar', 22 'Treemap': 'treemap' 23 } 24 25 export default class RadarOrTreemapVisualization extends React.Component { 26 // Custom props you wish to be configurable in the UI must also be defined in 27 // the nr1.json file for the visualization. See docs for more details. 28 static propTypes = { 29 /** 30 * A fill color to override the default fill color. This is an example of 31 * a custom chart configuration. 32 */ 33 fill: PropTypes.string, 34 35 /** 36 * A stroke color to override the default stroke color. This is an example of 37 * a custom chart configuration. 38 */ 39 stroke: PropTypes.string, 40 /** 41 * An array of objects consisting of a nrql `query` and `accountId`. 42 * This should be a standard prop for any NRQL based visualizations. 43 */ 44 nrqlQueries: PropTypes.arrayOf( 45 PropTypes.shape({ 46 accountId: PropTypes.number, 47 query: PropTypes.string, 48 }) 49 ), 50 }; 51 52 /** 53 * Restructure the data for a non-time-series, facet-based NRQL query into a 54 * form accepted by the Recharts library's RadarChart. 55 * (https://recharts.org/api/RadarChart). 56 */ 57 transformData = (rawData) => { 58 return rawData.map((entry) => ({ 59 name: entry.metadata.name, 60 // Only grabbing the first data value because this is not time-series data. 61 value: entry.data[0].y, 62 })); 63 }; 64 65 /** 66 * Format the given axis tick's numeric value into a string for display. 67 */ 68 formatTick = (value) => { 69 return value.toLocaleString(); 70 }; 71 72 render() { 73 const {nrqlQueries, stroke, fill, selectedChart} = this.props; 74 75 const nrqlQueryPropsAvailable = 76 nrqlQueries && 77 nrqlQueries[0] && 78 nrqlQueries[0].accountId && 79 nrqlQueries[0].query; 80 81 if (!nrqlQueryPropsAvailable) { 82 return <EmptyState />; 83 } 84 85 return ( 86 <AutoSizer> 87 {({width, height}) => ( 88 <NrqlQuery 89 query={nrqlQueries[0].query} 90 accountId={parseInt(nrqlQueries[0].accountId)} 91 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 92 > 93 {({data, loading, error}) => { 94 if (loading) { 95 return <Spinner />; 96 } 97 98 if (error) { 99 return <ErrorState />; 100 } 101 102 const transformedData = this.transformData(data); 103 104 return ( 105 <React.Fragment> 106 {!selectedChart || selectedChart === CHART_TYPES.Radar ? ( 107 <RadarChart 108 width={width} 109 height={height} 110 data={transformedData} 111 > 112 <PolarGrid /> 113 <PolarAngleAxis dataKey=\"name\" /> 114 <PolarRadiusAxis tickFormatter={this.formatTick} /> 115 <Radar 116 dataKey=\"value\" 117 stroke={stroke || '#51C9B7'} 118 fill={fill || '#51C9B7'} 119 fillOpacity={0.6} 120 /> 121 </RadarChart> 122 ) : ( 123 <Treemap 124 width={width} 125 height={height} 126 data={transformedData} 127 dataKey=\"value\" 128 ratio={4 / 3} 129 stroke={stroke || '#000000'} 130 fill={fill || '#51C9B7'} 131 /> 132 )} 133 </React.Fragment> 134 ); 135 }} 136 </NrqlQuery> 137 )} 138 </AutoSizer> 139 ); 140 } 141 } 142 143 const EmptyState = () => ( 144 <Card className=\"EmptyState\"> 145 <CardBody className=\"EmptyState-cardBody\"> 146 <HeadingText 147 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 148 type={HeadingText.TYPE.HEADING_3} 149 > 150 Please provide at least one NRQL query & account ID pair 151 </HeadingText> 152 <HeadingText 153 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 154 type={HeadingText.TYPE.HEADING_4} 155 > 156 An example NRQL query you can try is: 157 </HeadingText> 158 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 159 </CardBody> 160 </Card> 161 ); 162 163 const ErrorState = () => ( 164 <Card className=\"ErrorState\"> 165 <CardBody className=\"ErrorState-cardBody\"> 166 <HeadingText 167 className=\"ErrorState-headingText\" 168 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 169 type={HeadingText.TYPE.HEADING_3} 170 > 171 Oops! Something went wrong. 172 </HeadingText> 173 </CardBody> 174 </Card> 175 ); visualizations/radar-or-treemap/index.js Copy 1 { 2 \"schemaType\": \"VISUALIZATION\", 3 \"id\": \"radar-or-treemap\", 4 \"displayName\": \"RadarOrTreemap\", 5 \"description\": \"\", 6 \"configuration\": [ 7 { 8 \"name\": \"selectedChart\", 9 \"title\": \"Select chart\", 10 \"description\": \"Select which chart to display\", 11 \"type\": \"enum\", 12 \"items\": [ 13 { 14 \"title\": \"Radar\", 15 \"value\": \"radar\" 16 }, 17 { 18 \"title\": \"Treemap\", 19 \"value\": \"treemap\" 20 } 21 ] 22 }, 23 { 24 \"name\": \"nrqlQueries\", 25 \"title\": \"NRQL Queries\", 26 \"type\": \"collection\", 27 \"items\": [ 28 { 29 \"name\": \"accountId\", 30 \"title\": \"Account ID\", 31 \"description\": \"Account ID to be associated with the query\", 32 \"type\": \"account-id\" 33 }, 34 { 35 \"name\": \"query\", 36 \"title\": \"Query\", 37 \"description\": \"NRQL query for visualization\", 38 \"type\": \"nrql\" 39 } 40 ] 41 }, 42 { 43 \"name\": \"fill\", 44 \"title\": \"Fill color\", 45 \"description\": \"A fill color to override the default fill color\", 46 \"type\": \"string\" 47 }, 48 { 49 \"name\": \"stroke\", 50 \"title\": \"Stroke color\", 51 \"description\": \"A stroke color to override the default stroke color\", 52 \"type\": \"string\" 53 } 54 ] 55 } visualizations/radar-or-treemap/nr1.json Copy Step 5 of 5 Serve your Nerdpack locally, and view it in the Custom Visualizations app in New Relic. Select a chart type from the dropdown in the configuration sidebar, and see your visualization update to show the matching chart type: Summary Congratulations on completing this lesson! You've learned how to customize your visualization using nr1.json configuration. Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Add custom visualizations to your dashboards.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 422.80618,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". In the previous lesson, you built a custom visualization that shows queried data in one of two <em>chart</em> <em>types</em>: Radar<em>Chart</em> Treemap You used a SegmentedControl to switch between the two <em>chart</em> <em>types</em> in the visualization UI. This implementation takes up space in the visualization, but it offers your users"
      },
      "id": "6091fa3ae7b9d2df595068c1"
    },
    {
      "sections": [
        "Customize your visualization with SDK components",
        "Course",
        "Tip",
        "Before you begin",
        "Create your visualization",
        "Set up your component state",
        "Add SegmentedControl components",
        "Connect your component's state to the SegmentedControl",
        "Implement a Treemap option",
        "Technical detail",
        "Switch between charts with your component's state",
        "Summary"
      ],
      "title": "Customize your visualization with SDK components",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "NR One Catalog",
        "Subscribe visualizations"
      ],
      "external_id": "8317cf0361e92ab36c922dd87720e01a69530f9b",
      "image": "https://developer.newrelic.com/static/ae9d817689607337734a3d66e12d1dc4/ba3ac/radar-chart-with-segmented-control.png",
      "url": "https://developer.newrelic.com/build-apps/custom-visualizations-and-the-new-relic-one-sdk/",
      "published_at": "2021-07-11T01:44:14Z",
      "updated_at": "2021-05-13T01:45:29Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Customize your visualization",
      "body": "Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. Use New Relic One custom visualizations to display your data, whether it's from New Relic's database or an external source, in unique ways that are distinct from the charts offered by the New Relic platform. In this lesson, you build a visualization that displays your data in one of two chart types: RadarChart or Treemap. You then implement a SegmentedControl component from the New Relic One SDK, which allows you to alternate between the two chart types. Ultimately, this gives you freedom to view your data in a dynamic way that isn't possible with New Relic's base offerings. Tip If you get lost in the code project and would like to see what the files should look like when you're done with each lesson, check out the course project on Github. Before you begin Explore our custom visualization guides and build your first visualization. After you're done, you'll have a better foundation for building more complex visualizations, such as the one you'll build in this course. Finally, if you haven't already: Sign up for a New Relic account Install Node.js Complete the steps in the nr1 quick start to install and configure the CLI Create your visualization Step 1 of 2 Ensure you're working with the latest version of the New Relic One CLI: bash Copy $ nr1 update Step 2 of 2 Create a visualization, called radar-or-treemap, in a Nerdpack, called alternate-viz: bash Copy $ nr1 create --type visualization --name radar-or-treemap ✔ You’re trying to create a visualization outside of a Nerdpack. We’ll create a Nerdpack for you—what do you want to name it? … alternate-viz ✔ nerdpack created successfully! nerdpack alternate-viz is available at \"./alternate-viz\" ✔ visualization created successfully! visualization radar-or-treemap is available at \"./alternate-viz/visualizations/radar-or-treemap\" Tip If you receive a RequestError for a self-signed certificate when you run nr1 create, you may need to add a certificate to Node's certificate chain. Read more about this and other advanced configurations in Enable advanced configurations for your Nerdpack. As a result, you have a new visualizations/radar-or-treemap directory under alternate-viz: bash Copy $ cd alternate-viz $ ls visualizations/radar-or-treemap index.js nr1.json styles.scss Set up your component state Add component state to the default visualization template that nr1 created for you. Step 1 of 3 Navigate to alternate-viz/visualizations/radar-or-treemap/index.js. You'll work in here for the rest of this lesson. Step 2 of 3 Add a constant called CHART_TYPES: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 /** 45 * Restructure the data for a non-time-series, facet-based NRQL query into a 46 * form accepted by the Recharts library's RadarChart. 47 * (https://recharts.org/api/RadarChart). 48 */ 49 transformData = (rawData) => { 50 return rawData.map((entry) => ({ 51 name: entry.metadata.name, 52 // Only grabbing the first data value because this is not time-series data. 53 value: entry.data[0].y, 54 })); 55 }; 56 57 /** 58 * Format the given axis tick's numeric value into a string for display. 59 */ 60 formatTick = (value) => { 61 return value.toLocaleString(); 62 }; 63 64 render() { 65 const {nrqlQueries, stroke, fill} = this.props; 66 67 const nrqlQueryPropsAvailable = 68 nrqlQueries && 69 nrqlQueries[0] && 70 nrqlQueries[0].accountId && 71 nrqlQueries[0].query; 72 73 if (!nrqlQueryPropsAvailable) { 74 return <EmptyState />; 75 } 76 77 return ( 78 <AutoSizer> 79 {({width, height}) => ( 80 <NrqlQuery 81 query={nrqlQueries[0].query} 82 accountId={parseInt(nrqlQueries[0].accountId)} 83 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 84 > 85 {({data, loading, error}) => { 86 if (loading) { 87 return <Spinner />; 88 } 89 90 if (error) { 91 return <ErrorState />; 92 } 93 94 const transformedData = this.transformData(data); 95 96 return ( 97 <RadarChart 98 width={width} 99 height={height} 100 data={transformedData} 101 > 102 <PolarGrid /> 103 <PolarAngleAxis dataKey=\"name\" /> 104 <PolarRadiusAxis tickFormatter={this.formatTick} /> 105 <Radar 106 dataKey=\"value\" 107 stroke={stroke || '#51C9B7'} 108 fill={fill || '#51C9B7'} 109 fillOpacity={0.6} 110 /> 111 </RadarChart> 112 ); 113 }} 114 </NrqlQuery> 115 )} 116 </AutoSizer> 117 ); 118 } 119 } 120 121 const EmptyState = () => ( 122 <Card className=\"EmptyState\"> 123 <CardBody className=\"EmptyState-cardBody\"> 124 <HeadingText 125 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 126 type={HeadingText.TYPE.HEADING_3} 127 > 128 Please provide at least one NRQL query & account ID pair 129 </HeadingText> 130 <HeadingText 131 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 132 type={HeadingText.TYPE.HEADING_4} 133 > 134 An example NRQL query you can try is: 135 </HeadingText> 136 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 137 </CardBody> 138 </Card> 139 ); 140 141 const ErrorState = () => ( 142 <Card className=\"ErrorState\"> 143 <CardBody className=\"ErrorState-cardBody\"> 144 <HeadingText 145 className=\"ErrorState-headingText\" 146 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 147 type={HeadingText.TYPE.HEADING_3} 148 > 149 Oops! Something went wrong. 150 </HeadingText> 151 </CardBody> 152 </Card> 153 ); visualizations/radar-or-treemap/index.js Copy CHART_TYPES enumerates the two chart types you'll alternate between in your visualization. Step 3 of 3 Initialize selectedChart in your component's state: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import {Card, CardBody, HeadingText, NrqlQuery, Spinner, AutoSizer} from 'nr1'; 11 12 const CHART_TYPES = { 13 'Radar': 'radar', 14 'Treemap': 'treemap' 15 } 16 17 export default class RadarOrTreemapVisualization extends React.Component { 18 // Custom props you wish to be configurable in the UI must also be defined in 19 // the nr1.json file for the visualization. See docs for more details. 20 static propTypes = { 21 /** 22 * A fill color to override the default fill color. This is an example of 23 * a custom chart configuration. 24 */ 25 fill: PropTypes.string, 26 27 /** 28 * A stroke color to override the default stroke color. This is an example of 29 * a custom chart configuration. 30 */ 31 stroke: PropTypes.string, 32 /** 33 * An array of objects consisting of a nrql `query` and `accountId`. 34 * This should be a standard prop for any NRQL based visualizations. 35 */ 36 nrqlQueries: PropTypes.arrayOf( 37 PropTypes.shape({ 38 accountId: PropTypes.number, 39 query: PropTypes.string, 40 }) 41 ), 42 }; 43 44 state = { 45 selectedChart: CHART_TYPES.Radar, 46 }; 47 48 /** 49 * Restructure the data for a non-time-series, facet-based NRQL query into a 50 * form accepted by the Recharts library's RadarChart. 51 * (https://recharts.org/api/RadarChart). 52 */ 53 transformData = (rawData) => { 54 return rawData.map((entry) => ({ 55 name: entry.metadata.name, 56 // Only grabbing the first data value because this is not time-series data. 57 value: entry.data[0].y, 58 })); 59 }; 60 61 /** 62 * Format the given axis tick's numeric value into a string for display. 63 */ 64 formatTick = (value) => { 65 return value.toLocaleString(); 66 }; 67 68 render() { 69 const {nrqlQueries, stroke, fill} = this.props; 70 71 const nrqlQueryPropsAvailable = 72 nrqlQueries && 73 nrqlQueries[0] && 74 nrqlQueries[0].accountId && 75 nrqlQueries[0].query; 76 77 if (!nrqlQueryPropsAvailable) { 78 return <EmptyState />; 79 } 80 81 return ( 82 <AutoSizer> 83 {({width, height}) => ( 84 <NrqlQuery 85 query={nrqlQueries[0].query} 86 accountId={parseInt(nrqlQueries[0].accountId)} 87 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 88 > 89 {({data, loading, error}) => { 90 if (loading) { 91 return <Spinner />; 92 } 93 94 if (error) { 95 return <ErrorState />; 96 } 97 98 const transformedData = this.transformData(data); 99 100 return ( 101 <RadarChart 102 width={width} 103 height={height} 104 data={transformedData} 105 > 106 <PolarGrid /> 107 <PolarAngleAxis dataKey=\"name\" /> 108 <PolarRadiusAxis tickFormatter={this.formatTick} /> 109 <Radar 110 dataKey=\"value\" 111 stroke={stroke || '#51C9B7'} 112 fill={fill || '#51C9B7'} 113 fillOpacity={0.6} 114 /> 115 </RadarChart> 116 ); 117 }} 118 </NrqlQuery> 119 )} 120 </AutoSizer> 121 ); 122 } 123 } 124 125 const EmptyState = () => ( 126 <Card className=\"EmptyState\"> 127 <CardBody className=\"EmptyState-cardBody\"> 128 <HeadingText 129 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 130 type={HeadingText.TYPE.HEADING_3} 131 > 132 Please provide at least one NRQL query & account ID pair 133 </HeadingText> 134 <HeadingText 135 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 136 type={HeadingText.TYPE.HEADING_4} 137 > 138 An example NRQL query you can try is: 139 </HeadingText> 140 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 141 </CardBody> 142 </Card> 143 ); 144 145 const ErrorState = () => ( 146 <Card className=\"ErrorState\"> 147 <CardBody className=\"ErrorState-cardBody\"> 148 <HeadingText 149 className=\"ErrorState-headingText\" 150 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 151 type={HeadingText.TYPE.HEADING_3} 152 > 153 Oops! Something went wrong. 154 </HeadingText> 155 </CardBody> 156 </Card> 157 ); visualizations/radar-or-treemap/index.js Copy This state value stores the chart type in which you want to show your data. Now that you've created an object which enumerates the chart type options for your visualization, and you've initialized state.selectedChart, you're ready to implement a control UI for switching between the two chart types. Add SegmentedControl components state.selectedChart isn't useful unless your visualization's users can actually select a chart type. Use SegmentedControl and SegmentedControlItem to switch between the two chart types. Tip To learn more about the components available in the New Relic One SDK, go to our Intro to New Relic One SDK. Step 1 of 7 Import SegmentedControl and SegmentedControlItem from nr1: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <RadarChart 111 width={width} 112 height={height} 113 data={transformedData} 114 > 115 <PolarGrid /> 116 <PolarAngleAxis dataKey=\"name\" /> 117 <PolarRadiusAxis tickFormatter={this.formatTick} /> 118 <Radar 119 dataKey=\"value\" 120 stroke={stroke || '#51C9B7'} 121 fill={fill || '#51C9B7'} 122 fillOpacity={0.6} 123 /> 124 </RadarChart> 125 ); 126 }} 127 </NrqlQuery> 128 )} 129 </AutoSizer> 130 ); 131 } 132 } 133 134 const EmptyState = () => ( 135 <Card className=\"EmptyState\"> 136 <CardBody className=\"EmptyState-cardBody\"> 137 <HeadingText 138 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 139 type={HeadingText.TYPE.HEADING_3} 140 > 141 Please provide at least one NRQL query & account ID pair 142 </HeadingText> 143 <HeadingText 144 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 145 type={HeadingText.TYPE.HEADING_4} 146 > 147 An example NRQL query you can try is: 148 </HeadingText> 149 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 150 </CardBody> 151 </Card> 152 ); 153 154 const ErrorState = () => ( 155 <Card className=\"ErrorState\"> 156 <CardBody className=\"ErrorState-cardBody\"> 157 <HeadingText 158 className=\"ErrorState-headingText\" 159 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 160 type={HeadingText.TYPE.HEADING_3} 161 > 162 Oops! Something went wrong. 163 </HeadingText> 164 </CardBody> 165 </Card> 166 ); visualizations/radar-or-treemap/index.js Copy Step 2 of 7 In render(), wrap RadarChart in a React.Fragment: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <RadarChart 112 width={width} 113 height={height} 114 data={transformedData} 115 > 116 <PolarGrid /> 117 <PolarAngleAxis dataKey=\"name\" /> 118 <PolarRadiusAxis tickFormatter={this.formatTick} /> 119 <Radar 120 dataKey=\"value\" 121 stroke={stroke || '#51C9B7'} 122 fill={fill || '#51C9B7'} 123 fillOpacity={0.6} 124 /> 125 </RadarChart> 126 </React.Fragment> 127 ); 128 }} 129 </NrqlQuery> 130 )} 131 </AutoSizer> 132 ); 133 } 134 } 135 136 const EmptyState = () => ( 137 <Card className=\"EmptyState\"> 138 <CardBody className=\"EmptyState-cardBody\"> 139 <HeadingText 140 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 141 type={HeadingText.TYPE.HEADING_3} 142 > 143 Please provide at least one NRQL query & account ID pair 144 </HeadingText> 145 <HeadingText 146 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 147 type={HeadingText.TYPE.HEADING_4} 148 > 149 An example NRQL query you can try is: 150 </HeadingText> 151 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 152 </CardBody> 153 </Card> 154 ); 155 156 const ErrorState = () => ( 157 <Card className=\"ErrorState\"> 158 <CardBody className=\"ErrorState-cardBody\"> 159 <HeadingText 160 className=\"ErrorState-headingText\" 161 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 162 type={HeadingText.TYPE.HEADING_3} 163 > 164 Oops! Something went wrong. 165 </HeadingText> 166 </CardBody> 167 </Card> 168 ); visualizations/radar-or-treemap/index.js Copy This allows you to return multiple components from the same render(). Step 3 of 7 Add a SegmentedControl and two SegmentedControlItem components, each with a value and a label: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 render() { 78 const {nrqlQueries, stroke, fill} = this.props; 79 80 const nrqlQueryPropsAvailable = 81 nrqlQueries && 82 nrqlQueries[0] && 83 nrqlQueries[0].accountId && 84 nrqlQueries[0].query; 85 86 if (!nrqlQueryPropsAvailable) { 87 return <EmptyState />; 88 } 89 90 return ( 91 <AutoSizer> 92 {({width, height}) => ( 93 <NrqlQuery 94 query={nrqlQueries[0].query} 95 accountId={parseInt(nrqlQueries[0].accountId)} 96 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 97 > 98 {({data, loading, error}) => { 99 if (loading) { 100 return <Spinner />; 101 } 102 103 if (error) { 104 return <ErrorState />; 105 } 106 107 const transformedData = this.transformData(data); 108 109 return ( 110 <React.Fragment> 111 <SegmentedControl 112 onChange={(event, value) => console.log(value)} 113 > 114 <SegmentedControlItem 115 value={CHART_TYPES.Radar} 116 label=\"Radar chart\" 117 /> 118 <SegmentedControlItem 119 value={CHART_TYPES.Treemap} 120 label=\"Treemap chart\" 121 /> 122 </SegmentedControl> 123 <RadarChart 124 width={width} 125 height={height} 126 data={transformedData} 127 > 128 <PolarGrid /> 129 <PolarAngleAxis dataKey=\"name\" /> 130 <PolarRadiusAxis tickFormatter={this.formatTick} /> 131 <Radar 132 dataKey=\"value\" 133 stroke={stroke || '#51C9B7'} 134 fill={fill || '#51C9B7'} 135 fillOpacity={0.6} 136 /> 137 </RadarChart> 138 </React.Fragment> 139 ); 140 }} 141 </NrqlQuery> 142 )} 143 </AutoSizer> 144 ); 145 } 146 } 147 148 const EmptyState = () => ( 149 <Card className=\"EmptyState\"> 150 <CardBody className=\"EmptyState-cardBody\"> 151 <HeadingText 152 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 153 type={HeadingText.TYPE.HEADING_3} 154 > 155 Please provide at least one NRQL query & account ID pair 156 </HeadingText> 157 <HeadingText 158 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 159 type={HeadingText.TYPE.HEADING_4} 160 > 161 An example NRQL query you can try is: 162 </HeadingText> 163 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 164 </CardBody> 165 </Card> 166 ); 167 168 const ErrorState = () => ( 169 <Card className=\"ErrorState\"> 170 <CardBody className=\"ErrorState-cardBody\"> 171 <HeadingText 172 className=\"ErrorState-headingText\" 173 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 174 type={HeadingText.TYPE.HEADING_3} 175 > 176 Oops! Something went wrong. 177 </HeadingText> 178 </CardBody> 179 </Card> 180 ); visualizations/radar-or-treemap/index.js Copy Here, your SegmentedControl logs the SegmentedControlItem.value to the console when you change your selection. The values you've defined for your SegmentedControlItem components correspond to the two CHART_TYPES you created in a previous step. Step 4 of 7 Navigate to the root of your Nerdpack at alternate-viz. Step 5 of 7 Serve your Nerdpack locally: bash Copy $ nr1 nerdpack:serve Step 6 of 7 Open the link to your visualization that's shown in the terminal when the Node server starts: bash Copy Visualizations: ⁎ radar-or-treemap https://one.nr/012ab3cd4Ef Step 7 of 7 Configure your visualization with an account ID and a query: With some required data for your chart to process, you now see a RadarChart with the SegmentedControl at the top of the view. Look at your browser's console to see your SegmentedControl logs: Connect your component's state to the SegmentedControl Add a method to update state and connect that method with the SegmentedControl you added in the last section. Step 1 of 2 Add a component method, called updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={(event, value) => console.log(value)} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy This new method takes a value argument and sets state.selectedChart to that value. Step 2 of 2 Set SegmentedControl.onChange to updateSelectedChart(): index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 } from 'recharts'; 10 import { 11 AutoSizer, 12 Card, 13 CardBody, 14 HeadingText, 15 NrqlQuery, 16 SegmentedControl, 17 SegmentedControlItem, 18 Spinner, 19 } from 'nr1'; 20 21 const CHART_TYPES = { 22 'Radar': 'radar', 23 'Treemap': 'treemap' 24 } 25 26 export default class RadarOrTreemapVisualization extends React.Component { 27 // Custom props you wish to be configurable in the UI must also be defined in 28 // the nr1.json file for the visualization. See docs for more details. 29 static propTypes = { 30 /** 31 * A fill color to override the default fill color. This is an example of 32 * a custom chart configuration. 33 */ 34 fill: PropTypes.string, 35 36 /** 37 * A stroke color to override the default stroke color. This is an example of 38 * a custom chart configuration. 39 */ 40 stroke: PropTypes.string, 41 /** 42 * An array of objects consisting of a nrql `query` and `accountId`. 43 * This should be a standard prop for any NRQL based visualizations. 44 */ 45 nrqlQueries: PropTypes.arrayOf( 46 PropTypes.shape({ 47 accountId: PropTypes.number, 48 query: PropTypes.string, 49 }) 50 ), 51 }; 52 53 state = { 54 selectedChart: CHART_TYPES.Radar, 55 }; 56 57 /** 58 * Restructure the data for a non-time-series, facet-based NRQL query into a 59 * form accepted by the Recharts library's RadarChart. 60 * (https://recharts.org/api/RadarChart). 61 */ 62 transformData = (rawData) => { 63 return rawData.map((entry) => ({ 64 name: entry.metadata.name, 65 // Only grabbing the first data value because this is not time-series data. 66 value: entry.data[0].y, 67 })); 68 }; 69 70 /** 71 * Format the given axis tick's numeric value into a string for display. 72 */ 73 formatTick = (value) => { 74 return value.toLocaleString(); 75 }; 76 77 updateSelectedChart = (evt, value) => { 78 this.setState({ selectedChart: value }) 79 }; 80 81 render() { 82 const {nrqlQueries, stroke, fill} = this.props; 83 84 const nrqlQueryPropsAvailable = 85 nrqlQueries && 86 nrqlQueries[0] && 87 nrqlQueries[0].accountId && 88 nrqlQueries[0].query; 89 90 if (!nrqlQueryPropsAvailable) { 91 return <EmptyState />; 92 } 93 94 return ( 95 <AutoSizer> 96 {({width, height}) => ( 97 <NrqlQuery 98 query={nrqlQueries[0].query} 99 accountId={parseInt(nrqlQueries[0].accountId)} 100 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 101 > 102 {({data, loading, error}) => { 103 if (loading) { 104 return <Spinner />; 105 } 106 107 if (error) { 108 return <ErrorState />; 109 } 110 111 const transformedData = this.transformData(data); 112 113 return ( 114 <React.Fragment> 115 <SegmentedControl 116 onChange={this.updateSelectedChart} 117 > 118 <SegmentedControlItem 119 value={CHART_TYPES.Radar} 120 label=\"Radar chart\" 121 /> 122 <SegmentedControlItem 123 value={CHART_TYPES.Treemap} 124 label=\"Treemap chart\" 125 /> 126 </SegmentedControl> 127 <RadarChart 128 width={width} 129 height={height} 130 data={transformedData} 131 > 132 <PolarGrid /> 133 <PolarAngleAxis dataKey=\"name\" /> 134 <PolarRadiusAxis tickFormatter={this.formatTick} /> 135 <Radar 136 dataKey=\"value\" 137 stroke={stroke || '#51C9B7'} 138 fill={fill || '#51C9B7'} 139 fillOpacity={0.6} 140 /> 141 </RadarChart> 142 </React.Fragment> 143 ); 144 }} 145 </NrqlQuery> 146 )} 147 </AutoSizer> 148 ); 149 } 150 } 151 152 const EmptyState = () => ( 153 <Card className=\"EmptyState\"> 154 <CardBody className=\"EmptyState-cardBody\"> 155 <HeadingText 156 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 157 type={HeadingText.TYPE.HEADING_3} 158 > 159 Please provide at least one NRQL query & account ID pair 160 </HeadingText> 161 <HeadingText 162 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 163 type={HeadingText.TYPE.HEADING_4} 164 > 165 An example NRQL query you can try is: 166 </HeadingText> 167 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 168 </CardBody> 169 </Card> 170 ); 171 172 const ErrorState = () => ( 173 <Card className=\"ErrorState\"> 174 <CardBody className=\"ErrorState-cardBody\"> 175 <HeadingText 176 className=\"ErrorState-headingText\" 177 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 178 type={HeadingText.TYPE.HEADING_3} 179 > 180 Oops! Something went wrong. 181 </HeadingText> 182 </CardBody> 183 </Card> 184 ); visualizations/radar-or-treemap/index.js Copy Now, when you change your selection in the SegmentedControl, your selection will be set in state. Implement a Treemap option Add a Treemap to your visualization. This map will be an alternative to the existing RadarChart. Technical detail This guide uses Recharts components for third-party charts, but you can use any other JavaScript charting libraries that are compatible with the current React version when you build New Relic One visualizations and apps. Step 1 of 3 Import Treemap from recharts: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 </React.Fragment> 144 ); 145 }} 146 </NrqlQuery> 147 )} 148 </AutoSizer> 149 ); 150 } 151 } 152 153 const EmptyState = () => ( 154 <Card className=\"EmptyState\"> 155 <CardBody className=\"EmptyState-cardBody\"> 156 <HeadingText 157 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 158 type={HeadingText.TYPE.HEADING_3} 159 > 160 Please provide at least one NRQL query & account ID pair 161 </HeadingText> 162 <HeadingText 163 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 164 type={HeadingText.TYPE.HEADING_4} 165 > 166 An example NRQL query you can try is: 167 </HeadingText> 168 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 169 </CardBody> 170 </Card> 171 ); 172 173 const ErrorState = () => ( 174 <Card className=\"ErrorState\"> 175 <CardBody className=\"ErrorState-cardBody\"> 176 <HeadingText 177 className=\"ErrorState-headingText\" 178 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 179 type={HeadingText.TYPE.HEADING_3} 180 > 181 Oops! Something went wrong. 182 </HeadingText> 183 </CardBody> 184 </Card> 185 ); visualizations/radar-or-treemap/index.js Copy Now, you can use Treemap in your visualization component. Step 2 of 3 In render(), add a Treemap component: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 85 const nrqlQueryPropsAvailable = 86 nrqlQueries && 87 nrqlQueries[0] && 88 nrqlQueries[0].accountId && 89 nrqlQueries[0].query; 90 91 if (!nrqlQueryPropsAvailable) { 92 return <EmptyState />; 93 } 94 95 return ( 96 <AutoSizer> 97 {({width, height}) => ( 98 <NrqlQuery 99 query={nrqlQueries[0].query} 100 accountId={parseInt(nrqlQueries[0].accountId)} 101 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 102 > 103 {({data, loading, error}) => { 104 if (loading) { 105 return <Spinner />; 106 } 107 108 if (error) { 109 return <ErrorState />; 110 } 111 112 const transformedData = this.transformData(data); 113 114 return ( 115 <React.Fragment> 116 <SegmentedControl 117 onChange={this.updateSelectedChart} 118 > 119 <SegmentedControlItem 120 value={CHART_TYPES.Radar} 121 label=\"Radar chart\" 122 /> 123 <SegmentedControlItem 124 value={CHART_TYPES.Treemap} 125 label=\"Treemap chart\" 126 /> 127 </SegmentedControl> 128 <RadarChart 129 width={width} 130 height={height} 131 data={transformedData} 132 > 133 <PolarGrid /> 134 <PolarAngleAxis dataKey=\"name\" /> 135 <PolarRadiusAxis tickFormatter={this.formatTick} /> 136 <Radar 137 dataKey=\"value\" 138 stroke={stroke || '#51C9B7'} 139 fill={fill || '#51C9B7'} 140 fillOpacity={0.6} 141 /> 142 </RadarChart> 143 <Treemap 144 width={width} 145 height={height} 146 data={transformedData} 147 dataKey=\"value\" 148 ratio={4 / 3} 149 stroke={stroke || '#000000'} 150 fill={fill || '#51C9B7'} 151 /> 152 </React.Fragment> 153 ); 154 }} 155 </NrqlQuery> 156 )} 157 </AutoSizer> 158 ); 159 } 160 } 161 162 const EmptyState = () => ( 163 <Card className=\"EmptyState\"> 164 <CardBody className=\"EmptyState-cardBody\"> 165 <HeadingText 166 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 167 type={HeadingText.TYPE.HEADING_3} 168 > 169 Please provide at least one NRQL query & account ID pair 170 </HeadingText> 171 <HeadingText 172 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 173 type={HeadingText.TYPE.HEADING_4} 174 > 175 An example NRQL query you can try is: 176 </HeadingText> 177 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 178 </CardBody> 179 </Card> 180 ); 181 182 const ErrorState = () => ( 183 <Card className=\"ErrorState\"> 184 <CardBody className=\"ErrorState-cardBody\"> 185 <HeadingText 186 className=\"ErrorState-headingText\" 187 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 188 type={HeadingText.TYPE.HEADING_3} 189 > 190 Oops! Something went wrong. 191 </HeadingText> 192 </CardBody> 193 </Card> 194 ); visualizations/radar-or-treemap/index.js Copy Here, you've defined a new Treemap component with some props, including height, width, fill, and stroke. Step 3 of 3 With your Nerdpack served locally, view your visualization. The SegmentedControl and RadarChart are at the top of the view, but if you scroll down, you'll see your new Treemap: Switch between charts with your component's state Use state.selectedChart to determine which chart to show: the RadarChart or the Treemap. Step 1 of 1 Destructure this.state to access selectedChart as a separate constant. Then, compare selectedChart to CHART_TYPES.Radar. If they are the same, render a RadarChart. Otherwise, render a Treemap: index.js 1 import React from 'react'; 2 import PropTypes from 'prop-types'; 3 import { 4 Radar, 5 RadarChart, 6 PolarGrid, 7 PolarAngleAxis, 8 PolarRadiusAxis, 9 Treemap, 10 } from 'recharts'; 11 import { 12 AutoSizer, 13 Card, 14 CardBody, 15 HeadingText, 16 NrqlQuery, 17 SegmentedControl, 18 SegmentedControlItem, 19 Spinner, 20 } from 'nr1'; 21 22 const CHART_TYPES = { 23 'Radar': 'radar', 24 'Treemap': 'treemap' 25 } 26 27 export default class RadarOrTreemapVisualization extends React.Component { 28 // Custom props you wish to be configurable in the UI must also be defined in 29 // the nr1.json file for the visualization. See docs for more details. 30 static propTypes = { 31 /** 32 * A fill color to override the default fill color. This is an example of 33 * a custom chart configuration. 34 */ 35 fill: PropTypes.string, 36 37 /** 38 * A stroke color to override the default stroke color. This is an example of 39 * a custom chart configuration. 40 */ 41 stroke: PropTypes.string, 42 /** 43 * An array of objects consisting of a nrql `query` and `accountId`. 44 * This should be a standard prop for any NRQL based visualizations. 45 */ 46 nrqlQueries: PropTypes.arrayOf( 47 PropTypes.shape({ 48 accountId: PropTypes.number, 49 query: PropTypes.string, 50 }) 51 ), 52 }; 53 54 state = { 55 selectedChart: CHART_TYPES.Radar, 56 }; 57 58 /** 59 * Restructure the data for a non-time-series, facet-based NRQL query into a 60 * form accepted by the Recharts library's RadarChart. 61 * (https://recharts.org/api/RadarChart). 62 */ 63 transformData = (rawData) => { 64 return rawData.map((entry) => ({ 65 name: entry.metadata.name, 66 // Only grabbing the first data value because this is not time-series data. 67 value: entry.data[0].y, 68 })); 69 }; 70 71 /** 72 * Format the given axis tick's numeric value into a string for display. 73 */ 74 formatTick = (value) => { 75 return value.toLocaleString(); 76 }; 77 78 updateSelectedChart = (evt, value) => { 79 this.setState({ selectedChart: value }) 80 }; 81 82 render() { 83 const {nrqlQueries, stroke, fill} = this.props; 84 const {selectedChart} = this.state; 85 86 const nrqlQueryPropsAvailable = 87 nrqlQueries && 88 nrqlQueries[0] && 89 nrqlQueries[0].accountId && 90 nrqlQueries[0].query; 91 92 if (!nrqlQueryPropsAvailable) { 93 return <EmptyState />; 94 } 95 96 return ( 97 <AutoSizer> 98 {({width, height}) => ( 99 <NrqlQuery 100 query={nrqlQueries[0].query} 101 accountId={parseInt(nrqlQueries[0].accountId)} 102 pollInterval={NrqlQuery.AUTO_POLL_INTERVAL} 103 > 104 {({data, loading, error}) => { 105 if (loading) { 106 return <Spinner />; 107 } 108 109 if (error) { 110 return <ErrorState />; 111 } 112 113 const transformedData = this.transformData(data); 114 115 return ( 116 <React.Fragment> 117 <SegmentedControl 118 onChange={this.updateSelectedChart} 119 > 120 <SegmentedControlItem 121 value={CHART_TYPES.Radar} 122 label=\"Radar chart\" 123 /> 124 <SegmentedControlItem 125 value={CHART_TYPES.Treemap} 126 label=\"Treemap chart\" 127 /> 128 </SegmentedControl> 129 {selectedChart === CHART_TYPES.Radar ? ( 130 <RadarChart 131 width={width} 132 height={height} 133 data={transformedData} 134 > 135 <PolarGrid /> 136 <PolarAngleAxis dataKey=\"name\" /> 137 <PolarRadiusAxis tickFormatter={this.formatTick} /> 138 <Radar 139 dataKey=\"value\" 140 stroke={stroke || '#51C9B7'} 141 fill={fill || '#51C9B7'} 142 fillOpacity={0.6} 143 /> 144 </RadarChart> 145 ) : ( 146 <Treemap 147 width={width} 148 height={height} 149 data={transformedData} 150 dataKey=\"value\" 151 ratio={4 / 3} 152 stroke={stroke || '#000000'} 153 fill={fill || '#51C9B7'} 154 /> 155 )} 156 </React.Fragment> 157 ); 158 }} 159 </NrqlQuery> 160 )} 161 </AutoSizer> 162 ); 163 } 164 } 165 166 const EmptyState = () => ( 167 <Card className=\"EmptyState\"> 168 <CardBody className=\"EmptyState-cardBody\"> 169 <HeadingText 170 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 171 type={HeadingText.TYPE.HEADING_3} 172 > 173 Please provide at least one NRQL query & account ID pair 174 </HeadingText> 175 <HeadingText 176 spacingType={[HeadingText.SPACING_TYPE.MEDIUM]} 177 type={HeadingText.TYPE.HEADING_4} 178 > 179 An example NRQL query you can try is: 180 </HeadingText> 181 <code>FROM NrUsage SELECT sum(usage) FACET metric SINCE 1 week ago</code> 182 </CardBody> 183 </Card> 184 ); 185 186 const ErrorState = () => ( 187 <Card className=\"ErrorState\"> 188 <CardBody className=\"ErrorState-cardBody\"> 189 <HeadingText 190 className=\"ErrorState-headingText\" 191 spacingType={[HeadingText.SPACING_TYPE.LARGE]} 192 type={HeadingText.TYPE.HEADING_3} 193 > 194 Oops! Something went wrong. 195 </HeadingText> 196 </CardBody> 197 </Card> 198 ); visualizations/radar-or-treemap/index.js Copy Here, you used a ternary expression to render a RadarChart or a Treemap. The rendered chart is determined by the value of selectedChart. With your Nerdpack served locally, view your visualization. Select Radar chart from the SegmentedControl: Select Treemap chart from the SegmentedControl: Summary Congratulations! In this lesson, you learned how to: Customize your visualization using New Relic One SDK components Add a new chart type to your visualization Create a user interaction in your visualization Course This lesson is part of a course that teaches you how to build a custom visualization in the New Relic One platform. When you're ready, continue on to the next lesson: Customize visualizations with configuration.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 415.62387,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Switch between <em>charts</em> with your component&#x27;s state",
        "body": " spacing<em>Type</em>={[HeadingText.SPACING_<em>TYPE</em>.LARGE]} 147 <em>type</em>={HeadingText.<em>TYPE</em>.HEADING_3} 148 &gt; 149 Oops! Something went wrong. 150 &lt;&#x2F;HeadingText&gt; 151 &lt;&#x2F;CardBody&gt; 152 &lt;&#x2F;Card&gt; 153 ); visualizations&#x2F;radar-or-treemap&#x2F;index.js Copy <em>CHART_TYPES</em> enumerates the two <em>chart</em> <em>types</em> you&#x27;ll alternate between in your"
      },
      "id": "6091fa3b196a679beed52a6b"
    }
  ],
  "/docs/query-your-data/explore-query-data/use-charts/use-your-charts": [
    {
      "sections": [
        "Query builder: Basic mode",
        "Important",
        "Data type",
        "Example of using basic mode",
        "Step 1: Select the source of the data for a chart",
        "Step 2: Filter the data",
        "Step 3: Adjust time range and limits",
        "Step 4: Customize the chart"
      ],
      "title": "Query builder: Basic mode",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Query builder"
      ],
      "external_id": "7f076b3909c9462829453bc59f0dae0f5d5501fd",
      "image": "https://docs.newrelic.com/static/6be4a8d2af5e02259c01e180d7f43326/58213/crop-basic-example-chart_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/query-builder/query-builder-basic-mode/",
      "published_at": "2021-07-10T03:13:37Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the New Relic One query builder in basic mode to create a chart without having to use NRQL, our querying language. The basic mode helps guides you through a query-creation process. You can choose the source of the raw data, apply filters, and use other techniques to narrow the scope of the data in the chart. Important As of September 1, 2021, we are discontinuing support of the query builder's basic mode. Instead, you can use our data explorer's user-friendly and intuitive functionality in New Relic One. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. Data type The query builder basic mode has a Data type selector with two options: Events: In this context, this refers to all our non-Metric-type data, including events, logs, and trace data. Metrics: This refers to our dimensional Metric data type. You can also use this to query some types of metric timeslice data. For more on other types of metrics, see Data types. Example of using basic mode This example shows how to create a chart in basic mode. Step 1: Select the source of the data for a chart Begin by specifying what data you want to view in your chart. Click in the View a chart with box to select the event type, an attribute, and a function to perform on the attribute. You can use the event data dictionary to view information about an event type and its attributes on a single page. To see a tooltip with information about an event or attribute, hover over any term that has a dotted line underneath it. Here are the results of using the event data dictionary to specify the data: Event type. The Transaction event type measures a variety of data that describes what happens while a user is on a website, such as that user clicking on a button on a page. Attribute. The name attribute stores information on all transactions. Function. Select the unique_count function to get a count of all the transactions that occurred during the time frame. Basic mode now shows the selection: one.newrelic.com > Query builder > Basic > (event and attribute specified) As you specify data, the chart updates to show you the results from the data you specified. Based on the information specified so far, you can see a chart that shows the total number of transactions during the default time frame of 30 minutes. This total includes all transactions, whether the transaction was completed successfully or had errors. one.newrelic.com > Query builder > Basic > (event and attribute specified) Step 2: Filter the data Your next step is to determine which of those transactions got a 404 page not found error. If you look in the event data dictionary for the Transaction event type, you'll find this event also includes an attribute called httpResponseCode. Narrow the results to show only those transactions where a page not found error occurred. Use the Narrow results to box to create this filter: httpResponseCode = 404 . Because you want to be able to see the names of the apps that are resulting in the 404 errors, you use the Facet by box to see the results by appName (which is also an attribute for the Transaction event type). Faceting by appName updates the chart to break down the total number of 404 errors by the application names. This lets you know which apps are experiencing 404 errors. Your chart now shows the line chart with a line for each app, each with its own color. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) Step 3: Adjust time range and limits You decide to focus on the five apps with the most page not found errors. The default value for the Limit field is 10, meaning that your chart will show the ten most relevant returns. You change that value to 5. Customer support told you that they had been getting calls about these errors for a little over two hours. You decide to change the time range from the last 30 minutes to the last three hours so that you can view the errors during the time when the customers were calling support. Now that you have the data set so that you are seeing exactly what you need, you can turn your attention to the appearance of the chart. Step 4: Customize the chart Because you are more interested in the total number of errors than a timeline view, you change the chart type to a bar chart. one.newrelic.com > Query builder > Basic > (event and attribute specified) > (filters and facets applied) > (time range and limit customized) > (chart type customized) When you're finished with your chart, you can add it to a dashboard or share it. This table contains notes about using basic mode. Item Description Prompts You can start typing directly in an empty box; a list of items that match the information you type will display. You can also click on an empty box to view a list of all of the items that are appropriate for the field, based on your earlier choices. Saving a basic mode data specification Every time you run a query, that query is saved in the My recent queries dropdown in advanced (NRQL) mode. Events Basic mode only supports data for one event and attribute. If you want to use more than one event and/or attribute, use the SELECT statement in advanced (NRQL) mode. Shortcuts Basic mode contains shortcuts that can display more complex events and attributes that aren't generally supported, as in this example (which shows the tooltip for the shortcut). Example of the Response time histogram shortcut, showing a tooltip. Tooltips Any time you see a dotted line under a term, you can hover over that term to see a tooltip with an explanation of the term. Narrow by You can use more than one Narrow by definition in basic mode filter; the conditions will be joined by AND. The WHERE clause in advanced (NRQL) allows OR in addition to AND. Important If your query was started using basic mode and if you make changes to that query using advanced (NRQL) mode, you cannot return to basic mode to edit that query. Any additional changes may only be made in advanced (NRQL) mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.35175,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> builder: Basic mode",
        "sections": "Step 1: Select the source of the <em>data</em> for a <em>chart</em>",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": "<em>Use</em> the New Relic One <em>query</em> builder in basic mode to create a <em>chart</em> without having to <em>use</em> NRQL, our querying language. The basic mode helps guides you through a <em>query</em>-creation process. You can choose the source of the raw <em>data</em>, apply filters, and <em>use</em> other techniques to narrow the scope of the <em>data</em>"
      },
      "id": "603ec319e7b9d2008c2a07e0"
    },
    {
      "sections": [
        "Manage your dashboard",
        "Customize your dashboard",
        "Tip",
        "Edit your dashboard",
        "Settings menu",
        "TV mode",
        "Dark mode",
        "Copy your dashboard as JSON",
        "Export your dashboard",
        "Clone your dashboard",
        "Add new content to your dashboard",
        "Add custom content using the markdown editor",
        "Organize your dashboards with pages",
        "Add and edit pages to a dashboard",
        "Manage your charts and markdown content",
        "Important",
        "Filter and refine your charts",
        "Filter using the chart legend",
        "Filter dashboards using facets",
        "Use the time picker to adjust time settings",
        "Export and share your data"
      ],
      "title": "Manage your dashboard",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards"
      ],
      "external_id": "dce15c906d7868f83813516908f3490e5e3be78f",
      "image": "https://docs.newrelic.com/static/c0ad91accb3281bf160b50ef505530de/c1b63/dashboards_menu_20210623.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/manage-your-dashboard/",
      "published_at": "2021-07-10T03:14:27Z",
      "updated_at": "2021-07-02T20:16:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access any of your New Relic One dashboards to create or manage your charts directly from the chart menu, customize your dashboard's layout, adjust display modes, or export your data. Once you have customized your dashboard and built your charts, use our advanced visualization features and tools for data exploration to correlate and analyze your data. Customize your dashboard Dashboards are highly flexible: you can tailor your dashboard layout and arrange chart sizes to optimize how you see your data. Tip Click the icon to access the See metadata and manage tags modal. There you can see the dashboard's GUID, account ID, and App ID, and manage all the tags that have been added to the dashboard. Dashboards features include: Edit your dashboard Use the edit button to: Copy the dashboard's permalink. Rename your dashboard. Names are searchable, so we recommend giving it a meaningful name. Create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Resize and rearrange charts. You can move any chart and put it anywhere in the dashboard so the layout you set fits your preferences: place your more relevant charts on top, or drop less used charts in a corner. You can set up to 12 columns of charts. Settings menu Use the settings menu on the upper right corner: To change the name of the dashboard. Names are searchable, so we recommend giving it a meaningful name that will help you locate your dashboard easily. To modify the dashboard's permissions. At the settings menu you can also see when the dashboard was created and the account it belongs to. These values cannot be modified. TV mode You can enable a full-screen TV mode that optimizes the dashboard for display on a television screen. There are two ways to turn on TV mode: When viewing a dashboard in New Relic One, select the icon at the top right. Add this parameter to a dashboard page URL: &platform[tvMode]=true To configure TV mode, from a dashboard, select the icon. Options include: Dashboard name display. Turning off the dashboard name gives the dashboard charts more space on the screen. Page cycle. For dashboards with multiple pages, this automatically cycles from page to page. Dark mode High-contrast mode is available in dashboards. Select the icon from the upper right menu bar. Copy your dashboard as JSON You can copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard You can export your dashboard as a pdf file clicking the icon. Clone your dashboard You can clone your dashboard clicking the clone icon regardless of your permission levels. The dashboard is automatically copied and the clone is added to the index. The clone has Public - Read and write permissions. Access the new, cloned dashboard by clicking on the message that pops up on your screen. The cloned dashboard is named like the original dashboard followed by the word “copy”. For example, if you clone a dashboard named This is my dashboard, the clone is called This is my dashboard copy. You can change the name when you clone it. You can edit the name and other properties of the dashboard, such as permissions, any time. Tip You can use the search feature at any time to search data across New Relic One. Add new content to your dashboard There are multiple ways to add new content to your dashboard: From the data explorer and query builder features. Use the + Add to your dashboard button (accessible from the main dashboard page or in the edit mode) to access the query builder, or to add content (such as text, links, or images) using our Markdown editor. Copy an existing chart from any dashboard. If you experience issues adding new content, check our error messages. Add custom content using the markdown editor The Markdown editor contains a Markdown pane, where you enter your content, as well as a Preview pane, where you can view it. For more information about Markdown syntax options, see the Commonmark website. You can also edit existing content by clicking the ellipses icon on any markdown widget and selecting Edit. Organize your dashboards with pages You can use multiple pages to organize your dashboard data in different views. When you add more pages to that dashboard, you can access these pages using the tabs at the top of the dashboard UI. one.newrelic.com > Dashboards: This is an example of a dashboard in New Relic One with multiple pages, represented by the tabs at the top of the dashboard. You can add pages to dashboards, copy existing pages, and drag and drop the page tabs to new positions. You can use this feature to group together related dashboard views. This is valuable when you're aggregating a lot of data and charts related to a specific project, team, or subject. For example, a mobile app team might build a dashboard focused on app performance by country. The first dashboard page might be an overview of performance across all countries, with other pages focused on specific countries. We offer other features to connect dashboards: Create widgets containing markdown text to add direct links to specific UI pages or dashboards. Use facet filtering to create links that automatically link to and filter other dashboards. Use the dashboard search to find similarly named dashboards. To take advantage of this, you can add team- or project-specific words/phrases to dashboard names. In New Relic Insights, this feature was called data apps. For more about switching from Insights to New Relic One, see our transition guide. Add and edit pages to a dashboard To add or edit a page in a dashboard: From a new or existing dashboard, enter edit mode by selecting the icon. Add a new page: Select Add a page to add a blank page. Clone an existing page by clicking the dropdown next to a dashboard name, and selecting Duplicate. While in edit mode, you can add widgets to the new page, drag and drop page tabs to new locations, and do other dashboard editing tasks. When finished, select Done editing. Manage your charts and markdown content From any markdown element, access the menu on the upper right corner to edit or delete it. From any chart, access the chart action menu on the upper right corner to: Expand your chart to full screen. Share your chart as an image or with a link. Copy the chart to any dashboard. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Create an alert condition. Access the query builder to see or edit the query associated to the chart. Duplicate the chart. Delete the chart. Important You cannot edit the query of a chart if you have Read only permissions to the dashboard. Learn more about how to use your charts. Filter and refine your charts You can narrow down the information on display using the filtering function, which is a visual representation of query conditions: Use the filter bar to select the values or attributes you want to see, and remove the rest of the elements from the charts. Open the advanced filter bar to access the boolean operators (such as =, !=, CONTAINS, EXCLUDES, etc.) and add compound and complex conditions for filtering data. After applying the filter, your dashboard will only show the data associated to the elements you selected. A small counter indicates how many filters are being applied at a time. To return to the default view, click on the small cross by the filter to remove it. Filter using the chart legend Click on a legend in any chart with legends to see that series only and remove the rest of them from the chart. This helps you isolate the data you want to analyze. Use CMD (in a Mac) or CTRL (in Windows) for the opposite behavior: removing the selected series and keeping the rest. Filter dashboards using facets If a chart's NRQL query contains a FACET clause, you can use the faceted attributes to filter the current dashboard or another related dashboard. For details, see Filter by facets. Use the time picker to adjust time settings By default, each chart in the dashboard will show data for the time period specified when they were created in the query builder. However, you can use the time picker to change the time range of the data on display and set the same range for all charts. This is particularly useful while troubleshooting incidents, if you need to narrow down your data to observe what happened in a specific time period. The refresh rate depends on the duration of the time window you are viewing. For more information and examples, see Chart refresh intervals. To change the time range: Select one of the available options from the dropdown menu (ranging from Last 30 minutes to Last 7 days). Customize the time range with specific start and end timestamps using the custom menu. Important In dashboards, unlike Insights, the time zone is independent from your laptop's time. You can set the time zone you want to use in your user preferences, easily accessible from the custom menu in the time picker. Export and share your data It is very easy to export dashboard and chart data and share it within your company and beyond: You can export any dashboard as a PDF file, using the Export dashboard as PDF button located in the upper right menu bar. You can also share your charts either as a PNG image or as a link. Go to the chart menu and select either the Get as image or Get chart link options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 249.38254,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>your</em> dashboard",
        "sections": "Manage <em>your</em> <em>charts</em> <em>and</em> markdown content",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": "Access any of <em>your</em> New Relic One dashboards to create or manage <em>your</em> <em>charts</em> directly from the <em>chart</em> menu, customize <em>your</em> dashboard&#x27;s layout, adjust display modes, or export <em>your</em> <em>data</em>. Once you have customized <em>your</em> dashboard and built <em>your</em> <em>charts</em>, <em>use</em> our advanced visualization features and tools"
      },
      "id": "603ec235196a67206fa83dde"
    },
    {
      "sections": [
        "Import, export, add, and share dashboards and charts",
        "Import, share, and export dashboards",
        "Add and share charts and content from your dashboards",
        "Add new content to a dashboard",
        "Troubleshooting chart errors",
        "Share your charts and markdown content"
      ],
      "title": "Import, export, add, and share dashboards and charts",
      "type": "docs",
      "tags": [
        "Query your data",
        "Explore and query data",
        "Dashboards",
        "Charts"
      ],
      "external_id": "22808e0a9a221a5673904161dd056645acac18eb",
      "image": "https://docs.newrelic.com/static/aa4ac49ac23675b57725c49ca3cfed81/c1b63/20210628_dashboard_menu.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/explore-query-data/dashboards/dashboards-charts-import-export-data/",
      "published_at": "2021-07-09T23:45:11Z",
      "updated_at": "2021-07-07T10:52:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Dashboards is a powerful tool to visualize and track how your system is doing, and allows you to tackle issues and plan next steps. Learn to share all that information with your team, customers, or other stakeholders, using the following options to import, share and export dashboards, or add and share charts (or other content) in a dashboard. Import, share, and export dashboards At the dashboards index, you can import a dashboard as JSON. From any dashboard, share it with one of these options: Copy the dashboard's permalink. Copy your dashboard as JSON and add it to the clipboard by clicking on the < / > icon on the right corner. Export your dashboard as a pdf file clicking the icon. You can also clone your dashboard. Add and share charts and content from your dashboards Add new content to a dashboard You can add new content to any dashboard from the data explorer and query builder features. Also, in a given dashboard, to add content: Click the edit button at the top right corner, then create new content by clicking the Add widget button. Add a new chart using the query builder, or add text, images, or links using our markdown editor. Use the + Add to your dashboard button. From any chart, use the chart action menu on the upper right corner to copy or duplicate the chart. Troubleshooting chart errors When adding charts you may come across these error messages: Error message Description External Service 'NRDB' execution resulted in 400 - cause: TIMESERIES step size is larger than the current time window. The TIMESERIES step size is larger than the selected time window. Modify the step and run the query again. External Service 'NRDB' execution resulted in 400 - cause: Your query's start time must be before its end time. The provided startTime of the query must be before the endTime. Modify it and run the query again. NerdGraphGetAuthorizedAccountsCommand short-circuited and fallback disabled. Communication failed while we were authorizing the request. Try again in a few minutes. No application was matched (did you specify appId, appName or entity.guid?) No entity matched the query. Review the specified appId, appName or entity.guid and run the query again. NRQL Syntax Error: Error at line 1 position 15, unexpected 'FROM' FACET and TIMESERIES are not supported on events. Your query has syntax issues. Review it in the query builder to find the error. Query rejected due to inspected count limit exceeded by this query group. You’ve exceeded your querying limits. Check out our data usage limits and policies per account. Something went wrong while executing your query. There was an unexpected error while fetching the data. Try again in a few minutes. If this persists, contact support at https://support.newrelic.com/. TIMESERIES supports a maximum of 366 buckets The TIMESERIES bucket size is too low to span all the selected time window. Modify the bucket size and run the query again. You are not authorized to query account 2022412 You don’t have access to this account. Contact your admin for further assistance. Your query either timed out or we're under heavy load. Navigate to https://support.newrelic.com/ for further assistance. NRDB is experiencing heavy loads, which cause intermittent time-outs. Try again in a few minutes. Validation error on 'nrql': a query must be specified You need to provide a valid NRQL query. Learn more about our query language. Share your charts and markdown content From any chart, access the chart action menu on the upper right corner to: Share your chart as a PNG image or with a link. Go to the chart menu and select either the Get as image or Get chart link options. For table charts only, export as a .csv file. You can import this file into other apps like Microsoft Excel or Google Sheets to do further analysis. Copy the chart to any dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.03906,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Import, export, add, <em>and</em> share dashboards <em>and</em> <em>charts</em>",
        "sections": "Add <em>and</em> share <em>charts</em> <em>and</em> content from <em>your</em> dashboards",
        "tags": "<em>Explore</em> <em>and</em> <em>query</em> <em>data</em>",
        "body": " on the &lt; &#x2F; &gt; icon on the right corner. Export <em>your</em> dashboard as a pdf file clicking the icon. You can also clone <em>your</em> dashboard. Add and share <em>charts</em> and content from <em>your</em> dashboards Add new content to a dashboard You can add new content to any dashboard from the <em>data</em> explorer and <em>query</em> builder"
      },
      "id": "60e5877828ccbc77861881cc"
    }
  ],
  "/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language": [
    {
      "sections": [
        "NRQL syntax, clauses, and functions",
        "Syntax",
        "Query components",
        "Required clauses",
        "Required: SELECT statement",
        "Avg response time since last week",
        "Required: FROM clause",
        "Query one data type",
        "Query multiple data types",
        "Optional clauses",
        "AS clause",
        "Query using math function and AS",
        "Query using funnel and AS",
        "COMPARE WITH clause",
        "EXTRAPOLATE clause",
        "Important",
        "Example of extrapolating throughput",
        "Example of extrapolating throughput as a time series",
        "FACET clause",
        "Faceted query using count()",
        "Faceted query using uniqueCount()",
        "Grouping results across time",
        "FACET ... AS clause",
        "FACET CASES clause",
        "Basic usage with WHERE",
        "Group based on multiple attributes",
        "Label groups with AS",
        "FACET ... ORDER BY clause",
        "Tip",
        "LIMIT clause",
        "Query using LIMIT",
        "OFFSET clause",
        "ORDER BY clause",
        "SHOW EVENT TYPES clause",
        "Data types in the last day",
        "SINCE clause",
        "SLIDE BY clause",
        "Use SLIDE BY with MAX or AUTO interval",
        "TIMESERIES clause",
        "Use a set interval",
        "Use an automatically set interval",
        "Use MAX interval",
        "UNTIL clause",
        "WHERE clause",
        "Example query with three conditions",
        "WITH METRIC_FORMAT clause",
        "WITH TIMEZONE clause",
        "Query metric data",
        "Functions",
        "Aggregator functions",
        "aggregationendtime()",
        "apdex(attribute, t: )",
        "Get Apdex for specific customers",
        "Get Apdex for specific transaction",
        "Get overall Apdex for your app",
        "average(attribute)",
        "buckets(attribute, ceiling [,number of buckets])",
        "bucketPercentile(attribute)",
        "cardinality(attribute)",
        "count(*)",
        "derivative(attribute [,time interval])",
        "dimensions(include: {attributes}, exclude: {attributes})",
        "latestrate(attribute, time interval)",
        "Get the most recent rate of change of PageView Duration",
        "max(attribute)",
        "median(attribute)",
        "Median query",
        "min(attribute)",
        "minuteOf(attribute)",
        "mod(attribute, divisor)",
        "mod() within a WHERE clause condition",
        "mod() within a FACET clause",
        "percentage(function(attribute), WHERE condition)",
        "percentile(attribute [, percentile [, ...]])",
        "Basic percentile query",
        "predictLinear(attribute, [,time interval])",
        "rate(function(attribute) [,time interval])",
        "Basic rate query",
        "round(attribute)",
        "stddev(attribute)",
        "stdvar(attribute)",
        "sum(attribute)",
        "uniqueCount(attribute)",
        "uniques(attribute [,limit])",
        "Using tuple",
        "capture(attribute, regular expression)",
        "capture() within a SELECT clause condition",
        "capture() within a FACET clause condition",
        "capture() within a WHERE clause condition",
        "capture() with a numeric cast",
        "Non-aggregator functions",
        "earliest(attribute)",
        "Get earliest country per user agent from PageView",
        "eventType()",
        "Use eventType() in filter() function",
        "Use eventType() with FACET",
        "filter(function(attribute), WHERE condition)",
        "Analyze purchases that used offer codes",
        "funnel(attribute, steps)",
        "getField(attribute, field)",
        "histogram(attribute, ceiling [,number of buckets])",
        "Histogram of response times from PageView events",
        "Prometheus histogram buckets",
        "New Relic distribution metric",
        "Histogram with a FACET clause",
        "keyset()",
        "See all attributes for a data type",
        "latest(attribute)",
        "Get most recent country per user agent from PageView",
        "Type conversion"
      ],
      "title": "NRQL syntax, clauses, and functions",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "97c38ce7950d354d9f1d9efa5f432326f9bb4b00",
      "image": "https://docs.newrelic.com/static/507a44dd5750a7c536bee652e105179f/8c557/screen-apdex-function.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/",
      "published_at": "2021-07-09T21:24:47Z",
      "updated_at": "2021-07-09T21:24:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NRQL is a query language you can use to query the New Relic database. This document explains NRQL syntax, clauses, components, and functions. Syntax This document is a reference for the functions and clauses used in a NRQL query. Other resources for understanding NRQL: Intro to NRQL: explains what NRQL is used for, what data you can query with it, and basic NRQL syntax Examine NRQL queries used to build New Relic charts Learn how to query the Metric data type Simulate SQL JOIN functions Use funnels to evaluate a series of related data Format NRQL for querying with the Event API Query components Every NRQL query will begin with a SELECT statement or a FROM clause. All other clauses are optional. The clause definitions below also contain example NRQL queries. Required clauses Required: SELECT statement SELECT attribute ... Copy SELECT function(attribute) ... Copy The SELECT specifies what portion of a data type you want to query by specifying an attribute or a function. It's followed by one or more arguments separated by commas. In each argument you can: Get the values of all available attributes by using * as a wildcard. For example: SELECT * from Transaction. Get values associated with a specified attribute or multiple attributes specified in a comma separated list. Get aggregated values from specified attributes by selecting an aggregator function. Label the results returned in each argument with the AS clause. You can also use SELECT with basic math functions. Avg response time since last week This query returns the average response time since last week. SELECT average(duration) FROM PageView SINCE 1 week ago Copy Required: FROM clause SELECT ... FROM data type ... Copy Use the FROM clause to specify the data type you wish to query. You can start your query with FROM or with SELECT. You can merge values for the same attributes across multiple data types in a comma separated list. Query one data type This query returns the count of all APM transactions over the last three days: SELECT count(*) FROM Transaction SINCE 3 days ago Copy Query multiple data types This query returns the count of all APM transactions and browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Optional clauses AS clause SELECT ... AS 'label' ... Copy Use the AS clause to label an attribute, aggregator, step in a funnel, or the result of a math function with a string delimited by single quotes. The label is used in the resulting chart. Query using math function and AS This query returns the number of page views per session: SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session' FROM PageView Copy Query using funnel and AS This query returns a count of people who have visited both the main page and the careers page of a site over the past week: SELECT funnel(SESSION, WHERE name='Controller/about/main' AS 'Step 1', WHERE name = 'Controller/about/careers' AS 'Step 2') FROM PageView SINCE 1 week ago Copy COMPARE WITH clause SELECT ... (SINCE or UNTIL) (integer units) AGO COMPARE WITH (integer units) AGO ... Copy Use the COMPARE WITH clause to compare the values for two different time ranges. COMPARE WITH requires a SINCE or UNTIL statement. The time specified by COMPARE WITH is relative to the time specified by SINCE or UNTIL. For example, SINCE 1 day ago COMPARE WITH 1 day ago compares yesterday with the day before. The time range for theCOMPARE WITH value is always the same as that specified by SINCE or UNTIL. For example, SINCE 2 hours ago COMPARE WITH 4 hours ago might compare 3:00pm through 5:00pm against 11:00am through 1:00pm. COMPARE WITH can be formatted as either a line chart or a billboard: With TIMESERIES, COMPARE WITH creates a line chart with the comparison mapped over time. Without TIMESERIES, COMPARE WITH generates a billboard with the current value and the percent change from the COMPARE WITH value. Example: This query returns data as a line chart showing the 95th percentile for the past hour compared to the same range one week ago. First as a single value, then as a line chart. SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO Copy EXTRAPOLATE clause You can use this clause with these data types: Transaction TransactionError Custom events reported via APM agent APIs The purpose of EXTRAPOLATE is to mathematically compensate for the effects of APM agent sampling of event data so that query results more closely represent the total activity in your system. This clause will be useful when a New Relic APM agent reports so many events that it often passes its harvest cycle reporting limits. When that occurs, the agent begins to sample events. When EXTRAPOLATE is used in a NRQL query that supports its use, the ratio between the reported events and the total events is used to extrapolate a close approximation of the total unsampled data. When it is used in a NRQL query that doesn’t support its use or that hasn’t used sampled data, it has no effect. Important Note that EXTRAPOLATE is most useful for homogenous data (like throughput or error rate). It's not effective when attempting to extrapolate a count of distinct things (like uniqueCount() or uniques()). This clause works only with NRQL queries that use one of the following aggregator functions: apdex average count histogram sum percentage (if function it takes as an argument supports EXTRAPOLATE) rate (if function it takes as an argument supports EXTRAPOLATE) stddev Example of extrapolating throughput A query that will show the extrapolated throughput of a service named interestingApplication. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE Copy Example of extrapolating throughput as a time series A query that will show the extrapolated throughput of a service named interestingApplication by transaction name, displayed as a time series. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE Copy FACET clause SELECT ... FACET attribute ... Copy Use FACET to separate and group your results by attribute values. For example, you could FACET your PageView data by deviceType to figure out what percentage of your traffic comes from mobile, tablet, and desktop devices. Use the LIMIT clause to specify how many facets appear (default is 10). For more complex grouping, use FACET CASES. FACET clauses support up to five attributes, separated by commas. The facets are sorted in descending order by the first field you provide in the SELECT clause. If you are faceting on attributes with more than 2,000 unique values, a subset of facet values is selected and sorted according to the query type. When selecting min(), max(), or count(), FACET uses those functions to determine how facets are picked and sorted. When selecting any other function, FACET uses the frequency of the attribute you are faceting on to determine how facets are picked and sorted. For more on faceting on multiple attributes, with some real-world examples, see this New Relic blog post. Faceted query using count() This query shows cities with the highest pageview counts. This query uses the total number of pageviews per city to determine how facets are picked and ordered. SELECT count(*) FROM PageView FACET city Copy Faceted query using uniqueCount() This query shows the cities that access the highest number of unique URLs. This query uses the total number of times a particular city appears in the results to determine how facets are picked and ordered. SELECT uniqueCount(pageUrl) FROM PageView FACET city Copy Grouping results across time Advanced segmentation and cohort analysis allow you to facet on bucket functions to more effectively break out your data. Cohort analysis is a way to group results together based on timestamps. You can separate them into buckets that cover a specified range of dates and times. FACET ... AS clause Use FACET ... AS to name facets using the AS keyword in queries. This clause is helpful for adding clearer or simplified names for facets in your results. It can also be used to rename facets in nested aggregation queries. FACET ... AS queries will change the facet names in results (when they appear as headers in tables, for example), but not the actual facet names themselves. FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type' Copy FACET CASES clause SELECT ... FACET CASES ( WHERE attribute operator value, WHERE attribute operator value, ... ) ... Copy Use FACET CASES to break out your data by more complex conditions than possible with FACET. Separate multiple conditions with a comma ,. For example, you could query your PageView data and FACET CASES into categories like less than 1 second, from 1 to 10 seconds, and greater than 10 seconds. You can combine multiple attributes within your cases, and label the cases with the AS selector. Data points will be added to at most one facet case, the first facet case that they match. You may also use a time function with your attribute. Basic usage with WHERE SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10) Copy Group based on multiple attributes This example groups results into one bucket where the transaction name contains login, and another where the URL contains login and a custom attribute indicates that the user was a paid user: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') Copy Label groups with AS This example uses the AS selector to give your results a human-readable name: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users') Copy FACET ... ORDER BY clause In NRQL, the default is for the first aggregation in the SELECT clause to guide the selection of facets in a query. FACET ... ORDER BY allows you to override this default behavior by adding an aggregate function with the ORDER BY modifier to specify how facets are selected. Specifically, the clause will override the priority by which facets are chosen to be in the final result before being limited by the LIMIT clause. This clause can be used in querying but not for alerts or streaming. This example shows how to use FACET ... ORDER BY to find the average durations of app transactions, showing the top 10 (default limit) highest durations by apps which have the highest response size. In this case, if FACET ... ORDER BY is not used, the query results will instead show the top 10 by highest durations, with response size being irrelevant to the app selection. FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize) Copy Tip Because the operations are performed before the LIMIT clause is applied, FACET ... ORDER BY does not impact the sort of the final query results, which will be particularly noticeable in the results for non-timeseries queries. Important The ORDER BY modifier in this case works differently than the ORDER BY clause. When parsing queries that follow the format FACET attribute1 ORDER BY attribute2, New Relic will read these as FACET ... ORDER BY queries, but only if ORDER BY appears immediately after FACET. Otherwise ORDER BY will be interpreted by New Relic as a clause. LIMIT clause SELECT ... LIMIT count ... Copy Use the LIMIT clause to control the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. This clause takes a single integer value as an argument. If the LIMIT clause is not specified, or no value is provided, the limit defaults to 10 for FACET queries and 100 in the case of SELECT * queries. The maximum allowed value for the LIMIT clause is 2,000. Query using LIMIT This query shows the top 20 countries by session count and provides 95th percentile of response time for each country for Windows users only. SELECT uniqueCount(session), percentile(duration, 95) FROM PageView WHERE userAgentOS = 'Windows' FACET countryCode LIMIT 20 SINCE YESTERDAY Copy OFFSET clause SELECT ... LIMIT count OFFSET count ... Copy Use the OFFSET clause with LIMIT to control the portion of rows returned by SELECT * or SELECT column queries. Like the LIMIT clause, OFFSET takes a single integer value as an argument. OFFSET sets the number of rows to be skipped before the selected rows of your query are returned. This is constrained by LIMIT. OFFSET rows are skipped starting from the most recent record. For example, the query SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1 returns the last 5 values from Minute_Report except for the most recent one. ORDER BY clause The ORDER BY clause allows you to specify how you want to sort your query results in queries that select event attributes by row. This query orders transactions by duration. FROM Transaction SELECT appName, duration ORDER BY duration Copy The default sort order is ascending, but this can be changed by adding the ASC or DESC modifiers. SHOW EVENT TYPES clause SHOW EVENT TYPES... Copy SHOW EVENT TYPES will return a list of all the data types present in your account for a specific time range. It is used as the first clause in a query instead of SELECT. Important In this context, \"event types\" refers to the data types you can access with a NRQL query. Data types in the last day This query will return all the data types present over the past day: SHOW EVENT TYPES SINCE 1 day ago Copy SINCE clause SELECT ... SINCE [numerical units AGO | phrase] ... Copy The default value is 1 hour ago. Use the SINCE clause to define the beginning of a time range for the returned data. When using NRQL, you can set a UTC timestamp or relative time range. You can specify a timezone for the query but not for the results. NRQL results are based on your system time. SLIDE BY clause The SLIDE BY clause supports a feature known as sliding windows. With sliding windows,SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. To use SLIDE BY, place it in a query after the TIMESERIES clause. For example, this query pulls data in 5-minute windows with a 1-minute SLIDE BY interval, meaning that each window lasts 5 minutes, but window 1 starts at 0 minutes, window 2 starts at 1 minute, window 3 starts at 2 minutes, and so on. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy To learn more about how and when you can use SLIDE BY, see Create smoother charts with sliding windows. Use SLIDE BY with MAX or AUTO interval You can use sliding windows in combination with MAX or AUTO. However, MAX or AUTO may not be placed between TIMESERIES and SLIDE BY. This query will automatically decide a SLIDE BY window interval. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy This query will set the SLIDE BY window to the maximum interval granularity. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy Important The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which can cause gaps and unexpected results. TIMESERIES clause SELECT ... TIMESERIES integer units ... Copy Use the TIMESERIES clause to return data as a time series broken out by a specified period of time. Since TIMESERIES is used to trigger certain charts, there is no default value. To indicate the time range, use integer units. For example: TIMESERIES 1 minute TIMESERIES 30 minutes TIMESERIES 1 hour TIMESERIES 30 seconds TIMESERIES can be combined with arguments such as MAX, AUTO, and SLIDE BY to further tailor query results, as shown in the examples below. Important For functions such as average( ) or percentile( ), a large aggregation window can have a significant smoothing effect on outliers. This is true whether or not the query makes use of sliding windows. Use a set interval The value provided indicates the units used to break out the graph. For example, to present a one-day graph showing 30 minute increments: SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes Copy Use an automatically set interval TIMESERIES can also be set to AUTO, which will divide your graph into a reasonable number of divisions. For example, a daily chart will be divided into 30 minute intervals and a weekly chart will be divided into 6 hour intervals. This query returns data as a line chart showing the 50th and 90th percentile of client-side transaction time for one week with a data point every 6 hours. SELECT average(duration), percentile(duration, 50, 90) FROM PageView SINCE 1 week AGO TIMESERIES AUTO Copy Use MAX interval You can set TIMESERIES to MAX, which will automatically adjust your time window to the maximum number of intervals allowed for a given time period. This allows you to update your time windows without having to manually update your TIMESERIES buckets and ensures your time window is being split into the peak number of intervals allowed. The maximum number of TIMESERIES buckets that will be returned is 366. For example, the following query creates 4-minute intervals, which is the ceiling for a daily chart. SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX Copy UNTIL clause SELECT ... UNTIL integer units AGO ... Copy The default value is NOW. Only use UNTIL to specify an end point other than the default. Use the UNTIL clause to define the end of a time range across which to return data. Once a time range has been specified, the data will be preserved and can be reviewed after the time range has ended. See Use the time picker to adjust time settings for detailed information and examples. WHERE clause Use the WHERE clause to filter results. NRQL returns the results that fulfill the condition(s) you specify in the clause. SELECT function(attribute) ... WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ] [AND|OR ...] ... Copy If you specify more than one condition, separate the conditions by the operators AND or OR. If you want to simulate a SQL join, use custom attributes in a WHERE or FACET clause. Operators that the WHERE clause accepts Description =, !=, <, <=, >, >= NRQL accepts standard comparison operators. Example: state = 'WA' AND Used to define an intersection of two conditions. OR Used to define a union of two conditions. IS NULL Determines if an attribute has a null value. IS NOT NULL Determines if an attribute does not have a null value. IN Determines if the string value of an attribute is in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Example: animalType IN ('cat', 'dog', 'fish') NOT IN Determines if the string value of an attribute is not in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Values must be in parentheses, separated by commas. For example: SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA') Copy LIKE Determines if an attribute contains a specified sub-string. The string argument for the LIKE operator accepts the percent sign (%) as a wildcard anywhere in the string. If the substring does not begin or end the string you are matching against, the wildcard must begin or end the string. Examples: userAgentName LIKE 'IE%' IE IE Mobile userAgentName LIKE 'o%a%' Opera Opera Mini userAgentName LIKE 'o%a' Opera userAgentName LIKE '%o%a%' Opera Opera Mini Mozilla Gecko NOT LIKE Determines if an attribute does not contain a specified sub-string. RLIKE Determines if an attribute contains a specified Regex sub-string. Uses RE2 syntax. Examples: appName RLIKE r'z.*|q.*'' hostname RLIKE r'ip-10-351-[0-2]?[0-9]-.*' z-app q-app ip-10-351-19-237 ip-10-351-2-41 ip-10-351-24-238 ip-10-351-14-15 Important Regex defaults to full-string matching, therefore ^ and $ are implicit and you do not need to add them. NOT RLIKE Determines if an attribute does not contain a specified Regex sub-string. Uses RE2 syntax. Example query with three conditions This query returns the browser response time for pages with checkout in the URL for Safari users in the United States and Canada over the past 24 hours. SELECT histogram(duration, 50, 20) FROM PageView WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%' SINCE 1 day ago Copy WITH METRIC_FORMAT clause For information on querying metric data, see Query metrics. WITH TIMEZONE clause SELECT ... WITH TIMEZONE (selected zone) ... Copy By default, query results are displayed in the timezone of the browser you're using. Use the WITH TIMEZONE clause to select a time zone for a date or time in the query that hasn't already had a time zone specified for it. For example, the query clause SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York' will return data recorded from Monday at midnight, Eastern Standard Time, until midnight Tuesday, Eastern Standard Time. Available Time Zone Selections Africa/Abidjan Africa/Addis_Ababa Africa/Algiers Africa/Blantyre Africa/Cairo Africa/Windhoek America/Adak America/Anchorage America/Araguaina America/Argentina/Buenos_Aires America/Belize America/Bogota America/Campo_Grande America/Cancun America/Caracas America/Chicago America/Chihuahua America/Dawson_Creek America/Denver America/Ensenada America/Glace_Bay America/Godthab America/Goose_Bay America/Havana America/La_Paz America/Los_Angeles America/Miquelon America/Montevideo America/New_York America/Noronha America/Santiago America/Sao_Paulo America/St_Johns Asia/Anadyr Asia/Bangkok Asia/Beirut Asia/Damascus Asia/Dhaka Asia/Dubai Asia/Gaza Asia/Hong_Kong Asia/Irkutsk Asia/Jerusalem Asia/Kabul Asia/Katmandu Asia/Kolkata Asia/Krasnoyarsk Asia/Magadan Asia/Novosibirsk Asia/Rangoon Asia/Seoul Asia/Tashkent Asia/Tehran Asia/Tokyo Asia/Vladivostok Asia/Yakutsk Asia/Yekaterinburg Asia/Yerevan Atlantic/Azores Atlantic/Cape_Verde Atlantic/Stanley Australia/Adelaide Australia/Brisbane Australia/Darwin Australia/Eucla Australia/Hobart Australia/Lord_Howe Australia/Perth Chile/EasterIsland Etc/GMT+10 Etc/GMT+8 Etc/GMT-11 Etc/GMT-12 Europe/Amsterdam Europe/Belfast Europe/Belgrade Europe/Brussels Europe/Dublin Europe/Lisbon Europe/London Europe/Minsk Europe/Moscow Pacific/Auckland Pacific/Chatham Pacific/Gambier Pacific/Kiritimati Pacific/Marquesas Pacific/Midway Pacific/Norfolk Pacific/Tongatapu UTC See Set time range on dashboards and charts for detailed information and examples. Query metric data Metric data is more complex than other types of data. There are specific tips for querying it well. We have two types of metric data, each with their own query guidelines: Query dimensional metrics, which are reported by our Metric API and by some of our tools that use that API, like our Telemetry SDKs and our open-source telemetry integrations (OpenTelemetry, Kamon, Micrometer, more). Query metric timeslice data, which is our original metric data type reported by our APM, mobile monitoring, and browser monitoring. For more on understanding these data types, see Metric data types. Functions Here is a listing of the available functions in NRQL. The definitions below contain example NRQL queries. Aggregator functions Use aggregator functions to filter and aggregate data in a NRQL query. Some helpful information about using aggregator functions: See the New Relic University tutorials for Filter queries, Apdex queries, and Percentile queries. Or, go to the full online course Writing NRQL queries. Data type \"coercion\" is not supported. Read about available type conversion functions. Cohort analysis functions appear on the New Relic Insights Cohort analysis page. The cohort functions aggregate transactions into time segments. Examples: SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy aggregationendtime() Use the aggregationendtime() function to return the time of the relevant aggregation. More specifically, for a given aggregate, the aggregationendtime() function provides the timestamp of the end of the time period of that aggregation. For example, in a timeseries query, for a data point that encompasses an hour’s worth of data, the function would return the timestamp of the end of that hour period. apdex(attribute, t: ) Use the apdex function to return an Apdex score for a single transaction or for all your transactions. The attribute can be any attribute based on response time, such as duration or backendDuration. The t: argument defines an Apdex T threshold in seconds. The Apdex score returned by the apdex( ) function is based only on execution time. It does not account for APM errors. If a transaction includes an error but completes in Apdex T or less, that transaction will be rated satisfying by the apdex ( ) function. Get Apdex for specific customers If you have defined custom attributes, you can filter based on those attributes. For example, you could monitor the Apdex for a particularly important customer: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago Copy Get Apdex for specific transaction Use the name attribute to return a score for a specific transaction, or return an overall Apdex by omitting name. This query returns an Apdex score for the Controller/notes/index transaction over the last hour: The apdex function returns an Apdex score that measures user satisfaction with your site. Arguments are a response time attribute and an Apdex T threshold in seconds. SELECT apdex(duration, t: 0.5) from Transaction WHERE name='Controller/notes/index' SINCE 1 hour ago Copy Get overall Apdex for your app This example query returns an overall Apdex for the application over the last three weeks: SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago Copy average(attribute) Use the average( ) function to return the average value for an attribute. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. buckets(attribute, ceiling [,number of buckets]) Use the buckets() function to aggregate data split up by a FACET clause into buckets based on ranges. You can bucket by any attribute that is stored as a numerical value in the New Relic database. It takes three arguments: Attribute name Maximum value of the sample range. Any outliers will appear in the final bucket. Total number of buckets For more information and examples, see Split your data into buckets. bucketPercentile(attribute) The bucketPercentile( ) function is the NRQL equivalent of the histogram_quantile function in Prometheus. It is intended to be used with dimensional metric data. Instead of the quantile, New Relic returns the percentile, which is the quantile * 100. Use the bucketPercentile( ) function to calculate the quantile from the histogram data in a Prometheus format. It takes the bucket name as an argument and reports percentiles along the bucket's boundaries: SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago Copy Optionally, you can add percentile specifications as an argument: SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago Copy Because multiple metrics are used to make up Prometheus histogram data, you must query for specific Prometheus metrics in terms of the associated <basename>. For example, to compute percentiles from a Prometheus histogram, with the <basename> prometheus_http_request_duration_seconds using NRQL, use bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50). Note how _ bucket is added to the end of the <basename> as a suffix. See the Prometheus.io documentation for more information. cardinality(attribute) Use the cardinality( ) function to obtain the number of combinations of all the dimensions (attributes) on a metric. It takes three arguments, all optional: Metric name: if present, cardinality( ) only computes the metric specified. Include: if present, the include list restricts the cardinality computation to those attributes. Exclude: if present, the exclude list causes those attributes to be ignored in the cardinality computation. SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list}) Copy count(*) Use the count( ) function to return a count of available records. It takes a single argument; either *, an attribute, or a constant value. Currently, it follows typical SQL behavior and counts all records that have values for its argument. Since count(*) does not name a specific attribute, the results will be formatted in the default \"humanize\" format. derivative(attribute [,time interval]) derivative() finds the rate of change for a given dataset. The rate of change is calculated using a linear least-squares regression to approximate the derivative. Since this calculation requires comparing more than one datapoint, if only one datapoint is included in the evaluation range, the calculation is indeterminate and won't work, resulting in a null value. The time interval is the period for which the rate of change is calculated. For example, derivative(attributeName, 1 minute) will return the rate of change per minute. dimensions(include: {attributes}, exclude: {attributes}) Use the dimensions( ) function to return all the dimensional values on a data type. You can explicitly include or exclude specific attributes using the optional arguments: Include: if present, the include list limits dimensions( ) to those attributes. Exclude: if present, the dimensions( ) calculation ignores those attributes. FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions() Copy When used with a FACET clause, dimensions( ) produces a unique timeseries for all facets available on the event type, similar to how Prometheus behaves with non-aggregated queries. latestrate(attribute, time interval) Use the latestrate( ) function to return the rate of change of a value based on the last 2 data points. It takes the attribute in question as the first argument and the unit of time for the resulting rate as the second argument. The function returns a result in units of change in attribute/time interval. This function can be useful to provide the most recent rate of change for an attribute in order to see leading-edge trends. Get the most recent rate of change of PageView Duration This query returns the rate of change of duration based on the last 2 data points. It will be returned in units of duration/second because of the 1 SECOND argument. SELECT latestrate(duration, 1 SECOND) FROM PageView Copy max(attribute) Use the max( ) function to return the maximum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. median(attribute) Use the median( ) function to return an attribute's median, or 50th percentile. For more information about percentile queries, see percentile(). Tip The median( ) query is only available when using the query builder. Median query This query will generate a line chart for the median value. SELECT median(duration) FROM PageView TIMESERIES AUTO Copy min(attribute) Use the min( ) function to return the minimum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. minuteOf(attribute) Use the minuteOf() function to extract only the minute portion (i.e. 0-59) of an attribute holding a valid timestamp value. mod(attribute, divisor) Use the mod( ) function to return the floor modulus after dividing the value of the provided numeric attribute (the first argument, or dividend) by a numeric value (the second argument, or divisor). This modulo operation can be used within a WHERE clause condition to filter to an arbitrary subset of results or within a FACET clause as a way to subdivide the result set. mod() within a WHERE clause condition FROM Transaction SELECT * WHERE mod(port, 2) = 1 Copy mod() within a FACET clause FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10) Copy percentage(function(attribute), WHERE condition) Use the percentage( ) function to return the percentage of a target data set that matches some condition. The first argument requires an aggregator function against the desired attribute. Use exactly two arguments (arguments after the first two will be ignored). If the attribute is not numeric, this function returns a value of 100%. percentile(attribute [, percentile [, ...]]) Use the percentile( ) function to return an attribute's approximate value at a given percentile. It requires an attribute and can take any number of arguments representing percentile points. The percentile() function enables percentiles to displays with up to three digits after the decimal point, providing greater precision. Percentile thresholds may be specified as decimal values, but be aware that for most data sets, percentiles closer than 0.1 from each other will not be resolved. Percentile display examples Use TIMESERIES to generate a line chart with percentiles mapped over time. Omit TIMESERIES to generate a billboard and attribute sheet showing aggregate values for the percentiles. If no percentiles are listed, the default is the 95th percentile. To return only the 50th percentile value, the median, you can also use median(). Basic percentile query This query will generate a line chart with lines for the 5th, 50th, and 95th percentile. SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO Copy predictLinear(attribute, [,time interval]) predictLinear() is an extension of the derivative() function. It uses a similar method of least-squares linear regression to predict the future values for a dataset. The time interval is how far the query will look into the future. For example, predictLinear(attributeName, 1 hour) is a linear prediction 1 hour into the future of the query time window. Generally, predictLinear() is helpful for continuously growing values like disk space, or predictions on large trends. Since predictLinear() is a linear regression, familiarity with the dataset being queried helps to ensure accurate long-term predictions. Any dataset which grows exponentially, logarithmically, or by other nonlinear means will likely only be successful in very short-term predictions. New Relic recommends against using predictLinear in TIMESERIES queries. This is because each bucket will be making an individual prediction based on its relative timeframe within the query, meaning that such queries will not show predictions from the end of the timeseries forward. rate(function(attribute) [,time interval]) Use the rate( ) function to visualize the frequency or rate of a given query per time interval. For example, you might want to know the number of pageviews per minute over an hour-long period or the count of unique sessions on your site per hour over a day-long period. Use TIMESERIES to generate a line chart with rates mapped over time. Omit TIMESERIES to generate a billboard showing a single rate value averaged over time. Basic rate query This query will generate a line chart showing the rate of throughput for APM transactions per 10 minutes over the past 6 hours. SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago TIMESERIES Copy round(attribute) Use the round( ) function to return the rounded value of an attribute. Optionally round( ) can take a second argument, to_nearest, to round the first argument to the closest multiple of the second one. to_nearest can be fractional. SELECT round(n [, to_nearest]) Copy stddev(attribute) Use the stddev( ) function to return one standard deviation for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. stdvar(attribute) Use the stdvar( ) function to return the standard variance for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. sum(attribute) Use the sum( ) function to return the sum recorded values of a numeric attribute over the time range specified. It takes a single argument. Arguments after the first will be ignored. If the attribute is not numeric, it will return a value of zero. uniqueCount(attribute) Use the uniqueCount( ) function to return the number of unique values recorded for an attribute over the time range specified. Tip To optimize query performance, this function returns approximate results for queries that inspect more than 256 unique values. uniques(attribute [,limit]) Use the uniques( ) function to return a list of unique values recorded for an attribute over the time range specified. When used along with the facet clause, a list of unique attribute values will be returned per each facet value. The limit parameter is optional. When it is not provided, the default limit of 1,000 unique attribute values per facet is applied. You may specify a different limit value, up to a maximum of 10,000. The uniques( ) function will return the first set of unique attribute values discovered, until the limit is reached. Therefore, if you have 5,000 unique attribute values in your data set, and the limit is set to 1,000, the operator will return the first 1,000 unique values that it discovers, regardless of their frequency. The maximum number of values that can be returned in a query result is the product of the uniques( ) limit times the facet limit. In the following query, the theoretical maximum number of values that can be returned is 5 million (5,000 x 1,000). Depending on the data set being queried, and the complexity of the query, memory protection limits may prevent a very large query from being executed. From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000 Copy Using tuple If you'd like to know the unique combinations of a handful of attributes, you can structure a query in the format SELECT uniques(tuple(x, y, ... z)) ...` to get all the unique tuples of values, to maintain their relationship. In the following query, tuple is used on index and cellName together to find uniques where those two values occur in combination. FROM NodeStatus SELECT uniques(tuple(index, cellName), 5) Copy capture(attribute, regular expression) Use the capture() to extract values from an attribute using a regular expression. Uses RE2 syntax. It takes two arguments: Attribute name Regular expression with capture syntax. Regex expressions in NRQL use Python-like syntax, r'...'. When capturing, use the RE2 named-capture syntax ...(?P<name> pattern )... to capture the contained pattern, given the specified name. Currently, only 1 capture group is supported. Please see the examples below. capture() within a SELECT clause condition The following will select the domain name of the website, removing https:// and any paths following the .com SELECT capture(pageUrl, r'https://(?P<baseUrl>.*.com)/.+') FROM PageView SINCE 1 day ago Copy The following will capture only the first word of the error message. SELECT capture(errorMessage, r'(?P<firstWord>\\S+)\\s.+') FROM Transaction SINCE 1 hour ago where errorMessage is not null Copy capture() within a FACET clause condition The following will facet by the captured HTTP method. SELECT count(*) FROM Log WHERE message like '%HTTP%' FACET capture(message, r'.* \"(?P<httpMethod>[A-Z]+) .*') Copy capture() within a WHERE clause condition The following will filter the results based on Log events with message attribute that matches the regular expression where the captured job name is ExampleJob. SELECT message FROM Log WHERE capture(message, r'.*Job Failed: (?P<jobName>[A-Za-z]+),.*') = 'ExampleJob' SINCE 10 minutes ago Copy capture() with a numeric cast The following will capture sum of CPU Time from log lines. You must explicitly cast to numeric to do mathematical operations. SELECT sum(numeric(capture(message, r'.*CpuTime:\\s(?P<cpuTime>\\d+)'))) FROM Log WHERE message like '%CpuTime:%' SINCE 1 hour ago Copy Non-aggregator functions Use non-aggregator functions for non-numerical data in NRQL queries. earliest(attribute) Use the earliest( ) function to return the earliest value for an attribute over the specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get earliest country per user agent from PageView This query returns the earliest country code per each user agent from the PageView event. SELECT earliest(countryCode) FROM PageView FACET userAgentName Copy eventType() ...WHERE eventType() = 'EventNameHere'... ...FACET eventType()... Copy Use the eventType() function in a FACET clause to break out results by the selected data type or in a WHERE clause to filter results to a specific data type. This is particularly useful for targeting specific data types with the filter() and percentage() functions. Important In this context, \"event type\" refers to the types of data you can access with a NRQL query. Use eventType() in filter() function This query returns the percentage of total TransactionError results out of the total Transaction results. You can use the eventType() function to target specific types of data with the filter() function. SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago Copy Use eventType() with FACET This query displays a count of how many records each data type (Transaction and TransactionError) returns. SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES Copy filter(function(attribute), WHERE condition) Use the filter() function to limit the results for one of the aggregator functions in your SELECT statement. You can use filter() in conjunction with FACET or TIMESERIES. Filter is only useful when selecting multiple different aggregations such as SELECT filter(sum(x), WHERE attribute='a') AS 'A', filter(sum(x), WHERE attribute='b') AS 'B' .... Otherwise, it's better to just use the standard WHERE clause. Analyze purchases that used offer codes You could use filter() to compare the items bought in a set of transactions for those using an offer code versus those who aren't: Use the filter( ) function to limit the results for one of the aggregator functions in your SELECT statement. funnel(attribute, steps) Use the funnel() function to generate a funnel chart. It takes an attribute as its first argument. You then specify steps as WHERE clauses (with optional AS clauses for labels) separated by commas. For details and examples, see the funnels documentation. getField(attribute, field) Use the getField() function to extract a field from compound data types, such as metric data. It takes the following arguments: Metric type Supported fields summary count, total, max, min, type gauge count, total, max, min, latest, type distribution count, total, max, min, type counter count, type timeslice count, total, totalExclusive, min, and max Examples: SELECT max(getField(mySummary, count)) from Metric Copy SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10 Copy histogram(attribute, ceiling [,number of buckets]) Use the histogram( ) function to generate histograms. It takes three arguments: Attribute name Maximum value of the sample range Total number of buckets (between 1 and 500, inclusive) Histogram of response times from PageView events This query results in a histogram of response times ranging up to 10 seconds over 20 buckets. SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy Prometheus histogram buckets histogram( ) accepts Prometheus histogram buckets: SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago Copy New Relic distribution metric histogram( ) accepts Distribution metric as an input: SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago Copy Histogram with a FACET clause Use histogram( ) with a FACET clause to generate a heatmap chart: SELECT histogram(duration) FROM PageView FACET appName SINCE 1 week ago Copy keyset() Using keyset() will allow you to see all of the attributes for a given data type over a given time range. It takes no arguments. It returns a JSON structure containing groups of string-typed keys, numeric-typed keys, boolean-typed keys, and all keys. See all attributes for a data type This query returns the attributes found for PageView events from the last day: SELECT keyset() FROM PageView SINCE 1 day ago Copy latest(attribute) Use the latest( ) function to return the most recent value for an attribute over a specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get most recent country per user agent from PageView This query returns the most recent country code per each user agent from the PageView event. SELECT latest(countryCode) FROM PageView FACET userAgentName Copy Type conversion NRQL does not support \"coercion.\" This means that a float stored as a string is treated as a string and cannot be operated on by functions expecting float values. You can convert a string with a numeric value or a boolean with a string value to their numeric and boolean types with these functions: Use the numeric() function to convert a number with a string format to a numeric function. The function can be built into a query that uses math functions on query results or NRQL aggregator functions, such as average(). Use the boolean() function to convert a string value of \"true\" or \"false\" to the corresponding boolean value.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 373.2541,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> syntax, clauses, and functions",
        "sections": "<em>Query</em> metric <em>data</em>",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "<em>NRQL</em> is a <em>query</em> <em>language</em> you can use to <em>query</em> the <em>New</em> <em>Relic</em> database. This document explains <em>NRQL</em> syntax, clauses, components, and functions. Syntax This document is a reference for the functions and clauses used in a <em>NRQL</em> <em>query</em>. Other resources for understanding <em>NRQL</em>: Intro to <em>NRQL</em>: explains what"
      },
      "id": "604456c1196a678db8960f41"
    },
    {
      "sections": [
        "NRQL query examples for mobile monitoring",
        "Mobile, MobileSession, and MobileCrash event query examples",
        "Interactions: Which interactions are most popular among my users?",
        "Location: Which regions of China have the most users?",
        "Device profile: How many users use the latest OS versions?",
        "App version: Have we seen an increase in session duration since yesterday's release?",
        "Performance: How much memory does my app use for sessions longer than 5 seconds?",
        "Crashes: What are my app's most common crashes?",
        "Crash rate: What is the crash rate for different versions of my app?",
        "MobileRequest event query examples",
        "Error rate by request domain",
        "Error rate for business-critical API",
        "Response time percentiles of important APIs",
        "Volume of network requests",
        "Slow response user impact",
        "Response time distribution by domain, carrier, ASN owner, country, etc.",
        "Percentile response time",
        "Requests per session",
        "MobileRequestError event query examples",
        "Tip",
        "HTTP errors",
        "Network failures",
        "Error rate: Percentage of users impacted",
        "Errors by version",
        "Unique devices (by UUID)",
        "Historical HTTP error counts",
        "MobileHandledException event query examples",
        "App exceptions",
        "Top exception locations",
        "Most common interaction generating exceptions",
        "Most common exception message",
        "Most common method reporting exceptions",
        "Handled exception rate"
      ],
      "title": "NRQL query examples for mobile monitoring",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "2844422852b86681e69a3ef9333f2268deacbecb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-query-examples-mobile-monitoring/",
      "published_at": "2021-07-10T04:34:50Z",
      "updated_at": "2021-07-10T04:34:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are several ways to query your data. This document will show you some example NRQL queries from mobile monitoring data. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event query examples Mobile queries allow you to understand and compare a wide variety of mobile data, including interactions, location, device profile, app version, crashes, and performance. These examples use queries made on the Mobile, MobileSession, and MobileCrash event types: Interactions: Which interactions are most popular among my users? SELECT uniqueCount(uuid) FROM Mobile SINCE 1 day ago FACET name Copy Location: Which regions of China have the most users? SELECT uniqueCount(uuid) FROM MobileSession WHERE countryCode='CN' FACET regionCode SINCE 7 days ago Copy Device profile: How many users use the latest OS versions? SELECT uniqueCount(uuid) FROM MobileSession FACET osVersion SINCE 7 days ago Copy App version: Have we seen an increase in session duration since yesterday's release? SELECT percentile(sessionDuration, 90) FROM MobileSession since 1 day ago compare with 2 days ago Copy Performance: How much memory does my app use for sessions longer than 5 seconds? SELECT histogram(memUsageMb) FROM MobileSession WHERE sessionDuration > 5 Copy Crashes: What are my app's most common crashes? SELECT count(*) FROM MobileCrash FACET crashException Copy Crash rate: What is the crash rate for different versions of my app? SELECT percentage(uniqueCount(sessionId), WHERE category = 'Crash') as `Crash rate` FROM MobileSession, MobileCrash facet appVersion since 90 days ago Copy MobileRequest event query examples This feature requires mobile monitoring agent version 5.14.0 or higher. MobileRequest data is enabled by default for: Android version 5.15.2 or higher iOS version 6.0.0 or higher For earlier versions, starting with Android version 5.14.0 or iOS version 5.14.0, you must enable the feature. Upgrade to the latest Android or iOS version, or add the required feature flag to your app. Below are some NRQL queries that address common use cases. Use the MobileRequest attributes to make your own NRQL queries. The last two examples use MobileRequestError events in addition to MobileRequest to get an error rate. Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate seen by our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Response time percentiles of important APIs For important requests in the 90th percentile, what is the response time by URL? SELECT percentile(responseTime, 90), latest(requestUrl) as 'Latest URL' from MobileRequest facet cases(where requestUrl like '%{YOUR_CORE_API}%' as 'Core API', where requestUrl like '%{YOUR_FEATURE_API}%' as 'New Feature API') Copy Volume of network requests How much network traffic from the apps are backend services receiving? SELECT count(*) FROM MobileRequest FACET requestDomain since 3 days ago Copy Slow response user impact What % of users are impacted by http response times greater than 3 seconds? SELECT filter(uniqueCount(MobileRequest.uuid), WHERE responseTime > 3) / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted' FROM MobileRequest, MobileSession since 1 day ago timeseries compare with 2 days ago Copy Response time distribution by domain, carrier, ASN owner, country, etc. What is the distribution of response time and request count across domain, country, carrier, or ASN owner? SELECT histogram(responseTime, 20, 20) FROM MobileRequest since 3 days ago facet asnOwner Copy Percentile response time What is the breakdown of response time by different percentiles? SELECT percentile(responseTime, 98) as '98 percentile (sec)', percentile(responseTime, 90) as '90 percentile (sec)', percentile(responseTime, 50) as '50 percentile (sec)' from MobileRequest since 3 days ago Copy Requests per session How do requests per session compare across different apps or subsequent builds of those apps? SELECT count(*)/uniqueCount(sessionId) from MobileRequest, MobileSession facet appName timeseries Copy MobileRequestError event query examples Below are some NRQL queries that address common use cases. Use the MobileRequestError attributes to make your own NRQL queries. Tip For more information and examples, see the our blog post explaining the power of MobileRequestError event data. HTTP errors Which queries are causing the most errors? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestUrl Copy Network failures What network failures are most common for my application? SELECT count(*) FROM MobileRequestError where errorType = 'NetworkFailure' facet networkError Copy Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate in our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Error rate: Percentage of users impacted How many users are experiencing errors as compared to my total user count? SELECT filter(uniqueCount(MobileRequestError.uuid), WHERE errorType = 'HTTPError') / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted by Errors' FROM MobileRequestError, MobileSession COMPARE WITH 7 days AGO Copy Errors by version Which version(s) of my app are causing the most errors? SELECT count(*) FROM MobileRequestError FACET appVersion Copy Unique devices (by UUID) Which unique devices (by UUID) are having the most issues with my application? SELECT count(*), latest(device), latest(carrier), latest(asnOwner), latest(countryCode) FROM MobileRequestError FACET deviceUuid limit 100 SINCE 1 days ago Copy Historical HTTP error counts What does my historical HTTP Error count look like (by domain)? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestDomain timeseries Copy MobileHandledException event query examples Below are some NRQL queries for common handled exception use cases. Use the MobileHandledException attributes to make your own NRQL queries. App exceptions Which apps have reported the most number of handled exceptions? SELECT count(*) FROM MobileHandledException FACET appName SINCE 3 days ago Copy Top exception locations What are most common exception locations for my application? How many exceptions do we have, and where do they occur? SELECT count(*) FROM MobileHandledException FACET exceptionLocation SINCE 3 days ago Copy Most common interaction generating exceptions Which interaction produces the most exceptions? SELECT count(*) FROM MobileHandledException FACET lastInteraction SINCE 3 days ago Copy Most common exception message What are the most common reported exception messages? SELECT count(*) FROM MobileHandledException FACET exceptionMessage SINCE 3 days ago Copy Most common method reporting exceptions What are the most common methods reporting exceptions? SELECT count(*) FROM MobileHandledException FACET exceptionLocationMethod SINCE 3 days ago Copy Handled exception rate How often are handled exceptions encountered by our users? SELECT percentage(uniqueCount(sessionId), WHERE exceptionLocation IS NOT NULL) FROM MobileSession,MobileHandledException SINCE 3 days ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 252.14091,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> <em>query</em> examples for mobile monitoring",
        "sections": "<em>NRQL</em> <em>query</em> examples for mobile monitoring",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "There are several ways to <em>query</em> <em>your</em> <em>data</em>. This document will show you some example <em>NRQL</em> queries from mobile monitoring <em>data</em>. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event <em>query</em> examples Mobile queries"
      },
      "id": "60445a6128ccbc6b6a2c60ca"
    },
    {
      "sections": [
        "App data NRQL query examples",
        "Unique users",
        "Unique user trends",
        "Pageview trends",
        "OS version",
        "Key account Apdex"
      ],
      "title": "App data NRQL query examples",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "54b651240956896f8bdc7d9c3fbb7b6096f455a9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/app-data-nrql-query-examples/",
      "published_at": "2021-07-10T03:13:38Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use NRQL to query the application data collected by APM, browser monitoring, and mobile monitoring. You can then use this data to answer a variety of questions. Here are some basic examples. Unique users How many unique user sessions did you have in the last week? SELECT uniqueCount(session) FROM PageView SINCE 1 week ago Copy Unique user trends Were your unique user sessions up or down last week compared to the week before? SELECT uniqueCount(session) FROM PageView SINCE 1 week ago COMPARE WITH 1 week ago Copy Pageview trends How can I graph the number of unique users yesterday compared to the day before? SELECT count(*) FROM PageView SINCE 1 day ago COMPARE WITH 1 day ago TIMESERIES AUTO Copy OS version How many of your mobile users are on the latest OS version? SELECT uniqueCount(uuid) FROM MobileSession FACET osVersion SINCE 7 days ago Copy Key account Apdex What is the Apdex score for a particularly important customer? If you have defined some custom attributes, you can query to monitor how this customer experiences your app from a performance standpoint: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 251.29723,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "App <em>data</em> <em>NRQL</em> <em>query</em> examples",
        "sections": "App <em>data</em> <em>NRQL</em> <em>query</em> examples",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "You can use <em>NRQL</em> to <em>query</em> the application <em>data</em> collected by APM, browser monitoring, and mobile monitoring. You can then use this <em>data</em> to answer a variety of questions. Here are some basic examples. Unique users How many unique user sessions did you have in the last week? SELECT uniqueCount(session"
      },
      "id": "60445a0f64441f5a46378eec"
    }
  ],
  "/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-math-using-select": [
    {
      "sections": [
        "Introduction to NRQL, New Relic's query language",
        "What is NRQL?",
        "Where can you use NRQL?",
        "What data can you query with NRQL?",
        "Tip",
        "Start using NRQL",
        "Important",
        "NRQL query examples",
        "Basic NRQL query of browser data",
        "Attribute name with a space in it",
        "Querying multiple data sources",
        "Query returning multiple columns",
        "NRQL syntax"
      ],
      "title": "Introduction to NRQL, New Relic's query language",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "51e361ee5ec2a2379486d6686677e0383eb49163",
      "image": "https://docs.newrelic.com/static/04052353f8dbe132cd384d7472778b3f/c1b63/new-relic-view-chart-nrql-query_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language/",
      "published_at": "2021-07-09T22:51:45Z",
      "updated_at": "2021-07-09T22:51:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "One way to query your New Relic data is with the New Relic Query Language (NRQL). This resource explains what NRQL is, when and how you can use it, and basic syntax rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see NRQL syntax, clauses, and functions. What is NRQL? NRQL is New Relic's SQL-like query language. You can use NRQL to retrieve detailed New Relic data and get insight into your applications, hosts, and business-important activity. Reasons to use NRQL include: To answer a question for the purpose of troubleshooting or business analysis To create a new chart To make API queries of New Relic data (for example, using our NerdGraph API) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart's query and then edit it to make your own custom chart. Where can you use NRQL? You can use NRQL in these places: New Relic One query builder: Advanced mode is a NRQL query interface Basic mode provides a simplified query experience that doesn't require knowledge of NRQL but that uses NRQL to generate results NerdGraph: our GraphQL-format API, which includes options for making NRQL queries one.newrelic.com > Query your data: You can run a NRQL query in New Relic One. This NRQL query shows a count of distributed tracing spans faceted by their entity names. NRQL is one of several ways to query New Relic data. For more on all query options, see Query your data. What data can you query with NRQL? NRQL allows you to query these New Relic data types: Event data from all New Relic products, including: APM events, like Transaction Browser monitoring events, like PageView Mobile monitoring events, like Mobile Infrastructure events, like ProcessSample Synthetics events, like SyntheticCheck Custom events, like those reported by the Event API Metric timeslice data (metrics reported by New Relic APM, browser, and mobile) The Metric data type (metrics reported by the Metric API and data sources that use that API) The Span data type (distributed tracing data) The Log data type (data from New Relic Logs) Tip Some data, like relationships between monitored entities, is not available via NRQL but is available using our NerdGraph API. Start using NRQL One way to start using NRQL and to understand what data you have available is to go to a NRQL interface (for example, the New Relic One query builder), type FROM, and press space. The interface will suggest available types of data: To see the attributes available for a specific data type, type FROM DATA_TYPE SELECT and press space. The interface will suggest available attributes. For example: To see the complete JSON associated with a data type, including all of its attributes, use the keyset() attribute. For example: FROM Transaction SELECT keyset() Copy NRQL is used behind the scenes to build some New Relic charts and dashboards. One way to learn NRQL is to find one of these NRQL-generated charts and start playing with the NRQL to create new, customized queries and charts: Charts built with NRQL will have View query as an option. You can then edit and customize that query to see how your changes affect the resulting visualization. Important To explore your data without having to use NRQL, use the basic mode of New Relic One query builder. NRQL query examples Here's an example NRQL query of Transaction data, which is reported by New Relic APM. FROM Transaction SELECT average(duration) FACET appName TIMESERIES auto Copy This would generate a chart that looks like: Here are some more query examples: Basic NRQL query of browser data Here's a NRQL query of PageView data from browser monitoring. SELECT uniqueCount(user) FROM PageView WHERE userAgentOS = 'Mac' FACET countryCode SINCE 1 day ago LIMIT 20 Copy Attribute name with a space in it If a custom attribute name has a space in it, use backticks around the attribute name: SELECT count(*) FROM Transaction FACET `Logged-in user` Copy Querying multiple data sources To return data from two data sources, separate their data types with a comma. For example, this query returns a count of all APM transactions and browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Query returning multiple columns To return multiple columns from a dataset, separate the aggregator arguments with a comma: SELECT function(attribute), function(attribute) ... FROM ... Copy This query returns the minimum, average, and maximum duration for browser monitoring PageView events over the last week: SELECT min(duration), max(duration), average(duration) FROM PageView SINCE 1 week ago Copy See more NRQL query examples. NRQL syntax The syntax of a NRQL query is similar to standard SQL queries. Here is a breakdown of the structure of a NRQL query: SELECT function(attribute) [AS 'label'][, ...] FROM data type [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Copy Basic rules include: NRQL condition Details Required values The SELECT statement and FROM clause are required. All other clauses are optional. You can start your query with either SELECT or FROM. Query string size The query string must be less than 4 KB. Case sensitivity The data type names and attribute names are case sensitive. NRQL clauses and functions are not case sensitive. Syntax for strings NRQL uses single quotes to designate strings. For example: ... where traceId = '030a573f0df02c57' Copy Attribute names with spaces Use backticks `` to quote a custom attribute name that has a space in it. For example: ... FACET `Logged-in user` Copy Data type coercion Insights does not support data type \"coercion.\" For more information, see Data type conversion. Use of math functions Basic and advanced math functions are supported in the SELECT statement. JOIN functions NRQL does not have the equivalent of the SQL JOIN function, but you can simulate a JOIN with custom attributes. Read more about NRQL syntax and functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 374.54614,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>NRQL</em>, <em>New</em> <em>Relic&#x27;s</em> <em>query</em> <em>language</em>",
        "sections": "Introduction to <em>NRQL</em>, <em>New</em> <em>Relic&#x27;s</em> <em>query</em> <em>language</em>",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": ", clauses, and functions. What is <em>NRQL</em>? <em>NRQL</em> is <em>New</em> <em>Relic</em>&#x27;s SQL-like <em>query</em> <em>language</em>. You can use <em>NRQL</em> to retrieve detailed <em>New</em> <em>Relic</em> <em>data</em> and <em>get</em> insight into <em>your</em> applications, hosts, and business-important activity. Reasons to use <em>NRQL</em> include: To answer a question for the purpose of troubleshooting"
      },
      "id": "60445a0e196a67cb09960f6e"
    },
    {
      "sections": [
        "NRQL syntax, clauses, and functions",
        "Syntax",
        "Query components",
        "Required clauses",
        "Required: SELECT statement",
        "Avg response time since last week",
        "Required: FROM clause",
        "Query one data type",
        "Query multiple data types",
        "Optional clauses",
        "AS clause",
        "Query using math function and AS",
        "Query using funnel and AS",
        "COMPARE WITH clause",
        "EXTRAPOLATE clause",
        "Important",
        "Example of extrapolating throughput",
        "Example of extrapolating throughput as a time series",
        "FACET clause",
        "Faceted query using count()",
        "Faceted query using uniqueCount()",
        "Grouping results across time",
        "FACET ... AS clause",
        "FACET CASES clause",
        "Basic usage with WHERE",
        "Group based on multiple attributes",
        "Label groups with AS",
        "FACET ... ORDER BY clause",
        "Tip",
        "LIMIT clause",
        "Query using LIMIT",
        "OFFSET clause",
        "ORDER BY clause",
        "SHOW EVENT TYPES clause",
        "Data types in the last day",
        "SINCE clause",
        "SLIDE BY clause",
        "Use SLIDE BY with MAX or AUTO interval",
        "TIMESERIES clause",
        "Use a set interval",
        "Use an automatically set interval",
        "Use MAX interval",
        "UNTIL clause",
        "WHERE clause",
        "Example query with three conditions",
        "WITH METRIC_FORMAT clause",
        "WITH TIMEZONE clause",
        "Query metric data",
        "Functions",
        "Aggregator functions",
        "aggregationendtime()",
        "apdex(attribute, t: )",
        "Get Apdex for specific customers",
        "Get Apdex for specific transaction",
        "Get overall Apdex for your app",
        "average(attribute)",
        "buckets(attribute, ceiling [,number of buckets])",
        "bucketPercentile(attribute)",
        "cardinality(attribute)",
        "count(*)",
        "derivative(attribute [,time interval])",
        "dimensions(include: {attributes}, exclude: {attributes})",
        "latestrate(attribute, time interval)",
        "Get the most recent rate of change of PageView Duration",
        "max(attribute)",
        "median(attribute)",
        "Median query",
        "min(attribute)",
        "minuteOf(attribute)",
        "mod(attribute, divisor)",
        "mod() within a WHERE clause condition",
        "mod() within a FACET clause",
        "percentage(function(attribute), WHERE condition)",
        "percentile(attribute [, percentile [, ...]])",
        "Basic percentile query",
        "predictLinear(attribute, [,time interval])",
        "rate(function(attribute) [,time interval])",
        "Basic rate query",
        "round(attribute)",
        "stddev(attribute)",
        "stdvar(attribute)",
        "sum(attribute)",
        "uniqueCount(attribute)",
        "uniques(attribute [,limit])",
        "Using tuple",
        "capture(attribute, regular expression)",
        "capture() within a SELECT clause condition",
        "capture() within a FACET clause condition",
        "capture() within a WHERE clause condition",
        "capture() with a numeric cast",
        "Non-aggregator functions",
        "earliest(attribute)",
        "Get earliest country per user agent from PageView",
        "eventType()",
        "Use eventType() in filter() function",
        "Use eventType() with FACET",
        "filter(function(attribute), WHERE condition)",
        "Analyze purchases that used offer codes",
        "funnel(attribute, steps)",
        "getField(attribute, field)",
        "histogram(attribute, ceiling [,number of buckets])",
        "Histogram of response times from PageView events",
        "Prometheus histogram buckets",
        "New Relic distribution metric",
        "Histogram with a FACET clause",
        "keyset()",
        "See all attributes for a data type",
        "latest(attribute)",
        "Get most recent country per user agent from PageView",
        "Type conversion"
      ],
      "title": "NRQL syntax, clauses, and functions",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "97c38ce7950d354d9f1d9efa5f432326f9bb4b00",
      "image": "https://docs.newrelic.com/static/507a44dd5750a7c536bee652e105179f/8c557/screen-apdex-function.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions/",
      "published_at": "2021-07-09T21:24:47Z",
      "updated_at": "2021-07-09T21:24:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NRQL is a query language you can use to query the New Relic database. This document explains NRQL syntax, clauses, components, and functions. Syntax This document is a reference for the functions and clauses used in a NRQL query. Other resources for understanding NRQL: Intro to NRQL: explains what NRQL is used for, what data you can query with it, and basic NRQL syntax Examine NRQL queries used to build New Relic charts Learn how to query the Metric data type Simulate SQL JOIN functions Use funnels to evaluate a series of related data Format NRQL for querying with the Event API Query components Every NRQL query will begin with a SELECT statement or a FROM clause. All other clauses are optional. The clause definitions below also contain example NRQL queries. Required clauses Required: SELECT statement SELECT attribute ... Copy SELECT function(attribute) ... Copy The SELECT specifies what portion of a data type you want to query by specifying an attribute or a function. It's followed by one or more arguments separated by commas. In each argument you can: Get the values of all available attributes by using * as a wildcard. For example: SELECT * from Transaction. Get values associated with a specified attribute or multiple attributes specified in a comma separated list. Get aggregated values from specified attributes by selecting an aggregator function. Label the results returned in each argument with the AS clause. You can also use SELECT with basic math functions. Avg response time since last week This query returns the average response time since last week. SELECT average(duration) FROM PageView SINCE 1 week ago Copy Required: FROM clause SELECT ... FROM data type ... Copy Use the FROM clause to specify the data type you wish to query. You can start your query with FROM or with SELECT. You can merge values for the same attributes across multiple data types in a comma separated list. Query one data type This query returns the count of all APM transactions over the last three days: SELECT count(*) FROM Transaction SINCE 3 days ago Copy Query multiple data types This query returns the count of all APM transactions and browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Optional clauses AS clause SELECT ... AS 'label' ... Copy Use the AS clause to label an attribute, aggregator, step in a funnel, or the result of a math function with a string delimited by single quotes. The label is used in the resulting chart. Query using math function and AS This query returns the number of page views per session: SELECT count(*)/uniqueCount(session) AS 'Pageviews per Session' FROM PageView Copy Query using funnel and AS This query returns a count of people who have visited both the main page and the careers page of a site over the past week: SELECT funnel(SESSION, WHERE name='Controller/about/main' AS 'Step 1', WHERE name = 'Controller/about/careers' AS 'Step 2') FROM PageView SINCE 1 week ago Copy COMPARE WITH clause SELECT ... (SINCE or UNTIL) (integer units) AGO COMPARE WITH (integer units) AGO ... Copy Use the COMPARE WITH clause to compare the values for two different time ranges. COMPARE WITH requires a SINCE or UNTIL statement. The time specified by COMPARE WITH is relative to the time specified by SINCE or UNTIL. For example, SINCE 1 day ago COMPARE WITH 1 day ago compares yesterday with the day before. The time range for theCOMPARE WITH value is always the same as that specified by SINCE or UNTIL. For example, SINCE 2 hours ago COMPARE WITH 4 hours ago might compare 3:00pm through 5:00pm against 11:00am through 1:00pm. COMPARE WITH can be formatted as either a line chart or a billboard: With TIMESERIES, COMPARE WITH creates a line chart with the comparison mapped over time. Without TIMESERIES, COMPARE WITH generates a billboard with the current value and the percent change from the COMPARE WITH value. Example: This query returns data as a line chart showing the 95th percentile for the past hour compared to the same range one week ago. First as a single value, then as a line chart. SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO SELECT percentile(duration) FROM PageView SINCE 1 week ago COMPARE WITH 1 week AGO TIMESERIES AUTO Copy EXTRAPOLATE clause You can use this clause with these data types: Transaction TransactionError Custom events reported via APM agent APIs The purpose of EXTRAPOLATE is to mathematically compensate for the effects of APM agent sampling of event data so that query results more closely represent the total activity in your system. This clause will be useful when a New Relic APM agent reports so many events that it often passes its harvest cycle reporting limits. When that occurs, the agent begins to sample events. When EXTRAPOLATE is used in a NRQL query that supports its use, the ratio between the reported events and the total events is used to extrapolate a close approximation of the total unsampled data. When it is used in a NRQL query that doesn’t support its use or that hasn’t used sampled data, it has no effect. Important Note that EXTRAPOLATE is most useful for homogenous data (like throughput or error rate). It's not effective when attempting to extrapolate a count of distinct things (like uniqueCount() or uniques()). This clause works only with NRQL queries that use one of the following aggregator functions: apdex average count histogram sum percentage (if function it takes as an argument supports EXTRAPOLATE) rate (if function it takes as an argument supports EXTRAPOLATE) stddev Example of extrapolating throughput A query that will show the extrapolated throughput of a service named interestingApplication. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago EXTRAPOLATE Copy Example of extrapolating throughput as a time series A query that will show the extrapolated throughput of a service named interestingApplication by transaction name, displayed as a time series. SELECT count(*) FROM Transaction WHERE appName='interestingApplication' SINCE 60 minutes ago FACET name TIMESERIES 1 minute EXTRAPOLATE Copy FACET clause SELECT ... FACET attribute ... Copy Use FACET to separate and group your results by attribute values. For example, you could FACET your PageView data by deviceType to figure out what percentage of your traffic comes from mobile, tablet, and desktop devices. Use the LIMIT clause to specify how many facets appear (default is 10). For more complex grouping, use FACET CASES. FACET clauses support up to five attributes, separated by commas. The facets are sorted in descending order by the first field you provide in the SELECT clause. If you are faceting on attributes with more than 2,000 unique values, a subset of facet values is selected and sorted according to the query type. When selecting min(), max(), or count(), FACET uses those functions to determine how facets are picked and sorted. When selecting any other function, FACET uses the frequency of the attribute you are faceting on to determine how facets are picked and sorted. For more on faceting on multiple attributes, with some real-world examples, see this New Relic blog post. Faceted query using count() This query shows cities with the highest pageview counts. This query uses the total number of pageviews per city to determine how facets are picked and ordered. SELECT count(*) FROM PageView FACET city Copy Faceted query using uniqueCount() This query shows the cities that access the highest number of unique URLs. This query uses the total number of times a particular city appears in the results to determine how facets are picked and ordered. SELECT uniqueCount(pageUrl) FROM PageView FACET city Copy Grouping results across time Advanced segmentation and cohort analysis allow you to facet on bucket functions to more effectively break out your data. Cohort analysis is a way to group results together based on timestamps. You can separate them into buckets that cover a specified range of dates and times. FACET ... AS clause Use FACET ... AS to name facets using the AS keyword in queries. This clause is helpful for adding clearer or simplified names for facets in your results. It can also be used to rename facets in nested aggregation queries. FACET ... AS queries will change the facet names in results (when they appear as headers in tables, for example), but not the actual facet names themselves. FROM Transaction SELECT count(*) FACET response.headers.contentType AS 'content type' Copy FACET CASES clause SELECT ... FACET CASES ( WHERE attribute operator value, WHERE attribute operator value, ... ) ... Copy Use FACET CASES to break out your data by more complex conditions than possible with FACET. Separate multiple conditions with a comma ,. For example, you could query your PageView data and FACET CASES into categories like less than 1 second, from 1 to 10 seconds, and greater than 10 seconds. You can combine multiple attributes within your cases, and label the cases with the AS selector. Data points will be added to at most one facet case, the first facet case that they match. You may also use a time function with your attribute. Basic usage with WHERE SELECT count(*) FROM PageView FACET CASES (WHERE duration < 1, WHERE duration > 1 and duration < 10, WHERE duration > 10) Copy Group based on multiple attributes This example groups results into one bucket where the transaction name contains login, and another where the URL contains login and a custom attribute indicates that the user was a paid user: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%', WHERE name LIKE '%feature%' AND customer_type='Paid') Copy Label groups with AS This example uses the AS selector to give your results a human-readable name: SELECT count(*) FROM Transaction FACET CASES (WHERE name LIKE '%login%' AS 'Total Logins', WHERE name LIKE '%feature%' AND customer_type='Paid' AS 'Feature Visits from Paid Users') Copy FACET ... ORDER BY clause In NRQL, the default is for the first aggregation in the SELECT clause to guide the selection of facets in a query. FACET ... ORDER BY allows you to override this default behavior by adding an aggregate function with the ORDER BY modifier to specify how facets are selected. Specifically, the clause will override the priority by which facets are chosen to be in the final result before being limited by the LIMIT clause. This clause can be used in querying but not for alerts or streaming. This example shows how to use FACET ... ORDER BY to find the average durations of app transactions, showing the top 10 (default limit) highest durations by apps which have the highest response size. In this case, if FACET ... ORDER BY is not used, the query results will instead show the top 10 by highest durations, with response size being irrelevant to the app selection. FROM Transaction SELECT average(duration) TIMESERIES FACET appName ORDER BY max(responseSize) Copy Tip Because the operations are performed before the LIMIT clause is applied, FACET ... ORDER BY does not impact the sort of the final query results, which will be particularly noticeable in the results for non-timeseries queries. Important The ORDER BY modifier in this case works differently than the ORDER BY clause. When parsing queries that follow the format FACET attribute1 ORDER BY attribute2, New Relic will read these as FACET ... ORDER BY queries, but only if ORDER BY appears immediately after FACET. Otherwise ORDER BY will be interpreted by New Relic as a clause. LIMIT clause SELECT ... LIMIT count ... Copy Use the LIMIT clause to control the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. This clause takes a single integer value as an argument. If the LIMIT clause is not specified, or no value is provided, the limit defaults to 10 for FACET queries and 100 in the case of SELECT * queries. The maximum allowed value for the LIMIT clause is 2,000. Query using LIMIT This query shows the top 20 countries by session count and provides 95th percentile of response time for each country for Windows users only. SELECT uniqueCount(session), percentile(duration, 95) FROM PageView WHERE userAgentOS = 'Windows' FACET countryCode LIMIT 20 SINCE YESTERDAY Copy OFFSET clause SELECT ... LIMIT count OFFSET count ... Copy Use the OFFSET clause with LIMIT to control the portion of rows returned by SELECT * or SELECT column queries. Like the LIMIT clause, OFFSET takes a single integer value as an argument. OFFSET sets the number of rows to be skipped before the selected rows of your query are returned. This is constrained by LIMIT. OFFSET rows are skipped starting from the most recent record. For example, the query SELECT interestingValue FROM Minute_Report LIMIT 5 OFFSET 1 returns the last 5 values from Minute_Report except for the most recent one. ORDER BY clause The ORDER BY clause allows you to specify how you want to sort your query results in queries that select event attributes by row. This query orders transactions by duration. FROM Transaction SELECT appName, duration ORDER BY duration Copy The default sort order is ascending, but this can be changed by adding the ASC or DESC modifiers. SHOW EVENT TYPES clause SHOW EVENT TYPES... Copy SHOW EVENT TYPES will return a list of all the data types present in your account for a specific time range. It is used as the first clause in a query instead of SELECT. Important In this context, \"event types\" refers to the data types you can access with a NRQL query. Data types in the last day This query will return all the data types present over the past day: SHOW EVENT TYPES SINCE 1 day ago Copy SINCE clause SELECT ... SINCE [numerical units AGO | phrase] ... Copy The default value is 1 hour ago. Use the SINCE clause to define the beginning of a time range for the returned data. When using NRQL, you can set a UTC timestamp or relative time range. You can specify a timezone for the query but not for the results. NRQL results are based on your system time. SLIDE BY clause The SLIDE BY clause supports a feature known as sliding windows. With sliding windows,SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. To use SLIDE BY, place it in a query after the TIMESERIES clause. For example, this query pulls data in 5-minute windows with a 1-minute SLIDE BY interval, meaning that each window lasts 5 minutes, but window 1 starts at 0 minutes, window 2 starts at 1 minute, window 3 starts at 2 minutes, and so on. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy To learn more about how and when you can use SLIDE BY, see Create smoother charts with sliding windows. Use SLIDE BY with MAX or AUTO interval You can use sliding windows in combination with MAX or AUTO. However, MAX or AUTO may not be placed between TIMESERIES and SLIDE BY. This query will automatically decide a SLIDE BY window interval. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy This query will set the SLIDE BY window to the maximum interval granularity. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy Important The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which can cause gaps and unexpected results. TIMESERIES clause SELECT ... TIMESERIES integer units ... Copy Use the TIMESERIES clause to return data as a time series broken out by a specified period of time. Since TIMESERIES is used to trigger certain charts, there is no default value. To indicate the time range, use integer units. For example: TIMESERIES 1 minute TIMESERIES 30 minutes TIMESERIES 1 hour TIMESERIES 30 seconds TIMESERIES can be combined with arguments such as MAX, AUTO, and SLIDE BY to further tailor query results, as shown in the examples below. Important For functions such as average( ) or percentile( ), a large aggregation window can have a significant smoothing effect on outliers. This is true whether or not the query makes use of sliding windows. Use a set interval The value provided indicates the units used to break out the graph. For example, to present a one-day graph showing 30 minute increments: SELECT ... SINCE 1 day AGO TIMESERIES 30 minutes Copy Use an automatically set interval TIMESERIES can also be set to AUTO, which will divide your graph into a reasonable number of divisions. For example, a daily chart will be divided into 30 minute intervals and a weekly chart will be divided into 6 hour intervals. This query returns data as a line chart showing the 50th and 90th percentile of client-side transaction time for one week with a data point every 6 hours. SELECT average(duration), percentile(duration, 50, 90) FROM PageView SINCE 1 week AGO TIMESERIES AUTO Copy Use MAX interval You can set TIMESERIES to MAX, which will automatically adjust your time window to the maximum number of intervals allowed for a given time period. This allows you to update your time windows without having to manually update your TIMESERIES buckets and ensures your time window is being split into the peak number of intervals allowed. The maximum number of TIMESERIES buckets that will be returned is 366. For example, the following query creates 4-minute intervals, which is the ceiling for a daily chart. SELECT average(duration) FROM Transaction since 1 day ago TIMESERIES MAX Copy UNTIL clause SELECT ... UNTIL integer units AGO ... Copy The default value is NOW. Only use UNTIL to specify an end point other than the default. Use the UNTIL clause to define the end of a time range across which to return data. Once a time range has been specified, the data will be preserved and can be reviewed after the time range has ended. See Use the time picker to adjust time settings for detailed information and examples. WHERE clause Use the WHERE clause to filter results. NRQL returns the results that fulfill the condition(s) you specify in the clause. SELECT function(attribute) ... WHERE attribute [operator 'value' | IN ('value' [, 'value]) | IS [NOT] NULL ] [AND|OR ...] ... Copy If you specify more than one condition, separate the conditions by the operators AND or OR. If you want to simulate a SQL join, use custom attributes in a WHERE or FACET clause. Operators that the WHERE clause accepts Description =, !=, <, <=, >, >= NRQL accepts standard comparison operators. Example: state = 'WA' AND Used to define an intersection of two conditions. OR Used to define a union of two conditions. IS NULL Determines if an attribute has a null value. IS NOT NULL Determines if an attribute does not have a null value. IN Determines if the string value of an attribute is in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Example: animalType IN ('cat', 'dog', 'fish') NOT IN Determines if the string value of an attribute is not in a specified set. Using this method yields better performance than stringing together multiple WHERE clauses. Values must be in parentheses, separated by commas. For example: SELECT * FROM PageView WHERE countryCode NOT IN ('CA', 'WA') Copy LIKE Determines if an attribute contains a specified sub-string. The string argument for the LIKE operator accepts the percent sign (%) as a wildcard anywhere in the string. If the substring does not begin or end the string you are matching against, the wildcard must begin or end the string. Examples: userAgentName LIKE 'IE%' IE IE Mobile userAgentName LIKE 'o%a%' Opera Opera Mini userAgentName LIKE 'o%a' Opera userAgentName LIKE '%o%a%' Opera Opera Mini Mozilla Gecko NOT LIKE Determines if an attribute does not contain a specified sub-string. RLIKE Determines if an attribute contains a specified Regex sub-string. Uses RE2 syntax. Examples: appName RLIKE r'z.*|q.*'' hostname RLIKE r'ip-10-351-[0-2]?[0-9]-.*' z-app q-app ip-10-351-19-237 ip-10-351-2-41 ip-10-351-24-238 ip-10-351-14-15 Important Regex defaults to full-string matching, therefore ^ and $ are implicit and you do not need to add them. NOT RLIKE Determines if an attribute does not contain a specified Regex sub-string. Uses RE2 syntax. Example query with three conditions This query returns the browser response time for pages with checkout in the URL for Safari users in the United States and Canada over the past 24 hours. SELECT histogram(duration, 50, 20) FROM PageView WHERE countryCode IN ('CA', 'US') AND userAgentName='Safari' AND pageUrl LIKE '%checkout%' SINCE 1 day ago Copy WITH METRIC_FORMAT clause For information on querying metric data, see Query metrics. WITH TIMEZONE clause SELECT ... WITH TIMEZONE (selected zone) ... Copy By default, query results are displayed in the timezone of the browser you're using. Use the WITH TIMEZONE clause to select a time zone for a date or time in the query that hasn't already had a time zone specified for it. For example, the query clause SINCE Monday UNTIL Tuesday WITH TIMEZONE 'America/New_York' will return data recorded from Monday at midnight, Eastern Standard Time, until midnight Tuesday, Eastern Standard Time. Available Time Zone Selections Africa/Abidjan Africa/Addis_Ababa Africa/Algiers Africa/Blantyre Africa/Cairo Africa/Windhoek America/Adak America/Anchorage America/Araguaina America/Argentina/Buenos_Aires America/Belize America/Bogota America/Campo_Grande America/Cancun America/Caracas America/Chicago America/Chihuahua America/Dawson_Creek America/Denver America/Ensenada America/Glace_Bay America/Godthab America/Goose_Bay America/Havana America/La_Paz America/Los_Angeles America/Miquelon America/Montevideo America/New_York America/Noronha America/Santiago America/Sao_Paulo America/St_Johns Asia/Anadyr Asia/Bangkok Asia/Beirut Asia/Damascus Asia/Dhaka Asia/Dubai Asia/Gaza Asia/Hong_Kong Asia/Irkutsk Asia/Jerusalem Asia/Kabul Asia/Katmandu Asia/Kolkata Asia/Krasnoyarsk Asia/Magadan Asia/Novosibirsk Asia/Rangoon Asia/Seoul Asia/Tashkent Asia/Tehran Asia/Tokyo Asia/Vladivostok Asia/Yakutsk Asia/Yekaterinburg Asia/Yerevan Atlantic/Azores Atlantic/Cape_Verde Atlantic/Stanley Australia/Adelaide Australia/Brisbane Australia/Darwin Australia/Eucla Australia/Hobart Australia/Lord_Howe Australia/Perth Chile/EasterIsland Etc/GMT+10 Etc/GMT+8 Etc/GMT-11 Etc/GMT-12 Europe/Amsterdam Europe/Belfast Europe/Belgrade Europe/Brussels Europe/Dublin Europe/Lisbon Europe/London Europe/Minsk Europe/Moscow Pacific/Auckland Pacific/Chatham Pacific/Gambier Pacific/Kiritimati Pacific/Marquesas Pacific/Midway Pacific/Norfolk Pacific/Tongatapu UTC See Set time range on dashboards and charts for detailed information and examples. Query metric data Metric data is more complex than other types of data. There are specific tips for querying it well. We have two types of metric data, each with their own query guidelines: Query dimensional metrics, which are reported by our Metric API and by some of our tools that use that API, like our Telemetry SDKs and our open-source telemetry integrations (OpenTelemetry, Kamon, Micrometer, more). Query metric timeslice data, which is our original metric data type reported by our APM, mobile monitoring, and browser monitoring. For more on understanding these data types, see Metric data types. Functions Here is a listing of the available functions in NRQL. The definitions below contain example NRQL queries. Aggregator functions Use aggregator functions to filter and aggregate data in a NRQL query. Some helpful information about using aggregator functions: See the New Relic University tutorials for Filter queries, Apdex queries, and Percentile queries. Or, go to the full online course Writing NRQL queries. Data type \"coercion\" is not supported. Read about available type conversion functions. Cohort analysis functions appear on the New Relic Insights Cohort analysis page. The cohort functions aggregate transactions into time segments. Examples: SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy aggregationendtime() Use the aggregationendtime() function to return the time of the relevant aggregation. More specifically, for a given aggregate, the aggregationendtime() function provides the timestamp of the end of the time period of that aggregation. For example, in a timeseries query, for a data point that encompasses an hour’s worth of data, the function would return the timestamp of the end of that hour period. apdex(attribute, t: ) Use the apdex function to return an Apdex score for a single transaction or for all your transactions. The attribute can be any attribute based on response time, such as duration or backendDuration. The t: argument defines an Apdex T threshold in seconds. The Apdex score returned by the apdex( ) function is based only on execution time. It does not account for APM errors. If a transaction includes an error but completes in Apdex T or less, that transaction will be rated satisfying by the apdex ( ) function. Get Apdex for specific customers If you have defined custom attributes, you can filter based on those attributes. For example, you could monitor the Apdex for a particularly important customer: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago Copy Get Apdex for specific transaction Use the name attribute to return a score for a specific transaction, or return an overall Apdex by omitting name. This query returns an Apdex score for the Controller/notes/index transaction over the last hour: The apdex function returns an Apdex score that measures user satisfaction with your site. Arguments are a response time attribute and an Apdex T threshold in seconds. SELECT apdex(duration, t: 0.5) from Transaction WHERE name='Controller/notes/index' SINCE 1 hour ago Copy Get overall Apdex for your app This example query returns an overall Apdex for the application over the last three weeks: SELECT apdex(duration, t: 0.08) FROM Transaction SINCE 3 week ago Copy average(attribute) Use the average( ) function to return the average value for an attribute. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. buckets(attribute, ceiling [,number of buckets]) Use the buckets() function to aggregate data split up by a FACET clause into buckets based on ranges. You can bucket by any attribute that is stored as a numerical value in the New Relic database. It takes three arguments: Attribute name Maximum value of the sample range. Any outliers will appear in the final bucket. Total number of buckets For more information and examples, see Split your data into buckets. bucketPercentile(attribute) The bucketPercentile( ) function is the NRQL equivalent of the histogram_quantile function in Prometheus. It is intended to be used with dimensional metric data. Instead of the quantile, New Relic returns the percentile, which is the quantile * 100. Use the bucketPercentile( ) function to calculate the quantile from the histogram data in a Prometheus format. It takes the bucket name as an argument and reports percentiles along the bucket's boundaries: SELECT bucketPercentile(duration_bucket) FROM Metric SINCE 1 day ago Copy Optionally, you can add percentile specifications as an argument: SELECT bucketPercentile(duration_bucket, 50, 75, 90) FROM Metric SINCE 1 day ago Copy Because multiple metrics are used to make up Prometheus histogram data, you must query for specific Prometheus metrics in terms of the associated <basename>. For example, to compute percentiles from a Prometheus histogram, with the <basename> prometheus_http_request_duration_seconds using NRQL, use bucketPercentile(prometheus_http_request_duration_seconds_bucket, 50). Note how _ bucket is added to the end of the <basename> as a suffix. See the Prometheus.io documentation for more information. cardinality(attribute) Use the cardinality( ) function to obtain the number of combinations of all the dimensions (attributes) on a metric. It takes three arguments, all optional: Metric name: if present, cardinality( ) only computes the metric specified. Include: if present, the include list restricts the cardinality computation to those attributes. Exclude: if present, the exclude list causes those attributes to be ignored in the cardinality computation. SELECT cardinality(metric_name, include:{attribute_list}, exclude:{attribute_list}) Copy count(*) Use the count( ) function to return a count of available records. It takes a single argument; either *, an attribute, or a constant value. Currently, it follows typical SQL behavior and counts all records that have values for its argument. Since count(*) does not name a specific attribute, the results will be formatted in the default \"humanize\" format. derivative(attribute [,time interval]) derivative() finds the rate of change for a given dataset. The rate of change is calculated using a linear least-squares regression to approximate the derivative. Since this calculation requires comparing more than one datapoint, if only one datapoint is included in the evaluation range, the calculation is indeterminate and won't work, resulting in a null value. The time interval is the period for which the rate of change is calculated. For example, derivative(attributeName, 1 minute) will return the rate of change per minute. dimensions(include: {attributes}, exclude: {attributes}) Use the dimensions( ) function to return all the dimensional values on a data type. You can explicitly include or exclude specific attributes using the optional arguments: Include: if present, the include list limits dimensions( ) to those attributes. Exclude: if present, the dimensions( ) calculation ignores those attributes. FROM Metric SELECT count(node_filesystem_size) TIMESERIES FACET dimensions() Copy When used with a FACET clause, dimensions( ) produces a unique timeseries for all facets available on the event type, similar to how Prometheus behaves with non-aggregated queries. latestrate(attribute, time interval) Use the latestrate( ) function to return the rate of change of a value based on the last 2 data points. It takes the attribute in question as the first argument and the unit of time for the resulting rate as the second argument. The function returns a result in units of change in attribute/time interval. This function can be useful to provide the most recent rate of change for an attribute in order to see leading-edge trends. Get the most recent rate of change of PageView Duration This query returns the rate of change of duration based on the last 2 data points. It will be returned in units of duration/second because of the 1 SECOND argument. SELECT latestrate(duration, 1 SECOND) FROM PageView Copy max(attribute) Use the max( ) function to return the maximum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. median(attribute) Use the median( ) function to return an attribute's median, or 50th percentile. For more information about percentile queries, see percentile(). Tip The median( ) query is only available when using the query builder. Median query This query will generate a line chart for the median value. SELECT median(duration) FROM PageView TIMESERIES AUTO Copy min(attribute) Use the min( ) function to return the minimum recorded value of a numeric attribute over the time range specified. It takes a single attribute name as an argument. If a value of the attribute is not numeric, it will be ignored when aggregating. If data matching the query's conditions is not found, or there are no numeric values returned by the query, it will return a value of null. minuteOf(attribute) Use the minuteOf() function to extract only the minute portion (i.e. 0-59) of an attribute holding a valid timestamp value. mod(attribute, divisor) Use the mod( ) function to return the floor modulus after dividing the value of the provided numeric attribute (the first argument, or dividend) by a numeric value (the second argument, or divisor). This modulo operation can be used within a WHERE clause condition to filter to an arbitrary subset of results or within a FACET clause as a way to subdivide the result set. mod() within a WHERE clause condition FROM Transaction SELECT * WHERE mod(port, 2) = 1 Copy mod() within a FACET clause FROM NrDailyUsage SELECT uniques(hostId, 10000) SINCE 1 day AGO FACET mod(hostId, 10) Copy percentage(function(attribute), WHERE condition) Use the percentage( ) function to return the percentage of a target data set that matches some condition. The first argument requires an aggregator function against the desired attribute. Use exactly two arguments (arguments after the first two will be ignored). If the attribute is not numeric, this function returns a value of 100%. percentile(attribute [, percentile [, ...]]) Use the percentile( ) function to return an attribute's approximate value at a given percentile. It requires an attribute and can take any number of arguments representing percentile points. The percentile() function enables percentiles to displays with up to three digits after the decimal point, providing greater precision. Percentile thresholds may be specified as decimal values, but be aware that for most data sets, percentiles closer than 0.1 from each other will not be resolved. Percentile display examples Use TIMESERIES to generate a line chart with percentiles mapped over time. Omit TIMESERIES to generate a billboard and attribute sheet showing aggregate values for the percentiles. If no percentiles are listed, the default is the 95th percentile. To return only the 50th percentile value, the median, you can also use median(). Basic percentile query This query will generate a line chart with lines for the 5th, 50th, and 95th percentile. SELECT percentile(duration, 5, 50, 95) FROM PageView TIMESERIES AUTO Copy predictLinear(attribute, [,time interval]) predictLinear() is an extension of the derivative() function. It uses a similar method of least-squares linear regression to predict the future values for a dataset. The time interval is how far the query will look into the future. For example, predictLinear(attributeName, 1 hour) is a linear prediction 1 hour into the future of the query time window. Generally, predictLinear() is helpful for continuously growing values like disk space, or predictions on large trends. Since predictLinear() is a linear regression, familiarity with the dataset being queried helps to ensure accurate long-term predictions. Any dataset which grows exponentially, logarithmically, or by other nonlinear means will likely only be successful in very short-term predictions. New Relic recommends against using predictLinear in TIMESERIES queries. This is because each bucket will be making an individual prediction based on its relative timeframe within the query, meaning that such queries will not show predictions from the end of the timeseries forward. rate(function(attribute) [,time interval]) Use the rate( ) function to visualize the frequency or rate of a given query per time interval. For example, you might want to know the number of pageviews per minute over an hour-long period or the count of unique sessions on your site per hour over a day-long period. Use TIMESERIES to generate a line chart with rates mapped over time. Omit TIMESERIES to generate a billboard showing a single rate value averaged over time. Basic rate query This query will generate a line chart showing the rate of throughput for APM transactions per 10 minutes over the past 6 hours. SELECT rate(count(*), 10 minute) FROM Transaction SINCE 6 hours ago TIMESERIES Copy round(attribute) Use the round( ) function to return the rounded value of an attribute. Optionally round( ) can take a second argument, to_nearest, to round the first argument to the closest multiple of the second one. to_nearest can be fractional. SELECT round(n [, to_nearest]) Copy stddev(attribute) Use the stddev( ) function to return one standard deviation for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. stdvar(attribute) Use the stdvar( ) function to return the standard variance for a numeric attribute over the time range specified. It takes a single argument. If the attribute is not numeric, it will return a value of zero. sum(attribute) Use the sum( ) function to return the sum recorded values of a numeric attribute over the time range specified. It takes a single argument. Arguments after the first will be ignored. If the attribute is not numeric, it will return a value of zero. uniqueCount(attribute) Use the uniqueCount( ) function to return the number of unique values recorded for an attribute over the time range specified. Tip To optimize query performance, this function returns approximate results for queries that inspect more than 256 unique values. uniques(attribute [,limit]) Use the uniques( ) function to return a list of unique values recorded for an attribute over the time range specified. When used along with the facet clause, a list of unique attribute values will be returned per each facet value. The limit parameter is optional. When it is not provided, the default limit of 1,000 unique attribute values per facet is applied. You may specify a different limit value, up to a maximum of 10,000. The uniques( ) function will return the first set of unique attribute values discovered, until the limit is reached. Therefore, if you have 5,000 unique attribute values in your data set, and the limit is set to 1,000, the operator will return the first 1,000 unique values that it discovers, regardless of their frequency. The maximum number of values that can be returned in a query result is the product of the uniques( ) limit times the facet limit. In the following query, the theoretical maximum number of values that can be returned is 5 million (5,000 x 1,000). Depending on the data set being queried, and the complexity of the query, memory protection limits may prevent a very large query from being executed. From Transaction SELECT uniques(host,5000) FACET appName LIMIT 1000 Copy Using tuple If you'd like to know the unique combinations of a handful of attributes, you can structure a query in the format SELECT uniques(tuple(x, y, ... z)) ...` to get all the unique tuples of values, to maintain their relationship. In the following query, tuple is used on index and cellName together to find uniques where those two values occur in combination. FROM NodeStatus SELECT uniques(tuple(index, cellName), 5) Copy capture(attribute, regular expression) Use the capture() to extract values from an attribute using a regular expression. Uses RE2 syntax. It takes two arguments: Attribute name Regular expression with capture syntax. Regex expressions in NRQL use Python-like syntax, r'...'. When capturing, use the RE2 named-capture syntax ...(?P<name> pattern )... to capture the contained pattern, given the specified name. Currently, only 1 capture group is supported. Please see the examples below. capture() within a SELECT clause condition The following will select the domain name of the website, removing https:// and any paths following the .com SELECT capture(pageUrl, r'https://(?P<baseUrl>.*.com)/.+') FROM PageView SINCE 1 day ago Copy The following will capture only the first word of the error message. SELECT capture(errorMessage, r'(?P<firstWord>\\S+)\\s.+') FROM Transaction SINCE 1 hour ago where errorMessage is not null Copy capture() within a FACET clause condition The following will facet by the captured HTTP method. SELECT count(*) FROM Log WHERE message like '%HTTP%' FACET capture(message, r'.* \"(?P<httpMethod>[A-Z]+) .*') Copy capture() within a WHERE clause condition The following will filter the results based on Log events with message attribute that matches the regular expression where the captured job name is ExampleJob. SELECT message FROM Log WHERE capture(message, r'.*Job Failed: (?P<jobName>[A-Za-z]+),.*') = 'ExampleJob' SINCE 10 minutes ago Copy capture() with a numeric cast The following will capture sum of CPU Time from log lines. You must explicitly cast to numeric to do mathematical operations. SELECT sum(numeric(capture(message, r'.*CpuTime:\\s(?P<cpuTime>\\d+)'))) FROM Log WHERE message like '%CpuTime:%' SINCE 1 hour ago Copy Non-aggregator functions Use non-aggregator functions for non-numerical data in NRQL queries. earliest(attribute) Use the earliest( ) function to return the earliest value for an attribute over the specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get earliest country per user agent from PageView This query returns the earliest country code per each user agent from the PageView event. SELECT earliest(countryCode) FROM PageView FACET userAgentName Copy eventType() ...WHERE eventType() = 'EventNameHere'... ...FACET eventType()... Copy Use the eventType() function in a FACET clause to break out results by the selected data type or in a WHERE clause to filter results to a specific data type. This is particularly useful for targeting specific data types with the filter() and percentage() functions. Important In this context, \"event type\" refers to the types of data you can access with a NRQL query. Use eventType() in filter() function This query returns the percentage of total TransactionError results out of the total Transaction results. You can use the eventType() function to target specific types of data with the filter() function. SELECT 100 * filter(count(*), where eventType() = 'TransactionError') / filter(count(*), where eventType() = 'Transaction') FROM Transaction, TransactionError WHERE appName = 'App.Prod' TIMESERIES 2 Minutes SINCE 6 hours ago Copy Use eventType() with FACET This query displays a count of how many records each data type (Transaction and TransactionError) returns. SELECT count(*) FROM Transaction, TransactionError FACET eventType() TIMESERIES Copy filter(function(attribute), WHERE condition) Use the filter() function to limit the results for one of the aggregator functions in your SELECT statement. You can use filter() in conjunction with FACET or TIMESERIES. Filter is only useful when selecting multiple different aggregations such as SELECT filter(sum(x), WHERE attribute='a') AS 'A', filter(sum(x), WHERE attribute='b') AS 'B' .... Otherwise, it's better to just use the standard WHERE clause. Analyze purchases that used offer codes You could use filter() to compare the items bought in a set of transactions for those using an offer code versus those who aren't: Use the filter( ) function to limit the results for one of the aggregator functions in your SELECT statement. funnel(attribute, steps) Use the funnel() function to generate a funnel chart. It takes an attribute as its first argument. You then specify steps as WHERE clauses (with optional AS clauses for labels) separated by commas. For details and examples, see the funnels documentation. getField(attribute, field) Use the getField() function to extract a field from compound data types, such as metric data. It takes the following arguments: Metric type Supported fields summary count, total, max, min, type gauge count, total, max, min, latest, type distribution count, total, max, min, type counter count, type timeslice count, total, totalExclusive, min, and max Examples: SELECT max(getField(mySummary, count)) from Metric Copy SELECT sum(mySummary) from Metric where getField(mySummary, count) > 10 Copy histogram(attribute, ceiling [,number of buckets]) Use the histogram( ) function to generate histograms. It takes three arguments: Attribute name Maximum value of the sample range Total number of buckets (between 1 and 500, inclusive) Histogram of response times from PageView events This query results in a histogram of response times ranging up to 10 seconds over 20 buckets. SELECT histogram(duration, 10, 20) FROM PageView SINCE 1 week ago Copy Prometheus histogram buckets histogram( ) accepts Prometheus histogram buckets: SELECT histogram(duration_bucket, 10, 20) FROM Metric SINCE 1 week ago Copy New Relic distribution metric histogram( ) accepts Distribution metric as an input: SELECT histogram(myDistributionMetric, 10, 20) FROM Metric SINCE 1 week ago Copy Histogram with a FACET clause Use histogram( ) with a FACET clause to generate a heatmap chart: SELECT histogram(duration) FROM PageView FACET appName SINCE 1 week ago Copy keyset() Using keyset() will allow you to see all of the attributes for a given data type over a given time range. It takes no arguments. It returns a JSON structure containing groups of string-typed keys, numeric-typed keys, boolean-typed keys, and all keys. See all attributes for a data type This query returns the attributes found for PageView events from the last day: SELECT keyset() FROM PageView SINCE 1 day ago Copy latest(attribute) Use the latest( ) function to return the most recent value for an attribute over a specified time range. It takes a single argument. Arguments after the first will be ignored. If used in conjunction with a FACET it will return the most recent value for an attribute for each of the resulting facets. Get most recent country per user agent from PageView This query returns the most recent country code per each user agent from the PageView event. SELECT latest(countryCode) FROM PageView FACET userAgentName Copy Type conversion NRQL does not support \"coercion.\" This means that a float stored as a string is treated as a string and cannot be operated on by functions expecting float values. You can convert a string with a numeric value or a boolean with a string value to their numeric and boolean types with these functions: Use the numeric() function to convert a number with a string format to a numeric function. The function can be built into a query that uses math functions on query results or NRQL aggregator functions, such as average(). Use the boolean() function to convert a string value of \"true\" or \"false\" to the corresponding boolean value.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 373.2541,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> syntax, clauses, and functions",
        "sections": "<em>Query</em> metric <em>data</em>",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "<em>NRQL</em> is a <em>query</em> <em>language</em> you can use to <em>query</em> the <em>New</em> <em>Relic</em> database. This document explains <em>NRQL</em> syntax, clauses, components, and functions. Syntax This document is a reference for the functions and clauses used in a <em>NRQL</em> <em>query</em>. Other resources for understanding <em>NRQL</em>: Intro to <em>NRQL</em>: explains what"
      },
      "id": "604456c1196a678db8960f41"
    },
    {
      "sections": [
        "NRQL query examples for mobile monitoring",
        "Mobile, MobileSession, and MobileCrash event query examples",
        "Interactions: Which interactions are most popular among my users?",
        "Location: Which regions of China have the most users?",
        "Device profile: How many users use the latest OS versions?",
        "App version: Have we seen an increase in session duration since yesterday's release?",
        "Performance: How much memory does my app use for sessions longer than 5 seconds?",
        "Crashes: What are my app's most common crashes?",
        "Crash rate: What is the crash rate for different versions of my app?",
        "MobileRequest event query examples",
        "Error rate by request domain",
        "Error rate for business-critical API",
        "Response time percentiles of important APIs",
        "Volume of network requests",
        "Slow response user impact",
        "Response time distribution by domain, carrier, ASN owner, country, etc.",
        "Percentile response time",
        "Requests per session",
        "MobileRequestError event query examples",
        "Tip",
        "HTTP errors",
        "Network failures",
        "Error rate: Percentage of users impacted",
        "Errors by version",
        "Unique devices (by UUID)",
        "Historical HTTP error counts",
        "MobileHandledException event query examples",
        "App exceptions",
        "Top exception locations",
        "Most common interaction generating exceptions",
        "Most common exception message",
        "Most common method reporting exceptions",
        "Handled exception rate"
      ],
      "title": "NRQL query examples for mobile monitoring",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "2844422852b86681e69a3ef9333f2268deacbecb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-query-examples-mobile-monitoring/",
      "published_at": "2021-07-10T04:34:50Z",
      "updated_at": "2021-07-10T04:34:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are several ways to query your data. This document will show you some example NRQL queries from mobile monitoring data. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event query examples Mobile queries allow you to understand and compare a wide variety of mobile data, including interactions, location, device profile, app version, crashes, and performance. These examples use queries made on the Mobile, MobileSession, and MobileCrash event types: Interactions: Which interactions are most popular among my users? SELECT uniqueCount(uuid) FROM Mobile SINCE 1 day ago FACET name Copy Location: Which regions of China have the most users? SELECT uniqueCount(uuid) FROM MobileSession WHERE countryCode='CN' FACET regionCode SINCE 7 days ago Copy Device profile: How many users use the latest OS versions? SELECT uniqueCount(uuid) FROM MobileSession FACET osVersion SINCE 7 days ago Copy App version: Have we seen an increase in session duration since yesterday's release? SELECT percentile(sessionDuration, 90) FROM MobileSession since 1 day ago compare with 2 days ago Copy Performance: How much memory does my app use for sessions longer than 5 seconds? SELECT histogram(memUsageMb) FROM MobileSession WHERE sessionDuration > 5 Copy Crashes: What are my app's most common crashes? SELECT count(*) FROM MobileCrash FACET crashException Copy Crash rate: What is the crash rate for different versions of my app? SELECT percentage(uniqueCount(sessionId), WHERE category = 'Crash') as `Crash rate` FROM MobileSession, MobileCrash facet appVersion since 90 days ago Copy MobileRequest event query examples This feature requires mobile monitoring agent version 5.14.0 or higher. MobileRequest data is enabled by default for: Android version 5.15.2 or higher iOS version 6.0.0 or higher For earlier versions, starting with Android version 5.14.0 or iOS version 5.14.0, you must enable the feature. Upgrade to the latest Android or iOS version, or add the required feature flag to your app. Below are some NRQL queries that address common use cases. Use the MobileRequest attributes to make your own NRQL queries. The last two examples use MobileRequestError events in addition to MobileRequest to get an error rate. Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate seen by our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Response time percentiles of important APIs For important requests in the 90th percentile, what is the response time by URL? SELECT percentile(responseTime, 90), latest(requestUrl) as 'Latest URL' from MobileRequest facet cases(where requestUrl like '%{YOUR_CORE_API}%' as 'Core API', where requestUrl like '%{YOUR_FEATURE_API}%' as 'New Feature API') Copy Volume of network requests How much network traffic from the apps are backend services receiving? SELECT count(*) FROM MobileRequest FACET requestDomain since 3 days ago Copy Slow response user impact What % of users are impacted by http response times greater than 3 seconds? SELECT filter(uniqueCount(MobileRequest.uuid), WHERE responseTime > 3) / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted' FROM MobileRequest, MobileSession since 1 day ago timeseries compare with 2 days ago Copy Response time distribution by domain, carrier, ASN owner, country, etc. What is the distribution of response time and request count across domain, country, carrier, or ASN owner? SELECT histogram(responseTime, 20, 20) FROM MobileRequest since 3 days ago facet asnOwner Copy Percentile response time What is the breakdown of response time by different percentiles? SELECT percentile(responseTime, 98) as '98 percentile (sec)', percentile(responseTime, 90) as '90 percentile (sec)', percentile(responseTime, 50) as '50 percentile (sec)' from MobileRequest since 3 days ago Copy Requests per session How do requests per session compare across different apps or subsequent builds of those apps? SELECT count(*)/uniqueCount(sessionId) from MobileRequest, MobileSession facet appName timeseries Copy MobileRequestError event query examples Below are some NRQL queries that address common use cases. Use the MobileRequestError attributes to make your own NRQL queries. Tip For more information and examples, see the our blog post explaining the power of MobileRequestError event data. HTTP errors Which queries are causing the most errors? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestUrl Copy Network failures What network failures are most common for my application? SELECT count(*) FROM MobileRequestError where errorType = 'NetworkFailure' facet networkError Copy Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate in our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Error rate: Percentage of users impacted How many users are experiencing errors as compared to my total user count? SELECT filter(uniqueCount(MobileRequestError.uuid), WHERE errorType = 'HTTPError') / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted by Errors' FROM MobileRequestError, MobileSession COMPARE WITH 7 days AGO Copy Errors by version Which version(s) of my app are causing the most errors? SELECT count(*) FROM MobileRequestError FACET appVersion Copy Unique devices (by UUID) Which unique devices (by UUID) are having the most issues with my application? SELECT count(*), latest(device), latest(carrier), latest(asnOwner), latest(countryCode) FROM MobileRequestError FACET deviceUuid limit 100 SINCE 1 days ago Copy Historical HTTP error counts What does my historical HTTP Error count look like (by domain)? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestDomain timeseries Copy MobileHandledException event query examples Below are some NRQL queries for common handled exception use cases. Use the MobileHandledException attributes to make your own NRQL queries. App exceptions Which apps have reported the most number of handled exceptions? SELECT count(*) FROM MobileHandledException FACET appName SINCE 3 days ago Copy Top exception locations What are most common exception locations for my application? How many exceptions do we have, and where do they occur? SELECT count(*) FROM MobileHandledException FACET exceptionLocation SINCE 3 days ago Copy Most common interaction generating exceptions Which interaction produces the most exceptions? SELECT count(*) FROM MobileHandledException FACET lastInteraction SINCE 3 days ago Copy Most common exception message What are the most common reported exception messages? SELECT count(*) FROM MobileHandledException FACET exceptionMessage SINCE 3 days ago Copy Most common method reporting exceptions What are the most common methods reporting exceptions? SELECT count(*) FROM MobileHandledException FACET exceptionLocationMethod SINCE 3 days ago Copy Handled exception rate How often are handled exceptions encountered by our users? SELECT percentage(uniqueCount(sessionId), WHERE exceptionLocation IS NOT NULL) FROM MobileSession,MobileHandledException SINCE 3 days ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 252.14091,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> <em>query</em> examples for mobile monitoring",
        "sections": "<em>NRQL</em> <em>query</em> examples for mobile monitoring",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "There are several ways to <em>query</em> <em>your</em> <em>data</em>. This document will show you some example <em>NRQL</em> queries from mobile monitoring <em>data</em>. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event <em>query</em> examples Mobile queries"
      },
      "id": "60445a6128ccbc6b6a2c60ca"
    }
  ],
  "/docs/query-your-data/nrql-new-relic-query-language/get-started/nrql-syntax-clauses-functions": [
    {
      "sections": [
        "Introduction to NRQL, New Relic's query language",
        "What is NRQL?",
        "Where can you use NRQL?",
        "What data can you query with NRQL?",
        "Tip",
        "Start using NRQL",
        "Important",
        "NRQL query examples",
        "Basic NRQL query of browser data",
        "Attribute name with a space in it",
        "Querying multiple data sources",
        "Query returning multiple columns",
        "NRQL syntax"
      ],
      "title": "Introduction to NRQL, New Relic's query language",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "51e361ee5ec2a2379486d6686677e0383eb49163",
      "image": "https://docs.newrelic.com/static/04052353f8dbe132cd384d7472778b3f/c1b63/new-relic-view-chart-nrql-query_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language/",
      "published_at": "2021-07-09T22:51:45Z",
      "updated_at": "2021-07-09T22:51:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "One way to query your New Relic data is with the New Relic Query Language (NRQL). This resource explains what NRQL is, when and how you can use it, and basic syntax rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see NRQL syntax, clauses, and functions. What is NRQL? NRQL is New Relic's SQL-like query language. You can use NRQL to retrieve detailed New Relic data and get insight into your applications, hosts, and business-important activity. Reasons to use NRQL include: To answer a question for the purpose of troubleshooting or business analysis To create a new chart To make API queries of New Relic data (for example, using our NerdGraph API) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart's query and then edit it to make your own custom chart. Where can you use NRQL? You can use NRQL in these places: New Relic One query builder: Advanced mode is a NRQL query interface Basic mode provides a simplified query experience that doesn't require knowledge of NRQL but that uses NRQL to generate results NerdGraph: our GraphQL-format API, which includes options for making NRQL queries one.newrelic.com > Query your data: You can run a NRQL query in New Relic One. This NRQL query shows a count of distributed tracing spans faceted by their entity names. NRQL is one of several ways to query New Relic data. For more on all query options, see Query your data. What data can you query with NRQL? NRQL allows you to query these New Relic data types: Event data from all New Relic products, including: APM events, like Transaction Browser monitoring events, like PageView Mobile monitoring events, like Mobile Infrastructure events, like ProcessSample Synthetics events, like SyntheticCheck Custom events, like those reported by the Event API Metric timeslice data (metrics reported by New Relic APM, browser, and mobile) The Metric data type (metrics reported by the Metric API and data sources that use that API) The Span data type (distributed tracing data) The Log data type (data from New Relic Logs) Tip Some data, like relationships between monitored entities, is not available via NRQL but is available using our NerdGraph API. Start using NRQL One way to start using NRQL and to understand what data you have available is to go to a NRQL interface (for example, the New Relic One query builder), type FROM, and press space. The interface will suggest available types of data: To see the attributes available for a specific data type, type FROM DATA_TYPE SELECT and press space. The interface will suggest available attributes. For example: To see the complete JSON associated with a data type, including all of its attributes, use the keyset() attribute. For example: FROM Transaction SELECT keyset() Copy NRQL is used behind the scenes to build some New Relic charts and dashboards. One way to learn NRQL is to find one of these NRQL-generated charts and start playing with the NRQL to create new, customized queries and charts: Charts built with NRQL will have View query as an option. You can then edit and customize that query to see how your changes affect the resulting visualization. Important To explore your data without having to use NRQL, use the basic mode of New Relic One query builder. NRQL query examples Here's an example NRQL query of Transaction data, which is reported by New Relic APM. FROM Transaction SELECT average(duration) FACET appName TIMESERIES auto Copy This would generate a chart that looks like: Here are some more query examples: Basic NRQL query of browser data Here's a NRQL query of PageView data from browser monitoring. SELECT uniqueCount(user) FROM PageView WHERE userAgentOS = 'Mac' FACET countryCode SINCE 1 day ago LIMIT 20 Copy Attribute name with a space in it If a custom attribute name has a space in it, use backticks around the attribute name: SELECT count(*) FROM Transaction FACET `Logged-in user` Copy Querying multiple data sources To return data from two data sources, separate their data types with a comma. For example, this query returns a count of all APM transactions and browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Query returning multiple columns To return multiple columns from a dataset, separate the aggregator arguments with a comma: SELECT function(attribute), function(attribute) ... FROM ... Copy This query returns the minimum, average, and maximum duration for browser monitoring PageView events over the last week: SELECT min(duration), max(duration), average(duration) FROM PageView SINCE 1 week ago Copy See more NRQL query examples. NRQL syntax The syntax of a NRQL query is similar to standard SQL queries. Here is a breakdown of the structure of a NRQL query: SELECT function(attribute) [AS 'label'][, ...] FROM data type [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Copy Basic rules include: NRQL condition Details Required values The SELECT statement and FROM clause are required. All other clauses are optional. You can start your query with either SELECT or FROM. Query string size The query string must be less than 4 KB. Case sensitivity The data type names and attribute names are case sensitive. NRQL clauses and functions are not case sensitive. Syntax for strings NRQL uses single quotes to designate strings. For example: ... where traceId = '030a573f0df02c57' Copy Attribute names with spaces Use backticks `` to quote a custom attribute name that has a space in it. For example: ... FACET `Logged-in user` Copy Data type coercion Insights does not support data type \"coercion.\" For more information, see Data type conversion. Use of math functions Basic and advanced math functions are supported in the SELECT statement. JOIN functions NRQL does not have the equivalent of the SQL JOIN function, but you can simulate a JOIN with custom attributes. Read more about NRQL syntax and functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 374.5459,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>NRQL</em>, <em>New</em> <em>Relic&#x27;s</em> <em>query</em> <em>language</em>",
        "sections": "Introduction to <em>NRQL</em>, <em>New</em> <em>Relic&#x27;s</em> <em>query</em> <em>language</em>",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": ", clauses, and functions. What is <em>NRQL</em>? <em>NRQL</em> is <em>New</em> <em>Relic</em>&#x27;s SQL-like <em>query</em> <em>language</em>. You can use <em>NRQL</em> to retrieve detailed <em>New</em> <em>Relic</em> <em>data</em> and <em>get</em> insight into <em>your</em> applications, hosts, and business-important activity. Reasons to use <em>NRQL</em> include: To answer a question for the purpose of troubleshooting"
      },
      "id": "60445a0e196a67cb09960f6e"
    },
    {
      "sections": [
        "NRQL query examples for mobile monitoring",
        "Mobile, MobileSession, and MobileCrash event query examples",
        "Interactions: Which interactions are most popular among my users?",
        "Location: Which regions of China have the most users?",
        "Device profile: How many users use the latest OS versions?",
        "App version: Have we seen an increase in session duration since yesterday's release?",
        "Performance: How much memory does my app use for sessions longer than 5 seconds?",
        "Crashes: What are my app's most common crashes?",
        "Crash rate: What is the crash rate for different versions of my app?",
        "MobileRequest event query examples",
        "Error rate by request domain",
        "Error rate for business-critical API",
        "Response time percentiles of important APIs",
        "Volume of network requests",
        "Slow response user impact",
        "Response time distribution by domain, carrier, ASN owner, country, etc.",
        "Percentile response time",
        "Requests per session",
        "MobileRequestError event query examples",
        "Tip",
        "HTTP errors",
        "Network failures",
        "Error rate: Percentage of users impacted",
        "Errors by version",
        "Unique devices (by UUID)",
        "Historical HTTP error counts",
        "MobileHandledException event query examples",
        "App exceptions",
        "Top exception locations",
        "Most common interaction generating exceptions",
        "Most common exception message",
        "Most common method reporting exceptions",
        "Handled exception rate"
      ],
      "title": "NRQL query examples for mobile monitoring",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "2844422852b86681e69a3ef9333f2268deacbecb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-query-examples-mobile-monitoring/",
      "published_at": "2021-07-10T04:34:50Z",
      "updated_at": "2021-07-10T04:34:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are several ways to query your data. This document will show you some example NRQL queries from mobile monitoring data. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event query examples Mobile queries allow you to understand and compare a wide variety of mobile data, including interactions, location, device profile, app version, crashes, and performance. These examples use queries made on the Mobile, MobileSession, and MobileCrash event types: Interactions: Which interactions are most popular among my users? SELECT uniqueCount(uuid) FROM Mobile SINCE 1 day ago FACET name Copy Location: Which regions of China have the most users? SELECT uniqueCount(uuid) FROM MobileSession WHERE countryCode='CN' FACET regionCode SINCE 7 days ago Copy Device profile: How many users use the latest OS versions? SELECT uniqueCount(uuid) FROM MobileSession FACET osVersion SINCE 7 days ago Copy App version: Have we seen an increase in session duration since yesterday's release? SELECT percentile(sessionDuration, 90) FROM MobileSession since 1 day ago compare with 2 days ago Copy Performance: How much memory does my app use for sessions longer than 5 seconds? SELECT histogram(memUsageMb) FROM MobileSession WHERE sessionDuration > 5 Copy Crashes: What are my app's most common crashes? SELECT count(*) FROM MobileCrash FACET crashException Copy Crash rate: What is the crash rate for different versions of my app? SELECT percentage(uniqueCount(sessionId), WHERE category = 'Crash') as `Crash rate` FROM MobileSession, MobileCrash facet appVersion since 90 days ago Copy MobileRequest event query examples This feature requires mobile monitoring agent version 5.14.0 or higher. MobileRequest data is enabled by default for: Android version 5.15.2 or higher iOS version 6.0.0 or higher For earlier versions, starting with Android version 5.14.0 or iOS version 5.14.0, you must enable the feature. Upgrade to the latest Android or iOS version, or add the required feature flag to your app. Below are some NRQL queries that address common use cases. Use the MobileRequest attributes to make your own NRQL queries. The last two examples use MobileRequestError events in addition to MobileRequest to get an error rate. Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate seen by our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Response time percentiles of important APIs For important requests in the 90th percentile, what is the response time by URL? SELECT percentile(responseTime, 90), latest(requestUrl) as 'Latest URL' from MobileRequest facet cases(where requestUrl like '%{YOUR_CORE_API}%' as 'Core API', where requestUrl like '%{YOUR_FEATURE_API}%' as 'New Feature API') Copy Volume of network requests How much network traffic from the apps are backend services receiving? SELECT count(*) FROM MobileRequest FACET requestDomain since 3 days ago Copy Slow response user impact What % of users are impacted by http response times greater than 3 seconds? SELECT filter(uniqueCount(MobileRequest.uuid), WHERE responseTime > 3) / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted' FROM MobileRequest, MobileSession since 1 day ago timeseries compare with 2 days ago Copy Response time distribution by domain, carrier, ASN owner, country, etc. What is the distribution of response time and request count across domain, country, carrier, or ASN owner? SELECT histogram(responseTime, 20, 20) FROM MobileRequest since 3 days ago facet asnOwner Copy Percentile response time What is the breakdown of response time by different percentiles? SELECT percentile(responseTime, 98) as '98 percentile (sec)', percentile(responseTime, 90) as '90 percentile (sec)', percentile(responseTime, 50) as '50 percentile (sec)' from MobileRequest since 3 days ago Copy Requests per session How do requests per session compare across different apps or subsequent builds of those apps? SELECT count(*)/uniqueCount(sessionId) from MobileRequest, MobileSession facet appName timeseries Copy MobileRequestError event query examples Below are some NRQL queries that address common use cases. Use the MobileRequestError attributes to make your own NRQL queries. Tip For more information and examples, see the our blog post explaining the power of MobileRequestError event data. HTTP errors Which queries are causing the most errors? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestUrl Copy Network failures What network failures are most common for my application? SELECT count(*) FROM MobileRequestError where errorType = 'NetworkFailure' facet networkError Copy Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate in our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Error rate: Percentage of users impacted How many users are experiencing errors as compared to my total user count? SELECT filter(uniqueCount(MobileRequestError.uuid), WHERE errorType = 'HTTPError') / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted by Errors' FROM MobileRequestError, MobileSession COMPARE WITH 7 days AGO Copy Errors by version Which version(s) of my app are causing the most errors? SELECT count(*) FROM MobileRequestError FACET appVersion Copy Unique devices (by UUID) Which unique devices (by UUID) are having the most issues with my application? SELECT count(*), latest(device), latest(carrier), latest(asnOwner), latest(countryCode) FROM MobileRequestError FACET deviceUuid limit 100 SINCE 1 days ago Copy Historical HTTP error counts What does my historical HTTP Error count look like (by domain)? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestDomain timeseries Copy MobileHandledException event query examples Below are some NRQL queries for common handled exception use cases. Use the MobileHandledException attributes to make your own NRQL queries. App exceptions Which apps have reported the most number of handled exceptions? SELECT count(*) FROM MobileHandledException FACET appName SINCE 3 days ago Copy Top exception locations What are most common exception locations for my application? How many exceptions do we have, and where do they occur? SELECT count(*) FROM MobileHandledException FACET exceptionLocation SINCE 3 days ago Copy Most common interaction generating exceptions Which interaction produces the most exceptions? SELECT count(*) FROM MobileHandledException FACET lastInteraction SINCE 3 days ago Copy Most common exception message What are the most common reported exception messages? SELECT count(*) FROM MobileHandledException FACET exceptionMessage SINCE 3 days ago Copy Most common method reporting exceptions What are the most common methods reporting exceptions? SELECT count(*) FROM MobileHandledException FACET exceptionLocationMethod SINCE 3 days ago Copy Handled exception rate How often are handled exceptions encountered by our users? SELECT percentage(uniqueCount(sessionId), WHERE exceptionLocation IS NOT NULL) FROM MobileSession,MobileHandledException SINCE 3 days ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 252.14075,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> <em>query</em> examples for mobile monitoring",
        "sections": "<em>NRQL</em> <em>query</em> examples for mobile monitoring",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "There are several ways to <em>query</em> <em>your</em> <em>data</em>. This document will show you some example <em>NRQL</em> queries from mobile monitoring <em>data</em>. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event <em>query</em> examples Mobile queries"
      },
      "id": "60445a6128ccbc6b6a2c60ca"
    },
    {
      "sections": [
        "App data NRQL query examples",
        "Unique users",
        "Unique user trends",
        "Pageview trends",
        "OS version",
        "Key account Apdex"
      ],
      "title": "App data NRQL query examples",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "54b651240956896f8bdc7d9c3fbb7b6096f455a9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/app-data-nrql-query-examples/",
      "published_at": "2021-07-10T03:13:38Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use NRQL to query the application data collected by APM, browser monitoring, and mobile monitoring. You can then use this data to answer a variety of questions. Here are some basic examples. Unique users How many unique user sessions did you have in the last week? SELECT uniqueCount(session) FROM PageView SINCE 1 week ago Copy Unique user trends Were your unique user sessions up or down last week compared to the week before? SELECT uniqueCount(session) FROM PageView SINCE 1 week ago COMPARE WITH 1 week ago Copy Pageview trends How can I graph the number of unique users yesterday compared to the day before? SELECT count(*) FROM PageView SINCE 1 day ago COMPARE WITH 1 day ago TIMESERIES AUTO Copy OS version How many of your mobile users are on the latest OS version? SELECT uniqueCount(uuid) FROM MobileSession FACET osVersion SINCE 7 days ago Copy Key account Apdex What is the Apdex score for a particularly important customer? If you have defined some custom attributes, you can query to monitor how this customer experiences your app from a performance standpoint: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 251.29706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "App <em>data</em> <em>NRQL</em> <em>query</em> examples",
        "sections": "App <em>data</em> <em>NRQL</em> <em>query</em> examples",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "You can use <em>NRQL</em> to <em>query</em> the application <em>data</em> collected by APM, browser monitoring, and mobile monitoring. You can then use this <em>data</em> to answer a variety of questions. Here are some basic examples. Unique users How many unique user sessions did you have in the last week? SELECT uniqueCount(session"
      },
      "id": "60445a0f64441f5a46378eec"
    }
  ],
  "/docs/query-your-data/nrql-new-relic-query-language/get-started/rate-limits-nrql-queries": [
    {
      "sections": [
        "View system limits",
        "Responses to limit violations",
        "System limits UI",
        "Troubleshooting limits",
        "For more information"
      ],
      "title": "View system limits",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "d6ff940e92c5d1a3ae34f391e9fa3be5dfa21c2f",
      "image": "https://docs.newrelic.com/static/8ee61e3091f6e044202cff92026afada/8c557/limits-graph.png",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/view-system-limits/",
      "published_at": "2021-07-09T03:40:25Z",
      "updated_at": "2021-07-09T03:40:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure our systems are always up and ready to support you, and to keep you from unintended use, we place limits on the amount of data you can send, query, and store. Responses to limit violations Limits are enforced per sub-account, and across our APIs. You might reach a limit if you start monitoring a new high-traffic application, or have a sudden data spike. When you do reach a limit, New Relic responds according to the type of data and the limit that’s reached. For example: We place a limit on the number of ingested requests per minute (RPM) per data type. When this limit is reached, we stop accepting data and return a 429 status code for the duration of the minute. For queries, we place limits on the number of queries per minute and the number of records inspected (see query limits). When the number of queries per minute limit is reached, New Relic will begin rejecting queries until the number of queries is below the limit. When the records inspected limit is reached, New Relic will reject traffic from the source scanning the largest number of records and attempt to allow traffic from other sources. For metrics, we place a limit on the number of unique timeseries (cardinality) per account and per metric. When this limit is reached, aggregated data is turned off for the rest of the UTC day. For every major limit violation, New Relic creates an NrIntegrationError event for that account, which have these limit-related attributes: Attribute Description category 'RateLimit' or 'ApiLimit'. The 'RateLimit' category is used for limits based on a unit of time such as the number of requests ingested per minute. The 'ApiLimit' is used for constant limits, such as the number of attributes on a record. limitName The name of the limit. message Describes the limit and the impact. limitValue The limit reached. System limits UI The system Limits page (from the account dropdown, click Manage your data and click Limits on the left) displays when your account has encountered a rate limit in the specified time period. The page displays a default period of 24 hours; you can set a custom range from the top-right of the page. Non-limit-related NrIntegrationError events are not displayed here. In addition, this page does not display information about limits you have not hit, or how close you are to reaching a limit. For more on creating queries and alerts for data ingest and billing metrics, see Query billing/usage data. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a chart on the Limits UI page displaying a cardinality violation limit issue. To add more detail, or build a dashboard, click the View NRQL button on the chart to see the NRQL powering this view. The graph displays each unique limit type that was reached during the selected time-period. This can help you find any trends based on time. The Limits page also provides a table where you can find the limit name, the limit event message associated with it, and last occurrence time and date. If you click a limit in the table, you see more about what happened, and when. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a limit events table on the Limits UI page. Troubleshooting limits To troubleshoot limits when you reach them, click the limit info in the table, and then follow the docs link that's provided. Different limits have different solutions. For more information See Troubleshoot Metric API with NRIntegrationError events",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 238.93073,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View system <em>limits</em>",
        "sections": "View system <em>limits</em>",
        "body": " stop accepting data and return a 429 status code for the duration of the minute. For <em>queries</em>, we place <em>limits</em> on the number of <em>queries</em> per minute and the number of records inspected (see query <em>limits</em>). When the number of <em>queries</em> per minute <em>limit</em> is reached, New Relic will begin rejecting <em>queries</em>"
      },
      "id": "60446a7c64441f48d7378f2b"
    },
    {
      "sections": [
        "Query system limits",
        "Important",
        "What happens when you reach a limit",
        "Tip",
        "Create a dashboard to view your limit status",
        "Resource Consumption Limits as a %",
        "Max % Consumption in an hour",
        "APM Agent API transaction events request per minute",
        "Trace API With limit line",
        "Impact FACET",
        "NrIntegrationError by limit",
        "Multi-Account limits (on time series charts only)",
        "Limit list and NrIntegrationError",
        "Limit metrics",
        "newrelic.resourceConsumption.limitValue",
        "newrelic.resourceConsumption.currentValue",
        "newrelic.resourceConsumption.impact",
        "Metric attributes",
        "Set alerts on resource metrics",
        "Limits faceted by LimitName and scoped by Timewindow",
        "Alert on a single limit",
        "Alert on limit impact faceted by dataType, impact, resource, and reason",
        "Alert on impact of a single dataType"
      ],
      "title": "Query system limits",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest data manage data",
        "Manage data",
        "Resource metrics",
        "system limits"
      ],
      "external_id": "f8ca2368c70e4e339cd838d0ad192dd2c40fac0a",
      "image": "https://docs.newrelic.com/static/16cb17d5244a118d794df354f67bab81/c1b63/limits-dashboard.png",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/query-limits/",
      "published_at": "2021-07-09T03:38:47Z",
      "updated_at": "2021-07-09T03:38:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic has resource limits in place to protect your experience, our systems, and our other customers. These limits range from the maximum number of characters you can have in a query, to API request rates, to how many events your queries inspect, and more. This page describes the limit metrics and NrIntegrationError events that enable you to view your limits, your current data usage and overall resource consumption as compared to those limits, and the impact of experiencing a limit event. We also provide a handful of queries that, when compiled into a dashboard, can give you consistent insight into your limits status. Important While NrIntegrationError events cover many limits, resource metrics currently only cover request rate ingestion limits. What happens when you reach a limit Our response to reaching a limit depends on a handful of factors: the type of limit that’s reached, as well as the duration, frequency, and amount at which you exceed the limit. Exceeding a limit doesn’t always mean you experience a limit event, such as dropped data, rejected traffic, or having your data turned off for the rest of the day. We sometimes allow a small buffer before enforcing a limit. That said, any resource consumed above 100% is at risk for limit impact at any time. Many of our rate limits apply proportionally. That means if you’re barely exceeding the limit, we will take less action than if you're exceeding by 200%. Limit metrics are only visible if you're sending data in to a corresponding dataType or limitName API. For example, if you send in data via the Metric API, you’ll see the Metric API resource metrics, but if you don't send any APM data in, you won't see APM resource metrics. Tip Impact metrics will be generated regardless of impact; if there's no impact, you’ll see a 0. An NrIntegrationError is generated when you experience impact and is a good way to quickly see if you’re experiencing any limit events. See View System Limits for more information. Create a dashboard to view your limit status Using three limit metrics together on a dashboard, you can quickly see detailed visuals of your Ingest Resource Request Per Minute limits, and with NrIngrationError get a view into more limits. Dashboard displaying limits status using a handful of queries. We used the following queries to create this dashboard. To make a dashboard like this in New Relic One, select Dashboards, and then Create a dashboard. Then, add a new chart for each query you want to regularly monitor. The three limits metrics included in these queries are described in a separate section, below. From left to right, top to bottom: Resource Consumption Limits as a % FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) /latest(newrelic.resourceConsumption.limitValue) * 100 facet limitName where limitTimeInterval = '1 minute' timeseries limit max Copy Max % Consumption in an hour SELECT max(`usage`) FROM (FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) / latest(newrelic.resourceConsumption.limitValue) * 100 as 'usage' facet limitName timeseries ) facet limitName limit max Copy APM Agent API transaction events request per minute FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) where limitName = 'APM Agent API transaction events requests per minute' TIMESERIES Copy Trace API With limit line FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) as 'usage', latest(newrelic.resourceConsumption.limitValue) as 'limit' where limitName = 'Trace API requests per minute' TIMESERIES Copy Impact FACET From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, impact, resource TIMESERIES 1 minute limit max Copy NrIntegrationError by limit FROM NrIntegrationError select count(*) facet limitName TIMESERIES MAX since 1 day ago limit max Copy Multi-Account limits (on time series charts only) If you want to see limits for multiple accounts on one chart: run this query from one of the accounts: FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) / latest(newrelic.resourceConsumption.limitValue) * 100 facet limitName, consumingAccountId where limitTimeInterval = '1 minute' timeseries limit max Copy Click Add another query. Select a different account. Then run this query again: FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) / latest(newrelic.resourceConsumption.limitValue) * 100 facet limitName, consumingAccountId where limitTimeInterval = '1 minute' timeseries limit max Copy Finally, save it. Limit list and NrIntegrationError FROM Metric, NrIntegrationError select rate(sum(newrelic.resourceConsumption.currentValue), 1 minute) as 'Per Minute Count',latest(newrelic.resourceConsumption.limitValue) as ' limit Value',(rate(sum(newrelic.resourceConsumption.currentValue), 1 minute)/latest(newrelic.resourceConsumption.limitValue)*100)as 'Percent Used', filter (count(*), where NrIntegrationError.limitValue is not null) as 'limit reached count' facet limitName limit 1000 Copy Limit metrics These metrics, used in the dashboard queries above, can hone in on a single limit or resource. Or, with the help of FACET limitName or resource provide a view across all your limits. newrelic.resourceConsumption.limitValue limitValue allows you to see the setting for a limit by limitName and understand more about what resource is linked to this limit. The following examples use the limit value metric in the query: Example for Metric API requests per minute. FROM Metric select latest(newrelic.resourceConsumption.limitValue) where limitName = 'Metric API requests per minute' Copy To show all limits, add FACET limitName and consider grouping by limitTimeInterval. FROM Metric select latest(newrelic.resourceConsumption.limitValue) WHERE limitTimeInterval = '1 minute' FACET limitName limit max Copy newrelic.resourceConsumption.currentValue currentValue shows you how much of a given resource you’re currently consuming. To get a better glimpse into how our systems are viewing your consumption, use a rate() function with the time period that aligns with the limitTimeInterval. Limit 200. Example for Metric API request per minute: FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue),1 minute) where limitName = 'Metric API requests per minute' Copy To show all limits, add FACET limitName and consider grouping by limitTimeInterval. FROM Metric select rate(sum(newrelic.resourceConsumption.currentValue),1 minute) where limitTimeInterval = '1 minute' FACET limitName limit max Copy newrelic.resourceConsumption.impact impact lets you know for any given resource what impact limit events are having. Zeros mean you are not currently impacted. The most granular we have is dataType. It is possible for multiple instances of limitName to impact a single type, such as Metric RPM and DPM. If we know, we will display limitName. From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, resource, impact, limitName TIMESERIES limit max Copy Metric attributes Attributes on newrelic.resourceConsumption.limitValue and newrelic.resourceConsumption.currentValue: limitName - The Name of the limit for the metric data, i.e RPM Metric API. dataType - What kind of data the metric is tracking, i.e Metric, Log, or APM. Resource - What resource is being consumed, i.e. Requests, or DPM. limitTimeInterval - What time window this resource is evaluated for limiting. consumingAccountId - The New Relic account where the resource is being consumed. Attributes on newrelic.resourceConsumption.impact dataType - The kind of data that is being impacted, i.e Metric, Log, APM. Resource - What resource is being impacted, i.e Request Rate. Impact - A count of what is happening when resource has exceeded set limit, i.e dropped requests. consumingAccountId - The New Relic account where the resource is being consumed. Set alerts on resource metrics While building a dashboard to see all your limits is handy, being able to automate it is even better. You can set alerts on your limit metrics to provide updates on limits changes. Tip Because we currently only have metrics on 1 minute time windows, setting TimeWindow = 1 minute, will cover them all. Eventually, we make more metrics available, you might want to set separate alerts for limits that are enforced by different time windows. You can use the following NRQL queries to create alerts. Learn about creating alerts with NRQL queries here. Limits faceted by LimitName and scoped by Timewindow From Metric select (rate(sum(newrelic.resourceConsumption.currentValue), 1 minute)/latest(newrelic.resourceConsumption.limitValue))*100 facet limitName Copy Alert on a single limit From Metric select (rate(sum(newrelic.resourceConsumption.currentValue), 1 minute)/latest(newrelic.resourceConsumption.limitValue))*100 where limitName = 'my limit' Copy Alert on limit impact faceted by dataType, impact, resource, and reason From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, impact, resource, reason Copy Alert on impact of a single dataType From Metric select rate(sum(newrelic.resourceConsumption.impact), 1 minute) facet dataType, impact, resource, reason WHERE dataType = 'important things' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.51225,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> system <em>limits</em>",
        "sections": "<em>Query</em> system <em>limits</em>",
        "tags": "system <em>limits</em>",
        "body": " alerts for <em>limits</em> that are enforced by different time windows. You can use the following <em>NRQL</em> <em>queries</em> to create alerts. Learn about creating alerts with <em>NRQL</em> <em>queries</em> here. <em>Limits</em> faceted by <em>Limit</em>Name and scoped by Timewindow From Metric select (<em>rate</em>(sum(newrelic.resourceConsumption.currentValue), 1"
      },
      "id": "608abed9196a67a63064a7a6"
    },
    {
      "sections": [
        "Insights query API",
        "Tip",
        "Requirements and recommendations",
        "1. Register an API key",
        "2. Create the API query request",
        "Linux",
        "Microsoft Windows",
        "3. Process the returned JSON",
        "Example",
        "Query, query API request, returned data",
        "Rate limiting guidelines"
      ],
      "title": "Insights query API",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Insights API"
      ],
      "external_id": "fa0e72f1345a7adde2418c08dc8950c970140a74",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/insights-apis/query-insights-event-data-api/",
      "published_at": "2021-07-08T23:30:04Z",
      "updated_at": "2021-07-08T23:30:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Insights query API is a REST API for making NRQL queries. Tip This API is no longer the preferred way to query New Relic data. Please use NerdGraph to do that. Requirements and recommendations This API is no longer the preferred way to query New Relic data. Please use NerdGraph to do that. Use of this API may be restricted by role-related user permissions. To add custom data to New Relic, you'd use our data ingest APIs. If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. 1. Register an API key To use the Insights query API, you need a query key. You can have multiple query keys, and any query key can be used to initiate any Insights API query. If you have multiple systems querying Insights or different data destinations, New Relic recommends you use multiple query keys to enhance data security. For security reasons, query keys cannot be altered or read using the API. To change or read a query key, use the New Relic UI. Tip This API is no longer the preferred way to query New Relic data. Please use NerdGraph to do that. To create a new query key: Go to insights.newrelic.com > Manage data > API keys. Select the plus icon next to the Query keys heading. Enter a short description of the key. Select Save your notes. 2. Create the API query request When you create or edit a query key, you will see an example curl query that you can use as a template. The example query won't work unless you follow these query rules: The NRQL query string must be URL-encoded. The query string must be less than 4000 bytes. The URL must contain a valid account ID. The X-Query-Key must contain a valid query key. The Content-Type must be application/json. Linux Here is a curl example: curl -H \"Accept: application/json\" -H \"X-Query-Key: YOUR_QUERY_KEY\" \"https://insights-api.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/query?nrql=YOUR_URL_ENCODED_QUERY\" Copy Microsoft Windows You can use Powershell to query events via API: Invoke-WebRequest -Uri https://insights-api.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/query?nrql=YOUR_URL_ENCODED_QUERY -Headers @{\"X-Query-Key\"=\"YOUR_QUERY_KEY\"} -ContentType \"application/json\" -Method GET Copy 3. Process the returned JSON The query API returns results in JSON format. There is a limit of 2,000 results per request. The structure of the JSON data depends on the NRQL that you used in the request: Different combinations of SELECT statements, clauses, and functions each return an appropriate response. When writing your code to process the JSON, you should do a test run of your query and examine the resulting JSON. Example The Insights query API returns JSON data. Here's an example of a query, its query request format, and its returned data: Query, query API request, returned data Original NRQL query: SELECT count(appName) FROM PageView SINCE '2014-08-04 00:00:00+0500' Copy Query cURL request (with URL-encoded NRQL query): curl -H \"Accept: application/json\" -H \"X-Query-Key: YOUR_QUERY_KEY\" \"https://insights-api.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/query?nrql=SELECT+count%28appName%29+FROM+PageView+SINCE+%272014-08-04+00%3A00%3A00%2B0500%27\" Copy Returned JSON data: { \"results\": [ { \"count\": 80275388 } ], \"metadata\": { \"eventTypes\": [ \"PageView\" ], \"eventType\": \"PageView\", \"openEnded\": true, \"beginTime\": \"2014-08-03T19:00:00Z\", \"endTime\": \"2017-01-18T23:18:41Z\", \"beginTimeMillis=\": 1407092400000, \"endTimeMillis\": 1484781521198, \"rawSince\": \"'2014-08-04 00:00:00+0500'\", \"rawUntil\": \"`now`\", \"rawCompareWith\": \"\", \"clippedTimeWindows\": { \"Browser\": { \"beginTimeMillis\": 1483571921198, \"endTimeMillis\": 1484781521198, \"retentionMillis\": 1209600000 } }, \"messages\": [], \"contents\": [ { \"function\": \"count\", \"attribute\": \"appName\", \"simple\": true } ] } } Copy Rate limiting guidelines We have query rate limits. You likely won't encounter these limits, especially if you follow these general guidelines: Limit the amount of requests with complex queries (for example, queries with FACET or TIMESERIES clauses, or queries of over a million events) run at the same time. Limit the amount of requests run concurrently over extended periods of time to a maximum of 5, especially if they include complex queries. If New Relic applies rate limits on your account for the number of queries per minute, the query API returns a 429 error. If New Relic applies rate limits on your account for records inspected, the query API returns a 503 error and your charts may display timeout error messages.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 224.27283,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Insights <em>query</em> API",
        "sections": "<em>Rate</em> <em>limiting</em> guidelines",
        "body": " of 5, especially if they include complex <em>queries</em>. If New Relic applies <em>rate</em> <em>limits</em> on your account for the number of <em>queries</em> per minute, the query API returns a 429 error. If New Relic applies <em>rate</em> <em>limits</em> on your account for records inspected, the query API returns a 503 error and your charts may display timeout error messages."
      },
      "id": "609f9c86196a67e93722b170"
    }
  ],
  "/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/app-data-nrql-query-examples": [
    {
      "sections": [
        "NRQL query examples for mobile monitoring",
        "Mobile, MobileSession, and MobileCrash event query examples",
        "Interactions: Which interactions are most popular among my users?",
        "Location: Which regions of China have the most users?",
        "Device profile: How many users use the latest OS versions?",
        "App version: Have we seen an increase in session duration since yesterday's release?",
        "Performance: How much memory does my app use for sessions longer than 5 seconds?",
        "Crashes: What are my app's most common crashes?",
        "Crash rate: What is the crash rate for different versions of my app?",
        "MobileRequest event query examples",
        "Error rate by request domain",
        "Error rate for business-critical API",
        "Response time percentiles of important APIs",
        "Volume of network requests",
        "Slow response user impact",
        "Response time distribution by domain, carrier, ASN owner, country, etc.",
        "Percentile response time",
        "Requests per session",
        "MobileRequestError event query examples",
        "Tip",
        "HTTP errors",
        "Network failures",
        "Error rate: Percentage of users impacted",
        "Errors by version",
        "Unique devices (by UUID)",
        "Historical HTTP error counts",
        "MobileHandledException event query examples",
        "App exceptions",
        "Top exception locations",
        "Most common interaction generating exceptions",
        "Most common exception message",
        "Most common method reporting exceptions",
        "Handled exception rate"
      ],
      "title": "NRQL query examples for mobile monitoring",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "2844422852b86681e69a3ef9333f2268deacbecb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-query-examples-mobile-monitoring/",
      "published_at": "2021-07-10T04:34:50Z",
      "updated_at": "2021-07-10T04:34:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are several ways to query your data. This document will show you some example NRQL queries from mobile monitoring data. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event query examples Mobile queries allow you to understand and compare a wide variety of mobile data, including interactions, location, device profile, app version, crashes, and performance. These examples use queries made on the Mobile, MobileSession, and MobileCrash event types: Interactions: Which interactions are most popular among my users? SELECT uniqueCount(uuid) FROM Mobile SINCE 1 day ago FACET name Copy Location: Which regions of China have the most users? SELECT uniqueCount(uuid) FROM MobileSession WHERE countryCode='CN' FACET regionCode SINCE 7 days ago Copy Device profile: How many users use the latest OS versions? SELECT uniqueCount(uuid) FROM MobileSession FACET osVersion SINCE 7 days ago Copy App version: Have we seen an increase in session duration since yesterday's release? SELECT percentile(sessionDuration, 90) FROM MobileSession since 1 day ago compare with 2 days ago Copy Performance: How much memory does my app use for sessions longer than 5 seconds? SELECT histogram(memUsageMb) FROM MobileSession WHERE sessionDuration > 5 Copy Crashes: What are my app's most common crashes? SELECT count(*) FROM MobileCrash FACET crashException Copy Crash rate: What is the crash rate for different versions of my app? SELECT percentage(uniqueCount(sessionId), WHERE category = 'Crash') as `Crash rate` FROM MobileSession, MobileCrash facet appVersion since 90 days ago Copy MobileRequest event query examples This feature requires mobile monitoring agent version 5.14.0 or higher. MobileRequest data is enabled by default for: Android version 5.15.2 or higher iOS version 6.0.0 or higher For earlier versions, starting with Android version 5.14.0 or iOS version 5.14.0, you must enable the feature. Upgrade to the latest Android or iOS version, or add the required feature flag to your app. Below are some NRQL queries that address common use cases. Use the MobileRequest attributes to make your own NRQL queries. The last two examples use MobileRequestError events in addition to MobileRequest to get an error rate. Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate seen by our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Response time percentiles of important APIs For important requests in the 90th percentile, what is the response time by URL? SELECT percentile(responseTime, 90), latest(requestUrl) as 'Latest URL' from MobileRequest facet cases(where requestUrl like '%{YOUR_CORE_API}%' as 'Core API', where requestUrl like '%{YOUR_FEATURE_API}%' as 'New Feature API') Copy Volume of network requests How much network traffic from the apps are backend services receiving? SELECT count(*) FROM MobileRequest FACET requestDomain since 3 days ago Copy Slow response user impact What % of users are impacted by http response times greater than 3 seconds? SELECT filter(uniqueCount(MobileRequest.uuid), WHERE responseTime > 3) / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted' FROM MobileRequest, MobileSession since 1 day ago timeseries compare with 2 days ago Copy Response time distribution by domain, carrier, ASN owner, country, etc. What is the distribution of response time and request count across domain, country, carrier, or ASN owner? SELECT histogram(responseTime, 20, 20) FROM MobileRequest since 3 days ago facet asnOwner Copy Percentile response time What is the breakdown of response time by different percentiles? SELECT percentile(responseTime, 98) as '98 percentile (sec)', percentile(responseTime, 90) as '90 percentile (sec)', percentile(responseTime, 50) as '50 percentile (sec)' from MobileRequest since 3 days ago Copy Requests per session How do requests per session compare across different apps or subsequent builds of those apps? SELECT count(*)/uniqueCount(sessionId) from MobileRequest, MobileSession facet appName timeseries Copy MobileRequestError event query examples Below are some NRQL queries that address common use cases. Use the MobileRequestError attributes to make your own NRQL queries. Tip For more information and examples, see the our blog post explaining the power of MobileRequestError event data. HTTP errors Which queries are causing the most errors? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestUrl Copy Network failures What network failures are most common for my application? SELECT count(*) FROM MobileRequestError where errorType = 'NetworkFailure' facet networkError Copy Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate in our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Error rate: Percentage of users impacted How many users are experiencing errors as compared to my total user count? SELECT filter(uniqueCount(MobileRequestError.uuid), WHERE errorType = 'HTTPError') / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted by Errors' FROM MobileRequestError, MobileSession COMPARE WITH 7 days AGO Copy Errors by version Which version(s) of my app are causing the most errors? SELECT count(*) FROM MobileRequestError FACET appVersion Copy Unique devices (by UUID) Which unique devices (by UUID) are having the most issues with my application? SELECT count(*), latest(device), latest(carrier), latest(asnOwner), latest(countryCode) FROM MobileRequestError FACET deviceUuid limit 100 SINCE 1 days ago Copy Historical HTTP error counts What does my historical HTTP Error count look like (by domain)? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestDomain timeseries Copy MobileHandledException event query examples Below are some NRQL queries for common handled exception use cases. Use the MobileHandledException attributes to make your own NRQL queries. App exceptions Which apps have reported the most number of handled exceptions? SELECT count(*) FROM MobileHandledException FACET appName SINCE 3 days ago Copy Top exception locations What are most common exception locations for my application? How many exceptions do we have, and where do they occur? SELECT count(*) FROM MobileHandledException FACET exceptionLocation SINCE 3 days ago Copy Most common interaction generating exceptions Which interaction produces the most exceptions? SELECT count(*) FROM MobileHandledException FACET lastInteraction SINCE 3 days ago Copy Most common exception message What are the most common reported exception messages? SELECT count(*) FROM MobileHandledException FACET exceptionMessage SINCE 3 days ago Copy Most common method reporting exceptions What are the most common methods reporting exceptions? SELECT count(*) FROM MobileHandledException FACET exceptionLocationMethod SINCE 3 days ago Copy Handled exception rate How often are handled exceptions encountered by our users? SELECT percentage(uniqueCount(sessionId), WHERE exceptionLocation IS NOT NULL) FROM MobileSession,MobileHandledException SINCE 3 days ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.00635,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> <em>query</em> examples for mobile monitoring",
        "sections": "<em>NRQL</em> <em>query</em> examples for mobile monitoring",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "There are several ways to <em>query</em> <em>your</em> <em>data</em>. This document will show you some example <em>NRQL</em> queries from mobile monitoring <em>data</em>. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event <em>query</em> examples Mobile queries"
      },
      "id": "60445a6128ccbc6b6a2c60ca"
    },
    {
      "sections": [
        "Funnels: Evaluate data from a series of related events",
        "Why it matters",
        "Funnel query structure",
        "Funnel query technical details",
        "Funnel query example"
      ],
      "title": "Funnels: Evaluate data from a series of related events",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "4a1a5a2e5f137193c1e6b5c8465d04d44d988002",
      "image": "https://docs.newrelic.com/static/84e56be2136c40fa25afb3d333cfa36e/c1b63/crop-insights-funnels.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/funnels-evaluate-data-series-related-events/",
      "published_at": "2021-07-09T22:34:58Z",
      "updated_at": "2021-07-09T22:34:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NRQL, you can use funnels to evaluate sets of related actions. The actions generally share a relationship via an identifier such as a user ID or session ID. Why it matters NRQL funnel functions can answer questions like, \"Of the people that completed step A, how many also completed step B, and of the people that completed steps A and B, how many also completed step C?\" For example, at New Relic, we could use funnel to track the number of users who completed these steps: Visited the New Relic One marketing page. Signed up for an account. Created a dashboard. Funnel query structure Here's the structure of a simple NRQL funnel query: FROM DATA_TYPE SELECT funnel(AN_ATTRIBUTE, ACTION_A, ACTION_B) SINCE TIMEFRAME Copy See also a more complex funnel query example. Funnel queries require the funnel function, an attribute to funnel, and at least two steps: The first step is the anchor step, which will always represent 100% of the results. The second and later steps describe the number of users who have also completed additional actions. This number typically will be less than 100%. However, it could be 100% if every user who completes action (A) also completes the additional actions being queried. Funnel query technical details One way to use funnel queries is to calculate the rate at which multi-step, ordered sequences were completed over a given timeframe, like in the New Relic One signup example. But you can also use funnels to calculate overlap between several distinct actions that don't have a sequential relationship to one another. In other words, the order of steps doesn't impact the calculations performed. The way funnel queries compute results varies depending on the size of the data set: If the funnel is dealing with 256 funnel attribute values or fewer, it will calculate the value exactly. If it's dealing with more than 256 funnel attribute values, it applies an algorithm called MinHash to calculate approximate results for optimized performance. This means that for large data sets, there may be occasional \"false positives\" at the level of individual data points. These do not interfere greatly with the accuracy of the numerical estimates provided in query results. Here's a detailed breakdown of technical details and constraints for funnel queries. Technical details Comments Order of steps The order of steps completed is not enforced and does not impact results. Attributes You can only run funnel queries on one attribute at a time. Unique values For funnel queries that involve more than 256 unique funnel attribute values, the results are approximate. Maximum steps You can have a maximum of 10 steps within a single funnel query. Funnel query example This example queries the browser monitoring PageView event and its attributes. It queries unique browser sessions that have progressed from registration to account upgrades. Labels are included for each step, indicated by the keyword AS. FROM PageView SELECT funnel(session, WHERE pageUrl='http://www.storefront.com/signup' AS 'Email Sign Up', WHERE pageUrl='http://www.appproduction.com/basic_feature' AS 'Feature Compare', WHERE pageUrl='http://www.appproduction.com/advanced_feature/upgrade' AS 'Upgraded Account') SINCE 12 hours ago Copy This query returns the following: An example NRQL funnel query that displays a count of the users who registered for an account, visited a feature-compare page, and upgraded. Include additional actions inside the parentheses of the funnel function in a comma separated list: SELECT funnel(session, WHERE name='Controller/about/main' AS 'Action A', WHERE name = 'Controller/about/careers' AS 'Action B', WHERE name = 'Controller/about/insights' AS 'Action C', WHERE name = 'Controller/about/apply' AS 'Action D') FROM PageView SINCE 1 week ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 387.29926,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Funnels: Evaluate <em>data</em> from a series of related events",
        "sections": "Funnels: Evaluate <em>data</em> from a series of related events",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": ", and of the people that completed steps A and B, how many also completed step C?&quot; For example, at <em>New</em> <em>Relic</em>, we could use funnel to track the number of users who completed these steps: Visited the <em>New</em> <em>Relic</em> One marketing page. Signed up for an account. Created a dashboard. Funnel <em>query</em> structure Here"
      },
      "id": "6044371428ccbcc3fb2c60cd"
    },
    {
      "sections": [
        "Introduction to NRQL, New Relic's query language",
        "What is NRQL?",
        "Where can you use NRQL?",
        "What data can you query with NRQL?",
        "Tip",
        "Start using NRQL",
        "Important",
        "NRQL query examples",
        "Basic NRQL query of browser data",
        "Attribute name with a space in it",
        "Querying multiple data sources",
        "Query returning multiple columns",
        "NRQL syntax"
      ],
      "title": "Introduction to NRQL, New Relic's query language",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "Get started"
      ],
      "external_id": "51e361ee5ec2a2379486d6686677e0383eb49163",
      "image": "https://docs.newrelic.com/static/04052353f8dbe132cd384d7472778b3f/c1b63/new-relic-view-chart-nrql-query_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language/",
      "published_at": "2021-07-09T22:51:45Z",
      "updated_at": "2021-07-09T22:51:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "One way to query your New Relic data is with the New Relic Query Language (NRQL). This resource explains what NRQL is, when and how you can use it, and basic syntax rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see NRQL syntax, clauses, and functions. What is NRQL? NRQL is New Relic's SQL-like query language. You can use NRQL to retrieve detailed New Relic data and get insight into your applications, hosts, and business-important activity. Reasons to use NRQL include: To answer a question for the purpose of troubleshooting or business analysis To create a new chart To make API queries of New Relic data (for example, using our NerdGraph API) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart's query and then edit it to make your own custom chart. Where can you use NRQL? You can use NRQL in these places: New Relic One query builder: Advanced mode is a NRQL query interface Basic mode provides a simplified query experience that doesn't require knowledge of NRQL but that uses NRQL to generate results NerdGraph: our GraphQL-format API, which includes options for making NRQL queries one.newrelic.com > Query your data: You can run a NRQL query in New Relic One. This NRQL query shows a count of distributed tracing spans faceted by their entity names. NRQL is one of several ways to query New Relic data. For more on all query options, see Query your data. What data can you query with NRQL? NRQL allows you to query these New Relic data types: Event data from all New Relic products, including: APM events, like Transaction Browser monitoring events, like PageView Mobile monitoring events, like Mobile Infrastructure events, like ProcessSample Synthetics events, like SyntheticCheck Custom events, like those reported by the Event API Metric timeslice data (metrics reported by New Relic APM, browser, and mobile) The Metric data type (metrics reported by the Metric API and data sources that use that API) The Span data type (distributed tracing data) The Log data type (data from New Relic Logs) Tip Some data, like relationships between monitored entities, is not available via NRQL but is available using our NerdGraph API. Start using NRQL One way to start using NRQL and to understand what data you have available is to go to a NRQL interface (for example, the New Relic One query builder), type FROM, and press space. The interface will suggest available types of data: To see the attributes available for a specific data type, type FROM DATA_TYPE SELECT and press space. The interface will suggest available attributes. For example: To see the complete JSON associated with a data type, including all of its attributes, use the keyset() attribute. For example: FROM Transaction SELECT keyset() Copy NRQL is used behind the scenes to build some New Relic charts and dashboards. One way to learn NRQL is to find one of these NRQL-generated charts and start playing with the NRQL to create new, customized queries and charts: Charts built with NRQL will have View query as an option. You can then edit and customize that query to see how your changes affect the resulting visualization. Important To explore your data without having to use NRQL, use the basic mode of New Relic One query builder. NRQL query examples Here's an example NRQL query of Transaction data, which is reported by New Relic APM. FROM Transaction SELECT average(duration) FACET appName TIMESERIES auto Copy This would generate a chart that looks like: Here are some more query examples: Basic NRQL query of browser data Here's a NRQL query of PageView data from browser monitoring. SELECT uniqueCount(user) FROM PageView WHERE userAgentOS = 'Mac' FACET countryCode SINCE 1 day ago LIMIT 20 Copy Attribute name with a space in it If a custom attribute name has a space in it, use backticks around the attribute name: SELECT count(*) FROM Transaction FACET `Logged-in user` Copy Querying multiple data sources To return data from two data sources, separate their data types with a comma. For example, this query returns a count of all APM transactions and browser events over the last three days: SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Copy Query returning multiple columns To return multiple columns from a dataset, separate the aggregator arguments with a comma: SELECT function(attribute), function(attribute) ... FROM ... Copy This query returns the minimum, average, and maximum duration for browser monitoring PageView events over the last week: SELECT min(duration), max(duration), average(duration) FROM PageView SINCE 1 week ago Copy See more NRQL query examples. NRQL syntax The syntax of a NRQL query is similar to standard SQL queries. Here is a breakdown of the structure of a NRQL query: SELECT function(attribute) [AS 'label'][, ...] FROM data type [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Copy Basic rules include: NRQL condition Details Required values The SELECT statement and FROM clause are required. All other clauses are optional. You can start your query with either SELECT or FROM. Query string size The query string must be less than 4 KB. Case sensitivity The data type names and attribute names are case sensitive. NRQL clauses and functions are not case sensitive. Syntax for strings NRQL uses single quotes to designate strings. For example: ... where traceId = '030a573f0df02c57' Copy Attribute names with spaces Use backticks `` to quote a custom attribute name that has a space in it. For example: ... FACET `Logged-in user` Copy Data type coercion Insights does not support data type \"coercion.\" For more information, see Data type conversion. Use of math functions Basic and advanced math functions are supported in the SELECT statement. JOIN functions NRQL does not have the equivalent of the SQL JOIN function, but you can simulate a JOIN with custom attributes. Read more about NRQL syntax and functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 326.4903,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>NRQL</em>, <em>New</em> <em>Relic&#x27;s</em> <em>query</em> <em>language</em>",
        "sections": "Introduction to <em>NRQL</em>, <em>New</em> <em>Relic&#x27;s</em> <em>query</em> <em>language</em>",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "One way to <em>query</em> <em>your</em> <em>New</em> <em>Relic</em> <em>data</em> is with the <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em> (<em>NRQL</em>). This resource explains what <em>NRQL</em> is, when and how you can use it, and basic syntax rules. For more detailed information on querying, including a listing of clauses and functions and example queries, see <em>NRQL</em> syntax"
      },
      "id": "60445a0e196a67cb09960f6e"
    }
  ],
  "/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/browserspa-nrql-query-examples": [
    {
      "sections": [
        "NRQL query examples for mobile monitoring",
        "Mobile, MobileSession, and MobileCrash event query examples",
        "Interactions: Which interactions are most popular among my users?",
        "Location: Which regions of China have the most users?",
        "Device profile: How many users use the latest OS versions?",
        "App version: Have we seen an increase in session duration since yesterday's release?",
        "Performance: How much memory does my app use for sessions longer than 5 seconds?",
        "Crashes: What are my app's most common crashes?",
        "Crash rate: What is the crash rate for different versions of my app?",
        "MobileRequest event query examples",
        "Error rate by request domain",
        "Error rate for business-critical API",
        "Response time percentiles of important APIs",
        "Volume of network requests",
        "Slow response user impact",
        "Response time distribution by domain, carrier, ASN owner, country, etc.",
        "Percentile response time",
        "Requests per session",
        "MobileRequestError event query examples",
        "Tip",
        "HTTP errors",
        "Network failures",
        "Error rate: Percentage of users impacted",
        "Errors by version",
        "Unique devices (by UUID)",
        "Historical HTTP error counts",
        "MobileHandledException event query examples",
        "App exceptions",
        "Top exception locations",
        "Most common interaction generating exceptions",
        "Most common exception message",
        "Most common method reporting exceptions",
        "Handled exception rate"
      ],
      "title": "NRQL query examples for mobile monitoring",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "2844422852b86681e69a3ef9333f2268deacbecb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-query-examples-mobile-monitoring/",
      "published_at": "2021-07-10T04:34:50Z",
      "updated_at": "2021-07-10T04:34:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are several ways to query your data. This document will show you some example NRQL queries from mobile monitoring data. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event query examples Mobile queries allow you to understand and compare a wide variety of mobile data, including interactions, location, device profile, app version, crashes, and performance. These examples use queries made on the Mobile, MobileSession, and MobileCrash event types: Interactions: Which interactions are most popular among my users? SELECT uniqueCount(uuid) FROM Mobile SINCE 1 day ago FACET name Copy Location: Which regions of China have the most users? SELECT uniqueCount(uuid) FROM MobileSession WHERE countryCode='CN' FACET regionCode SINCE 7 days ago Copy Device profile: How many users use the latest OS versions? SELECT uniqueCount(uuid) FROM MobileSession FACET osVersion SINCE 7 days ago Copy App version: Have we seen an increase in session duration since yesterday's release? SELECT percentile(sessionDuration, 90) FROM MobileSession since 1 day ago compare with 2 days ago Copy Performance: How much memory does my app use for sessions longer than 5 seconds? SELECT histogram(memUsageMb) FROM MobileSession WHERE sessionDuration > 5 Copy Crashes: What are my app's most common crashes? SELECT count(*) FROM MobileCrash FACET crashException Copy Crash rate: What is the crash rate for different versions of my app? SELECT percentage(uniqueCount(sessionId), WHERE category = 'Crash') as `Crash rate` FROM MobileSession, MobileCrash facet appVersion since 90 days ago Copy MobileRequest event query examples This feature requires mobile monitoring agent version 5.14.0 or higher. MobileRequest data is enabled by default for: Android version 5.15.2 or higher iOS version 6.0.0 or higher For earlier versions, starting with Android version 5.14.0 or iOS version 5.14.0, you must enable the feature. Upgrade to the latest Android or iOS version, or add the required feature flag to your app. Below are some NRQL queries that address common use cases. Use the MobileRequest attributes to make your own NRQL queries. The last two examples use MobileRequestError events in addition to MobileRequest to get an error rate. Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate seen by our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Response time percentiles of important APIs For important requests in the 90th percentile, what is the response time by URL? SELECT percentile(responseTime, 90), latest(requestUrl) as 'Latest URL' from MobileRequest facet cases(where requestUrl like '%{YOUR_CORE_API}%' as 'Core API', where requestUrl like '%{YOUR_FEATURE_API}%' as 'New Feature API') Copy Volume of network requests How much network traffic from the apps are backend services receiving? SELECT count(*) FROM MobileRequest FACET requestDomain since 3 days ago Copy Slow response user impact What % of users are impacted by http response times greater than 3 seconds? SELECT filter(uniqueCount(MobileRequest.uuid), WHERE responseTime > 3) / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted' FROM MobileRequest, MobileSession since 1 day ago timeseries compare with 2 days ago Copy Response time distribution by domain, carrier, ASN owner, country, etc. What is the distribution of response time and request count across domain, country, carrier, or ASN owner? SELECT histogram(responseTime, 20, 20) FROM MobileRequest since 3 days ago facet asnOwner Copy Percentile response time What is the breakdown of response time by different percentiles? SELECT percentile(responseTime, 98) as '98 percentile (sec)', percentile(responseTime, 90) as '90 percentile (sec)', percentile(responseTime, 50) as '50 percentile (sec)' from MobileRequest since 3 days ago Copy Requests per session How do requests per session compare across different apps or subsequent builds of those apps? SELECT count(*)/uniqueCount(sessionId) from MobileRequest, MobileSession facet appName timeseries Copy MobileRequestError event query examples Below are some NRQL queries that address common use cases. Use the MobileRequestError attributes to make your own NRQL queries. Tip For more information and examples, see the our blog post explaining the power of MobileRequestError event data. HTTP errors Which queries are causing the most errors? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestUrl Copy Network failures What network failures are most common for my application? SELECT count(*) FROM MobileRequestError where errorType = 'NetworkFailure' facet networkError Copy Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate in our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Error rate: Percentage of users impacted How many users are experiencing errors as compared to my total user count? SELECT filter(uniqueCount(MobileRequestError.uuid), WHERE errorType = 'HTTPError') / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted by Errors' FROM MobileRequestError, MobileSession COMPARE WITH 7 days AGO Copy Errors by version Which version(s) of my app are causing the most errors? SELECT count(*) FROM MobileRequestError FACET appVersion Copy Unique devices (by UUID) Which unique devices (by UUID) are having the most issues with my application? SELECT count(*), latest(device), latest(carrier), latest(asnOwner), latest(countryCode) FROM MobileRequestError FACET deviceUuid limit 100 SINCE 1 days ago Copy Historical HTTP error counts What does my historical HTTP Error count look like (by domain)? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestDomain timeseries Copy MobileHandledException event query examples Below are some NRQL queries for common handled exception use cases. Use the MobileHandledException attributes to make your own NRQL queries. App exceptions Which apps have reported the most number of handled exceptions? SELECT count(*) FROM MobileHandledException FACET appName SINCE 3 days ago Copy Top exception locations What are most common exception locations for my application? How many exceptions do we have, and where do they occur? SELECT count(*) FROM MobileHandledException FACET exceptionLocation SINCE 3 days ago Copy Most common interaction generating exceptions Which interaction produces the most exceptions? SELECT count(*) FROM MobileHandledException FACET lastInteraction SINCE 3 days ago Copy Most common exception message What are the most common reported exception messages? SELECT count(*) FROM MobileHandledException FACET exceptionMessage SINCE 3 days ago Copy Most common method reporting exceptions What are the most common methods reporting exceptions? SELECT count(*) FROM MobileHandledException FACET exceptionLocationMethod SINCE 3 days ago Copy Handled exception rate How often are handled exceptions encountered by our users? SELECT percentage(uniqueCount(sessionId), WHERE exceptionLocation IS NOT NULL) FROM MobileSession,MobileHandledException SINCE 3 days ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.00635,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> <em>query</em> examples for mobile monitoring",
        "sections": "<em>NRQL</em> <em>query</em> examples for mobile monitoring",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "There are several ways to <em>query</em> <em>your</em> <em>data</em>. This document will show you some example <em>NRQL</em> queries from mobile monitoring <em>data</em>. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event <em>query</em> examples Mobile queries"
      },
      "id": "60445a6128ccbc6b6a2c60ca"
    },
    {
      "sections": [
        "App data NRQL query examples",
        "Unique users",
        "Unique user trends",
        "Pageview trends",
        "OS version",
        "Key account Apdex"
      ],
      "title": "App data NRQL query examples",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "54b651240956896f8bdc7d9c3fbb7b6096f455a9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/app-data-nrql-query-examples/",
      "published_at": "2021-07-10T03:13:38Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use NRQL to query the application data collected by APM, browser monitoring, and mobile monitoring. You can then use this data to answer a variety of questions. Here are some basic examples. Unique users How many unique user sessions did you have in the last week? SELECT uniqueCount(session) FROM PageView SINCE 1 week ago Copy Unique user trends Were your unique user sessions up or down last week compared to the week before? SELECT uniqueCount(session) FROM PageView SINCE 1 week ago COMPARE WITH 1 week ago Copy Pageview trends How can I graph the number of unique users yesterday compared to the day before? SELECT count(*) FROM PageView SINCE 1 day ago COMPARE WITH 1 day ago TIMESERIES AUTO Copy OS version How many of your mobile users are on the latest OS version? SELECT uniqueCount(uuid) FROM MobileSession FACET osVersion SINCE 7 days ago Copy Key account Apdex What is the Apdex score for a particularly important customer? If you have defined some custom attributes, you can query to monitor how this customer experiences your app from a performance standpoint: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 391.6913,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "App <em>data</em> <em>NRQL</em> <em>query</em> examples",
        "sections": "App <em>data</em> <em>NRQL</em> <em>query</em> examples",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "You can use <em>NRQL</em> to <em>query</em> the application <em>data</em> collected by APM, browser monitoring, and mobile monitoring. You can then use this <em>data</em> to answer a variety of questions. Here are some basic examples. Unique users How many unique user sessions did you have in the last week? SELECT uniqueCount(session"
      },
      "id": "60445a0f64441f5a46378eec"
    },
    {
      "sections": [
        "Funnels: Evaluate data from a series of related events",
        "Why it matters",
        "Funnel query structure",
        "Funnel query technical details",
        "Funnel query example"
      ],
      "title": "Funnels: Evaluate data from a series of related events",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "4a1a5a2e5f137193c1e6b5c8465d04d44d988002",
      "image": "https://docs.newrelic.com/static/84e56be2136c40fa25afb3d333cfa36e/c1b63/crop-insights-funnels.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/funnels-evaluate-data-series-related-events/",
      "published_at": "2021-07-09T22:34:58Z",
      "updated_at": "2021-07-09T22:34:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NRQL, you can use funnels to evaluate sets of related actions. The actions generally share a relationship via an identifier such as a user ID or session ID. Why it matters NRQL funnel functions can answer questions like, \"Of the people that completed step A, how many also completed step B, and of the people that completed steps A and B, how many also completed step C?\" For example, at New Relic, we could use funnel to track the number of users who completed these steps: Visited the New Relic One marketing page. Signed up for an account. Created a dashboard. Funnel query structure Here's the structure of a simple NRQL funnel query: FROM DATA_TYPE SELECT funnel(AN_ATTRIBUTE, ACTION_A, ACTION_B) SINCE TIMEFRAME Copy See also a more complex funnel query example. Funnel queries require the funnel function, an attribute to funnel, and at least two steps: The first step is the anchor step, which will always represent 100% of the results. The second and later steps describe the number of users who have also completed additional actions. This number typically will be less than 100%. However, it could be 100% if every user who completes action (A) also completes the additional actions being queried. Funnel query technical details One way to use funnel queries is to calculate the rate at which multi-step, ordered sequences were completed over a given timeframe, like in the New Relic One signup example. But you can also use funnels to calculate overlap between several distinct actions that don't have a sequential relationship to one another. In other words, the order of steps doesn't impact the calculations performed. The way funnel queries compute results varies depending on the size of the data set: If the funnel is dealing with 256 funnel attribute values or fewer, it will calculate the value exactly. If it's dealing with more than 256 funnel attribute values, it applies an algorithm called MinHash to calculate approximate results for optimized performance. This means that for large data sets, there may be occasional \"false positives\" at the level of individual data points. These do not interfere greatly with the accuracy of the numerical estimates provided in query results. Here's a detailed breakdown of technical details and constraints for funnel queries. Technical details Comments Order of steps The order of steps completed is not enforced and does not impact results. Attributes You can only run funnel queries on one attribute at a time. Unique values For funnel queries that involve more than 256 unique funnel attribute values, the results are approximate. Maximum steps You can have a maximum of 10 steps within a single funnel query. Funnel query example This example queries the browser monitoring PageView event and its attributes. It queries unique browser sessions that have progressed from registration to account upgrades. Labels are included for each step, indicated by the keyword AS. FROM PageView SELECT funnel(session, WHERE pageUrl='http://www.storefront.com/signup' AS 'Email Sign Up', WHERE pageUrl='http://www.appproduction.com/basic_feature' AS 'Feature Compare', WHERE pageUrl='http://www.appproduction.com/advanced_feature/upgrade' AS 'Upgraded Account') SINCE 12 hours ago Copy This query returns the following: An example NRQL funnel query that displays a count of the users who registered for an account, visited a feature-compare page, and upgraded. Include additional actions inside the parentheses of the funnel function in a comma separated list: SELECT funnel(session, WHERE name='Controller/about/main' AS 'Action A', WHERE name = 'Controller/about/careers' AS 'Action B', WHERE name = 'Controller/about/insights' AS 'Action C', WHERE name = 'Controller/about/apply' AS 'Action D') FROM PageView SINCE 1 week ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 387.29926,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Funnels: Evaluate <em>data</em> from a series of related events",
        "sections": "Funnels: Evaluate <em>data</em> from a series of related events",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": ", and of the people that completed steps A and B, how many also completed step C?&quot; For example, at <em>New</em> <em>Relic</em>, we could use funnel to track the number of users who completed these steps: Visited the <em>New</em> <em>Relic</em> One marketing page. Signed up for an account. Created a dashboard. Funnel <em>query</em> structure Here"
      },
      "id": "6044371428ccbcc3fb2c60cd"
    }
  ],
  "/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows": [
    {
      "sections": [
        "NRQL query examples for mobile monitoring",
        "Mobile, MobileSession, and MobileCrash event query examples",
        "Interactions: Which interactions are most popular among my users?",
        "Location: Which regions of China have the most users?",
        "Device profile: How many users use the latest OS versions?",
        "App version: Have we seen an increase in session duration since yesterday's release?",
        "Performance: How much memory does my app use for sessions longer than 5 seconds?",
        "Crashes: What are my app's most common crashes?",
        "Crash rate: What is the crash rate for different versions of my app?",
        "MobileRequest event query examples",
        "Error rate by request domain",
        "Error rate for business-critical API",
        "Response time percentiles of important APIs",
        "Volume of network requests",
        "Slow response user impact",
        "Response time distribution by domain, carrier, ASN owner, country, etc.",
        "Percentile response time",
        "Requests per session",
        "MobileRequestError event query examples",
        "Tip",
        "HTTP errors",
        "Network failures",
        "Error rate: Percentage of users impacted",
        "Errors by version",
        "Unique devices (by UUID)",
        "Historical HTTP error counts",
        "MobileHandledException event query examples",
        "App exceptions",
        "Top exception locations",
        "Most common interaction generating exceptions",
        "Most common exception message",
        "Most common method reporting exceptions",
        "Handled exception rate"
      ],
      "title": "NRQL query examples for mobile monitoring",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "2844422852b86681e69a3ef9333f2268deacbecb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/nrql-query-examples-mobile-monitoring/",
      "published_at": "2021-07-10T04:34:50Z",
      "updated_at": "2021-07-10T04:34:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are several ways to query your data. This document will show you some example NRQL queries from mobile monitoring data. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event query examples Mobile queries allow you to understand and compare a wide variety of mobile data, including interactions, location, device profile, app version, crashes, and performance. These examples use queries made on the Mobile, MobileSession, and MobileCrash event types: Interactions: Which interactions are most popular among my users? SELECT uniqueCount(uuid) FROM Mobile SINCE 1 day ago FACET name Copy Location: Which regions of China have the most users? SELECT uniqueCount(uuid) FROM MobileSession WHERE countryCode='CN' FACET regionCode SINCE 7 days ago Copy Device profile: How many users use the latest OS versions? SELECT uniqueCount(uuid) FROM MobileSession FACET osVersion SINCE 7 days ago Copy App version: Have we seen an increase in session duration since yesterday's release? SELECT percentile(sessionDuration, 90) FROM MobileSession since 1 day ago compare with 2 days ago Copy Performance: How much memory does my app use for sessions longer than 5 seconds? SELECT histogram(memUsageMb) FROM MobileSession WHERE sessionDuration > 5 Copy Crashes: What are my app's most common crashes? SELECT count(*) FROM MobileCrash FACET crashException Copy Crash rate: What is the crash rate for different versions of my app? SELECT percentage(uniqueCount(sessionId), WHERE category = 'Crash') as `Crash rate` FROM MobileSession, MobileCrash facet appVersion since 90 days ago Copy MobileRequest event query examples This feature requires mobile monitoring agent version 5.14.0 or higher. MobileRequest data is enabled by default for: Android version 5.15.2 or higher iOS version 6.0.0 or higher For earlier versions, starting with Android version 5.14.0 or iOS version 5.14.0, you must enable the feature. Upgrade to the latest Android or iOS version, or add the required feature flag to your app. Below are some NRQL queries that address common use cases. Use the MobileRequest attributes to make your own NRQL queries. The last two examples use MobileRequestError events in addition to MobileRequest to get an error rate. Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate seen by our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Response time percentiles of important APIs For important requests in the 90th percentile, what is the response time by URL? SELECT percentile(responseTime, 90), latest(requestUrl) as 'Latest URL' from MobileRequest facet cases(where requestUrl like '%{YOUR_CORE_API}%' as 'Core API', where requestUrl like '%{YOUR_FEATURE_API}%' as 'New Feature API') Copy Volume of network requests How much network traffic from the apps are backend services receiving? SELECT count(*) FROM MobileRequest FACET requestDomain since 3 days ago Copy Slow response user impact What % of users are impacted by http response times greater than 3 seconds? SELECT filter(uniqueCount(MobileRequest.uuid), WHERE responseTime > 3) / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted' FROM MobileRequest, MobileSession since 1 day ago timeseries compare with 2 days ago Copy Response time distribution by domain, carrier, ASN owner, country, etc. What is the distribution of response time and request count across domain, country, carrier, or ASN owner? SELECT histogram(responseTime, 20, 20) FROM MobileRequest since 3 days ago facet asnOwner Copy Percentile response time What is the breakdown of response time by different percentiles? SELECT percentile(responseTime, 98) as '98 percentile (sec)', percentile(responseTime, 90) as '90 percentile (sec)', percentile(responseTime, 50) as '50 percentile (sec)' from MobileRequest since 3 days ago Copy Requests per session How do requests per session compare across different apps or subsequent builds of those apps? SELECT count(*)/uniqueCount(sessionId) from MobileRequest, MobileSession facet appName timeseries Copy MobileRequestError event query examples Below are some NRQL queries that address common use cases. Use the MobileRequestError attributes to make your own NRQL queries. Tip For more information and examples, see the our blog post explaining the power of MobileRequestError event data. HTTP errors Which queries are causing the most errors? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestUrl Copy Network failures What network failures are most common for my application? SELECT count(*) FROM MobileRequestError where errorType = 'NetworkFailure' facet networkError Copy Error rate by request domain Which domains are prone to failure and error? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestDomain Copy Error rate for business-critical API What is the error rate in our mobile apps for the most business-critical API? SELECT percentage(count(*), where errorType = 'NetworkFailure' OR errorType = 'HTTPError') as 'Error Rate %', count(*) as '# of Requests', filter(count(*), where errorType='NetworkFailure' OR errorType='HTTPError' as '# of Errors') FROM MobileRequestError, MobileRequest facet requestPath where requestPath = '{MY_API_PATH}' Copy Error rate: Percentage of users impacted How many users are experiencing errors as compared to my total user count? SELECT filter(uniqueCount(MobileRequestError.uuid), WHERE errorType = 'HTTPError') / uniqueCount(MobileSession.uuid) * 100 as '% Users Impacted by Errors' FROM MobileRequestError, MobileSession COMPARE WITH 7 days AGO Copy Errors by version Which version(s) of my app are causing the most errors? SELECT count(*) FROM MobileRequestError FACET appVersion Copy Unique devices (by UUID) Which unique devices (by UUID) are having the most issues with my application? SELECT count(*), latest(device), latest(carrier), latest(asnOwner), latest(countryCode) FROM MobileRequestError FACET deviceUuid limit 100 SINCE 1 days ago Copy Historical HTTP error counts What does my historical HTTP Error count look like (by domain)? SELECT count(*) FROM MobileRequestError where errorType = 'HTTPError' FACET requestDomain timeseries Copy MobileHandledException event query examples Below are some NRQL queries for common handled exception use cases. Use the MobileHandledException attributes to make your own NRQL queries. App exceptions Which apps have reported the most number of handled exceptions? SELECT count(*) FROM MobileHandledException FACET appName SINCE 3 days ago Copy Top exception locations What are most common exception locations for my application? How many exceptions do we have, and where do they occur? SELECT count(*) FROM MobileHandledException FACET exceptionLocation SINCE 3 days ago Copy Most common interaction generating exceptions Which interaction produces the most exceptions? SELECT count(*) FROM MobileHandledException FACET lastInteraction SINCE 3 days ago Copy Most common exception message What are the most common reported exception messages? SELECT count(*) FROM MobileHandledException FACET exceptionMessage SINCE 3 days ago Copy Most common method reporting exceptions What are the most common methods reporting exceptions? SELECT count(*) FROM MobileHandledException FACET exceptionLocationMethod SINCE 3 days ago Copy Handled exception rate How often are handled exceptions encountered by our users? SELECT percentage(uniqueCount(sessionId), WHERE exceptionLocation IS NOT NULL) FROM MobileSession,MobileHandledException SINCE 3 days ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.0061,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NRQL</em> <em>query</em> examples for mobile monitoring",
        "sections": "<em>NRQL</em> <em>query</em> examples for mobile monitoring",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "There are several ways to <em>query</em> <em>your</em> <em>data</em>. This document will show you some example <em>NRQL</em> queries from mobile monitoring <em>data</em>. To see descriptions of the mobile-reported events and attributes available, see Mobile events. Mobile, MobileSession, and MobileCrash event <em>query</em> examples Mobile queries"
      },
      "id": "60445a6128ccbc6b6a2c60ca"
    },
    {
      "sections": [
        "App data NRQL query examples",
        "Unique users",
        "Unique user trends",
        "Pageview trends",
        "OS version",
        "Key account Apdex"
      ],
      "title": "App data NRQL query examples",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "54b651240956896f8bdc7d9c3fbb7b6096f455a9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/app-data-nrql-query-examples/",
      "published_at": "2021-07-10T03:13:38Z",
      "updated_at": "2021-07-10T03:13:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use NRQL to query the application data collected by APM, browser monitoring, and mobile monitoring. You can then use this data to answer a variety of questions. Here are some basic examples. Unique users How many unique user sessions did you have in the last week? SELECT uniqueCount(session) FROM PageView SINCE 1 week ago Copy Unique user trends Were your unique user sessions up or down last week compared to the week before? SELECT uniqueCount(session) FROM PageView SINCE 1 week ago COMPARE WITH 1 week ago Copy Pageview trends How can I graph the number of unique users yesterday compared to the day before? SELECT count(*) FROM PageView SINCE 1 day ago COMPARE WITH 1 day ago TIMESERIES AUTO Copy OS version How many of your mobile users are on the latest OS version? SELECT uniqueCount(uuid) FROM MobileSession FACET osVersion SINCE 7 days ago Copy Key account Apdex What is the Apdex score for a particularly important customer? If you have defined some custom attributes, you can query to monitor how this customer experiences your app from a performance standpoint: SELECT apdex(duration, t: 0.4) FROM Transaction WHERE customerName='ReallyImportantCustomer' SINCE 1 day ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 391.69104,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "App <em>data</em> <em>NRQL</em> <em>query</em> examples",
        "sections": "App <em>data</em> <em>NRQL</em> <em>query</em> examples",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": "You can use <em>NRQL</em> to <em>query</em> the application <em>data</em> collected by APM, browser monitoring, and mobile monitoring. You can then use this <em>data</em> to answer a variety of questions. Here are some basic examples. Unique users How many unique user sessions did you have in the last week? SELECT uniqueCount(session"
      },
      "id": "60445a0f64441f5a46378eec"
    },
    {
      "sections": [
        "Funnels: Evaluate data from a series of related events",
        "Why it matters",
        "Funnel query structure",
        "Funnel query technical details",
        "Funnel query example"
      ],
      "title": "Funnels: Evaluate data from a series of related events",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "4a1a5a2e5f137193c1e6b5c8465d04d44d988002",
      "image": "https://docs.newrelic.com/static/84e56be2136c40fa25afb3d333cfa36e/c1b63/crop-insights-funnels.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/funnels-evaluate-data-series-related-events/",
      "published_at": "2021-07-09T22:34:58Z",
      "updated_at": "2021-07-09T22:34:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NRQL, you can use funnels to evaluate sets of related actions. The actions generally share a relationship via an identifier such as a user ID or session ID. Why it matters NRQL funnel functions can answer questions like, \"Of the people that completed step A, how many also completed step B, and of the people that completed steps A and B, how many also completed step C?\" For example, at New Relic, we could use funnel to track the number of users who completed these steps: Visited the New Relic One marketing page. Signed up for an account. Created a dashboard. Funnel query structure Here's the structure of a simple NRQL funnel query: FROM DATA_TYPE SELECT funnel(AN_ATTRIBUTE, ACTION_A, ACTION_B) SINCE TIMEFRAME Copy See also a more complex funnel query example. Funnel queries require the funnel function, an attribute to funnel, and at least two steps: The first step is the anchor step, which will always represent 100% of the results. The second and later steps describe the number of users who have also completed additional actions. This number typically will be less than 100%. However, it could be 100% if every user who completes action (A) also completes the additional actions being queried. Funnel query technical details One way to use funnel queries is to calculate the rate at which multi-step, ordered sequences were completed over a given timeframe, like in the New Relic One signup example. But you can also use funnels to calculate overlap between several distinct actions that don't have a sequential relationship to one another. In other words, the order of steps doesn't impact the calculations performed. The way funnel queries compute results varies depending on the size of the data set: If the funnel is dealing with 256 funnel attribute values or fewer, it will calculate the value exactly. If it's dealing with more than 256 funnel attribute values, it applies an algorithm called MinHash to calculate approximate results for optimized performance. This means that for large data sets, there may be occasional \"false positives\" at the level of individual data points. These do not interfere greatly with the accuracy of the numerical estimates provided in query results. Here's a detailed breakdown of technical details and constraints for funnel queries. Technical details Comments Order of steps The order of steps completed is not enforced and does not impact results. Attributes You can only run funnel queries on one attribute at a time. Unique values For funnel queries that involve more than 256 unique funnel attribute values, the results are approximate. Maximum steps You can have a maximum of 10 steps within a single funnel query. Funnel query example This example queries the browser monitoring PageView event and its attributes. It queries unique browser sessions that have progressed from registration to account upgrades. Labels are included for each step, indicated by the keyword AS. FROM PageView SELECT funnel(session, WHERE pageUrl='http://www.storefront.com/signup' AS 'Email Sign Up', WHERE pageUrl='http://www.appproduction.com/basic_feature' AS 'Feature Compare', WHERE pageUrl='http://www.appproduction.com/advanced_feature/upgrade' AS 'Upgraded Account') SINCE 12 hours ago Copy This query returns the following: An example NRQL funnel query that displays a count of the users who registered for an account, visited a feature-compare page, and upgraded. Include additional actions inside the parentheses of the funnel function in a comma separated list: SELECT funnel(session, WHERE name='Controller/about/main' AS 'Action A', WHERE name = 'Controller/about/careers' AS 'Action B', WHERE name = 'Controller/about/insights' AS 'Action C', WHERE name = 'Controller/about/apply' AS 'Action D') FROM PageView SINCE 1 week ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 387.299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Funnels: Evaluate <em>data</em> from a series of related events",
        "sections": "Funnels: Evaluate <em>data</em> from a series of related events",
        "tags": "<em>NRQL</em>: <em>New</em> <em>Relic</em> <em>Query</em> <em>Language</em>",
        "body": ", and of the people that completed steps A and B, how many also completed step C?&quot; For example, at <em>New</em> <em>Relic</em>, we could use funnel to track the number of users who completed these steps: Visited the <em>New</em> <em>Relic</em> One marketing page. Signed up for an account. Created a dashboard. Funnel <em>query</em> structure Here"
      },
      "id": "6044371428ccbcc3fb2c60cd"
    }
  ]
}