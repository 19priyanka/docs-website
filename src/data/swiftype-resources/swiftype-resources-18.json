{
  "/docs/serverless-function-monitoring/aws-lambda-monitoring/ui-data/understand-lambda-data-structure": [
    {
      "sections": [
        "Understand the Lambda monitoring UI",
        "View your data",
        "Important",
        "UI pages",
        "Understand chart data"
      ],
      "title": "Understand the Lambda monitoring UI",
      "type": "docs",
      "tags": [
        "Serverless function monitoring",
        "AWS Lambda monitoring",
        "UI and data"
      ],
      "external_id": "45a6a881de05bcb4814f7f25f2bfa1632257a7f1",
      "image": "https://docs.newrelic.com/static/17e88e0171bc6b4358292daf4ddf7cf4/c1b63/new-relic-lambda-entities-screenshot_0.png",
      "url": "https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/ui-data/understand-lambda-monitoring-ui/",
      "published_at": "2021-12-25T18:02:57Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Serverless monitoring for AWS Lambda offers in-depth performance monitoring for your Lambda functions. This document explains how to: Find your Lambda data in the UI Understand the UI components Understand your chart data How to create custom charts View your data one.newrelic.com> Explorer > Amazon Web Services > Lambda functions: Click Lambda functions to see charts and details. To view your Lambda data in New Relic: Go to one.newrelic.com, click Explorer. In the left nav under Amazon Web Services, click Lambda functions. For more about our UI, see Intro to New Relic One. Important If you can't find your Lambda data: Ensure you've followed the instructions for enabling Lambda monitoring. Note that this feature is different from our infrastructure monitoring Lambda integration. UI pages Here are descriptions of the UI pages available for our Lambda monitoring: UI page Functionality Summary The Summary page displays charts that give you a quick view into the most important performance data. If available, this will feature data gathered from APM agent instrumentation. CloudWatch metrics The CloudWatch metrics page displays Lambda data that comes from AWS CloudWatch. Charts include: invocation counts, duration, throttles, and error counts. Distributed tracing The Distributed tracing page shows distributed traces that include the monitored Lambda function. For details about this feature, see Distributed tracing. Errors The Errors page displays errors (AwsLambdaInvocationError events). You can filter by error rate, error percentage, or error class. You can drill down into errors and see attributes and, if available, stack traces. Invocations The Invocations page lets you filter your invocations by attribute, and view duration, throughput, external calls, and invocation breakdowns. About invocation breakdowns: Some invocations will generate a breakdown if distributed tracing is enabled during instrumentation. Breakdowns are sampled; approximately 10% of invocations generate a breakdown. This sampling rate may be higher, depending on upstream sampling decisions. Logs The Logs page displays recent log messages from your Lambda function. For details about this feature, see Logs. Understand chart data Lambda data charts are generated by running NRQL queries of Lambda-related event data. Reasons to view a chart's NRQL query include: To better understand what a chart is displaying To get ideas on how to create a custom NRQL query and chart Related documentation: Learn how to view a chart's query. Learn about Lambda data storage and structure.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.30571,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Understand the <em>Lambda</em> <em>monitoring</em> <em>UI</em>",
        "sections": "Understand the <em>Lambda</em> <em>monitoring</em> <em>UI</em>",
        "tags": "<em>Serverless</em> <em>function</em> <em>monitoring</em>",
        "body": "<em>Serverless</em> <em>monitoring</em> for <em>AWS</em> <em>Lambda</em> offers in-depth performance <em>monitoring</em> for your <em>Lambda</em> functions. This document explains how to: Find your <em>Lambda</em> <em>data</em> in the <em>UI</em> Understand the <em>UI</em> components Understand your chart <em>data</em> How to create custom charts View your <em>data</em> one.newrelic.com&gt; Explorer"
      },
      "id": "603eb10f196a67c65da83da2"
    },
    {
      "sections": [
        "Lambda monitoring architecture",
        "The New Relic Lambda monitoring stack",
        "Your function",
        "New Relic agent or SDK",
        "New Relic Lambda Extension",
        "New Relic's backend",
        "Lambda UI in New Relic One",
        "The legacy CloudWatch path"
      ],
      "title": "Lambda monitoring architecture",
      "type": "docs",
      "tags": [
        "Serverless function monitoring",
        "AWS Lambda monitoring",
        "Background",
        "Architecture"
      ],
      "external_id": "61c238aabc54923ed6f7d08d9a0cc111193f72a3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/get-started/architecture/",
      "published_at": "2021-12-25T17:48:40Z",
      "updated_at": "2021-12-05T04:36:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Lambda monitoring stack There are several important parts to Lambda monitoring: Your function The New Relic agent or SDK The New Relic Lambda Extension New Relic's backend The New Relic One Lambda UI Your function Your function is the code you want to understand. You want to know when it's encountering errors, why it's slow, or how often it gets invoked. New Relic agent or SDK This is a library that New Relic provides for the language that your function is written in. Its job is to do the actual monitoring of your code. It measures the duration of your function invocations, notes errors that occur, records details about the source events, and your functions responses. To do this, it needs to wrap around your Lambda invocation handler function. With a bit more work on your part, you can break your invocation into interesting segments, and tie together the interaction of your function with other functions and services, providing a holistic view of your serverless application. New Relic Lambda Extension This sidecar process runs inside the Lambda execution environment, alongside your code. It enhances the telemetry that the agent collects, and sends it to New Relic's back end in batches. It can also send your function's logs to New Relic. The extension is a small application that integrates tightly with the AWS Lambda lifecycle, and works to minimize both the time it takes your telemetry to arrive at New Relic, and the impact that instrumentation has on your function's latency and throughput. See more about our Lambda extension. New Relic's backend The New Relic service receives your telemetry, processes it into AwsLambdaInvocation, AwsLambdaInvocationError, Span, and custom events, and stores all that in our telemetry database: NRDB. Lambda UI in New Relic One Lambda functions aren't quite like traditional services, so the experience of managing them is a little different from the classic APM experience. Inside New Relic One, Lambda functions have a custom UI, which quickly surfaces the most important information about your function, and integrates closely with our logging and distributed tracing features. Backed by NRDB and NRQL, you can also write custom dashboards and alerts for your functions. The legacy CloudWatch path Older integrations send telemetry in a slightly different way. Instead of passing telemetry off to the extension, the agent writes it out to CloudWatch as a log line. By adding a log subscription filter to pipe your function logs into the aws-log-ingestion Lambda function, we can recover that Cloudwatch log line, and forward it on to New Relic, along with some other platform telemetry. In the past, we've seen that this approach has some considerable drawbacks. The AWS CloudWatch service can generate a lot of data. If you're on the free tier, you may hit your data limit pretty quickly. If you're paying for data, you may find this service making up the largest share of the data you're sending to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.85748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Lambda</em> <em>monitoring</em> architecture",
        "sections": "<em>Lambda</em> <em>monitoring</em> architecture",
        "tags": "<em>Serverless</em> <em>function</em> <em>monitoring</em>",
        "body": "The New Relic <em>Lambda</em> <em>monitoring</em> stack There are several important parts to <em>Lambda</em> <em>monitoring</em>: Your <em>function</em> The New Relic agent or SDK The New Relic <em>Lambda</em> Extension New Relic&#x27;s backend The New Relic One <em>Lambda</em> <em>UI</em> Your <em>function</em> Your <em>function</em> is the code you want to understand. You want to know when"
      },
      "id": "605ab190196a67fc8238d740"
    },
    {
      "sections": [
        "Monitoring AWS Lambda with Serverless monitoring",
        "Why it matters",
        "Access and requirements",
        "Next steps: Enable and use Lambda monitoring"
      ],
      "title": "Monitoring AWS Lambda with Serverless monitoring",
      "type": "docs",
      "tags": [
        "Serverless function monitoring",
        "AWS Lambda monitoring",
        "Get started"
      ],
      "external_id": "5d1d86ec786398b3190ed1a6e152373e0547dc57",
      "image": "",
      "url": "https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/get-started/monitoring-aws-lambda-serverless-monitoring/",
      "published_at": "2021-12-25T17:49:22Z",
      "updated_at": "2021-09-14T18:21:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We offer in-depth performance monitoring for your serverless AWS Lambda functions. Read on to learn about the feature, how it works, and its requirements. This Lambda monitoring feature is not the same as the Lambda monitoring integration, which only uses CloudWatch data. Serverless Lambda monitoring is more extensive and uses both CloudWatch data and code-level instrumentation to deliver more in-depth monitoring. Why it matters Do you need to rapidly instrument monitoring and observability to your serverless functions without resorting to code changes? Our Lambda layer provides unified visibility into the most detailed behaviors of your Lambda functions so you can understand what's going on in your serverless applications. Use all this information to troubleshoot your systems and optimize your functions so they can function faster and deliver with confidence on serverless architectures. Spend less time instrumenting, and more time building. Lambda monitoring gives you: Every invocation of your Lambda functions, including performance data like detailed duration, cold starts, exceptions, and tracebacks. AWS Lambda event source information, which provides context and attributes about events that triggered each AWS Lambda invocation, such as API Gateway, ALB SNS, SQS, DynamoDB, and more. Visibility into your entire ecosystem with distributed tracing: see the path of requests that led to your Lambda, and see Lambda spans in your other distributed traces. Logs in context, which provides full invocation and function level logs right along side the metrics, attributes, and trace data. Inventoried tags and metadata. We retrieve information from your AWS entities, giving you the ability to filter and facet down to the team, or specific metadata attributes on the function configuration or invocation itself. Easy ability to query your data with an automatic facet builder, which instantly facets your dashboards and charts by attribute or function to explore custom data, without having to write queries. Lambda data is displayed in its own dedicated UI in New Relic One. Access and requirements See Compatibility and requirements of AWS Lambda monitoring. Next steps: Enable and use Lambda monitoring To get started using our Lambda monitoring, see the installation and enablement instructions. To better understand how Lambda monitoring works, read about the New Relic Lambda monitoring stack. You can also set up alerts or add your own custom events or attributes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.65013,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitoring</em> <em>AWS</em> <em>Lambda</em> with <em>Serverless</em> <em>monitoring</em>",
        "sections": "<em>Monitoring</em> <em>AWS</em> <em>Lambda</em> with <em>Serverless</em> <em>monitoring</em>",
        "tags": "<em>Serverless</em> <em>function</em> <em>monitoring</em>",
        "body": "We offer in-depth performance <em>monitoring</em> for your <em>serverless</em> <em>AWS</em> <em>Lambda</em> functions. Read on to learn about the feature, how it works, and its requirements. This <em>Lambda</em> <em>monitoring</em> feature is not the same as the <em>Lambda</em> <em>monitoring</em> integration, which only uses CloudWatch <em>data</em>. <em>Serverless</em> <em>Lambda</em>"
      },
      "id": "603eb08b28ccbc8b90eba75c"
    }
  ],
  "/docs/serverless-function-monitoring/aws-lambda-monitoring/ui-data/understand-lambda-monitoring-ui": [
    {
      "sections": [
        "Understand the Lambda data structure",
        "Sources of Lambda data",
        "Event definitions and attributes"
      ],
      "title": "Understand the Lambda data structure",
      "type": "docs",
      "tags": [
        "Serverless function monitoring",
        "AWS Lambda monitoring",
        "UI and data"
      ],
      "external_id": "07406ff52f251eb6195f76d730e30615828cb734",
      "image": "",
      "url": "https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/ui-data/understand-lambda-data-structure/",
      "published_at": "2021-12-25T17:49:59Z",
      "updated_at": "2021-03-16T18:11:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our serverless monitoring for AWS Lambda offers in-depth performance monitoring for your Lambda functions. This document will explain the source, structure, and storage of your Lambda data. Sources of Lambda data Our Lambda monitoring data comes from these two sources: Our APM agent instrumentation (or similar customer-created instrumentation) AWS CloudWatch metrics For details on how this data is configured and how it flows to New Relic, see the enablement procedures. The data displayed in the UI is a combination of these data sources. For example, the Overview page displays data reported by instrumentation, while the Metrics page displays CloudWatch data. Event definitions and attributes Lambda data is stored in our database (NRDB) as events (data objects with associated attributes). Lambda data is attached to the following event types. Select an event name to see its attributes. AwsLambdaInvocation event: Captures overall timing and associated metadata. A Lambda invocation generates a single AwsLambdaInvocation event. AwsLambdaInvocationError event: If an error occurs during a Lambda, this event will be generated. Span: This includes detail about a segment of a Lambda function. Spans are used for distributed tracing. Distributed tracing relies on data sampling; 10% of invocations are sampled to generate spans. Custom event types: With some agent APIs, custom events can be created and associated with a particular Lambda invocation, and then queried with NRQL. For more about limits on event storage, see Access and requirements.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.50525,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Understand the <em>Lambda</em> <em>data</em> structure",
        "sections": "Understand the <em>Lambda</em> <em>data</em> structure",
        "tags": "<em>Serverless</em> <em>function</em> <em>monitoring</em>",
        "body": "Our <em>serverless</em> <em>monitoring</em> for <em>AWS</em> <em>Lambda</em> offers in-depth performance <em>monitoring</em> for your <em>Lambda</em> functions. This document will explain the source, structure, and storage of your <em>Lambda</em> <em>data</em>. Sources of <em>Lambda</em> <em>data</em> Our <em>Lambda</em> <em>monitoring</em> <em>data</em> comes from these two sources: Our APM agent instrumentation"
      },
      "id": "603eb0c8e7b9d24b202a0820"
    },
    {
      "sections": [
        "Lambda monitoring architecture",
        "The New Relic Lambda monitoring stack",
        "Your function",
        "New Relic agent or SDK",
        "New Relic Lambda Extension",
        "New Relic's backend",
        "Lambda UI in New Relic One",
        "The legacy CloudWatch path"
      ],
      "title": "Lambda monitoring architecture",
      "type": "docs",
      "tags": [
        "Serverless function monitoring",
        "AWS Lambda monitoring",
        "Background",
        "Architecture"
      ],
      "external_id": "61c238aabc54923ed6f7d08d9a0cc111193f72a3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/get-started/architecture/",
      "published_at": "2021-12-25T17:48:40Z",
      "updated_at": "2021-12-05T04:36:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Lambda monitoring stack There are several important parts to Lambda monitoring: Your function The New Relic agent or SDK The New Relic Lambda Extension New Relic's backend The New Relic One Lambda UI Your function Your function is the code you want to understand. You want to know when it's encountering errors, why it's slow, or how often it gets invoked. New Relic agent or SDK This is a library that New Relic provides for the language that your function is written in. Its job is to do the actual monitoring of your code. It measures the duration of your function invocations, notes errors that occur, records details about the source events, and your functions responses. To do this, it needs to wrap around your Lambda invocation handler function. With a bit more work on your part, you can break your invocation into interesting segments, and tie together the interaction of your function with other functions and services, providing a holistic view of your serverless application. New Relic Lambda Extension This sidecar process runs inside the Lambda execution environment, alongside your code. It enhances the telemetry that the agent collects, and sends it to New Relic's back end in batches. It can also send your function's logs to New Relic. The extension is a small application that integrates tightly with the AWS Lambda lifecycle, and works to minimize both the time it takes your telemetry to arrive at New Relic, and the impact that instrumentation has on your function's latency and throughput. See more about our Lambda extension. New Relic's backend The New Relic service receives your telemetry, processes it into AwsLambdaInvocation, AwsLambdaInvocationError, Span, and custom events, and stores all that in our telemetry database: NRDB. Lambda UI in New Relic One Lambda functions aren't quite like traditional services, so the experience of managing them is a little different from the classic APM experience. Inside New Relic One, Lambda functions have a custom UI, which quickly surfaces the most important information about your function, and integrates closely with our logging and distributed tracing features. Backed by NRDB and NRQL, you can also write custom dashboards and alerts for your functions. The legacy CloudWatch path Older integrations send telemetry in a slightly different way. Instead of passing telemetry off to the extension, the agent writes it out to CloudWatch as a log line. By adding a log subscription filter to pipe your function logs into the aws-log-ingestion Lambda function, we can recover that Cloudwatch log line, and forward it on to New Relic, along with some other platform telemetry. In the past, we've seen that this approach has some considerable drawbacks. The AWS CloudWatch service can generate a lot of data. If you're on the free tier, you may hit your data limit pretty quickly. If you're paying for data, you may find this service making up the largest share of the data you're sending to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.85748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Lambda</em> <em>monitoring</em> architecture",
        "sections": "<em>Lambda</em> <em>monitoring</em> architecture",
        "tags": "<em>Serverless</em> <em>function</em> <em>monitoring</em>",
        "body": "The New Relic <em>Lambda</em> <em>monitoring</em> stack There are several important parts to <em>Lambda</em> <em>monitoring</em>: Your <em>function</em> The New Relic agent or SDK The New Relic <em>Lambda</em> Extension New Relic&#x27;s backend The New Relic One <em>Lambda</em> <em>UI</em> Your <em>function</em> Your <em>function</em> is the code you want to understand. You want to know when"
      },
      "id": "605ab190196a67fc8238d740"
    },
    {
      "sections": [
        "Monitoring AWS Lambda with Serverless monitoring",
        "Why it matters",
        "Access and requirements",
        "Next steps: Enable and use Lambda monitoring"
      ],
      "title": "Monitoring AWS Lambda with Serverless monitoring",
      "type": "docs",
      "tags": [
        "Serverless function monitoring",
        "AWS Lambda monitoring",
        "Get started"
      ],
      "external_id": "5d1d86ec786398b3190ed1a6e152373e0547dc57",
      "image": "",
      "url": "https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/get-started/monitoring-aws-lambda-serverless-monitoring/",
      "published_at": "2021-12-25T17:49:22Z",
      "updated_at": "2021-09-14T18:21:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We offer in-depth performance monitoring for your serverless AWS Lambda functions. Read on to learn about the feature, how it works, and its requirements. This Lambda monitoring feature is not the same as the Lambda monitoring integration, which only uses CloudWatch data. Serverless Lambda monitoring is more extensive and uses both CloudWatch data and code-level instrumentation to deliver more in-depth monitoring. Why it matters Do you need to rapidly instrument monitoring and observability to your serverless functions without resorting to code changes? Our Lambda layer provides unified visibility into the most detailed behaviors of your Lambda functions so you can understand what's going on in your serverless applications. Use all this information to troubleshoot your systems and optimize your functions so they can function faster and deliver with confidence on serverless architectures. Spend less time instrumenting, and more time building. Lambda monitoring gives you: Every invocation of your Lambda functions, including performance data like detailed duration, cold starts, exceptions, and tracebacks. AWS Lambda event source information, which provides context and attributes about events that triggered each AWS Lambda invocation, such as API Gateway, ALB SNS, SQS, DynamoDB, and more. Visibility into your entire ecosystem with distributed tracing: see the path of requests that led to your Lambda, and see Lambda spans in your other distributed traces. Logs in context, which provides full invocation and function level logs right along side the metrics, attributes, and trace data. Inventoried tags and metadata. We retrieve information from your AWS entities, giving you the ability to filter and facet down to the team, or specific metadata attributes on the function configuration or invocation itself. Easy ability to query your data with an automatic facet builder, which instantly facets your dashboards and charts by attribute or function to explore custom data, without having to write queries. Lambda data is displayed in its own dedicated UI in New Relic One. Access and requirements See Compatibility and requirements of AWS Lambda monitoring. Next steps: Enable and use Lambda monitoring To get started using our Lambda monitoring, see the installation and enablement instructions. To better understand how Lambda monitoring works, read about the New Relic Lambda monitoring stack. You can also set up alerts or add your own custom events or attributes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.65013,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitoring</em> <em>AWS</em> <em>Lambda</em> with <em>Serverless</em> <em>monitoring</em>",
        "sections": "<em>Monitoring</em> <em>AWS</em> <em>Lambda</em> with <em>Serverless</em> <em>monitoring</em>",
        "tags": "<em>Serverless</em> <em>function</em> <em>monitoring</em>",
        "body": "We offer in-depth performance <em>monitoring</em> for your <em>serverless</em> <em>AWS</em> <em>Lambda</em> functions. Read on to learn about the feature, how it works, and its requirements. This <em>Lambda</em> <em>monitoring</em> feature is not the same as the <em>Lambda</em> <em>monitoring</em> integration, which only uses CloudWatch <em>data</em>. <em>Serverless</em> <em>Lambda</em>"
      },
      "id": "603eb08b28ccbc8b90eba75c"
    }
  ],
  "/docs/serverless-function-monitoring/index": [
    {
      "sections": [
        "Compatibility and requirements of AWS Lambda monitoring",
        "Recommended AWS Lambda language runtimes",
        "About AWS costs"
      ],
      "title": "Compatibility and requirements of AWS Lambda monitoring",
      "type": "docs",
      "tags": [
        "Serverless function monitoring",
        "AWS Lambda monitoring",
        "Get started"
      ],
      "external_id": "067a3685f16418cb4e6df1477a9584edeed006f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/get-started/compatibility-requirements-aws-lambda-monitoring/",
      "published_at": "2021-12-25T17:49:22Z",
      "updated_at": "2021-09-02T16:45:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before enabling serverless monitoring for AWS Lambda, make sure you meet the requirements and learn about AWS charges resulting from its use. Recommended AWS Lambda language runtimes NodeJS: nodejs12.x, nodejs14.x Python: python3.7, python3.8, python3.9 Go: provided, provided.al2 Java: java8.al2, java11 .NET Core: dotnetcore3.1 AWS has older runtimes for these languages as well, but AWS has not chosen to support the latest Lambda APIs with those older runtimes. Integration for older runtimes requires a different strategy, but is possible. Python and NodeJS are by far the most popular languages in the Lambda ecosystem. The New Relic Lambda Layers for Node and Python include the very latest New Relic Agent version, and provide rich instrumentation with minimal configuration, right out of the box. Similarly, Go uses the New Relic Go Agent. We recommend building self-hosting Go lambda functions, because the latest AWS Lambda APIs are not supported in the AWS go1.x runtime. Fortunately, this is well supported by the AWS Lambda SDK for Go. New Relic recommends keeping the agent module up to date. Support is limited for agent versions older than 3.9.0. To minimize performance impact, we've taken a different approach with Java and .NET Core. New Relic provides OpenTelemetry SDKs for these runtimes. This approach requires a bit more code to integrate. For complete Lambda instrumentation, some of our agents included in our Lambda layers depend on a language-specific AWS SDK. If an AWS SDK is not used, Lambda data will appear as external service calls in the UI, with minimal detail. In other words, we rely on the AWS SDK to facilitate instrumentation of your function. For the following services, only the \"target\" (Lambda function name, SNS topic ARN, DynamoDB table name, etc.) is reported: Autoscaling, Athena, Batch, Cloud9, CodeBuild, DynamoDB, Greengrass, IoT, Kinesis (Streams, Firehose, Analytics, Video), Lambda, Lex, Machine Learning, MQ, Redshift, Rekognition, S3, SES, SimpleDB, SNS, SQS, Storage Gateway, and STS. About AWS costs Enabling serverless monitoring for AWS Lambda may result in Amazon Web Services charges. Our newrelic-log-ingestion Lambda function, which reports your Lambda data to us, is considered a Third Party Service: AWS charges resulting from your use of it are your responsibility. If you use the Lambda Extension, you can avoid the CloudWatch Logs ingest charge for the telemetry gathered by New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.08984,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements of AWS Lambda <em>monitoring</em>",
        "sections": "Compatibility and requirements of AWS Lambda <em>monitoring</em>",
        "tags": "<em>Serverless</em> function <em>monitoring</em>",
        "body": "Before enabling <em>serverless</em> <em>monitoring</em> for AWS Lambda, make sure you meet the requirements and learn about AWS charges resulting from its use. Recommended AWS Lambda language runtimes NodeJS: nodejs12.x, nodejs14.x Python: python3.7, python3.8, python3.9 Go: provided, provided.al2 Java: java8.al2"
      },
      "id": "603e98bd64441ff7454e8885"
    },
    {
      "sections": [
        "Lambda monitoring architecture",
        "The New Relic Lambda monitoring stack",
        "Your function",
        "New Relic agent or SDK",
        "New Relic Lambda Extension",
        "New Relic's backend",
        "Lambda UI in New Relic One",
        "The legacy CloudWatch path"
      ],
      "title": "Lambda monitoring architecture",
      "type": "docs",
      "tags": [
        "Serverless function monitoring",
        "AWS Lambda monitoring",
        "Background",
        "Architecture"
      ],
      "external_id": "61c238aabc54923ed6f7d08d9a0cc111193f72a3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/get-started/architecture/",
      "published_at": "2021-12-25T17:48:40Z",
      "updated_at": "2021-12-05T04:36:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Lambda monitoring stack There are several important parts to Lambda monitoring: Your function The New Relic agent or SDK The New Relic Lambda Extension New Relic's backend The New Relic One Lambda UI Your function Your function is the code you want to understand. You want to know when it's encountering errors, why it's slow, or how often it gets invoked. New Relic agent or SDK This is a library that New Relic provides for the language that your function is written in. Its job is to do the actual monitoring of your code. It measures the duration of your function invocations, notes errors that occur, records details about the source events, and your functions responses. To do this, it needs to wrap around your Lambda invocation handler function. With a bit more work on your part, you can break your invocation into interesting segments, and tie together the interaction of your function with other functions and services, providing a holistic view of your serverless application. New Relic Lambda Extension This sidecar process runs inside the Lambda execution environment, alongside your code. It enhances the telemetry that the agent collects, and sends it to New Relic's back end in batches. It can also send your function's logs to New Relic. The extension is a small application that integrates tightly with the AWS Lambda lifecycle, and works to minimize both the time it takes your telemetry to arrive at New Relic, and the impact that instrumentation has on your function's latency and throughput. See more about our Lambda extension. New Relic's backend The New Relic service receives your telemetry, processes it into AwsLambdaInvocation, AwsLambdaInvocationError, Span, and custom events, and stores all that in our telemetry database: NRDB. Lambda UI in New Relic One Lambda functions aren't quite like traditional services, so the experience of managing them is a little different from the classic APM experience. Inside New Relic One, Lambda functions have a custom UI, which quickly surfaces the most important information about your function, and integrates closely with our logging and distributed tracing features. Backed by NRDB and NRQL, you can also write custom dashboards and alerts for your functions. The legacy CloudWatch path Older integrations send telemetry in a slightly different way. Instead of passing telemetry off to the extension, the agent writes it out to CloudWatch as a log line. By adding a log subscription filter to pipe your function logs into the aws-log-ingestion Lambda function, we can recover that Cloudwatch log line, and forward it on to New Relic, along with some other platform telemetry. In the past, we've seen that this approach has some considerable drawbacks. The AWS CloudWatch service can generate a lot of data. If you're on the free tier, you may hit your data limit pretty quickly. If you're paying for data, you may find this service making up the largest share of the data you're sending to New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 284.5426,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Lambda <em>monitoring</em> architecture",
        "sections": "Lambda <em>monitoring</em> architecture",
        "tags": "<em>Serverless</em> function <em>monitoring</em>",
        "body": "The New Relic Lambda <em>monitoring</em> stack There are several important parts to Lambda <em>monitoring</em>: Your function The New Relic agent or SDK The New Relic Lambda Extension New Relic&#x27;s backend The New Relic One Lambda UI Your function Your function is the code you want to understand. You want to know when"
      },
      "id": "605ab190196a67fc8238d740"
    },
    {
      "sections": [
        "Get started with New Relic observability",
        "Get your data into New Relic",
        "All the answers in one place",
        "Troubleshoot from anywhere in your stack"
      ],
      "title": "Get started with New Relic observability",
      "type": "docs",
      "tags": [
        "Observe everything",
        "Get started"
      ],
      "external_id": "30f87d5f702f926efec49b59591679fa93627ad5",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability-2.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/get-started-full-stack-observability/",
      "published_at": "2021-12-25T19:49:49Z",
      "updated_at": "2021-12-15T12:41:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "True observability is the power of knowing what's happening across your digital system and why it's happening—at any time, whatever solution you’re using. It’s getting the whole picture of everything that enables your applications and devices to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Our platform goes beyond simple monitoring by offering you observability: data insights to help you make proactive and predictive improvements to your environment. A comparison between simple monitoring and observability. Get your data into New Relic New Relic I/O is a rich catalog of open source quickstarts - out-of-the-box bundles of integrations, dashboards, and alerts. Each quickstart is created by observability experts around the world, vetted by New Relic, and ready for you to install with one click. Leverage community expertise and get more value out of your telemetry data with New Relic I/O, your hub for instant observability. Ready to get started? Find your quickstart in New Relic I/O: New Relic I/O Alternatively, if you're comfortable with the command line, our guided install discovers the applications, infrastructure, and log sources running in your environment, and recommends which ones should be instrumented. The install automates the configuration and deployment of each system you choose to instrument. Guided install EU Guided install If your account reports data through our EU data center, click EU Guided install. All the answers in one place Once your data is in New Relic, we give you a UI with tools to cut through the layers of complexity surrounding your systems. This is all in one platform so you don't need to switch between diagnostic applications. You can interrogate your data for patterns, discover them using our data platform, or get proactive results from our machine learning tools. As a full platform user you get access to our entire set of observability tools. All our tools are interconnected and accessible in New Relic One. All the data you bring to New Relic through agents and integrations are metrics, events, logs, and traces that feed our platform's analytics and monitoring capabilities. New Relic links your data in a meaningful way so that you can explore it, build dashboards, and set up alerts. Our out-of-the-box observability UI experiences allow to visualize, analyze, and troubleshoot your entire software stack in one unified platform. The New Relic Explorer consolidates all the entities in your system, and how they're connected, in a single place, so you can easily detect performance trends and issues. By automatically connecting infrastructure health with application performance and end-user behavior, you can cut through the noise to find useful signals. Troubleshoot from anywhere in your stack Being fully-connected, the New Relic UI allows you to start your observability journey from any element of your stack. For example, you can get to crucial infrastructure logs from traces of an application running on a problematic Kubernetes pod. Use the Explorer in New Relic One to access and observe the full stack of your software, see performance data and alerting status at a glance, and check relationships. We provide you with a simple, yet powerful visual tool to monitor all your entities, that is, anything we can identify that reports data. In the New Relic ecosystem, entities include basic components like applications, hosts, containers, or database services, but it can also refer to custom groupings of such elements. You can also create your own entities. The more entities you instrument, the more data you'll bring in. The more data you've brought to New Relic, the more you'll understand your metrics, events, logs, and traces. Here are some examples of UI paths you might follow to drill into your data: You want to instrument... Start with Keep exploring Front-end applications Mobile applications User behavior and flows New Relic Explorer Browser monitoring Mobile monitoring Synthetic monitoring Single page monitoring Scripted browsers Containerized minions Workloads Backend applications Serverless applications New Relic Explorer Application monitoring Serverless monitoring Learning about Apdex Distributed tracing Logs in context APM data to infrastructure Workloads Infrastructure hosts and services (on-premise, cloud, orchestrated) Container environments and orchestration tools (Kubernetes, ECS, etc.) Infrastructure monitoring Infrastructure integrations Kubernetes integration Docker integration ECS integration Log forwarding APM data to infrastructure Custom integrations Kubernetes cluster explorer Infrastructure alerts Workloads",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 271.72815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "... Start with Keep exploring Front-end applications Mobile applications User behavior and flows New Relic Explorer Browser <em>monitoring</em> Mobile <em>monitoring</em> Synthetic <em>monitoring</em> Single page <em>monitoring</em> Scripted browsers Containerized minions Workloads Backend applications <em>Serverless</em> applications New"
      },
      "id": "61743c6764441f60375fd317"
    }
  ],
  "/docs/service-level-management/consume-slm": [
    {
      "sections": [
        "Service Levels Management: Questions and next steps",
        "BETA FEATURE",
        "What permissions do I need to use New Relic's Service Levels?",
        "How do I get support from New Relic during the public beta?",
        "Why don’t I see any data right after I create an SLI?",
        "Can I configure an SLI on any entity type?",
        "Can I get alerts on SLI data?",
        "How does New Relic calculate the remaining error budget?",
        "How can I view the queries that define an SLI from the UI?",
        "How can I view the queries that define an SLI through the API?",
        "Can I chart the SLI attainment on a dashboard?"
      ],
      "title": "Service Levels Management: Questions and next steps",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started",
        "Service Level Management"
      ],
      "external_id": "262058f4dc430fbaee0382261f79de147e348f53",
      "image": "https://docs.newrelic.com/static/763695119ceaa7668fdb3fb858c83c75/c1b63/slm_edit_menu_2.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/faqs-slm/",
      "published_at": "2021-12-25T02:33:00Z",
      "updated_at": "2021-12-25T02:33:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic's Service Levels? To use New Relic's Service Levels and see SLO results, you need a full platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify events to metric rules. If you get the following errors, check your user permissions: The UI has disabled the option to save an SLI/SLO. The API returns the error message “Cannot query field \\\"eventExportRegisterRule\\\" on type \\\"RootMutationType\\\".”. How do I get support from New Relic during the public beta? Service Levels Management is in public beta, and no official support is offered yet through the Support portal. If you have general questions and feedback, please post them on the Explorers Hub. New Relic’s community and the product team will be glad to help you there. If you have suggestions about documentation, please suggest an improvement or send your contribution using the Create issue or Edit page buttons on the top right corner in the docs UI. Why don’t I see any data right after I create an SLI? New Relic starts generating new SLI metrics from the moment that you create an SLI. This is why we need a few minutes before we can start showing the first meaningful SLI attainment results. The benefit of the new data is that it has 13 month retention by default, and it’s more efficient to query for long periods of time. Can I configure an SLI on any entity type? Yes, you can configure an SLI on any entity type, such as an APM service, a browser application, or a Lambda function. SLI queries support NRDB events. Support for dimensional metrics on SLI queries is on our roadmap. Can I get alerts on SLI data? Alerts on New Relic's Service Levels are on our roadmap. How does New Relic calculate the remaining error budget? The remaining error budget indicates what percentage of requests could still have a bad response over the SLO period without compromising the objective. Therefore, the total amount of tolerated bad responses will vary with the throughput of requests. Time-based error budgets are on our roadmap. How can I view the queries that define an SLI from the UI? To view the queries that define an SLI, you can click on the ... menu on the SLI summary card, then select the Edit option. The queries will show at the top-right corner. How can I view the queries that define an SLI through the API? To view the queries that define an SLI through the API, use Nerdgraph. In order to view the SLI configuration, you'll need to know the GUID of the entity the SLI is attached to, and replace it in the following query: { actor { entity(guid: \"{entityGuid}\") { serviceLevel { indicators { events { badEvents { where from } goodEvents { from where } validEvents { from where } } name } } } } } Copy As a response you are going to receive all the SLIs attached to the entity, the SLI name, and the queries. Keep in mind that either goodEvents or badEvents is going to have content, depending on the configuration of the SLI. Can I chart the SLI attainment on a dashboard? You can chart SLI attainment time series on your custom dashboards using the following query: FROM Metric SELECT clamp_max((count(newrelic.sli.valid) - count(newrelic.sli.bad)) / count(newrelic.sli.valid) * 100, 100) as 'SLI attainment' WHERE sli.id = '<sli.id>' UNTIL 2 MINUTES AGO TIMESERIES AUTO Copy Where sli.id is the SLI identifier. The easiest way to add a chart like this to your dashboard is by using the Add to dashboard option, available on the Details view. Alternatively, you can find the SLI id and SLI attainment query through the Nerdgraph API with the following query: { actor { entity(guid: \"{entityGuid}\") { serviceLevel { indicators { name id resultQueries { indicator { nrql } } } } } } } Copy Use the entityGuid of the entity that's associated with the SLI. On the query results, you’ll get the SLI id in the serviceLevel.indicators.id field.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 590.9623,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Service</em> <em>Levels</em> <em>Management</em>: Questions and next steps",
        "sections": "<em>Service</em> <em>Levels</em> <em>Management</em>: Questions and next steps",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic&#x27;s <em>Service</em> Levels? To use New Relic&#x27;s <em>Service</em> Levels and see <em>SLO</em> results, you need a <em>full</em> platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify"
      },
      "id": "61ab3a9d28ccbc492ac23ee2"
    },
    {
      "sections": [
        "Configure Service Levels via the NerdGraph API",
        "BETA FEATURE",
        "Important",
        "Create an SLI with an SLO",
        "Retrieve the configuration of an SLI for an APM service",
        "Update the SLOs of an SLI"
      ],
      "title": "Configure Service Levels via the NerdGraph API",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Service Level Management",
        "SLI/SLO",
        "Configure",
        "Consume",
        "NerdGraph"
      ],
      "external_id": "bbc11b33aca5f3cd12d3c6217d44ad9d5f7b5daa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-slm/",
      "published_at": "2021-12-25T15:06:00Z",
      "updated_at": "2021-12-04T09:46:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. With New Relic you can implement Service Levels for your applications, consume the results easily from the UI during your planning sessions and incident response, and progressively iterate on the configuration to adjust your objectives to the desired user experience. Besides the UI, you can also use our NerdGraph API Explorer to create and edit of SLIs and their SLOs. Alternatively, you can automate this configuration using the Terraform Service Level resource. Important In order to create Service Levels, the API key needs a role with permissions to modify and delete metric rules. Create an SLI with an SLO Please refer to Create and edit SLIs and SLOs to learn the basic concepts in the SLI and SLO configuration, such as the entity that an SLI is associated with. Also, you can refer to that documentation to find examples of the most common indicators for APM services and browser applications. The following is an example NerdGraph call that creates an SLI using the serviceLevelCreate mutation query: mutation { serviceLevelCreate( entityGuid: \"entityGuid\", indicator: { name: \"Latency below 0.25 seconds\", description: \"The proportion of valid requests that were served faster than 0.25s, which is considered to correspond to a good experience.\", events: { validEvents: { from: \"Transaction\", where: \"entityGuid = 'entityGuid'\" }, goodEvents: { from: \"Transaction\", where: \"entityGuid = 'entityGuid' and duration < 0.25\" }, accountId: accountId}, objectives: { target: 99.5, timeWindow: { rolling: { count: 7, unit: DAY }}}}) { id description } } Copy It contains these fields: entityGuid: The GUID of the entity (for example, APM service, browser application, etc.) that you want to relate this SLI to. On the UI, you can find this GUID on the entity page, under See metadata and manage tags. description: Use detailed descriptions, including the selected threshold that determines good events. For example, for an availability SLI, include something like “The proportion of valid requests that were served without errors.” Or, for a latency SLI, include a description such as “The proportion of valid requests that were served faster than 0.25s, which is considered to correspond to a good experience”. accountId: The ID of the account where the APM service or browser application belongs to, which contains the NRDB data for the SLI/SLO calculations. badEvents.from, badEvents.where The NRQL query that defines bad events, SELECT count(*) FROM badEvents.from WHERE badEvents.where, requires these FROM and WHERE clauses. If you defined an SLI from valid and bad events, leave the goodEvents object empty. goodEvents.from, goodEvents.where The NRQL query that defines good events, SELECT count(*) FROM goodEvents.from WHERE goodEvents.where, requires these FROM and WHERE clauses. If you defined an SLI from valid and good events, leave the badEvents object empty. validEvents.from, validEvents.where These are the FROM and WHERE clauses for the NRQL query that defines valid events, which will result in SELECT count(*) FROM validEvents.from WHERE validEvents.where. name: A short category name for your SLI to help understand what the Service Level is about. We suggest including any specific parameters and filters involved in the SLI definition. Examples: Availability Latency below 4 seconds CLS for desktops below 0.1 objectives: An array of objectives (SLOs) for the SLI. target: The target for your SLO, up to 100.00. The field supports up to 5 decimals. If your users are happy with the current experience, set the SLO percentage to match the current baseline. For instance, the percentile used to determine the SLI's good events. timeWindow.rolling.count: The length of the period taken into consideration to calculate the SLO. The supported values are 1, 7, 14, 28, and 30. timeWindow.rolling.unit: DAYis the supported value. Retrieve the configuration of an SLI for an APM service Use this query to retrieve the configuration of an SLI, including its id. { actor { entity(guid: \"entityGuid\") { guid name serviceLevel { indicators { createdAt createdBy { email } description entityGuid id name objectives { target timeWindow { rolling { count unit } } } } } } } } Copy Update the SLOs of an SLI Use the serviceLevelUpdate mutation to define one or more SLOs for each one of the SLIs. To obtain the SLI's id, use the query above. mutation { serviceLevelUpdate( id: \"indicators.id\", indicator: { objectives: { target: 99.00, timeWindow: { rolling: { count: 7, unit: DAY }}}}) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 376.81744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure <em>Service</em> <em>Levels</em> via the NerdGraph API",
        "sections": "Configure <em>Service</em> <em>Levels</em> via the NerdGraph API",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": " indicators for APM services and browser applications. The following is an example NerdGraph call that creates an <em>SLI</em> using the <em>serviceLevel</em>Create mutation query: mutation { <em>serviceLevel</em>Create( entityGuid: &quot;entityGuid&quot;, indicator: { name: &quot;Latency below 0.25 seconds&quot;, description: &quot;The proportion"
      },
      "id": "61ab38e028ccbcf9dbc25413"
    },
    {
      "sections": [
        "Create and edit SLIs and SLOs",
        "BETA FEATURE",
        "Important",
        "Key concepts to create SLIs and SLOs",
        "The SLI entity",
        "SLI queries",
        "Suggested SLIs",
        "SLIs for APM services instrumented with the New Relic agent",
        "Service availability",
        "Service latency",
        "SLIs for APM services instrumented with OpenTelemetry",
        "SLIs for browser applications",
        "Browser app largest contentful paint",
        "Browser app first input delay",
        "Browser app cumulative layout shift",
        "Create and edit Service Levels",
        "Select the SLI data source",
        "Configure the queries",
        "Set the SLO time window and target",
        "Define your SLI",
        "Edit SLIs"
      ],
      "title": "Create and edit SLIs and SLOs",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Service Level Management",
        "SLI/SLO",
        "Configure"
      ],
      "external_id": "ac0e19e3d890a02dde12bd639c55d4bd02a61778",
      "image": "https://docs.newrelic.com/static/fffe62dc00eff1b932b5c76be5730e5a/c1b63/slm_edit_menu.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/create-slm/",
      "published_at": "2021-12-25T14:39:20Z",
      "updated_at": "2021-12-15T00:25:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. You can create SLIs and SLOs manually through the New Relic UI. Alternatively, you can automate the process with our NerdGraph API and the Terraform Service Level resource. Important In order to create Service Levels you need a role with permissions to modify and delete metric rules. Key concepts to create SLIs and SLOs Keep in mind these concepts when defining SLIs and SLOs. The SLI entity In the New Relic ecosystem, SLIs and SLOs are linked to entities, which are all the elements in your stack that report data to us, or that generate data that we have access to. The entity that an SLI is related to determines where the SLI/SLO results show. And the entity's tags help filter down SLI results on the Service Levels view. You can define SLIs on any NRDB event that is reported to New Relic, and therefore you can also base SLIs on custom events. Most custom events are not related to a single New Relic entity, but provide higher level business and user experience insights. In this case, you can still relate the SLI to a specific entity or to a workload. SLI queries SLIs are defined as the percentage of good responses out of the total number of valid requests. Most often you’ll set up your SLIs by defining the valid and good pieces: A valid request is any request that you want to count as meaningful for your SLIs (for example, all transactions related to an endpoint that weren’t initiated by a health check). A good response is any response that you consider to provide a good output for the end-user or client service (for example, the service responded in less than 2 seconds, providing a good navigation experience for the end user). Alternatively, you can define what you consider to be the bad responses instead: A bad response is any response that you consider to provide a bad output (for example, the service responded with a server error, causing the client to fail its flow). New Relic will automatically derive the count of good responses as valid - bad. Request-based SLOs are based on an SLI defined as the ratio of the number of good requests to the total number of requests. A request-based SLO is met when that ratio meets or exceeds the goal for the compliance period. Suggested SLIs In this section you’ll find some SLIs that are typically used to measure the performance of services and browser applications. SLIs for APM services instrumented with the New Relic agent Based on Transaction events, these SLIs are the most common for request-driven services: Service availability Service availability is the ratio of the number of successful responses to the number of all requests. This effectively is an error rate, but you can filter it down, for example removing expected errors. Valid events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Bad events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' AND error IS TRUE Copy Where {entityGuid} is the service's GUID. Service latency A latency SLI measures the proportion of valid requests that were served faster than the threshold established as a good experience. In order to determine that duration threshold, check how the service has been performing in the past weeks, and use that result as a realistic and achievable baseline. Afterwards, you can iterate on the SLI threshold, and align it with a more ambitious performance. To select an appropriate value for the duration condition, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find this duration threshold using the query builder, and use it to determine what you consider to be good events for your SLI: select percentile(duration, 95) from Transaction where entityGuid = '{entityGuid}' since 7 days ago limit max Valid events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Good events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' and duration < {duration} Copy Where {entityGuid} is the service's GUID. Where {duration} is the response time that you consider provides a good experience for your client service or end-user, in seconds. SLIs for APM services instrumented with OpenTelemetry Based on OpenTelemetry spans, these SLIs are the most common for request-driven services: Service availability Service availability is the ratio of the number of successful responses to the number of all requests. This effectively is an error rate, but you can filter it down, for example removing expected errors. Valid events fields FROM: Span WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) Copy Where {entityGuid} is the service's GUID. Bad events fields FROM: Span WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) AND otel.status_code = 'ERROR' Copy Where {entityGuid} is the service's GUID. Service latency A latency SLI measures the proportion of valid requests that were served faster than the threshold established as a good experience. In order to determine that duration threshold, check how the service has been performing in the past weeks, and use that result as a realistic and achievable baseline. Afterwards, you can iterate on the SLI threshold, and align it with a more ambitious performance. To select an appropriate value for the duration condition, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find this duration threshold using the query builder, and use it to determine what you consider to be good events for your SLI: select percentile(duration.ms, 95) from Span where entityGuid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) since 7 days ago limit max Valid events fields FROM: Span WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) Copy Where {entityGuid} is the service's GUID. Good events fields FROM: Span WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) AND duration.ms < {duration} Copy Where {entityGuid} is the service's GUID. Where {duration} is the response time that you consider provides a good experience for your client service or end-user, in seconds. SLIs for browser applications The following SLIs are based on Google’s Browser Core Web Vitals. Browser app largest contentful paint It’s the proportion of valid page views where the largest content element visible in the viewport was rendered faster than the threshold considered to correspond to a good experience. Valid events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Good events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' and largestContentfulPaint<'{largestContentfulPaint}' Copy Where {entityGuid} is the browser app GUID. Where {largestContentfulPaint} is the amount of time (in milliseconds) to render the largest content element visible in the viewport that you consider provides a good experience for your end user. A frequent standard is 4000 ms. To determine a realistic number to use for {largestContentfulPaint} in your environment, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find it by using the query builder: SELECT percentile (largestContentfulPaint,95) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max Browser app first input delay It’s the proportion of page views where the time between a user's first interacion with the page and the time when the browser responds to that interaction is less than a certain threshold. Valid events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Good events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' and firstInputDelay<{firstInputDelay} Copy Where {entityGuid} is the browser app GUID. Where {firstInputDelay} is the amount of time (in milliseconds) the browser should respond in to provide a good experience for your end user. A frequent standard is 300 ms. To determine a realistic number to use for {firstInputDelay} in your environment, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find it by using the query builder: SELECT percentile(firstInputDelay,95) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max facet deviceType Browser app cumulative layout shift It’s the proportion of page views with a good cumulative layout shift (CLS). CLS is described as the total sum of all individual layout shift scores for every unexpected layout shift that occurs during the entire lifespan of the page. A layout shift occurs any time a visible element changes its position from one rendered frame to the next. Valid events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. If you’d like to create separate SLIs to track CLS in desktop and mobile devices separately, add one of these clauses at the end of the field: and deviceType = 'Mobile' and deviceType = 'Desktop' Good events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' and cumulativeLayoutShift < {cumulativeLayoutShift} Copy Where {entityGuid} is the browser app GUID. Where {cumulativeLayoutShift} is a pre-set value. To provide a good user experience, your site should strive to have a CLS score of 0.1 or less. A CLS score of 0.25 or more is considered a poor user experience. If you’ve decided to create separate SLIs to track CLS in desktop and mobile devices separately when you defined the valid events query, add this clause at the end of the field: and deviceType = 'Mobile' and deviceType = 'Desktop' To determine a realistic number to select for {cumulativeLayoutShift} in your environment, one typical practice is to select the 75th percentile of page loads for the last 7 or 15 days, segmented across mobile and desktop devices. Find it by using the query builder: SELECT percentile(cumulativeLayoutShift,75) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max facet deviceType Create and edit Service Levels To create SLIs and SLOs, go to the Service Levels tab at any workload in New Relic One and follow these steps: Select the SLI data source In order to define your new SLI, choose one of these two options: Entity data: Base the SLI on standard data coming from New Relic One agents. This is the most common option. If this is your choice, select the entity (for example, APM service) you want to use. Custom data: Alternatively, you can base the SLI on your custom NRDB events. Use this option when you can't relate the service level data to a specific entity, or when you want to relate the service level directly to a workload. Configure the queries The account where the data is gathered from matches the account of the entity that the SLI refers to. The rest of the fields correspond to the NRDB event that goes into the FROM clause, as well as the WHERE clauses that determine what is a valid and a good/bad event. Please see the section above to know what goes into each field. On the left you’ll see the final queries; and at the bottom you’ll get a preview of the count of valid and good/bad events in the last month. Important SLI queries support NRDB events, but not dimensional metrics yet. Set the SLO time window and target In this step you’ll get a preview of the SLI value. You can add one or more SLOs for this SLI. Just select the length of the time window and the percentage target. The chart on the left will help you anticipate whether the target you’re setting is feasible or if it's often missed. Rolling time-window SLOs are supported. With a rolling time-window, the SLO compliance takes into account the last N days. Every minute, the oldest data drops out of the current calculation and new data replaces it. Define your SLI Select a short name for your SLI that helps you recognize what it’s measuring. Optionally, you may add a description. Edit SLIs After you’ve created an SLI, access the UI and click on the ... menu to edit it:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 366.16183,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create and edit <em>SLIs</em> and <em>SLOs</em>",
        "sections": "Create and edit <em>Service</em> <em>Levels</em>",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": " that we have access to. The entity that an <em>SLI</em> is related to determines where the <em>SLI</em>&#x2F;<em>SLO</em> results show. And the entity&#x27;s tags help filter down <em>SLI</em> results on the <em>Service</em> Levels view. You can define SLIs on any NRDB event that is reported to New Relic, and therefore you can also base SLIs on custom"
      },
      "id": "61ab3a71196a67792ad10bd6"
    }
  ],
  "/docs/service-level-management/create-slm": [
    {
      "sections": [
        "Service Levels Management: Questions and next steps",
        "BETA FEATURE",
        "What permissions do I need to use New Relic's Service Levels?",
        "How do I get support from New Relic during the public beta?",
        "Why don’t I see any data right after I create an SLI?",
        "Can I configure an SLI on any entity type?",
        "Can I get alerts on SLI data?",
        "How does New Relic calculate the remaining error budget?",
        "How can I view the queries that define an SLI from the UI?",
        "How can I view the queries that define an SLI through the API?",
        "Can I chart the SLI attainment on a dashboard?"
      ],
      "title": "Service Levels Management: Questions and next steps",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started",
        "Service Level Management"
      ],
      "external_id": "262058f4dc430fbaee0382261f79de147e348f53",
      "image": "https://docs.newrelic.com/static/763695119ceaa7668fdb3fb858c83c75/c1b63/slm_edit_menu_2.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/faqs-slm/",
      "published_at": "2021-12-25T02:33:00Z",
      "updated_at": "2021-12-25T02:33:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic's Service Levels? To use New Relic's Service Levels and see SLO results, you need a full platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify events to metric rules. If you get the following errors, check your user permissions: The UI has disabled the option to save an SLI/SLO. The API returns the error message “Cannot query field \\\"eventExportRegisterRule\\\" on type \\\"RootMutationType\\\".”. How do I get support from New Relic during the public beta? Service Levels Management is in public beta, and no official support is offered yet through the Support portal. If you have general questions and feedback, please post them on the Explorers Hub. New Relic’s community and the product team will be glad to help you there. If you have suggestions about documentation, please suggest an improvement or send your contribution using the Create issue or Edit page buttons on the top right corner in the docs UI. Why don’t I see any data right after I create an SLI? New Relic starts generating new SLI metrics from the moment that you create an SLI. This is why we need a few minutes before we can start showing the first meaningful SLI attainment results. The benefit of the new data is that it has 13 month retention by default, and it’s more efficient to query for long periods of time. Can I configure an SLI on any entity type? Yes, you can configure an SLI on any entity type, such as an APM service, a browser application, or a Lambda function. SLI queries support NRDB events. Support for dimensional metrics on SLI queries is on our roadmap. Can I get alerts on SLI data? Alerts on New Relic's Service Levels are on our roadmap. How does New Relic calculate the remaining error budget? The remaining error budget indicates what percentage of requests could still have a bad response over the SLO period without compromising the objective. Therefore, the total amount of tolerated bad responses will vary with the throughput of requests. Time-based error budgets are on our roadmap. How can I view the queries that define an SLI from the UI? To view the queries that define an SLI, you can click on the ... menu on the SLI summary card, then select the Edit option. The queries will show at the top-right corner. How can I view the queries that define an SLI through the API? To view the queries that define an SLI through the API, use Nerdgraph. In order to view the SLI configuration, you'll need to know the GUID of the entity the SLI is attached to, and replace it in the following query: { actor { entity(guid: \"{entityGuid}\") { serviceLevel { indicators { events { badEvents { where from } goodEvents { from where } validEvents { from where } } name } } } } } Copy As a response you are going to receive all the SLIs attached to the entity, the SLI name, and the queries. Keep in mind that either goodEvents or badEvents is going to have content, depending on the configuration of the SLI. Can I chart the SLI attainment on a dashboard? You can chart SLI attainment time series on your custom dashboards using the following query: FROM Metric SELECT clamp_max((count(newrelic.sli.valid) - count(newrelic.sli.bad)) / count(newrelic.sli.valid) * 100, 100) as 'SLI attainment' WHERE sli.id = '<sli.id>' UNTIL 2 MINUTES AGO TIMESERIES AUTO Copy Where sli.id is the SLI identifier. The easiest way to add a chart like this to your dashboard is by using the Add to dashboard option, available on the Details view. Alternatively, you can find the SLI id and SLI attainment query through the Nerdgraph API with the following query: { actor { entity(guid: \"{entityGuid}\") { serviceLevel { indicators { name id resultQueries { indicator { nrql } } } } } } } Copy Use the entityGuid of the entity that's associated with the SLI. On the query results, you’ll get the SLI id in the serviceLevel.indicators.id field.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 633.1727,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Service</em> <em>Levels</em> <em>Management</em>: Questions and next steps",
        "sections": "<em>Service</em> <em>Levels</em> <em>Management</em>: Questions and next steps",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic&#x27;s <em>Service</em> Levels? To use New Relic&#x27;s <em>Service</em> Levels and see <em>SLO</em> results, you need a <em>full</em> platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify"
      },
      "id": "61ab3a9d28ccbc492ac23ee2"
    },
    {
      "sections": [
        "Configure Service Levels via the NerdGraph API",
        "BETA FEATURE",
        "Important",
        "Create an SLI with an SLO",
        "Retrieve the configuration of an SLI for an APM service",
        "Update the SLOs of an SLI"
      ],
      "title": "Configure Service Levels via the NerdGraph API",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Service Level Management",
        "SLI/SLO",
        "Configure",
        "Consume",
        "NerdGraph"
      ],
      "external_id": "bbc11b33aca5f3cd12d3c6217d44ad9d5f7b5daa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-slm/",
      "published_at": "2021-12-25T15:06:00Z",
      "updated_at": "2021-12-04T09:46:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. With New Relic you can implement Service Levels for your applications, consume the results easily from the UI during your planning sessions and incident response, and progressively iterate on the configuration to adjust your objectives to the desired user experience. Besides the UI, you can also use our NerdGraph API Explorer to create and edit of SLIs and their SLOs. Alternatively, you can automate this configuration using the Terraform Service Level resource. Important In order to create Service Levels, the API key needs a role with permissions to modify and delete metric rules. Create an SLI with an SLO Please refer to Create and edit SLIs and SLOs to learn the basic concepts in the SLI and SLO configuration, such as the entity that an SLI is associated with. Also, you can refer to that documentation to find examples of the most common indicators for APM services and browser applications. The following is an example NerdGraph call that creates an SLI using the serviceLevelCreate mutation query: mutation { serviceLevelCreate( entityGuid: \"entityGuid\", indicator: { name: \"Latency below 0.25 seconds\", description: \"The proportion of valid requests that were served faster than 0.25s, which is considered to correspond to a good experience.\", events: { validEvents: { from: \"Transaction\", where: \"entityGuid = 'entityGuid'\" }, goodEvents: { from: \"Transaction\", where: \"entityGuid = 'entityGuid' and duration < 0.25\" }, accountId: accountId}, objectives: { target: 99.5, timeWindow: { rolling: { count: 7, unit: DAY }}}}) { id description } } Copy It contains these fields: entityGuid: The GUID of the entity (for example, APM service, browser application, etc.) that you want to relate this SLI to. On the UI, you can find this GUID on the entity page, under See metadata and manage tags. description: Use detailed descriptions, including the selected threshold that determines good events. For example, for an availability SLI, include something like “The proportion of valid requests that were served without errors.” Or, for a latency SLI, include a description such as “The proportion of valid requests that were served faster than 0.25s, which is considered to correspond to a good experience”. accountId: The ID of the account where the APM service or browser application belongs to, which contains the NRDB data for the SLI/SLO calculations. badEvents.from, badEvents.where The NRQL query that defines bad events, SELECT count(*) FROM badEvents.from WHERE badEvents.where, requires these FROM and WHERE clauses. If you defined an SLI from valid and bad events, leave the goodEvents object empty. goodEvents.from, goodEvents.where The NRQL query that defines good events, SELECT count(*) FROM goodEvents.from WHERE goodEvents.where, requires these FROM and WHERE clauses. If you defined an SLI from valid and good events, leave the badEvents object empty. validEvents.from, validEvents.where These are the FROM and WHERE clauses for the NRQL query that defines valid events, which will result in SELECT count(*) FROM validEvents.from WHERE validEvents.where. name: A short category name for your SLI to help understand what the Service Level is about. We suggest including any specific parameters and filters involved in the SLI definition. Examples: Availability Latency below 4 seconds CLS for desktops below 0.1 objectives: An array of objectives (SLOs) for the SLI. target: The target for your SLO, up to 100.00. The field supports up to 5 decimals. If your users are happy with the current experience, set the SLO percentage to match the current baseline. For instance, the percentile used to determine the SLI's good events. timeWindow.rolling.count: The length of the period taken into consideration to calculate the SLO. The supported values are 1, 7, 14, 28, and 30. timeWindow.rolling.unit: DAYis the supported value. Retrieve the configuration of an SLI for an APM service Use this query to retrieve the configuration of an SLI, including its id. { actor { entity(guid: \"entityGuid\") { guid name serviceLevel { indicators { createdAt createdBy { email } description entityGuid id name objectives { target timeWindow { rolling { count unit } } } } } } } } Copy Update the SLOs of an SLI Use the serviceLevelUpdate mutation to define one or more SLOs for each one of the SLIs. To obtain the SLI's id, use the query above. mutation { serviceLevelUpdate( id: \"indicators.id\", indicator: { objectives: { target: 99.00, timeWindow: { rolling: { count: 7, unit: DAY }}}}) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 376.81738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> <em>Service</em> <em>Levels</em> via the NerdGraph API",
        "sections": "<em>Configure</em> <em>Service</em> <em>Levels</em> via the NerdGraph API",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": " indicators for APM services and browser applications. The following is an example NerdGraph call that creates an <em>SLI</em> using the <em>serviceLevel</em>Create mutation query: mutation { <em>serviceLevel</em>Create( entityGuid: &quot;entityGuid&quot;, indicator: { name: &quot;Latency below 0.25 seconds&quot;, description: &quot;The proportion"
      },
      "id": "61ab38e028ccbcf9dbc25413"
    },
    {
      "sections": [
        "Consume Service Levels",
        "BETA FEATURE",
        "Check your SLOs state",
        "Understand Service Levels details",
        "Good and bad responses",
        "SLI attainment over time (%)",
        "Compliance over the period",
        "Remaining error budget (Requests)",
        "SLI attainment over time and SLO target (%)",
        "Analyze bad responses"
      ],
      "title": "Consume Service Levels",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Service Level Management",
        "SLI/SLO",
        "Consume"
      ],
      "external_id": "2b1e77937fb81e4b43d6f81d660e53f1cbbb5f80",
      "image": "https://docs.newrelic.com/static/5ecaa57f52ed11c79de67ea6200443c8/c1b63/sli_card.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/consume-slm/",
      "published_at": "2021-12-25T05:08:01Z",
      "updated_at": "2021-12-04T09:53:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. After you create your set of SLIs and SLOs, New Relic will start generating SLI data. The first results will take a few minutes to appear in the New Relic One UI. Find Service Levels: At the top nav bar, under Service Levels in the More menu (which you can customize). Here you can filter the SLIs by entity tags. At the previews of those entities that have an SLI defined. You can find them all around the UI. For instance, click on an entity from the Explorer's Navigator view. In APM services, at the reports section. In any workload that contains the SLI entity, such as an APM service or browser application. If you want to group SLIs under a certain workload, make sure to add the APM service or browser app to an existing workload, or create a new one. Click on any SLI to open the SLI card, which contains: The entity the SLI refers to, and the SLI name. Each row represents an SLO with: Target and time window. Compliance in the SLO period. Remaining requests error budget. Check your SLOs state Request-based SLOs are determined from SLIs defined as the ratio of the number of good responses to the total number of requests. This means a request-based SLO is met when that ratio meets or exceeds the goal for the SLO compliance period. If the SLO row has a green background, you’re doing good for the period. You may have not served successfully 100% of the requests, but you still have some remaining error budget to consume. If the SLO row has a yellow background, your error budget is closer to being totally consumed, and you should be more cautious for the rest of the period. If the SLO row has a red background, you’ve not reached the target SLO in this period, and you’ve consumed all of your error budget. Be careful if you need to deploy, and plan some work to improve your SLIs. You can click on the SLO to see more data about the entity, such as the golden metrics, the latest deployments, anomalies, and ongoing issues. This data can help you understand when and why you missed the SLO targets. You can define more than one SLO for the same SLI to check how fast you’re consuming the error budget. For instance, if you have an error budget of 0,1% requests for a whole week, you may not want to consume most of it in a single day, or the SLO will be at risk for the rest of the week. Understand Service Levels details We provide SLI details for two main purposes: For SLO analysis: See in which time ranges the SLO targets were missed. For SLI/SLO configuration and fine tuning: Learn how New Relic calculated SLO values. The SLI card contains the following charts: Good and bad responses These are the key concepts to analyze Service Levels: A valid request is any request that you want to count as meaningful for your SLIs. A good response is any response that you consider to provide a good experience (for example, the service responded in less than 2 seconds, providing a good navigation experience for the end user). A bad response is any response that you consider to provide a bad experience (like the service responded with a server error, interrupting the user's flow). This chart shows the total number of valid requests that your service received, broken down by good or bad. This chart shows the actual throughput of your service, which you can use to see if there’s any correlation between the increase of throughput and bad responses. SLI attainment over time (%) It's the proportion of what you consider good responses over time. The line should stay close to 100%, meaning that most requests were served successfully. Compliance over the period It's the ratio of good events (responses) to total events (requests), measured over the SLO compliance period. The closer to 100%, the closer your service is to meet the SLO target over the period. When this percentage goes below the SLO target, the chart will turn red: You need to put more effort in reliability. Remaining error budget (Requests) The error budget is an alternative way to read the SLO. It indicates what percentage of requests could still have a bad response over the SLO period, without compromising the objective. As the total amount of tolerated bad responses will vary with the request throughput, New Relic shows the percentage of remaining error budget: As long as the remaining error budget is above 25%, you'll see green, and your SLO is good. When the error budget goes below 25%, it will turn yellow. This means you’re close to burning the whole budget for the period. You may want to be more careful with new deployments and changes, and plan for some reliability work. Once the error budget is completely spent, it will show in red. SLI attainment over time and SLO target (%) The last chart shows two time series: the (SLI attainment over time) [#sli-over-time] , and the SLO target. When the SLI value is below the SLO target,your service is missing the SLO. Use this chart to learn in which time ranges your service missed the SLO target. Analyze bad responses When an SLO is not compliant, you need to analyze the original data to better understand what the impact is for your customer, with a special focus on what went wrong. At the Service Levels page, click the ... menu in any SLI and select Analyze. You'll access the query that represents the original NRDB events used to determine the bad responses which calculate the SLI attainment. You can then use the query builder to facet and filter down the unsuccessful responses by user account, client id, requesting source, etc. to better understand the cause and impact of missing your SLIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 319.10892,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Consume <em>Service</em> <em>Levels</em>",
        "sections": "Consume <em>Service</em> <em>Levels</em>",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": " for the same <em>SLI</em> to check how fast you’re consuming the error budget. For instance, if you have an error budget of 0,1% requests for a whole week, you may not want to consume most of it in a single day, or the <em>SLO</em> will be at risk for the rest of the week. Understand <em>Service</em> Levels details We provide"
      },
      "id": "61ab3a9d28ccbc4b5fc23f44"
    }
  ],
  "/docs/service-level-management/faqs-slm": [
    {
      "sections": [
        "New Relic guided install overview",
        "Why it matters",
        "Some technical detail",
        "Important",
        "On-host integration (OHI) recipes",
        "Troubleshoot common problems",
        "MySQL: Incorrect user permissions",
        "NGINX: No status URL"
      ],
      "title": "New Relic guided install overview",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started"
      ],
      "external_id": "78c43fb865811c44f388f0601e0fb5f7da82fe87",
      "image": "https://docs.newrelic.com/static/6bf45ccf002250f7ebaa69cbe3ff706c/c1b63/guided-install-cli.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/cross-product-functions/install-configure/new-relic-guided-install-overview/",
      "published_at": "2021-12-25T21:43:08Z",
      "updated_at": "2021-12-14T03:50:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you haven't already, sign up for a free New Relic account so you can instrument your systems and send telemetry data to New Relic. Our guided install creates a customized CLI command for your environment that downloads and installs the New Relic CLI and the infrastructure agent. Ready to get started? Click the Guided install button. Or, if your account reports data through our EU data center, click EU Guided install. Guided install EU Guided install Our infrastructure agent discovers the applications and infrastructure and log sources running in your environment, and recommends which ones should be instrumented. The install automates the configuration and deployment of each system you choose to instrument. Why it matters With our guided install, you can instrument your applications and infrastructure and start seeing your data in New Relic in minutes. The guided install uses our command line interface (CLI), the infrastructure agent for your host environment, and a library of installation recipes to instrument your applications and infrastructure for you. That means less toil for you. Because our instrumentation recipes are open source, you can modify existing recipes, or build new ones, to suit your needs. Some technical detail The New Relic guided install uses open source installation recipes to instrument on-host integrations. These recipes include installation and setup commands, information about logs, and metadata related to what’s being installed. They're collected in a YAML file for each type of system and have all of the installation details necessary to install the infrastructure agent for a specific integration. Important On Windows, our guided install only supports Microsoft SQL Server, logs, and the infrastructure agent. All other integrations are only supported on Linux. On-host integration (OHI) recipes The guided install automates the discovery, configuration, and installation of OHIs. However, there may be times when you want to instrument them one-by-one using the CLI install command. To install any individual on-host integration, run this command: curl -Ls https://raw.githubusercontent.com/newrelic/newrelic-cli/master/scripts/install.sh | bash && sudo NEW_RELIC_API_KEY=API_KEY NEW_RELIC_ACCOUNT_ID=ACCOUNT_ID /usr/local/bin/newrelic install -n INTEGRATION-FLAG Copy For example: curl -Ls https://raw.githubusercontent.com/newrelic/newrelic-cli/master/scripts/install.sh | bash && sudo NEW_RELIC_API_KEY=<API_KEY> NEW_RELIC_ACCOUNT_ID=<ACCOUNT_ID> /usr/local/bin/newrelic install -n apache-open-source-integration Copy The table lists the integrations supported by the guided install CLI command. The specific on-host integration commands are provided for your reference. Our open source integrations send performance metrics and inventory data from your servers and applications to the New Relic platform. You can view pre-built dashboards of your metric data, create alert policies, and create your own custom queries and charts. Integration Command Apache newrelic install -n apache-open-source-integration Cassandra newrelic install -n cassandra-open-source-integration Couchbase newrelic install -n couchbase-open-source-integration ElasticSearch newrelic install -n elasticsearch-open-source-integration HAProxy newrelic install -n haproxy-open-source-integration HashiCorp Consul newrelic install -n hashicorp-consul-open-source-integration Memcached newrelic install -n memcached-open-source-integration Microsoft SQL Server (Windows only) newrelic install -n mssql-server-integration-installer MongoDB newrelic install -n mongodb-open-source-integration MySQL newrelic install -n mysql-open-source-integration Nagios newrelic install -n nagios-open-source-integration Nginx newrelic install -n nginx-open-source-integration PostgreSQL newrelic install -n postgres-open-source-integration RabbitMQ newrelic install -n rabbitmq-open-source-integration Redis newrelic install -n redis-open-source-integration Varnish Cache newrelic install -n varnish-cache-open-source-integration Troubleshoot common problems As we identify areas where the guided install fails, we'll document them here and provide some troubleshooting guidance. MySQL: Incorrect user permissions To monitor MySQL health data, you need a valid username and password with specific permissions. These commands will create a user and grant the required permissions: Create a user newrelic@localhost with a specific password. sudo mysql -e \"CREATE USER 'newrelic'@'localhost' IDENTIFIED BY 'YOUR_SELECTED_PASSWORD';\" Copy Give replication privileges to newrelic@localhost with a maximum of 5 connections. sudo mysql -e \"GRANT REPLICATION CLIENT ON *.* TO 'newrelic'@'localhost' WITH MAX_USER_CONNECTIONS 5;\" Copy Give select privileges to newrelic@localhost with a maximum of 5 connections. sudo mysql -e \"GRANT SELECT ON *.* TO 'newrelic'@'localhost' WITH MAX_USER_CONNECTIONS 5;\" Copy Once done, your next guided install attempt should work. NGINX: No status URL To monitor your NGINX server, you'll need to configure a valid status URL. status_url: The URL set up to provide the metrics using the status module. If the default value of 127.0.0.1 is incorrect, substitute the address/FQDN/URL for your system. Example: status_url: http://127.0.0.1/status You can read more about the status_url in these NGINX docs: For NGINX Open Source: HTTP stub status module For NGINX Plus: HTTP status module and HTTP API module There are different ways to set status_url, depending on how NGINX was installed: If enabled via Kubernetes: See Monitor services running on Kubernetes. If enabled via Amazon ECS: See Monitor services running on ECS. If installed on-host: Edit the config in the integration's YAML config file, nginx-config.yml.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 325.5559,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Full</em>-<em>Stack</em> <em>Observability</em>",
        "body": "If you haven&#x27;t already, sign up for a free New Relic account so you can instrument your systems and send telemetry data to New Relic. Our guided install creates a customized CLI command for your environment that downloads and installs the New Relic CLI and the infrastructure agent. Ready to <em>get</em>"
      },
      "id": "61b8148c64441fb9d3d703b5"
    },
    {
      "sections": [
        "Get started with New Relic's Service Levels Management",
        "BETA FEATURE",
        "What are SLIs and SLOs?",
        "Service Levels and APM SLA reports",
        "What's next?"
      ],
      "title": "Get started with New Relic's Service Levels Management",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started",
        "Service Level Management"
      ],
      "external_id": "c3da65667ad9557562bd537c738309d80d3f31ee",
      "image": "https://docs.newrelic.com/static/a0a3554edde9777dc70c4ee8281fddd6/01e7c/slm1_1.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/intro-slm/",
      "published_at": "2021-12-26T01:42:11Z",
      "updated_at": "2021-12-02T01:44:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. With New Relic you can define and consume service level indicators and service level objectives for your applications. What are SLIs and SLOs? Service Levels are used to measure the performance of a service from the end user (or client application) point of view. For instance, a Service Level can represent whether a video loaded quickly enough, or whether a directions service returned at least one possible route between two points. Service level indicators (SLIs) are accurate quantitative measures of the user experience as described by a service level. They represent a proportion of successful outputs, and therefore they’re expressed as a percentage (%). For example, an SLI can measure the proportion of requests that were faster than some threshold, or the proportion of records coming into a pipeline that resulted in the correct value coming out. And while users understand that a video might take a few additional seconds to load, or that an application might return an error from time to time, this shouldn’t happen often if you don’t want to lose their trust. Therefore, once you’ve defined SLIs for the performance aspects that are most relevant for the end users of your services, you need to set SLOs to track that the service is meeting their expectations. Service level objectives (SLOs) are defined as a target value that an SLI must meet over a period of time. For example, videos must start playing in less than 2 seconds 99% of the time over a week period. Please refer to the Service Level management use case implementation guide to learn more about identifying service boundaries and deploying the instrumentation that your service levels will be based on. Service Levels and APM SLA reports New Relic has provided automatic SLA Reports for APM Services for a long time. The Apdex-based reports, which you can get on your email inbox on Mondays, are automatically generated for services that produce web transactions, and are useful to see trends over time. On top of the SLAs, our new SLM level capability is better aligned with modern service level best practices, such as those promoted by the Google SRE Handbook, and provides new, improved functionality: SLIs can be defined on any NRDB event that is reported to New Relic, not just APM transactions. Therefore you can also base SLIs on your own custom events. You can decide which service boundaries and which metrics are relevant for your service levels, and you can set your own objectives. You can view SLO results across your accounts, and within your workloads. What's next? Ready to get started? If you don't already have one, sign up for a free New Relic account. You can find Service Levels in several places in New Relic One: At the top nav bar, under the More menu (which you can customize). At the previews of those entities that have an SLI defined. In APM services, at the reports section. Within a workload, at the Service Levels tab. Carry on and read our docs on how to create and consume SLIs and SLOs. You can also check out how to manage SLMs with our API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 324.0119,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with New Relic&#x27;s <em>Service</em> <em>Levels</em> <em>Management</em>",
        "sections": "<em>Get</em> <em>started</em> with New Relic&#x27;s <em>Service</em> <em>Levels</em> <em>Management</em>",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": " that are most relevant for the end users of your services, you need to set SLOs to track that the <em>service</em> is meeting their expectations. <em>Service</em> <em>level</em> objectives (SLOs) are defined as a target value that an SLI must meet over a period of time. For example, videos must <em>start</em> playing in less than 2 seconds 99"
      },
      "id": "61a824fe28ccbcc5e3c22dc5"
    },
    {
      "sections": [
        "Create and edit SLIs and SLOs",
        "BETA FEATURE",
        "Important",
        "Key concepts to create SLIs and SLOs",
        "The SLI entity",
        "SLI queries",
        "Suggested SLIs",
        "SLIs for APM services instrumented with the New Relic agent",
        "Service availability",
        "Service latency",
        "SLIs for APM services instrumented with OpenTelemetry",
        "SLIs for browser applications",
        "Browser app largest contentful paint",
        "Browser app first input delay",
        "Browser app cumulative layout shift",
        "Create and edit Service Levels",
        "Select the SLI data source",
        "Configure the queries",
        "Set the SLO time window and target",
        "Define your SLI",
        "Edit SLIs"
      ],
      "title": "Create and edit SLIs and SLOs",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Service Level Management",
        "SLI/SLO",
        "Configure"
      ],
      "external_id": "ac0e19e3d890a02dde12bd639c55d4bd02a61778",
      "image": "https://docs.newrelic.com/static/fffe62dc00eff1b932b5c76be5730e5a/c1b63/slm_edit_menu.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/create-slm/",
      "published_at": "2021-12-25T14:39:20Z",
      "updated_at": "2021-12-15T00:25:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. You can create SLIs and SLOs manually through the New Relic UI. Alternatively, you can automate the process with our NerdGraph API and the Terraform Service Level resource. Important In order to create Service Levels you need a role with permissions to modify and delete metric rules. Key concepts to create SLIs and SLOs Keep in mind these concepts when defining SLIs and SLOs. The SLI entity In the New Relic ecosystem, SLIs and SLOs are linked to entities, which are all the elements in your stack that report data to us, or that generate data that we have access to. The entity that an SLI is related to determines where the SLI/SLO results show. And the entity's tags help filter down SLI results on the Service Levels view. You can define SLIs on any NRDB event that is reported to New Relic, and therefore you can also base SLIs on custom events. Most custom events are not related to a single New Relic entity, but provide higher level business and user experience insights. In this case, you can still relate the SLI to a specific entity or to a workload. SLI queries SLIs are defined as the percentage of good responses out of the total number of valid requests. Most often you’ll set up your SLIs by defining the valid and good pieces: A valid request is any request that you want to count as meaningful for your SLIs (for example, all transactions related to an endpoint that weren’t initiated by a health check). A good response is any response that you consider to provide a good output for the end-user or client service (for example, the service responded in less than 2 seconds, providing a good navigation experience for the end user). Alternatively, you can define what you consider to be the bad responses instead: A bad response is any response that you consider to provide a bad output (for example, the service responded with a server error, causing the client to fail its flow). New Relic will automatically derive the count of good responses as valid - bad. Request-based SLOs are based on an SLI defined as the ratio of the number of good requests to the total number of requests. A request-based SLO is met when that ratio meets or exceeds the goal for the compliance period. Suggested SLIs In this section you’ll find some SLIs that are typically used to measure the performance of services and browser applications. SLIs for APM services instrumented with the New Relic agent Based on Transaction events, these SLIs are the most common for request-driven services: Service availability Service availability is the ratio of the number of successful responses to the number of all requests. This effectively is an error rate, but you can filter it down, for example removing expected errors. Valid events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Bad events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' AND error IS TRUE Copy Where {entityGuid} is the service's GUID. Service latency A latency SLI measures the proportion of valid requests that were served faster than the threshold established as a good experience. In order to determine that duration threshold, check how the service has been performing in the past weeks, and use that result as a realistic and achievable baseline. Afterwards, you can iterate on the SLI threshold, and align it with a more ambitious performance. To select an appropriate value for the duration condition, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find this duration threshold using the query builder, and use it to determine what you consider to be good events for your SLI: select percentile(duration, 95) from Transaction where entityGuid = '{entityGuid}' since 7 days ago limit max Valid events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Good events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' and duration < {duration} Copy Where {entityGuid} is the service's GUID. Where {duration} is the response time that you consider provides a good experience for your client service or end-user, in seconds. SLIs for APM services instrumented with OpenTelemetry Based on OpenTelemetry spans, these SLIs are the most common for request-driven services: Service availability Service availability is the ratio of the number of successful responses to the number of all requests. This effectively is an error rate, but you can filter it down, for example removing expected errors. Valid events fields FROM: Span WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) Copy Where {entityGuid} is the service's GUID. Bad events fields FROM: Span WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) AND otel.status_code = 'ERROR' Copy Where {entityGuid} is the service's GUID. Service latency A latency SLI measures the proportion of valid requests that were served faster than the threshold established as a good experience. In order to determine that duration threshold, check how the service has been performing in the past weeks, and use that result as a realistic and achievable baseline. Afterwards, you can iterate on the SLI threshold, and align it with a more ambitious performance. To select an appropriate value for the duration condition, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find this duration threshold using the query builder, and use it to determine what you consider to be good events for your SLI: select percentile(duration.ms, 95) from Span where entityGuid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) since 7 days ago limit max Valid events fields FROM: Span WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) Copy Where {entityGuid} is the service's GUID. Good events fields FROM: Span WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) AND duration.ms < {duration} Copy Where {entityGuid} is the service's GUID. Where {duration} is the response time that you consider provides a good experience for your client service or end-user, in seconds. SLIs for browser applications The following SLIs are based on Google’s Browser Core Web Vitals. Browser app largest contentful paint It’s the proportion of valid page views where the largest content element visible in the viewport was rendered faster than the threshold considered to correspond to a good experience. Valid events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Good events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' and largestContentfulPaint<'{largestContentfulPaint}' Copy Where {entityGuid} is the browser app GUID. Where {largestContentfulPaint} is the amount of time (in milliseconds) to render the largest content element visible in the viewport that you consider provides a good experience for your end user. A frequent standard is 4000 ms. To determine a realistic number to use for {largestContentfulPaint} in your environment, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find it by using the query builder: SELECT percentile (largestContentfulPaint,95) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max Browser app first input delay It’s the proportion of page views where the time between a user's first interacion with the page and the time when the browser responds to that interaction is less than a certain threshold. Valid events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Good events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' and firstInputDelay<{firstInputDelay} Copy Where {entityGuid} is the browser app GUID. Where {firstInputDelay} is the amount of time (in milliseconds) the browser should respond in to provide a good experience for your end user. A frequent standard is 300 ms. To determine a realistic number to use for {firstInputDelay} in your environment, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find it by using the query builder: SELECT percentile(firstInputDelay,95) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max facet deviceType Browser app cumulative layout shift It’s the proportion of page views with a good cumulative layout shift (CLS). CLS is described as the total sum of all individual layout shift scores for every unexpected layout shift that occurs during the entire lifespan of the page. A layout shift occurs any time a visible element changes its position from one rendered frame to the next. Valid events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. If you’d like to create separate SLIs to track CLS in desktop and mobile devices separately, add one of these clauses at the end of the field: and deviceType = 'Mobile' and deviceType = 'Desktop' Good events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' and cumulativeLayoutShift < {cumulativeLayoutShift} Copy Where {entityGuid} is the browser app GUID. Where {cumulativeLayoutShift} is a pre-set value. To provide a good user experience, your site should strive to have a CLS score of 0.1 or less. A CLS score of 0.25 or more is considered a poor user experience. If you’ve decided to create separate SLIs to track CLS in desktop and mobile devices separately when you defined the valid events query, add this clause at the end of the field: and deviceType = 'Mobile' and deviceType = 'Desktop' To determine a realistic number to select for {cumulativeLayoutShift} in your environment, one typical practice is to select the 75th percentile of page loads for the last 7 or 15 days, segmented across mobile and desktop devices. Find it by using the query builder: SELECT percentile(cumulativeLayoutShift,75) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max facet deviceType Create and edit Service Levels To create SLIs and SLOs, go to the Service Levels tab at any workload in New Relic One and follow these steps: Select the SLI data source In order to define your new SLI, choose one of these two options: Entity data: Base the SLI on standard data coming from New Relic One agents. This is the most common option. If this is your choice, select the entity (for example, APM service) you want to use. Custom data: Alternatively, you can base the SLI on your custom NRDB events. Use this option when you can't relate the service level data to a specific entity, or when you want to relate the service level directly to a workload. Configure the queries The account where the data is gathered from matches the account of the entity that the SLI refers to. The rest of the fields correspond to the NRDB event that goes into the FROM clause, as well as the WHERE clauses that determine what is a valid and a good/bad event. Please see the section above to know what goes into each field. On the left you’ll see the final queries; and at the bottom you’ll get a preview of the count of valid and good/bad events in the last month. Important SLI queries support NRDB events, but not dimensional metrics yet. Set the SLO time window and target In this step you’ll get a preview of the SLI value. You can add one or more SLOs for this SLI. Just select the length of the time window and the percentage target. The chart on the left will help you anticipate whether the target you’re setting is feasible or if it's often missed. Rolling time-window SLOs are supported. With a rolling time-window, the SLO compliance takes into account the last N days. Every minute, the oldest data drops out of the current calculation and new data replaces it. Define your SLI Select a short name for your SLI that helps you recognize what it’s measuring. Optionally, you may add a description. Edit SLIs After you’ve created an SLI, access the UI and click on the ... menu to edit it:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.2171,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create and edit <em>Service</em> <em>Levels</em>",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": "BETA FEATURE This feature is currently in beta. You can create SLIs and SLOs manually through the New Relic UI. Alternatively, you can automate the process with our NerdGraph API and the Terraform <em>Service</em> <em>Level</em> resource. Important In order to create <em>Service</em> Levels you need a role with permissions"
      },
      "id": "61ab3a71196a67792ad10bd6"
    }
  ],
  "/docs/service-level-management/intro-slm": [
    {
      "sections": [
        "Service Levels Management: Questions and next steps",
        "BETA FEATURE",
        "What permissions do I need to use New Relic's Service Levels?",
        "How do I get support from New Relic during the public beta?",
        "Why don’t I see any data right after I create an SLI?",
        "Can I configure an SLI on any entity type?",
        "Can I get alerts on SLI data?",
        "How does New Relic calculate the remaining error budget?",
        "How can I view the queries that define an SLI from the UI?",
        "How can I view the queries that define an SLI through the API?",
        "Can I chart the SLI attainment on a dashboard?"
      ],
      "title": "Service Levels Management: Questions and next steps",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started",
        "Service Level Management"
      ],
      "external_id": "262058f4dc430fbaee0382261f79de147e348f53",
      "image": "https://docs.newrelic.com/static/763695119ceaa7668fdb3fb858c83c75/c1b63/slm_edit_menu_2.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/faqs-slm/",
      "published_at": "2021-12-25T02:33:00Z",
      "updated_at": "2021-12-25T02:33:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic's Service Levels? To use New Relic's Service Levels and see SLO results, you need a full platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify events to metric rules. If you get the following errors, check your user permissions: The UI has disabled the option to save an SLI/SLO. The API returns the error message “Cannot query field \\\"eventExportRegisterRule\\\" on type \\\"RootMutationType\\\".”. How do I get support from New Relic during the public beta? Service Levels Management is in public beta, and no official support is offered yet through the Support portal. If you have general questions and feedback, please post them on the Explorers Hub. New Relic’s community and the product team will be glad to help you there. If you have suggestions about documentation, please suggest an improvement or send your contribution using the Create issue or Edit page buttons on the top right corner in the docs UI. Why don’t I see any data right after I create an SLI? New Relic starts generating new SLI metrics from the moment that you create an SLI. This is why we need a few minutes before we can start showing the first meaningful SLI attainment results. The benefit of the new data is that it has 13 month retention by default, and it’s more efficient to query for long periods of time. Can I configure an SLI on any entity type? Yes, you can configure an SLI on any entity type, such as an APM service, a browser application, or a Lambda function. SLI queries support NRDB events. Support for dimensional metrics on SLI queries is on our roadmap. Can I get alerts on SLI data? Alerts on New Relic's Service Levels are on our roadmap. How does New Relic calculate the remaining error budget? The remaining error budget indicates what percentage of requests could still have a bad response over the SLO period without compromising the objective. Therefore, the total amount of tolerated bad responses will vary with the throughput of requests. Time-based error budgets are on our roadmap. How can I view the queries that define an SLI from the UI? To view the queries that define an SLI, you can click on the ... menu on the SLI summary card, then select the Edit option. The queries will show at the top-right corner. How can I view the queries that define an SLI through the API? To view the queries that define an SLI through the API, use Nerdgraph. In order to view the SLI configuration, you'll need to know the GUID of the entity the SLI is attached to, and replace it in the following query: { actor { entity(guid: \"{entityGuid}\") { serviceLevel { indicators { events { badEvents { where from } goodEvents { from where } validEvents { from where } } name } } } } } Copy As a response you are going to receive all the SLIs attached to the entity, the SLI name, and the queries. Keep in mind that either goodEvents or badEvents is going to have content, depending on the configuration of the SLI. Can I chart the SLI attainment on a dashboard? You can chart SLI attainment time series on your custom dashboards using the following query: FROM Metric SELECT clamp_max((count(newrelic.sli.valid) - count(newrelic.sli.bad)) / count(newrelic.sli.valid) * 100, 100) as 'SLI attainment' WHERE sli.id = '<sli.id>' UNTIL 2 MINUTES AGO TIMESERIES AUTO Copy Where sli.id is the SLI identifier. The easiest way to add a chart like this to your dashboard is by using the Add to dashboard option, available on the Details view. Alternatively, you can find the SLI id and SLI attainment query through the Nerdgraph API with the following query: { actor { entity(guid: \"{entityGuid}\") { serviceLevel { indicators { name id resultQueries { indicator { nrql } } } } } } } Copy Use the entityGuid of the entity that's associated with the SLI. On the query results, you’ll get the SLI id in the serviceLevel.indicators.id field.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 529.46246,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Service</em> <em>Levels</em> <em>Management</em>: Questions and next steps",
        "sections": "<em>Service</em> <em>Levels</em> <em>Management</em>: Questions and next steps",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": " find the SLI id and SLI attainment query through the Nerdgraph API with the following query: { actor { entity(guid: &quot;{entityGuid}&quot;) { <em>serviceLevel</em> { indicators { name id resultQueries { indicator { nrql } } } } } } } Copy Use the entityGuid of the entity that&#x27;s associated with the SLI. On the query results, you’ll <em>get</em> the SLI id in the <em>serviceLevel</em>.indicators.id field."
      },
      "id": "61ab3a9d28ccbc492ac23ee2"
    },
    {
      "sections": [
        "New Relic guided install overview",
        "Why it matters",
        "Some technical detail",
        "Important",
        "On-host integration (OHI) recipes",
        "Troubleshoot common problems",
        "MySQL: Incorrect user permissions",
        "NGINX: No status URL"
      ],
      "title": "New Relic guided install overview",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started"
      ],
      "external_id": "78c43fb865811c44f388f0601e0fb5f7da82fe87",
      "image": "https://docs.newrelic.com/static/6bf45ccf002250f7ebaa69cbe3ff706c/c1b63/guided-install-cli.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/cross-product-functions/install-configure/new-relic-guided-install-overview/",
      "published_at": "2021-12-25T21:43:08Z",
      "updated_at": "2021-12-14T03:50:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you haven't already, sign up for a free New Relic account so you can instrument your systems and send telemetry data to New Relic. Our guided install creates a customized CLI command for your environment that downloads and installs the New Relic CLI and the infrastructure agent. Ready to get started? Click the Guided install button. Or, if your account reports data through our EU data center, click EU Guided install. Guided install EU Guided install Our infrastructure agent discovers the applications and infrastructure and log sources running in your environment, and recommends which ones should be instrumented. The install automates the configuration and deployment of each system you choose to instrument. Why it matters With our guided install, you can instrument your applications and infrastructure and start seeing your data in New Relic in minutes. The guided install uses our command line interface (CLI), the infrastructure agent for your host environment, and a library of installation recipes to instrument your applications and infrastructure for you. That means less toil for you. Because our instrumentation recipes are open source, you can modify existing recipes, or build new ones, to suit your needs. Some technical detail The New Relic guided install uses open source installation recipes to instrument on-host integrations. These recipes include installation and setup commands, information about logs, and metadata related to what’s being installed. They're collected in a YAML file for each type of system and have all of the installation details necessary to install the infrastructure agent for a specific integration. Important On Windows, our guided install only supports Microsoft SQL Server, logs, and the infrastructure agent. All other integrations are only supported on Linux. On-host integration (OHI) recipes The guided install automates the discovery, configuration, and installation of OHIs. However, there may be times when you want to instrument them one-by-one using the CLI install command. To install any individual on-host integration, run this command: curl -Ls https://raw.githubusercontent.com/newrelic/newrelic-cli/master/scripts/install.sh | bash && sudo NEW_RELIC_API_KEY=API_KEY NEW_RELIC_ACCOUNT_ID=ACCOUNT_ID /usr/local/bin/newrelic install -n INTEGRATION-FLAG Copy For example: curl -Ls https://raw.githubusercontent.com/newrelic/newrelic-cli/master/scripts/install.sh | bash && sudo NEW_RELIC_API_KEY=<API_KEY> NEW_RELIC_ACCOUNT_ID=<ACCOUNT_ID> /usr/local/bin/newrelic install -n apache-open-source-integration Copy The table lists the integrations supported by the guided install CLI command. The specific on-host integration commands are provided for your reference. Our open source integrations send performance metrics and inventory data from your servers and applications to the New Relic platform. You can view pre-built dashboards of your metric data, create alert policies, and create your own custom queries and charts. Integration Command Apache newrelic install -n apache-open-source-integration Cassandra newrelic install -n cassandra-open-source-integration Couchbase newrelic install -n couchbase-open-source-integration ElasticSearch newrelic install -n elasticsearch-open-source-integration HAProxy newrelic install -n haproxy-open-source-integration HashiCorp Consul newrelic install -n hashicorp-consul-open-source-integration Memcached newrelic install -n memcached-open-source-integration Microsoft SQL Server (Windows only) newrelic install -n mssql-server-integration-installer MongoDB newrelic install -n mongodb-open-source-integration MySQL newrelic install -n mysql-open-source-integration Nagios newrelic install -n nagios-open-source-integration Nginx newrelic install -n nginx-open-source-integration PostgreSQL newrelic install -n postgres-open-source-integration RabbitMQ newrelic install -n rabbitmq-open-source-integration Redis newrelic install -n redis-open-source-integration Varnish Cache newrelic install -n varnish-cache-open-source-integration Troubleshoot common problems As we identify areas where the guided install fails, we'll document them here and provide some troubleshooting guidance. MySQL: Incorrect user permissions To monitor MySQL health data, you need a valid username and password with specific permissions. These commands will create a user and grant the required permissions: Create a user newrelic@localhost with a specific password. sudo mysql -e \"CREATE USER 'newrelic'@'localhost' IDENTIFIED BY 'YOUR_SELECTED_PASSWORD';\" Copy Give replication privileges to newrelic@localhost with a maximum of 5 connections. sudo mysql -e \"GRANT REPLICATION CLIENT ON *.* TO 'newrelic'@'localhost' WITH MAX_USER_CONNECTIONS 5;\" Copy Give select privileges to newrelic@localhost with a maximum of 5 connections. sudo mysql -e \"GRANT SELECT ON *.* TO 'newrelic'@'localhost' WITH MAX_USER_CONNECTIONS 5;\" Copy Once done, your next guided install attempt should work. NGINX: No status URL To monitor your NGINX server, you'll need to configure a valid status URL. status_url: The URL set up to provide the metrics using the status module. If the default value of 127.0.0.1 is incorrect, substitute the address/FQDN/URL for your system. Example: status_url: http://127.0.0.1/status You can read more about the status_url in these NGINX docs: For NGINX Open Source: HTTP stub status module For NGINX Plus: HTTP status module and HTTP API module There are different ways to set status_url, depending on how NGINX was installed: If enabled via Kubernetes: See Monitor services running on Kubernetes. If enabled via Amazon ECS: See Monitor services running on ECS. If installed on-host: Edit the config in the integration's YAML config file, nginx-config.yml.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 325.55585,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Full</em>-<em>Stack</em> <em>Observability</em>",
        "body": "If you haven&#x27;t already, sign up for a free New Relic account so you can instrument your systems and send telemetry data to New Relic. Our guided install creates a customized CLI command for your environment that downloads and installs the New Relic CLI and the infrastructure agent. Ready to <em>get</em>"
      },
      "id": "61b8148c64441fb9d3d703b5"
    },
    {
      "sections": [
        "Create and edit SLIs and SLOs",
        "BETA FEATURE",
        "Important",
        "Key concepts to create SLIs and SLOs",
        "The SLI entity",
        "SLI queries",
        "Suggested SLIs",
        "SLIs for APM services instrumented with the New Relic agent",
        "Service availability",
        "Service latency",
        "SLIs for APM services instrumented with OpenTelemetry",
        "SLIs for browser applications",
        "Browser app largest contentful paint",
        "Browser app first input delay",
        "Browser app cumulative layout shift",
        "Create and edit Service Levels",
        "Select the SLI data source",
        "Configure the queries",
        "Set the SLO time window and target",
        "Define your SLI",
        "Edit SLIs"
      ],
      "title": "Create and edit SLIs and SLOs",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Service Level Management",
        "SLI/SLO",
        "Configure"
      ],
      "external_id": "ac0e19e3d890a02dde12bd639c55d4bd02a61778",
      "image": "https://docs.newrelic.com/static/fffe62dc00eff1b932b5c76be5730e5a/c1b63/slm_edit_menu.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/create-slm/",
      "published_at": "2021-12-25T14:39:20Z",
      "updated_at": "2021-12-15T00:25:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. You can create SLIs and SLOs manually through the New Relic UI. Alternatively, you can automate the process with our NerdGraph API and the Terraform Service Level resource. Important In order to create Service Levels you need a role with permissions to modify and delete metric rules. Key concepts to create SLIs and SLOs Keep in mind these concepts when defining SLIs and SLOs. The SLI entity In the New Relic ecosystem, SLIs and SLOs are linked to entities, which are all the elements in your stack that report data to us, or that generate data that we have access to. The entity that an SLI is related to determines where the SLI/SLO results show. And the entity's tags help filter down SLI results on the Service Levels view. You can define SLIs on any NRDB event that is reported to New Relic, and therefore you can also base SLIs on custom events. Most custom events are not related to a single New Relic entity, but provide higher level business and user experience insights. In this case, you can still relate the SLI to a specific entity or to a workload. SLI queries SLIs are defined as the percentage of good responses out of the total number of valid requests. Most often you’ll set up your SLIs by defining the valid and good pieces: A valid request is any request that you want to count as meaningful for your SLIs (for example, all transactions related to an endpoint that weren’t initiated by a health check). A good response is any response that you consider to provide a good output for the end-user or client service (for example, the service responded in less than 2 seconds, providing a good navigation experience for the end user). Alternatively, you can define what you consider to be the bad responses instead: A bad response is any response that you consider to provide a bad output (for example, the service responded with a server error, causing the client to fail its flow). New Relic will automatically derive the count of good responses as valid - bad. Request-based SLOs are based on an SLI defined as the ratio of the number of good requests to the total number of requests. A request-based SLO is met when that ratio meets or exceeds the goal for the compliance period. Suggested SLIs In this section you’ll find some SLIs that are typically used to measure the performance of services and browser applications. SLIs for APM services instrumented with the New Relic agent Based on Transaction events, these SLIs are the most common for request-driven services: Service availability Service availability is the ratio of the number of successful responses to the number of all requests. This effectively is an error rate, but you can filter it down, for example removing expected errors. Valid events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Bad events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' AND error IS TRUE Copy Where {entityGuid} is the service's GUID. Service latency A latency SLI measures the proportion of valid requests that were served faster than the threshold established as a good experience. In order to determine that duration threshold, check how the service has been performing in the past weeks, and use that result as a realistic and achievable baseline. Afterwards, you can iterate on the SLI threshold, and align it with a more ambitious performance. To select an appropriate value for the duration condition, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find this duration threshold using the query builder, and use it to determine what you consider to be good events for your SLI: select percentile(duration, 95) from Transaction where entityGuid = '{entityGuid}' since 7 days ago limit max Valid events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Good events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' and duration < {duration} Copy Where {entityGuid} is the service's GUID. Where {duration} is the response time that you consider provides a good experience for your client service or end-user, in seconds. SLIs for APM services instrumented with OpenTelemetry Based on OpenTelemetry spans, these SLIs are the most common for request-driven services: Service availability Service availability is the ratio of the number of successful responses to the number of all requests. This effectively is an error rate, but you can filter it down, for example removing expected errors. Valid events fields FROM: Span WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) Copy Where {entityGuid} is the service's GUID. Bad events fields FROM: Span WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) AND otel.status_code = 'ERROR' Copy Where {entityGuid} is the service's GUID. Service latency A latency SLI measures the proportion of valid requests that were served faster than the threshold established as a good experience. In order to determine that duration threshold, check how the service has been performing in the past weeks, and use that result as a realistic and achievable baseline. Afterwards, you can iterate on the SLI threshold, and align it with a more ambitious performance. To select an appropriate value for the duration condition, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find this duration threshold using the query builder, and use it to determine what you consider to be good events for your SLI: select percentile(duration.ms, 95) from Span where entityGuid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) since 7 days ago limit max Valid events fields FROM: Span WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) Copy Where {entityGuid} is the service's GUID. Good events fields FROM: Span WHERE: entity.guid = '{entityGuid}' AND (span.kind IN ('server', 'consumer') OR kind IN ('server', 'consumer')) AND duration.ms < {duration} Copy Where {entityGuid} is the service's GUID. Where {duration} is the response time that you consider provides a good experience for your client service or end-user, in seconds. SLIs for browser applications The following SLIs are based on Google’s Browser Core Web Vitals. Browser app largest contentful paint It’s the proportion of valid page views where the largest content element visible in the viewport was rendered faster than the threshold considered to correspond to a good experience. Valid events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Good events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' and largestContentfulPaint<'{largestContentfulPaint}' Copy Where {entityGuid} is the browser app GUID. Where {largestContentfulPaint} is the amount of time (in milliseconds) to render the largest content element visible in the viewport that you consider provides a good experience for your end user. A frequent standard is 4000 ms. To determine a realistic number to use for {largestContentfulPaint} in your environment, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find it by using the query builder: SELECT percentile (largestContentfulPaint,95) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max Browser app first input delay It’s the proportion of page views where the time between a user's first interacion with the page and the time when the browser responds to that interaction is less than a certain threshold. Valid events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Good events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' and firstInputDelay<{firstInputDelay} Copy Where {entityGuid} is the browser app GUID. Where {firstInputDelay} is the amount of time (in milliseconds) the browser should respond in to provide a good experience for your end user. A frequent standard is 300 ms. To determine a realistic number to use for {firstInputDelay} in your environment, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find it by using the query builder: SELECT percentile(firstInputDelay,95) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max facet deviceType Browser app cumulative layout shift It’s the proportion of page views with a good cumulative layout shift (CLS). CLS is described as the total sum of all individual layout shift scores for every unexpected layout shift that occurs during the entire lifespan of the page. A layout shift occurs any time a visible element changes its position from one rendered frame to the next. Valid events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. If you’d like to create separate SLIs to track CLS in desktop and mobile devices separately, add one of these clauses at the end of the field: and deviceType = 'Mobile' and deviceType = 'Desktop' Good events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' and cumulativeLayoutShift < {cumulativeLayoutShift} Copy Where {entityGuid} is the browser app GUID. Where {cumulativeLayoutShift} is a pre-set value. To provide a good user experience, your site should strive to have a CLS score of 0.1 or less. A CLS score of 0.25 or more is considered a poor user experience. If you’ve decided to create separate SLIs to track CLS in desktop and mobile devices separately when you defined the valid events query, add this clause at the end of the field: and deviceType = 'Mobile' and deviceType = 'Desktop' To determine a realistic number to select for {cumulativeLayoutShift} in your environment, one typical practice is to select the 75th percentile of page loads for the last 7 or 15 days, segmented across mobile and desktop devices. Find it by using the query builder: SELECT percentile(cumulativeLayoutShift,75) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max facet deviceType Create and edit Service Levels To create SLIs and SLOs, go to the Service Levels tab at any workload in New Relic One and follow these steps: Select the SLI data source In order to define your new SLI, choose one of these two options: Entity data: Base the SLI on standard data coming from New Relic One agents. This is the most common option. If this is your choice, select the entity (for example, APM service) you want to use. Custom data: Alternatively, you can base the SLI on your custom NRDB events. Use this option when you can't relate the service level data to a specific entity, or when you want to relate the service level directly to a workload. Configure the queries The account where the data is gathered from matches the account of the entity that the SLI refers to. The rest of the fields correspond to the NRDB event that goes into the FROM clause, as well as the WHERE clauses that determine what is a valid and a good/bad event. Please see the section above to know what goes into each field. On the left you’ll see the final queries; and at the bottom you’ll get a preview of the count of valid and good/bad events in the last month. Important SLI queries support NRDB events, but not dimensional metrics yet. Set the SLO time window and target In this step you’ll get a preview of the SLI value. You can add one or more SLOs for this SLI. Just select the length of the time window and the percentage target. The chart on the left will help you anticipate whether the target you’re setting is feasible or if it's often missed. Rolling time-window SLOs are supported. With a rolling time-window, the SLO compliance takes into account the last N days. Every minute, the oldest data drops out of the current calculation and new data replaces it. Define your SLI Select a short name for your SLI that helps you recognize what it’s measuring. Optionally, you may add a description. Edit SLIs After you’ve created an SLI, access the UI and click on the ... menu to edit it:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.21704,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create and edit <em>Service</em> <em>Levels</em>",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": "BETA FEATURE This feature is currently in beta. You can create SLIs and SLOs manually through the New Relic UI. Alternatively, you can automate the process with our NerdGraph API and the Terraform <em>Service</em> <em>Level</em> resource. Important In order to create <em>Service</em> Levels you need a role with permissions"
      },
      "id": "61ab3a71196a67792ad10bd6"
    }
  ],
  "/docs/style-guide/capitalization/capitalization": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-25T06:04:19Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.3778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-25T15:04:59Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-25T05:51:50Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.4676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/formatting/buttons": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-25T06:04:19Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.37778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-25T15:04:59Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.99396,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-25T05:51:50Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.46756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/formatting/callouts": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-25T06:04:19Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.37778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-25T05:51:50Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.46756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    },
    {
      "sections": [
        "Lists",
        "Tip",
        "In-line lists"
      ],
      "title": "Lists",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "c8dd72524718c4e6e1d36d0f23b9af6ab4203e2a",
      "image": "https://docs.newrelic.com/static/425a3955215de94222a432e13be5dc84/8c557/tables-example.png",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/lists/",
      "published_at": "2021-12-25T06:03:29Z",
      "updated_at": "2021-11-24T09:17:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Lists are a powerful way to organize information, but they don't always make for a pleasant reading experience. Keep these points in mind when you're writing a list: Always capitalize the first letter of the first word in each list item. Use ordered (numbered) lists for step-by-step procedures, where the order matters. Use unordered (bulleted) lists to make it easier for users to skim related information. Use OR on a separate line when there is more than one option for a numbered step or a bullet point. Use tables when your ordered or unordered list would benefit from some extra detail. Tip For punctuation guidelines, follow the Microsoft Writing Style Guide, which includes considerations for localization. Here's an example of an ordered list as a table. Because each step is a row, the table helps to structure the levels of detail. In-line lists As an alternative to using bullet point lists, you can do an in-line list, like this: C SDK | Go | Java. You might want to use an in-line list when: You're linking to further documentation. Customers will likely be selecting a single option. The list item can be displayed with a short word or phrase (like Java, or Infrastructure). You think a bullet point list takes up a lot of vertical space. This may happen in circumstances where a procedure must include several lists. Here's one example of this. There are only two or three potential options they'll be choosing from and a bullet point list seems unnecessary. Here's an example.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.4666,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " For punctuation guidelines, follow the Microsoft Writing <em>Style</em> <em>Guide</em>, which includes considerations for localization. Here&#x27;s an example of an ordered list as a table. Because each step is a row, the table helps to structure the levels of detail. In-line lists As an alternative to using bullet point"
      },
      "id": "60421e4e28ccbc71a9eba7a2"
    }
  ],
  "/docs/style-guide/formatting/code-examples": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-25T06:04:19Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.37775,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-25T15:04:59Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.99393,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-25T05:51:50Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.46753,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/formatting/code-formatting-guidelines-var-mark": [
    {
      "sections": [
        "Code references",
        "For inline code or data (<code>)",
        "For multi-line code blocks (<pre>)",
        "Highlight user input with <var>",
        "Highlight important sections with <mark>",
        "Add syntax highlighting",
        "Link to other docs",
        "Formatting terminal commands"
      ],
      "title": "Code references",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "9b4c6e235a285475be7ba8afd23936ce3d4cf923",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/code-examples/",
      "published_at": "2021-12-25T05:19:12Z",
      "updated_at": "2021-11-24T09:04:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We use a variety of formatting to highlight code or other technical language. You can use the <code>, <pre>, and <var> tags to indicate \"raw\" technical content such as excerpts from a config file, an API method name, or a file path. The following table provides some examples of our use of code format. For this... Example Command line utility names To install the utility, use apt. File paths and file names The agent looks for newrelic.config in the %ALLUSERSPROFILE%\\New Relic\\.NET Agent directory. Insights event names and attributes To analyze APM errors, use the TransactionError event. Method names To initialize the APM agent, use startAgent(). Non-clickable URLs In your web browser, navigate to the minion Overview page at http://MINION_IP_ADDRESS. The <var> formatting automatically applies color coding and italics in this situation. These sections break down when to use specific types of code formatting. For inline code or data (<code>) To surround small blocks of code or data (single words or lines), mark as code: Source: Use <code> tags. Markdown: Surround the text with backtick ` characters. For multi-line code blocks (<pre>) To surround longer blocks of data that run multiple lines, mark as preformatted text: Source: Use <pre> tags. Markdown: Do not use Markdown-style indented code formatting, as this can cause unexpected formatting problems. Highlight user input with <var> Use the <var> tag to highlight areas of a code block where a user is expected to supply their own value. For more context on when to use <var> tags, see < var> formatting guidelines. Follow these guidelines when you use <var> tags: Address the reader directly Use all caps and underscores _ to separate words (also known as SCREAMING_SNAKE_CASE). Don't use other punctuation (such as wrapping the text in angle brackets). Exception: REST API examples use a ${VARNAME} syntax inspired by Bash conventions. Standard examples: echo \"license_key: YOUR_LICENSE_KEY\" | sudo tee -a /etc/newrelic-infra.yml Copy msiexec.exe /qn /i PATH\\TO\\newrelic-infra.msi Copy https://rpm.newrelic.com/accounts/ACCOUNT_ID/applications/APP_ID Copy REST API v2 example: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=average_call_time&values[]=call_count&from=2014-03-01T20:59:00+00:00&to=2014-03-01T21:59:00+00:00&summarize=true' Copy Highlight important sections with <mark> Use the <mark> tag to highlight areas of a code block that are particularly important. Most commonly, <mark> is used to highlight New Relic API methods in sample code that contains a lot of \"other logic.\" When you use <mark>, you should usually follow the code block with a list of bullets that explain what each API call is doing and link to method syntax. For more context on when to use <mark> tags, see < mark> formatting guidelines. Examples: Example of using the <mark> tag private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal(DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()) ; // fire and forget DB_POOL.submit(() -> { segment.end() ; insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For method syntax, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in APM with datastore data. For more information, see reportAsExternal API. For method syntax, see the Javadoc. segment.end(): Stops timing this segment. For method syntax, see the Javadoc. Add syntax highlighting To add syntax highlighting to a code block, add class=\"highlight\" to the <pre> tag. The syntax highlighter tries to auto-detect the language. If it's not working as expected, ensure the language is supported and specify the language by adding the a lang-LANG-NAME class (for example: lang-html). View a full list of supported languages for syntax highlighting. Element colors and themes are fully customizable. Link to other docs You can add <a href> tags inside a <pre> blocks, just as you would any other content. However, make sure to use them judiciously since they can be easy to miss. A good example is the Infrastructure config file template, where each config element links to the relevant section of the main config doc. Formatting terminal commands If you have sentences that mention single-word system commands, surround these words in code tags (Markdown uses backticks ` for this) so translators don't confuse these words with words in general usage. Here are some words that translators or readers could confuse: curl: Sends http requests via a terminal session–not to be confused with the curls you do with weights at the gym. cat: Lists the first ten lines of a file–not a feline pet who ignores you. date: Displays the day, year, and time–not an outing that couples take. tail: Displays the last ten lines of a file–not the appendage on various mammals. which: Show the location of a program executable–not the pronoun. The moral of the story: If you think a reader or translator might confuse a command with a general English word, just enclose it in backticks (`).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.07878,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Code</em> references",
        "sections": "<em>Formatting</em> terminal commands",
        "body": " lines, <em>mark</em> as preformatted text: Source: Use &lt;pre&gt; tags. Markdown: Do not use Markdown-style indented <em>code</em> <em>formatting</em>, as this can cause unexpected <em>formatting</em> problems. Highlight user input with &lt;<em>var</em>&gt; Use the &lt;<em>var</em>&gt; tag to highlight areas of a <em>code</em> block where a user is expected to supply their own"
      },
      "id": "619e001be7b9d23c04fe7524"
    },
    {
      "sections": [
        "Format overview"
      ],
      "title": "Format overview",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "19cdfd626e9695a9576778f2151a883cfe9b9f80",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/format-overview/",
      "published_at": "2021-12-25T05:19:12Z",
      "updated_at": "2021-11-24T09:02:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Generally, follow the Microsoft Style Guide for formating common text elements. You can find code formatting info in the code examples page of this guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.31944,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Format</em> overview",
        "sections": "<em>Format</em> overview",
        "body": "Generally, follow the Microsoft Style Guide for formating common text elements. You can find <em>code</em> <em>formatting</em> info in the <em>code</em> examples page of this guide."
      },
      "id": "619dffb5196a6712afa098a4"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/agile-handbook/heroing/managing-the-github-boards/",
      "sections": [
        "Managing the GitHub boards",
        "A note on Assignee vs Reviewer",
        "Drafts column",
        "Hero to triage column",
        "Hero: To do column",
        "In progress/being reviewed column",
        "Writer needs PR review column",
        "Writer needs peer edit column",
        "Waiting on SME/blocked column",
        "Waiting on TW to merge column",
        "Tip"
      ],
      "published_at": "2021-12-25T14:39:20Z",
      "title": "Managing the GitHub boards",
      "updated_at": "2021-10-31T02:28:56Z",
      "type": "docs",
      "external_id": "8552cb5f3cec74364831b7d0d85a5d3bdd734e09",
      "document_type": "page",
      "popularity": 1,
      "body": "The Docs pull requests and Issues board is our source of truth for what's going on in our project. The board is divided into a series of columns so we can see visually what the status of each issue and pull request is. A note on Assignee vs Reviewer Assignee and Reviewer have different meanings: Assignee means you own the pull request or issue and are getting it into a merge-ready state. If you are no longer owning a given pull request or issue, take your name off as assignee. Reviewer means you are actively reviewing a pull request. If it's a pull request from outside the docs team, the reviewer is also responsible for merging the pull request into develop. If you're reviewing a pull request from a fellow docs writer, add your comments and mark the pull request as Approved, then move it to Waiting on TW to merge. Drafts column These issues and pull requests are in a draft state. Do not merge until their owner moves them out of the column. This column should only be for draft pull requests. Do not \"hold\" pull requests or issues here. The Hero should look at this column multiple times per day in case a pull request has been marked ready for review. Move any ready-for-review pull requests into the correct column. Hero to triage column New issues and pull requests flow into this column automatically. As hero, you need to triage each one: Determine if the pull request or issue is content-related. If it's an eng issue or pull request, you can just Archive it to remove it from the board. Assign mandatory labels: Label type Required on Description content Issues and pull requests Use this label to indicate an issue or pull request relates to content (versus the code of the site). from_ Issues and pull requests Use this label to indicate who created the issue or pull request. Use from_tw when it's created by a docs writer, from_internal when it's created by a Relic, and from_external when it's from outside the company. pg_ Issues Indicates which New Relic product group is associated with this issue. Give the ticket an assignee (most likely you). Move the ticket to the appropriate column. Hero: To do column Work that the GitHub has triaged, but hasn't started working on yet. Tickets in this column need to have an assignee. In progress/being reviewed column Work is underway on this issue or pull request. For example, reviewing pull requests from outside the team, doing a peer edit, investigating a GitHub issue. The person doing the work should make themselves the assignee as soon as they move the pull request or issue into this column to prevent others from duplicating work. Writer needs PR review column Exactly what it says. Typically, the writer who submitted the pull request will move it to this column. A pull request review means reviewing for basic stuff like is it rendering correctly, are there typos or wording issues, and are there any obvious errors in the .mdx content shown in the diff. Once you've reviewed the pull request, mark it approved in the GitHub review UI, and move it to the Waiting on TW to merge column. Writer needs peer edit column Also exactly what it says. As with pull request review column, the writer who submitted the pull request will drag to this column. This includes all the stuff in a pull request review plus an actual peer edit. Once you've reviewed the pull request and left your feedback in the GitHub review UI, mark it Approved and move it to the Waiting on TW to merge column. From there, the author of pull request is responsible for reviewing the feedback and updating it before merging. If you find significant issues (inaccuracies, bad formatting, build issues), don't mark it Approved. Waiting on SME/blocked column Blocked until something else happens. Usually this means it's waiting on answers or approval from the SME or the person who submitted the pull request. Waiting on TW to merge column When a docs writer creates a pull request, it's their responsibility to merge it into develop at the appropriate time. After a reviewer is done with their pull request review or peer edit, they move it into this column so the original writer can merge when ready. ← What is a hero? Appendix: Ticket best practices → Tip We welcome thoughts or questions on our handbook! The easiest way to get in touch is to file a GitHub issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.61038,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " issues (inaccuracies, bad <em>formatting</em>, build issues), don&#x27;t <em>mark</em> it Approved. Waiting on SME&#x2F;blocked column Blocked until something else happens. Usually this means it&#x27;s waiting on answers or approval from the SME or the person who submitted the pull request. Waiting on TW to merge column When"
      },
      "id": "616c0d6628ccbcbb0b003a72"
    }
  ],
  "/docs/style-guide/formatting/format-overview": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-25T06:04:19Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.37775,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-25T15:04:59Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.99393,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-25T05:51:50Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.46753,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/formatting/hyperlinks": [
    {
      "sections": [
        "apiStyleGuidelines (Example agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Return values",
        "Examples",
        "URL guidelines",
        "Title guidelines",
        "Short title guidelines",
        "Syntax guidelines",
        "Important"
      ],
      "title": "apiStyleGuidelines (Example agent API)",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "API writing guidelines"
      ],
      "external_id": "fb967e77ea9a94d7a35329c0c87062ff93ab2ff8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/apistyleguidelines-example-agent-api/",
      "published_at": "2021-12-25T17:20:58Z",
      "updated_at": "2021-11-26T09:14:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.apiStyleGuidelines(data type $parameter_name[, integer $optional_param]) newrelic.apiStyleGuidelines(data type $parameter_name, array $different_param, string $third_param) Copy Briefly describe the call. Ideally, one line or less on the \"View all methods\" page. Requirements Agent version 1.2.3.4 or higher. Additional requirements on their own line (do not use bullets). Do not use any callouts. If there are no special requirements, write: Compatible with all agent versions. Description Describe the behavior of the call with as much detail as possible. Do not describe what individual parameters do except in broad strokes; details of parameters and call variants belong under the Parameters heading. Similarly, do not describe return values. When cross-referencing another API call, format its name with code blocks, and include parentheses () like this: anotherCoolMethod(). Tip You can include callouts, but use discretion. These pages are already visually busy. Parameters If there are no parameters, leave this section blank. If there is only one call variant, do not include a syntax block in this section. Parameter Description newrelic.apiStyleGuidelines(data type $parameter_name[, integer $optional_param]) Copy $parameter_name data type Required. Brief description of parameter. $optional_param integer Optional. Brief description of parameter. newrelic.apiStyleGuidelines(data type $parameter_name, array $different_param) Copy $parameter_name data type Required. Brief description of parameter. $different_param array Required. Brief description of parameter. $third_param string Required. Brief description of parameter. Return values What does this call return, and in what circumstances? Are there any things we expect customers to do with that return value? If the call does not return anything, leave this section blank. Examples This section documents rules for oddballs that aren't self-documenting. The rest of the examples are embedded within the page itself. In general, this page is intended for style reference. For examples of how to write good API method pages, check out our existing API docs, such as the PHP API. URL guidelines For the doc's URL: Manually edit the URL slug to remove the agent name. Where the API call does not already include separators (as in newrelic_awesome_call), separate the bits with hyphens -. For example: https://docs.newrelic.com/docs/new-relic-only/advanced-style-guide/writing-guidelines/api-style-guidelines Copy Title guidelines For the doc's title: Include the method name and the agent name in parentheses. Do not include newrelic. prefixes unless they are integral to the call name (as in the PHP agent). Do not include parentheses () in the call itself. For example: apiStyleGuidelines (Example agent API) Copy Short title guidelines For the doc's short title: Include only the method name. Do not include newrelic. prefixes unless they are integral to the call name (as in the PHP agent). Do not include parentheses (). Adjust if necessary to fit on a single line in the category's sidebar. For example: apiStyleGuidelines Copy Syntax guidelines Important The Python and iOS agents use their own guidelines. For those guidelines, see the existing methods in those languages. Document each variant of a call on its own line. Do not use any formatting except italicizing the data type. Wrap optional parameters (including the comma separator) in square brackets []. Indicate the variable portion by prefacing it with a dollar sign $. If the call must be prefixed with newrelic. or similar, include that in the syntax. Optional: Include the return value, if that seems important for your particular agent. If you do, follow language conventions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.28574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "URL <em>guidelines</em>",
        "tags": "API writing <em>guidelines</em>",
        "body": "Syntax newrelic.apiStyle<em>Guidelines</em>(data type $parameter_name[, integer $optional_param]) newrelic.apiStyle<em>Guidelines</em>(data type $parameter_name, array $different_param, string $third_param) Copy Briefly describe the call. Ideally, one line or less on the &quot;View all methods&quot; page. Requirements Agent"
      },
      "id": "61ab484ee7b9d293670e847e"
    },
    {
      "sections": [
        "API tutorial template",
        "Introduction (this heading will not be visible)",
        "Optional: Provide an overview for complex processes",
        "Provide a procedure to accomplish the task",
        "Tip",
        "Step 1. Do something...",
        "If needed: Step 2. Do something else...",
        "If needed: Step 3. Do something else...",
        "Last step. Verify that the task was completed...",
        "Optional: Do something else with the API",
        "Optional: Large example code block",
        "Code block example",
        "Optional: Troubleshooting"
      ],
      "title": "API tutorial template  ",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "API writing guidelines"
      ],
      "external_id": "b69605a3a5585b2ee7f89c250bbdd5345c5d9311",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/api-tutorial-template/",
      "published_at": "2021-12-25T17:20:29Z",
      "updated_at": "2021-11-26T09:14:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is a template for an API tutorial document: Please skim the entire template first to understand the expected structure for this type of doc. Then, clone this doc using the Clone content link in the Page tools box. Delete all content up to Introduction (this heading won't be visible). For the doc title (the field at top of page): Doc should be named in a practical, use-case-focused way. Example: Add custom attributes to transactions Introduction (this heading will not be visible) Provide a brief explanation of what this document will teach customers, and why it is valuable for customers to know how to do that. Focus on the value the API provides to the customers and mention specific, common use cases. Any relevant notes about support/compatability should go here, too. Here's an example from the Java API asynchronous tutorial doc: New Relic for Java includes an API to instrument asynchronous activity. For supported frameworks, the Java agent usually instruments async work automatically. However, the async API can be useful for adding more detail to your data. This document provides examples of using tokens and segments to instrument your app. Optional: Provide an overview for complex processes This is an optional section for complicated tutorials that involve either using several methods in one procedure or that have different alternate steps you can take to achieve similar results. This section can link to lower-down sections to allow users to skip around as needed. For simple tutorials, this section isn't necessary. For an example, see this section of the Java async tutorial. Provide a procedure to accomplish the task Tell the user how to accomplish the task, and link to the methods necessary to accomplish that task. As much as possible, we're looking to describe tasks in \"procedures\" (procedure is tech writer jargon for a series of numbered steps). This may be tough to do for fairly open-ended/variable tasks, but it will usually be possible to chunk the content at a fairly high-level to make it into a procedure. Along the way, explain what the importance of the procedure step is, and how one might verify that the step was done correctly. For code samples, avoid using large chunks of code. Instead, use smaller pieces of code and give context for how they are being used. (If you think a large app code example would be helpful, place that later in the doc in the Example section.) Tip For an example of an open-ended task segmented into procedural chunks, see the Asynchronous doc section Connecting async threads. For another example, see this TomCat GAE Flex procedure. Base your procedure on the simple structure below. Tech writers will edit your content to match our style and formatting requirements: Step 1. Do something... Methods and example code to implement the first step. For each step, if applicable, indicate the significance of that step (why it's important) and how the user might verify that the step was done correctly (for example, something showing up in UI, or running a verification test of some sort). If needed: Step 2. Do something else... Methods and example code to implement step 2. If needed: Step 3. Do something else... Methods and example code to implement step 3. Last step. Verify that the task was completed... Explain how a user would know they'd completed the task correctly. In particular, how would the user find the new change or data in the New Relic UI. What New Relic products and pages would the change be noticed on? If new data shows up in Insights, what event types can it be found under? Optional: Do something else with the API Same as above. Make as many headings and separate procedures as needed. Optional: Large example code block If you think a large app code example would be useful, place here. Within any code block, explain all New Relic functions/methods, not just the main methods. Instead of in-line comments, consider using highlighted sections underneath the code block to give additional context. Here's an example: Code block example The following code example shows a segment starting in the storeItem method to measure how long the Lambda statement is waiting in the thread pool. To stop timing the segment, you must call either .end() or .ignore(). If you don't want to report the segment as part of its parent transaction, call .ignore(). Otherwise, to report the segment as part of its parent transaction, call .end(). private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal (DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()); // fire and forget DB_POOL.submit(() -> { segment.end(); insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For more on this method, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in APM with datastore data. For more information, see reportAsExternal API. segment.end(): Stops timing this segment. For more on this method, see the Javadoc. Optional: Troubleshooting Optional area for any common errors or troubleshooting tips.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.28568,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "API writing <em>guidelines</em>",
        "body": "This document is a template for an API tutorial document: Please skim the entire template first to understand the expected structure for this type of doc. Then, clone this doc using the Clone content <em>link</em> in the Page tools box. Delete all content up to Introduction (this heading won&#x27;t be visible"
      },
      "id": "61b35723196a675e16a5b0a4"
    },
    {
      "sections": [
        "New Relic Metrics Adapter",
        "BETA FEATURE",
        "Requirements",
        "Installation",
        "Tip",
        "Configuration",
        "How it works",
        "Caution",
        "Troubleshooting",
        "Get verbose logs",
        "Get raw metrics",
        "Metrics not working"
      ],
      "title": "New Relic Metrics Adapter",
      "type": "docs",
      "tags": [
        "Integrations",
        "Kubernetes integration",
        "Link apps and services"
      ],
      "external_id": "e2a825763b10ccf4bd1bd8423e2209f66dfb61bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/kubernetes-pixie/kubernetes-integration/newrelic-hpa-metrics-adapter/newrelic-metrics-adapter/",
      "published_at": "2021-12-25T15:37:56Z",
      "updated_at": "2021-11-13T08:47:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is still in development, but we encourage you to try it out! You can use metrics from your New Relic account to autoscale applications and services in your Kubernetes cluster by deploying the New Relic Metrics Adapter. This adapter fetches the metric values from New Relic and makes them available for the Horizontal Pod Autoscalers. The newrelic-k8s-metrics-adapter implements the external.metrics.k8s.io API to support the use of external metrics based New Relic NRQL queries results. Once deployed, the value for each configured metric is fetched using the NerdGraph API based on the configured NRQL query. The metrics adapter exposes the metrics over a secured endpoint with TLS. New Relic metrics adapter in a cluster. Requirements Kubernetes 1.16 or higher. The New Relic Kubernetes integration. New Relic's user API key. No other External Metrics Adapter installed in the cluster. Installation To install the New Relic Metrics Adapter, we provide the newrelic-k8s-metrics-adapter Helm chart, which is also included in the nri-bundle chart used to deploy all New Relic Kubernetes components. If not already installed, install our Kubernetes integration. Upgrade the installation to include the New Relic Metrics Adapter with the following command: helm upgrade --install newrelic newrelic/nri-bundle \\ --namespace newrelic --create-namespace --reuse-values \\ --set metrics-adapter.enabled=true \\ --set newrelic-k8s-metrics-adapter.personalAPIKey=YOUR_NEW_RELIC_PERSONAL_API_KEY \\ --set newrelic-k8s-metrics-adapter.config.accountID=YOUR_NEW_RELIC_ACCOUNT_ID \\ --set newrelic-k8s-metrics-adapter.config.externalMetrics.external_metric_name.query=NRQL query Copy Please notice and adjust the following flags: metrics-adapter.enabled: Must be set to true so the metrics adapter chart is installed. newrelic-k8s-metrics-adapter.personalAPIKey: Must be set to valid New Relic Personal API key. newrelic-k8s-metrics-adapter.accountID: Must be set to valid New Relic account where metrics are going to be fetched from. newrelic-k8s-metrics-adapter.config.externalMetrics.<var>external_metric_name</var>.<var>query</var>: Adds a new external metric where: <var>external_metric_name</var>: The metric name. <var>query</var>: The base NRQL query that is used to get the value for the metric. Tip Alternatively, you can use a values.yaml file that can be passed to the helm command with the --values flag. Values files can contain all parameters needed to configure the metrics explained in the configuration section. Configuration You can configure multiple metrics in the metrics adapter and change some parameters to modify the behaviour of the metrics cache and filtering. To see the full list and descriptions of all parameters that can be modified, refer to the chart README.md and values.yaml files. How it works The following example is a Helm values file that enable the metrics adapter on the nri-bundle chart installation, and configures the nginx_average_requests metric: metrics-adapter: enabled: true newrelic-k8s-metrics-adapter: personalAPIKey: <Personal API Key> config: accountID: <Account ID> externalMetrics: nginx_average_requests: query: \"FROM Metric SELECT average(nginx.server.net.requestsPerSecond) SINCE 2 MINUTES AGO\" Copy Caution The default time span for metrics is 1h. Therefore, you should define queries with the SINCE clause to adjust the time span according to your environment and needs. There is an HPA consuming the external metric as follows: kind: HorizontalPodAutoscaler apiVersion: autoscaling/v2beta2 metadata: name: nginx-scaler spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: nginx minReplicas: 1 maxReplicas: 10 metrics: - type: External external: metric: name: nginx_average_requests selector: matchLabels: k8s.namespaceName: nginx target: type: Value value: 10000 Copy Based on the HPA definition, the controller manager fetches the metrics from the external metrics API which are served by the New Relic metrics adapter. The New Relic metrics adapter receives the query including the nginx_average_requests metric name and all the selectors, and searches for a matching metric name in the internal memory based on the configured metrics. Then, it adds the selectors to the query to form a final query that is executed using NerdGraph to fetch the value from New Relic. The above example will generate a query like the following: FROM Metric SELECT average(nginx.server.net.requestsPerSecond) WHERE clusterName=<clusterName> AND `k8s.namespaceName`='nginx' SINCE 2 MINUTES AGO Copy Notice that a clusterName filter has been automatically added to the query to exclude metrics from other clusters in the same account. You can remove it by using the removeClusterFilter configuration parameter. Also the value is cached for a period of time defined by the cacheTTLSeconds configuration parameter, whose default is 30 seconds. Troubleshooting Get verbose logs Most common errors are displayed in the standard (non-verbose) logs. If you're doing a more in-depth investigation on your own or with New Relic Support, you can enable verbose mode. To get verbose logging details for an integration using Helm: Enable verbose logging: bash Copy $ helm upgrade -n <namespace> --reuse-values newrelic-bundle --set newrelic-k8s-metrics-adapter.verboseLog=true newrelic/nri-bundle Leave on verbose mode for a few minutes, or until enough activity has occurred. When you have the information you need, disable verbose logging: bash Copy $ helm upgrade --reuse-values newrelic-bundle --set newrelic-k8s-metrics-adapter.verboseLog=false newrelic/nri-bundle Caution Verbose mode increases significantly the amount of information sent to log files. Enable this mode temporarily, only for troubleshooting purposes, and reset the log level when finished. Get raw metrics Sometimes it's useful to get the list of available metrics and also to get the current value of an specific metric. To get the list of metrics available, run: bash Copy $ kubectl get --raw \"/apis/external.metrics.k8s.io/v1beta1/\" To get the value for a specific metric with a selector, run: bash Copy $ kubectl get --raw \"/apis/external.metrics.k8s.io/v1beta1/namespaces/*/<metric_name>?labelSelector=<selector_key>=<selector_value>\" Tip You must replace <metric_name>, <selector_key> and <selector_value> with your values. Metrics not working There are some usual errors that could cause a metric fail to retrieve the value. These errors are showed in the status of the metrics when you describe the HPA or are printed when you get the raw metrics directly. executing query: NRQL Syntax Error: Error at line...: The query that is being run has syntax errors. The same error message gives you the executed query and position of the error. You can try this query inside the New Relic query builder and correct the configuration from the adapter. extracting return value: expected first value to be of type \"float64\", got %!q(<nil>): The query doesn't return any value. The same error message gives you the executed query so you can try this query inside the New Relic query builder and correct the configuration from the adapter or the match selectors in the HPA.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 70.027145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Link</em> apps and services"
      },
      "id": "6175209d28ccbcf310c6bb2f"
    }
  ],
  "/docs/style-guide/formatting/titles": [
    {
      "sections": [
        "Infrastructure agent overhead",
        "Linux single-task host",
        "Linux Docker host",
        "Windows host",
        "Linux ARM64 host",
        "Manage data",
        "Resource utilization"
      ],
      "title": "Infrastructure agent overhead",
      "type": "docs",
      "tags": [
        "Infrastructure",
        "Install the infrastructure agent",
        "Manage your agent"
      ],
      "external_id": "cd4b0d49bf6d11a12ff3a8357b223786b4c3f881",
      "image": "",
      "url": "https://docs.newrelic.com/docs/infrastructure/install-infrastructure-agent/manage-your-agent/infrastructure-agent-performance-overhead/",
      "published_at": "2021-12-25T15:24:36Z",
      "updated_at": "2021-12-25T15:24:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The infrastructure agent is a lightweight piece of software, designed to minimize its impact on the performance of your hosts. However, the exact load varies depending on your host's workload, particularly on the number of processes running on the host. This is because the agent collects detailed data from each individual process. As a general guideline, New Relic has collected benchmarks for some common types of hosts: Linux single-task host The agent has very low performance overhead on a classic, single-task host. For example, a server running Apache, Unicorn, or a single Java application. Our benchmarks for this type of host are based on an Amazon EC2 t3.2xlarge: vCPUs: 8 vCPUs Memory: 32.0 GB Storage: 160.0 GB Operating system: CentOS 7 For this type of classic, single-task host, typical usage is: CPU: about 0.3% Virtual memory: about 1 GB Resident memory: 25 to 35 MB Storage on disk: about 50 MB Linux Docker host The agent has very low performance overhead on a host running Docker, with exact usage depending on the number of Docker containers your machine hosts, and whether those processes are long- or short-lived. Our benchmarks for this type of host are based on an Amazon EC2 t3.2xlarge: vCPUs: 8 vCPUs Memory: 32.0 GB Storage: 160.0 GB Number of containers: 25 containers, about 100 long-lived processes running in containers Operating system: CentOS 7 For this type of Docker host, typical usage is: CPU: about 0.8% Virtual memory: about 1 GB Resident memory: 25 to 35 MB Storage on disk: about 50 MB Windows host The agent has very low performance overhead on a typical Windows host serving web apps and running the Windows/IIS stack. Our benchmarks for this type of host are based on an Amazon EC2 t2.small: vCPUs: 1 Memory: 2.0 GB Storage: 30.0 GB Operating system: Windows Server 2012 R2 For this type of Windows host, typical usage is: CPU: 2 to 3% Resident Memory: 30 MB Storage on disk: about 50 MB Linux ARM64 host The agent has similar performance overhead on an ARM64 (Graviton 2) host on EC2 when compared with AMD64 machines. The benchmark is based on Amazon EC2 t3.2xlarge vs. t4g.2xlarge instances. Amazon Linux 2 EC2 instance with infrastructure agent default settings: CPU: about 0.1% on ARM vs 0.13% AMD Virtual memory: about 0.75GB ARM vs 1 GB AMD Resident memory: 20MB ARM vs 22 MB AMD We are always improving the performance of the infrastructure agent. If you see unusually high agent performance overhead, get support at support.newrelic.com. Manage data To learn how to adjust how much data our infrastructure monitoring ingests and reports, see Manage infrastructure data. Resource utilization On Linux systems, infrastructure is installed with default settings for each supported service manager. A memory limit of 1 Gigabyte is enforced. Please consider reviewing and adjusting the default configuration based on your system requirements.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 281.7374,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on disk: about 50 MB Linux Docker host The agent has very low performance overhead on a host running Docker, with exact usage depending on the number of Docker containers your machine hosts, and whether those processes are long- or <em>short</em>-lived. Our benchmarks for this type of host are based on an Amazon"
      },
      "id": "6043fa3464441f329a378f18"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "835ddacc0acae04e05c8c2ddc694799819a7d696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-12-25T17:05:55Z",
      "updated_at": "2021-11-26T05:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.6199,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Rename or <em>redirect</em> a document",
        "sections": "Rename or <em>redirect</em> a document",
        "body": "This document describes how to change the title of a document and how to create, edit, and delete <em>redirects</em>. Procedures are the same for both standard docs (&quot;basic pages&quot;) and release notes. Caution Changing <em>titles</em> or updating <em>redirects</em> can create issues with finding content. If you need to change"
      },
      "id": "61b35af428ccbca9318c6b13"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/levels-headings/",
      "sections": [
        "Levels of headings",
        "Use parallel construction",
        "Keep it short, avoid -ing words",
        "Do not use h1 headings",
        "Use level two headings to identify chunks of information",
        "Important",
        "Avoid using level three headings"
      ],
      "published_at": "2021-12-25T06:03:29Z",
      "title": "Levels of headings",
      "updated_at": "2021-11-24T09:15:43Z",
      "type": "docs",
      "external_id": "18f0cf0f9cd08f4c6118d17119aa9a52b1620136",
      "document_type": "page",
      "popularity": 1,
      "body": "Taking some time to consider your headings and document titles is time well spent. Titles and headings are not only important for search results, but they can make your docs easier to skim. For all headings, subheadings, and titles use sentence case. This means you should capitalize the first word of the title and proper nouns only. You should also capitalize the first word after a colon. Avoid dashes and ellipses in headlines and titles. Avoid using punctuation, with the exception of question marks. Use parallel construction Use parallel construction when naming headers. For example, use all nouns (\"Organization,\" \"Tone\"), all verbs (\"Create,\" \"Delete\"), etc. Keep it short, avoid -ing words For all headers, keep the title as short as possible. In particular, avoid headers that are more than a line long. As with all our writing, you should feel free to address the reader directly: Install the agent, for example, rather than Agent installation. You should also avoid -ing words, which add to character count without contributing clarity. Do not use h1 headings After you publish your doc, the docs site will automatically use what you added to the Title field as the doc's level one heading (h1). To ensure that your doc is properly indexed for search, do not manually create additional h1 headings. If your doc's title is long and you would like a shorter title to appear in the sidebar menu, create a GitHub issue and we'll help you with that change. Use level two headings to identify chunks of information Organize chunks of information into sections with level two headings (##). For example: ## Create a new user [#create-new-user] Copy Important If you don't specify an ID manually, the site will use your header text as that header's ID (also known as anchor link). Create a manual ID to preserve links to that header if you change the header text. If you have too many level sections, consider splitting the document into multiple pages. Avoid using level three headings Avoid using ### headings unless it makes sense for the content or if the content is lengthy. Collapsers, tables, and other structural elements are often a better choice. Be particularly careful about level three headings that make a level two section longer than a single screen height. Here are two examples of good scenarios for using level three headings: Example #1: Events-to-metrics API doc Example #2: Infrastructure integration doc",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.3175,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Keep it <em>short</em>, avoid -ing words",
        "body": "Taking some time to consider your headings and document <em>titles</em> is time well spent. <em>Titles</em> and headings are not only important for search results, but they can make your docs easier to skim. For all headings, subheadings, and <em>titles</em> use sentence case. This means you should capitalize the first word"
      },
      "id": "604221d3196a677e3aa83db4"
    }
  ],
  "/docs/style-guide/formatting/ui-paths": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-25T06:04:19Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.37762,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-25T15:04:59Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.99387,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-25T05:51:50Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.4675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/images/embed-images": [
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-25T17:36:34Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.969,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use content types <em>and</em> text formats",
        "sections": "Use content types <em>and</em> text formats",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " release notes. What&#x27;s New posts This format includes specific fields for product announcements. What&#x27;s New posts are created by PMM for larger announcements. They&#x27;re available in the docs site, but they&#x27;re also visible in the New Relic One UI. For more information, see What&#x27;s New <em>style</em> guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs <em>guide</em>."
      },
      "id": "61b35517196a677196a59e07"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "835ddacc0acae04e05c8c2ddc694799819a7d696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-12-25T17:05:55Z",
      "updated_at": "2021-11-26T05:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.9675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. <em>Procedures</em> are the same for both standard docs (&quot;basic pages&quot;) and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change"
      },
      "id": "61b35af428ccbca9318c6b13"
    },
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "9ec2ccd8a8509ab1b54273206e84f9571164c4f9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-12-25T17:50:00Z",
      "updated_at": "2021-11-26T05:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.96613,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Procedures</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original <em>tech</em> <em>writer</em> or docs site contributor"
      },
      "id": "61b35af4e7b9d2769c5a38f9"
    }
  ],
  "/docs/style-guide/images/embed-videos": [
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-25T17:36:34Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.969,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use content types <em>and</em> text formats",
        "sections": "Use content types <em>and</em> text formats",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " release notes. What&#x27;s New posts This format includes specific fields for product announcements. What&#x27;s New posts are created by PMM for larger announcements. They&#x27;re available in the docs site, but they&#x27;re also visible in the New Relic One UI. For more information, see What&#x27;s New <em>style</em> guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs <em>guide</em>."
      },
      "id": "61b35517196a677196a59e07"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "835ddacc0acae04e05c8c2ddc694799819a7d696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-12-25T17:05:55Z",
      "updated_at": "2021-11-26T05:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.9675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. <em>Procedures</em> are the same for both standard docs (&quot;basic pages&quot;) and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change"
      },
      "id": "61b35af428ccbca9318c6b13"
    },
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "9ec2ccd8a8509ab1b54273206e84f9571164c4f9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-12-25T17:50:00Z",
      "updated_at": "2021-11-26T05:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.96613,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Procedures</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original <em>tech</em> <em>writer</em> or docs site contributor"
      },
      "id": "61b35af4e7b9d2769c5a38f9"
    }
  ],
  "/docs/style-guide/images/screenshots-images": [
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "9ec2ccd8a8509ab1b54273206e84f9571164c4f9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-12-25T17:50:00Z",
      "updated_at": "2021-11-26T05:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 792.6211,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Processes <em>and</em> procedures",
        "body": " sentences, or long paragraphs. Useful <em>images</em> For <em>screenshots</em> and <em>images</em>, check that: Full size <em>images</em> always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped <em>images</em> clearly show their relevance, with or without captions. In addition, make sure"
      },
      "id": "61b35af4e7b9d2769c5a38f9"
    },
    {
      "sections": [
        "Capitalization",
        "Use sentence case in headings",
        "Important",
        "Products and features",
        "UI elements and UI page paths"
      ],
      "title": "Capitalization",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "5d5fb84286568c2a7842bae1247613d33a347593",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/capitalization/capitalization/",
      "published_at": "2021-12-25T02:27:38Z",
      "updated_at": "2021-11-24T08:52:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In general, we only capitalize things when we need to. Over use of capitalization is distracting and limits accessibility for our readers with vision impairment. Read on for some guidelines on how to decide what to capitalize in a document's title, headings, products, features, and other elements of the page. Use sentence case in headings Use sentence case for headings. This includes category headings and document titles. With sentence case, capitalize only the first letter of: The first word Proper nouns Acronyms and abbreviations We have some exceptions: If the heading is a code term, such as a variable or function, then capitalize it exactly as it's used in the code; for example: noticeError. If the heading includes a colon, follow the Microsoft Style Guide for titles and headings, and capitalize the first word that appears after the colon; for example: APM Error profiles: Troubleshoot trends. Important Use sentence case for graphical illustrations such as diagrams and figures. Explore our Screenshots and images document for more information on our image guidelines. Products and features Item Example We use title case for products. Infinite Tracing We don't capitalize features (including features that used to be products). Use transaction traces to... not Use Transaction Traces to... Our infrastructure monitoring... not Our Infrastructure monitoring... UI elements and UI page paths Item Example We use sentence case and bold for UI elements, even if the UI element is in a different case in the UI. \"From the Transactions page, select Transaction traces and...\" We use sentence case and bold for each element in a path that references UI pages. Go to one.newrelic.com > APM > Transactions > Transaction traces > (select a trace) > Another thing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 667.4823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Products <em>and</em> features",
        "body": ": Troubleshoot trends. Important Use sentence case for graphical illustrations such as diagrams and figures. Explore our <em>Screenshots</em> and <em>images</em> document for more information on our image guidelines. Products and features Item Example We use title case for products. Infinite Tracing We don&#x27;t capitalize features"
      },
      "id": "60421e50196a67d785a83d97"
    },
    {
      "sections": [
        "Update your Nerdpack's catalog information",
        "Update your CLI",
        "Check your permissions",
        "Publish your Nerdpack",
        "Update your Nerdpack's catalog metadata",
        "Update your Nerdpack's icons",
        "Resolve issues with submitting catalog information",
        "Resize your images",
        "Check the length of your strings"
      ],
      "title": "Update your Nerdpack's catalog information",
      "type": "developer",
      "tags": [
        "nerdpack",
        "catalog"
      ],
      "external_id": "dfee75ddee87a216eb9454abcaeabcc1ee0a8c7d",
      "image": "https://developer.newrelic.com/static/e79ab0693c4758e13b4d9d0e586bd3e8/0086b/published-app.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/catalog/",
      "published_at": "2021-12-26T01:45:53Z",
      "updated_at": "2021-11-20T01:49:50Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn to describe your Nerdpack in the Instant Observability catalog",
      "body": "Add screenshots, descriptions, and other metadata to your Nerdpack, and upload it all to Instant Observability. Update your CLI Before you run any commands, ensure that you have the latest version of the CLI: bash Copy $ nr1 update Check your permissions To publish your Nerdpack and update its catalog information, you need: Access to the account that published it The necessary permissions for managing Nerdpacks Publish your Nerdpack You need to publish Nerdpacks that you create before you can update their catalog information. Update your Nerdpack's catalog metadata After you've published your Nerdpack to the Instant Observability catalog, update the Nerdpack's metadata to let users know all about your Nerdlets or visualizations. Step 1 of 9 Go to New Relic: Step 2 of 9 Navigate to Instant Observability: Step 3 of 9 Find your published Nerdpack using the Apps filter or search bar: Notice that there is no information on the Instant Observability or details page other than the Nerdpack's name and the brief description found in nr1.json: There are no screenshots, icons, details, or what's new features. For these, you need to provide catalog information to your Nerdpack. Step 4 of 9 From the root of your Nerdpack, create catalog directories to house your Nerdpack's screenshots and metadata: bash Copy $ nr1 create --type catalog ✔ created: launchers/launcher/catalog ✔ created: nerdlets/home/catalog ✔ catalog created successfully! catalog is available at \"./catalog\" Inside your root catalog directory, you'll find specific files and directories for portraying information about your Nerdpack to your users: bash Copy $ ls catalog README.md additionalInfo.md config.json documentation.md screenshots File Description README.md A markdown file that instructs you how to use the information and metadata in catalog config.json A JSON file that contains the following fields: tagline: A brief headline for the application. This cannot exceed 30 characters. repository: The URL for the Nerdpack's remote repository. This cannot exceed 1000 characters. details: The purpose of the Nerdpack and how to use it. This cannot exceed 1000 characters. Use newlines for formatting, and don't include any markdown or HTML. categoryTerms: A list of terms that matches the Nerdpack to a category in the Instant Observability catalog. You can look up a mapping of category terms with NerdGraph: US Query EU Query keywords: A list of relevant words to improve the search discoverability of the Nerdpack. This cannot exceed 50 words, and each word cannot exceed 64 characters. support: An object that contains: issues: A URL for the repository's issues list. For example, the Issues tab if using GitHub. email: A valid email address for the team supporting the application community: A URL for a support thread, forum, or website for troubleshooting and usage support whatsNew: A bulleted list of changes in the current release version. This cannot exceed 500 characters. Use newlines for formatting, and don't include markdown or HTML. Check out our Pageview Map application's config.json to see a real-life implementation. documentation.md A markdown file that tells users how to use the Nerdpack's Nerdlets or visualizations. This shows in the detail view's Documentation tab. additionalInfo.md An optional markdown file for any additional information about using your application screenshots A directory that contains screenshots showcasing your Nerdpack, such as select images of Nerdlets or visualizations. This can contain no more than 6 images. All screenshots must meet the following criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide This command also generates a catalog directory for each launcher, Nerdlet, and visualization in your Nerdpack. Inside you'll find a directory that allows you to add screenshots for each Nerdpack item. bash Copy $ ls launchers/launcher/catalog screenshots $ ls nerdlets/home/catalog screenshots Step 5 of 9 Update your Nerdpack's documentation.md file: documentation.md config.json 1 Enter your first and last name into the fields provided. When you're done, press **Submit** to see a personalized \"Hello!\" message. catalog/documentation.md Copy 1 { 2 \"tagline\": \"\", 3 \"details\": \"\", 4 \"categoryTerms\": [], 5 \"keywords\": [], 6 \"repository\": \"\", 7 \"whatsNew\": \"\", 8 \"support\": { 9 \"email\": { 10 \"address\": \"\" 11 }, 12 \"issues\": { 13 \"url\": \"\" 14 }, 15 \"community\": { 16 \"url\": \"\" 17 } 18 } 19 } catalog/config.json Copy Step 6 of 9 Update your config.json file: documentation.md config.json 1 Enter your first and last name into the fields provided. When you're done, press **Submit** to see a personalized \"Hello!\" message. catalog/documentation.md Copy 1 { 2 \"tagline\": \"Say hi!\", 3 \"details\": \"DemoApp says Hello to a user.\", 4 \"categoryTerms\": [], 5 \"keywords\": [\"hello world\"], 6 \"repository\": \"https://github.com/newrelic/developer-website\", 7 \"whatsNew\": \"feat: Initial commit\" 8 } catalog/config.json Copy Step 7 of 9 Include screenshots in your root screenshots directory or any Nerdpack item screenshots directory. Step 8 of 9 Submit the information to the Instant Observability catalog: bash Copy $ nr1 catalog:submit Uploading screenshots from demo-app... ✔ Screenshots uploaded from: demo-app Uploading screenshots from demo-app/launchers/launcher... ✔ Screenshots uploaded from: demo-app/launchers/launcher Uploading screenshots from demo-app/nerdlets/home... ✔ Screenshots uploaded from: demo-app/nerdlets/home ✔ Updated metadata for DemoApp 1.0.0 Step 9 of 9 Go to Instant Observability to see your changes: Click your Nerdpack to see the new details: Click What's inside to see any screenshots you uploaded for individual items in your Nerdpack: Update your Nerdpack's icons Within a Nerdpack, you can set two types of icons: One for your entire Nerdpack, which represents your Nerdpack in the catalog One for each of your launchers, which represents your Nerdlets Replace these icons and publish your Nerdpack to see the changes. Step 1 of 7 Update the icon.png in the root of your Nerdpack. This icon is used in the catalog and the Nerdpack's detail page. Step 2 of 7 If you're building a Nerdpack with one or more launchers, update the icon.png in each of your launcher's subfolders. Step 3 of 7 Update your package.json version: { \"private\": true, \"name\": \"demo-app\", \"version\": \"1.0.1\", \"scripts\": { \"start\": \"nr1 nerdpack:serve\", \"test\": \"exit 0\" }, \"nr1\": { \"uuid\": \"f2dbc999-e9a3-49b9-933d-5a704c6750bd\" }, \"dependencies\": { \"prop-types\": \"^15.6.2\", \"react\": \"^16.6.3\", \"react-dom\": \"^16.6.3\" }, \"browserslist\": [\"last 2 versions\", \"not ie < 11\", \"not dead\"] } package.json Copy This allows you to publish a new version of your Nerdpack. Step 4 of 7 Publish your Nerdpack: bash Copy $ nr1 nerdpack:publish Step 5 of 7 Update your whatsNew string in catalog/config.json: documentation.md config.json 1 Enter your first and last name into the fields provided. When you're done, press **Submit** to see a personalized \"Hello!\" message. catalog/documentation.md Copy 1 { 2 \"tagline\": \"Say hi!\", 3 \"details\": \"DemoApp says Hello to a user.\", 4 \"categoryTerms\": [], 5 \"keywords\": [\"hello world\"], 6 \"repository\": \"https://github.com/newrelic/developer-website\", 7 \"whatsNew\": \"feat: Add new icons\" 8 } catalog/config.json Copy This will tell users what you added in the latest version of your Nerdpack. Step 6 of 7 Submit this new metadata to the catalog: bash Copy $ nr1 catalog:submit Uploading screenshots from demo-app... ✔ Screenshots uploaded from: demo-app Uploading screenshots from demo-app/launchers/launcher... ✔ Screenshots uploaded from: demo-app/launchers/launcher Uploading screenshots from demo-app/nerdlets/home... ✔ Screenshots uploaded from: demo-app/nerdlets/home ✔ Updated metadata for DemoApp 1.0.1 Step 7 of 7 Go to the catalog and subscribe to your Nerdpack to see your new icon: Resolve issues with submitting catalog information Sometimes, when you work with catalog metadata, you may run into issues. Consider some common solutions for resolving these issues. Publish your Nerdpack Remember that you can only submit catalog metadata for Nerdpacks that have already been published. If you try to submit information for a Nerdpack that hasn't been published, the CLI will try to help: bash Copy $ nr1 catalog:submit Uploading screenshots... › Error: 1 error while updating DemoApp 1.0.0 › › Invalid Version: Nerdpack version 1.0.0 not found. Have you run `nr1 nerdpack:publish` yet? › Code: UNKNOWN Resize your images Screenshots for the catalog must meet the criteria specified previously in this guide. If they don't, the CLI will try to help: bash Copy $ nr1 catalog:submit Uploading screenshots... › Error: 2 errors while updating DemoApp 1.0.1 › › catalog/screenshots/screenshot.png › Invalid Screenshot: screenshot.png has a size ratio of 4:2. Update size ratio to 3:2. › › catalog/screenshots/screenshot.png › Invalid Screenshot: screenshot.png has a width of 3054px. Update size to be between 1600px and 2400px. › Code: UNKNOWN Check the length of your strings Most of the content in config.json has string-length requirements. Make sure you review those requirements and adhere to them when you update your config.json file. Otherwise, you'll see errors when you try to submit your configuration to the catalog: bash Copy $ nr1 catalog:submit Uploading screenshots... ✔ Screenshots uploaded › Error: 2 errors while updating DemoApp 1.0.1 › › catalog/config.json › Invalid Metadata: `details` has a character length of 2204. Must be no longer than 1000 characters › › catalog/config.json › Invalid Metadata: `tagline` has a character length of 266. Must be no longer than 30 characters › Code: UNKNOWN",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 274.70767,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Resize your <em>images</em>",
        "body": " An optional markdown file for any additional information about using your application <em>screenshots</em> A directory that contains <em>screenshots</em> showcasing your Nerdpack, such as select <em>images</em> of Nerdlets or visualizations. This can contain no more than 6 <em>images</em>. All <em>screenshots</em> must meet the following criteria"
      },
      "id": "609c868664441f2bf22f3706"
    }
  ],
  "/docs/style-guide/structure/collapsers": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-25T06:04:19Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.3776,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-25T15:04:59Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.99384,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-25T05:51:50Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.4675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/structure/levels-headings": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-strategies/organize-doc/",
      "sections": [
        "Organize your page",
        "Organize your page to make it easier to read",
        "Use action-oriented titles",
        "Start the document with an introductory paragraph",
        "Keep documents short",
        "Use the New Relic voice",
        "Change doc titles and anchors",
        "Create and edit categories",
        "Start writing and editing docs"
      ],
      "published_at": "2021-12-25T15:06:49Z",
      "title": "Organize your page",
      "updated_at": "2021-11-24T07:56:48Z",
      "type": "docs",
      "external_id": "a3e3c993c0bf65626e805676496bcae8ea8d2c64",
      "document_type": "page",
      "popularity": 1,
      "body": "These are some organization basics. Organize your page to make it easier to read Consider these organization guidelines when thinking about the order of information in a doc. By following these guidelines, you'll make it easier for readers to skim and find what they need. How to organize information Comments Separate what and why from how. Define any necessary prerequisites, policies, or background information (the what and the why) before you step through the how (step-by-step procedures). Examples: Explain what the feature is and why it matters before telling readers how to use it. Describe any limitations with user permissions or subscription levels that would prevent them from using the feature. If the feature is available for any user or subscription level, don't bother to say so. Provide a roadmap for what users will be able to accomplish, so they know before starting a procedure that they have everything they need. Front-load directions with context. Make sure readers know where they need to be, before telling them what to do. In general, use (select an app) to describe what users select from the product index. Examples: Go to one.newrelic.com > Explorer > (select an app or service). Select (account dropdown) > User preferences. On the command line, type gitk. Also, structure steps by front-loading context from the user's point of view. For example, instead of \"Go to x to do y,\" structure the step as \"To do y, go to x.\" Separate requirements from options. Example: Type the Email you use to sign in and to receive information from New Relic. Optional: Type additional user emails, separated by commas. Follow the \"five to nine\" guideline. Depending on the topic, organize the information so there is a maximum of five to nine chunks of information. For example, readers may start to get lost or overwhelmed after about five h2 sections or seven steps into a procedure. If you have more than nine h2 sections or steps, you might need to create an additional doc or procedure. Other organization tools to consider: Levels of headings Lists Collapsers Callouts Tables Code examples For more help section Use action-oriented titles Wherever possible, give your document or h2 heading a task- or action-oriented title. Focus on what users are trying to accomplish or the problem they're trying to solve. Use present-tense verbs, rather than \"-ing\" verbs. Quality Title example Bad The query history Okay View query history Good Query history: Create and edit NRQL queries Start the document with an introductory paragraph Unless the document is less than a single screen in length, begin with a brief paragraph that introduces the topic or summarizes the important points. Not sure where to start? Try writing all the content for your document first, and then add the introduction to the top to summarize your key points. Or use the introduction to expand on the text in your metaDescription in the metadata. Keep documents short The amount of content needed can help you decide whether you need one or more documents for the topic. If all of the document's contents apply directly to the title, then everything belongs in the same document. If several related sections could be logically split into individual documents, and the overall length of your document is more than about two screenfuls, split those sections into other documents. Be sure to include links to the related contents. If a large document needs to be broken into multiple smaller documents, consider whether they might be best grouped together in their own sub-category. Use the New Relic voice We strive for a voice that's approachable, expert, and visionary. Check out our voice guidelines for how to write content with these qualities. And keep in mind these essential writing tips that apply to any type of documentation. Guidelines Comments Be clear and direct. Remember to: Use present tense. Use active voice; avoid passive voice. Tell users what to do, not what they \"should\" do. If absolutely necessary, tell users what not to do in situations where unexpected results may occur. Whenever possible, provide an alternative suggestion when telling users what not to do. Example: Using active voice with an alternative suggestion for what not to do Do not use your config file to change this setting, because this could affect other processes. Instead, go to one.newrelic.com > APM > (select an app or service) > Settings > Application. Write to aid localization and translation. Do not use euphemisms, idioms, jargon, or slang. Use the same terms and wording consistently. If you need to include an abbreviation or acronym, spell it out the first time it appears in the document. Always take a moment to ask yourself whether people will really understand the terms you are using in the way you're using them. Change doc titles and anchors Because changes to doc titles, anchors, and redirects can break links to other docs, please create an issue to request these types of changes and we'll help you out with that. Create and edit categories Because changes to categories can affect large groups of docs at once, please create an issue to request these types of changes and we'll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see Create and edit content. To learn how to create and publish release notes, see Create release notes. To make it even easier to start a new doc, use templates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 682.9351,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " any limitations with user permissions or subscription <em>levels</em> that would prevent them from using the feature. If the feature is available for any user or subscription <em>level</em>, don&#x27;t bother to say so. Provide a roadmap for what users will be able to accomplish, so they know before starting a procedure"
      },
      "id": "619df04028ccbc2730b9a00a"
    },
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "9ec2ccd8a8509ab1b54273206e84f9571164c4f9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-12-25T17:50:00Z",
      "updated_at": "2021-11-26T05:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.928955,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Headings</em> (H2s)",
        "body": " that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they&#x27;ve found the right doc. It provides a short, readable overview of the doc&#x27;s contents. <em>Headings</em> (H2s) Check that: Heading names are concise, yet provide information that helps readers"
      },
      "id": "61b35af4e7b9d2769c5a38f9"
    },
    {
      "sections": [
        "Capitalization",
        "Use sentence case in headings",
        "Important",
        "Products and features",
        "UI elements and UI page paths"
      ],
      "title": "Capitalization",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "5d5fb84286568c2a7842bae1247613d33a347593",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/capitalization/capitalization/",
      "published_at": "2021-12-25T02:27:38Z",
      "updated_at": "2021-11-24T08:52:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In general, we only capitalize things when we need to. Over use of capitalization is distracting and limits accessibility for our readers with vision impairment. Read on for some guidelines on how to decide what to capitalize in a document's title, headings, products, features, and other elements of the page. Use sentence case in headings Use sentence case for headings. This includes category headings and document titles. With sentence case, capitalize only the first letter of: The first word Proper nouns Acronyms and abbreviations We have some exceptions: If the heading is a code term, such as a variable or function, then capitalize it exactly as it's used in the code; for example: noticeError. If the heading includes a colon, follow the Microsoft Style Guide for titles and headings, and capitalize the first word that appears after the colon; for example: APM Error profiles: Troubleshoot trends. Important Use sentence case for graphical illustrations such as diagrams and figures. Explore our Screenshots and images document for more information on our image guidelines. Products and features Item Example We use title case for products. Infinite Tracing We don't capitalize features (including features that used to be products). Use transaction traces to... not Use Transaction Traces to... Our infrastructure monitoring... not Our Infrastructure monitoring... UI elements and UI page paths Item Example We use sentence case and bold for UI elements, even if the UI element is in a different case in the UI. \"From the Transactions page, select Transaction traces and...\" We use sentence case and bold for each element in a path that references UI pages. Go to one.newrelic.com > APM > Transactions > Transaction traces > (select a trace) > Another thing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.21045,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use sentence case in <em>headings</em>",
        "body": "In general, we only capitalize things when we need to. Over use of capitalization is distracting and limits accessibility for our readers with vision impairment. Read on for some guidelines on how to decide what to capitalize in a document&#x27;s title, <em>headings</em>, products, features, and other elements"
      },
      "id": "60421e50196a67d785a83d97"
    }
  ],
  "/docs/style-guide/structure/lists": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-25T06:04:19Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.37753,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-25T15:04:59Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.9938,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-25T05:51:50Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.46747,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/structure/tables": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-25T06:04:19Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 321.3775,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-25T15:04:59Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.99377,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Lists",
        "Tip",
        "In-line lists"
      ],
      "title": "Lists",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "c8dd72524718c4e6e1d36d0f23b9af6ab4203e2a",
      "image": "https://docs.newrelic.com/static/425a3955215de94222a432e13be5dc84/8c557/tables-example.png",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/lists/",
      "published_at": "2021-12-25T06:03:29Z",
      "updated_at": "2021-11-24T09:17:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Lists are a powerful way to organize information, but they don't always make for a pleasant reading experience. Keep these points in mind when you're writing a list: Always capitalize the first letter of the first word in each list item. Use ordered (numbered) lists for step-by-step procedures, where the order matters. Use unordered (bulleted) lists to make it easier for users to skim related information. Use OR on a separate line when there is more than one option for a numbered step or a bullet point. Use tables when your ordered or unordered list would benefit from some extra detail. Tip For punctuation guidelines, follow the Microsoft Writing Style Guide, which includes considerations for localization. Here's an example of an ordered list as a table. Because each step is a row, the table helps to structure the levels of detail. In-line lists As an alternative to using bullet point lists, you can do an in-line list, like this: C SDK | Go | Java. You might want to use an in-line list when: You're linking to further documentation. Customers will likely be selecting a single option. The list item can be displayed with a short word or phrase (like Java, or Infrastructure). You think a bullet point list takes up a lot of vertical space. This may happen in circumstances where a procedure must include several lists. Here's one example of this. There are only two or three potential options they'll be choosing from and a bullet point list seems unnecessary. Here's an example.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.46652,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " For punctuation guidelines, follow the Microsoft Writing <em>Style</em> <em>Guide</em>, which includes considerations for localization. Here&#x27;s an example of an ordered list as a table. Because each step is a row, the table helps to structure the levels of detail. In-line lists As an alternative to using bullet point"
      },
      "id": "60421e4e28ccbc71a9eba7a2"
    }
  ],
  "/docs/style-guide/word-choice/pricing-language-guidelines": [
    {
      "sections": [
        "Query and alert on billing/usage data",
        "Available data types",
        "Query examples",
        "Data usage queries",
        "Daily data usage",
        "Daily usage by source",
        "Metrics ingest by source",
        "Month-to-date data usage",
        "Month-to-date estimated data cost",
        "User count queries",
        "Month-to-date full platform users",
        "Projected monthly full platform user count",
        "Count full platform users and basic users",
        "Set usage alerts",
        "Caution",
        "Ingested gigabytes exceed a fixed value",
        "Usage exceeds fixed threshold for GBs",
        "Usage exceeds fixed threshold for users",
        "Usage exceeds fixed threshold for estimated cost",
        "Available attributes"
      ],
      "title": "Query and alert on billing/usage data",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "New Relic One pricing and billing"
      ],
      "external_id": "e22ae9e26686d11726a82ad4036ff58520b4a439",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-pricing-billing/usage-queries-alerts/",
      "published_at": "2021-12-25T06:05:12Z",
      "updated_at": "2021-12-04T21:08:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For accounts on our New Relic One pricing model, we provide a View your usage UI for understanding billing-related usage and a Manage your data UI for managing billing-related data. Additionally, you can: Query your usage data to get more detail than is available in the UI. Set up NRQL alert conditions to get notifications about changes in your usage. Note that account hierarchy may affect queried data. See Account structure. Available data types Usage data is attached to these events: NrConsumption records usage every hour, and is the equivalent of \"real-time\" usage. Use this event to observe usage trends over time. NrMTDConsumption generates aggregate values from the NrConsumption event. Use this event to see usage or estimated cost for a billing period. NrUsage records usage every hour and is used to see usage reported per product. To see changes made to your account (for example, user management changes), you can query NrAuditEvent. Query examples The View your usage UI displays your data usage and billable user count. If you need more detail than that UI provides, you can use these NRQL queries. For definitions of some of the attributes used in these queries, see Attributes. Data usage queries Here are some data usage query examples: Daily data usage This query totals your billable ingested data, and displays a daily value for the past three months: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' SINCE 3 months ago TIMESERIES 1 day Copy Daily usage by source This query totals your billable ingested data, and displays a daily value for the past three months faceted by the source: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' SINCE 3 months ago FACET usageMetric TIMESERIES 1 day Copy Metrics ingest by source This query breaks down Metric data by the top ten metric names. You could also facet by appName or host to adjust the analysis. FROM Metric SELECT bytecountestimate()/10e8 as 'GB Estimate' SINCE '2021-04-01' UNTIL '2021-04-08' FACET metricName LIMIT 10 TIMESERIES 1 day Copy Month-to-date data usage This query shows the current full platform user count. In other words, it shows how much you'd be billed for your data for that month if you were billed right now. FROM NrMTDConsumption SELECT latest(GigabytesIngested) WHERE productLine = 'DataPlatform' SINCE this month Copy Month-to-date estimated data cost This query shows the estimated cost of your ingested data: FROM NrMTDConsumption SELECT latest(estimatedCost) WHERE productLine = 'DataPlatform' SINCE this month Copy User count queries Here are some user-related query examples. For details on how users are counted, see User count calculations. Month-to-date full platform users This query shows the billable full platform users for the month. In other words, it shows how much you'd be billed for your users for that month if you were billed right now. FROM NrMTDConsumption SELECT latest(usersBillable) SINCE this month Copy This query shows how many full platform users were counted by hour. This is useful for seeing how the full platform user count changed over time. from NrConsumption SELECT max(FullUsers) SINCE 10 days ago TIMESERIES 1 hour Copy Projected monthly full platform user count This query shows a projected count of monthly users. This query would not be good for using in a dashboard; it requires values based on a) the days remaining in the month, b) the start of the month. Here's an example querying the projected end-of-month count with 10 days left in that month: FROM NrMTDConsumption SELECT predictLinear(FullUsers, 10 days) SINCE '2020-09-01' Copy Count full platform users and basic users The usage UI shows the count of full platform users and basic users. The query used is: FROM NrUsage SELECT max(usage) SINCE 10 days ago WHERE productLine='FullStackObservability' WHERE metric in ('FullUsers', 'BasicUsers') FACET metric Copy To see the count of full and basic users over time: FROM NrUsage SELECT max(usage) SINCE 10 days ago WHERE productLine='FullStackObservability' WHERE metric in ('FullUsers', 'BasicUsers') FACET metric TIMESERIES 1 hour Copy Set usage alerts To help manage your billable data, you can set alerts to notify you of unexpected increases in usage. Learn how to create alerts with NRQL queries here. Caution When creating alert conditions, you should use the Event Timer method, which works very well with infrequent data. Here are some NRQL alert condition examples. For attribute definitions, see Attributes. Ingested gigabytes exceed a fixed value This query will create an alert when your hourly usage exceeds a fixed value: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' Copy If you have multiple child accounts, you may want to set threshold alerts for a specific subaccount: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' AND consumingAccountId = YOUR_CHILD-ACCOUNT_ID Copy Usage exceeds fixed threshold for GBs This query will create an alert when your usage exceeds fixed monthly threshold for GBs: FROM NrMTDConsumption SELECT latest(GigabytesIngested) WHERE productLine = 'DataPlatform' Copy Usage exceeds fixed threshold for users This query will create an alert when your usage exceeds fixed monthly threshold for billable users: FROM NrMTDConsumption SELECT latest(usersBillable) Copy Usage exceeds fixed threshold for estimated cost This query will create an alert when your usage exceeds fixed threshold for estimated cost: FROM NrMTDConsumption SELECT latest(estimatedCost) WHERE productLine = 'DataPlatform' Copy Available attributes Below are some of the important attributes attached to usage events. Attribute Description productLine The category of usage. There are three options: DataPlatform, FullStackObservability, and ProactiveDetection. (Starting November 1, 2021, IncidentIntelligence is no longer a billing factor). For more details about these categories, see New Relic platform. metric Consolidates multiple categories of usage into a single metric. Helpful when faceting by productLine. consumingAccountId ID of the New Relic account that is directly responsible for the stored events, as determined from the license key used. estimatedCost Calculates a cost estimate based on usage and metric cost. This is an estimate of costs to date, not your monthly invoice. For more attributes, see the data dictionary.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.49639,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Query and alert on <em>billing</em>&#x2F;usage data",
        "sections": "Query and alert on <em>billing</em>&#x2F;usage data",
        "tags": "New Relic One <em>pricing</em> and <em>billing</em>",
        "body": "For accounts on our New Relic One <em>pricing</em> model, we provide a View your usage UI for understanding <em>billing</em>-<em>related</em> usage and a Manage your data UI for managing <em>billing</em>-<em>related</em> data. Additionally, you can: Query your usage data to get more detail than is available in the UI. Set up NRQL alert"
      },
      "id": "6175f12b64441f53a35fc21c"
    },
    {
      "sections": [
        "New Relic One pricing and billing",
        "Important",
        "How the New Relic One pricing model works",
        "Billing and usage in the UI",
        "Billing calculation details",
        "Data usage calculation",
        "Full platform user count billing details",
        "Data retention",
        "Billing periods",
        "Usage plan details",
        "Query and alert on usage data",
        "Free tier",
        "Non-profit use of New Relic",
        "Cancel or downgrade"
      ],
      "title": "New Relic One pricing and billing ",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "New Relic One pricing and billing"
      ],
      "external_id": "03d43f14ae24579c81b601571242aef540833c8c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-pricing-billing/new-relic-one-pricing-billing/",
      "published_at": "2021-12-25T04:45:38Z",
      "updated_at": "2021-11-24T14:22:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "An explanation of how New Relic One pricing works, and how to view and manage billing. Important This document explains the New Relic One pricing model. If you’re on our original pricing model, see Original pricing. Not sure which you're on? See Overview of pricing. How the New Relic One pricing model works Starting July 30, 2020, all of our new customers are on a pricing model that we call New Relic One pricing. Customers on our original pricing model are able to transition to this pricing. For New Relic One pricing, billing is based on these factors: The amount of data ingested. 100 GBs per month is free. $0.25 per GB ingested above that. The number of provisioned full platform users, who have access to our more curated UI experiences. Basic users are free. The cost of each full platform user depends on your edition: Standard, Pro, or Enterprise. Standard edition includes one full platform user for free, and a max of five. Pro and Enterprise give access to more account and user management features, more support, longer data retention, and other features. For a summary of what's included for free, see Free edition. For an overview of pricing, see our Pricing page. Keep reading for details about New Relic One pricing and billing. Billing and usage in the UI For how to view and manage billing and usage in the UI, see Pricing and billing UI. If you need more detail than the usage UI shows, you can also run queries of your usage data and set up alerts. Billing calculation details For accounts on New Relic One pricing, some high-level billing information is displayed in the UI. Here are some more details about how billing works: Data usage calculation One pricing factor is your ingested data. In this context, “ingested” refers to the data actually saved to your account after we apply various data trimming and data transformation rules. In other words, it’s not the size of the raw data sent to New Relic, but the size of the data that actually ends up stored. To view and manage your usage, go to the usage UI. Other calculation details: In the context of our pricing model, a GB is defined as 1 billion bytes. Monthly data ingested is rounded down to the nearest integer. For example, if your account uses 100.9 GBs during a month, that’s counted as 100 GBs. For more on how data is ingested, see Manage data ingest. For how to query usage, see Query and alert on usage. Full platform user count billing details For accounts with New Relic One pricing, the monthly count of provisioned full platform users is one billing factor. To give an example: if you're on the Pro pricing edition and your organization has 100 full platform users during the month of January, you'd be billed for 100 full platform users for that month. A full platform user counts as a billable user the moment they're added to a New Relic organization (provisioned), whether or not that user has logged into or used New Relic yet. A user's user type is meant to be long-term setting determined by a user's expected New Relic duties and responsibilities. Because user type is a billing factor, we have restrictions around how often a full platform user can be downgraded to a basic user: a full platform user can downgrade to a basic user a maximum of two times in a rolling 12-month period. If a full platform user has been changed to a basic user two times in that 12-month period, that user won't be able to return to being a basic user until the start of the next 12-month period. To learn reasons for assigning one user type or another, see Tips on assigning user type. Here are more user-related billing details and caveats: You can see your full platform user count in the UI. We de-duplicate users based on email address. If there are multiple users in an organization that have the same email address, those user records count as a single user for billing purposes. The count of full platform users is prorated based on the start of a New Relic subscription, or based on when a user is created as a full platform user or converted to a full platform user. A New Relic user can have a maximum of either three concurrent active sessions, or three unique IP addresses in use at any given time. For organizations on our original user model that have a parent/child account structure, the count of billable users in the UI may differ from the users you can see. For more on this, see User count discrepancy. The Standard edition of the New Relic One pricing model includes one free full platform user. For organizations on our original user model, because the organization-related settings aren't as robust as on our newer model, a user may be set as a basic user in one account and as a full platform user in another account. In such cases, the full platform user status takes precedence and that user is considered a full platform user. For how to query usage data, see Query and alert on usage. For more on user capabilities, see Users and roles. Data retention See Data retention. Billing periods For pay-as-you-go customers, billing occurs at the end of the month (UTC), and you can see this tracked in the UI. When you input your credit card and start to be charged, your end-of-month bill will take into account all activity (billable data usage and users) that occurred since the beginning of that month. For example: if you input your credit card in the middle of the month, and so far at that point your account has 200 GBs of usage for that month, that 200 GBs counts towards your end-of-month bill. For how to query user-related usage, see Query and alert on usage. Usage plan details There are two New Relic One pricing usage plans: Pay-as-you-go: This plan bills at the end of each month. There are no commitments and you can cancel at any time. For details, see Usage plans. Annual pool of funds: This plan applies to some customers who have subscribed for a year or more. For details, see Usage plans. For some frequently asked questions, see Pricing FAQs. Query and alert on usage data To create detailed queries of your usage, and get notifications when you are close to hitting certain usage levels, see Query usage data. Free tier If your organization is on New Relic One pricing and on the Standard pricing edition, you can use New Relic free, forever, if you stay under the free allowed limits. Here's a summary of what Standard edition gets access to for free: A single account (Pro and Enterprise editions can have multiple accounts per organization). Up to 100 GBs of ingested data per month. One full platform user, and unlimited basic users. To upgrade to Pro or Enterprise, or to learn more about pricing, see New Relic pricing. Non-profit use of New Relic If you’re a non-profit and want to use New Relic at special pricing, see our Non-profit eligibility docs. Cancel or downgrade See Downgrade account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.884766,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic One <em>pricing</em> and <em>billing</em> ",
        "sections": "New Relic One <em>pricing</em> and <em>billing</em>",
        "tags": "New Relic One <em>pricing</em> and <em>billing</em>",
        "body": " at that point your account has 200 GBs of usage for that month, that 200 GBs counts towards your end-of-month <em>bill</em>. For how to query user-<em>related</em> usage, see Query and alert on usage. Usage plan details There are two New Relic One <em>pricing</em> usage plans: Pay-as-you-go: This plan bills at the end"
      },
      "id": "6043f69a64441f7b26378eda"
    },
    {
      "sections": [
        "Overview of changes to pricing and user model",
        "Overview of how pricing model and user model relate",
        "Pricing plans explained",
        "Determine pricing model",
        "Convert to new pricing",
        "User models explained",
        "Requirements for new user model",
        "Determine which user model you're on",
        "Feature impacts of user model",
        "Transition to new models"
      ],
      "title": "Overview of changes to pricing and user model",
      "type": "docs",
      "tags": [
        "Accounts",
        "Original accounts and billing",
        "Original product-based pricing"
      ],
      "external_id": "b19d61b5a0c65ca352e2ce0e260e2b53391b94fc",
      "image": "https://docs.newrelic.com/static/1461470cc1ef0be91120c84d76a7ccdd/c1b63/new-relic-one-pricing-plan-billing-ui.png",
      "url": "https://docs.newrelic.com/docs/accounts/original-accounts-billing/original-product-based-pricing/overview-changes-pricing-user-model/",
      "published_at": "2021-12-25T14:53:12Z",
      "updated_at": "2021-11-24T14:34:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In 2020, New Relic released both a newer pricing model and a newer user model. Keep reading to learn about: How the pricing model and the user model relate to each other Pricing plans explained User models explained How to switch to the new models Overview of how pricing model and user model relate In 2020, we released both a new, improved pricing model and a new, improved user model. These models represent the future. All new sign-ups are on these new models and eventually all organizations will be on these models. But currently, our customers from before July 2020 may have one of several combinations of these as they either switch to the new pricing or migrate their users to the new user model. This table shows how pricing and user model relate to each other: Pricing plan factors User model factors Original pricing If your organization was created before July 30 2020, you remain on our original pricing model until you transition to New Relic One pricing. For original pricing accounts, you have users on the original user model unless you've migrated your users to the new model. Note that if you've added users via automated user management, they're on the new model. This means it's possible to have some users on both models. New Relic One pricing An organization is on the New Relic One pricing model: If it was created on or after July 30 2020, or If it's an older organization but has switched to New Relic One pricing. If your organization was created on or after July 30 2020, your users are on the New Relic One user model. If you have an older organization, you have users on the original user model unless you've migrated your users to the new model. Pricing plans explained New Relic organizations are on one of two pricing models: New Relic One pricing: Our new pricing model is simpler. It bills on a) which edition you're on (Standard, Pro, or Enterprise), b) the GBs of data ingested, and c) how many billable full platform users you have. All organizations created on or after July 30 2020 are on this pricing model, as are older organizations that have switched to this pricing. There are two versions of this pricing model. Our original product-based pricing model: this is based on subscriptions to specific products (for example, APM, Browser, Mobile, Infrastructure). Some organizations have the option to transition to the newer pricing model: in that case, their users remain on our original user model. Determine pricing model To determine which pricing model you’re on: go to one.newrelic.com, select the account dropdown, and select Manage your plan. If you see billing information about data ingested and the number of billable users, you’re on the new pricing model. If you're on New Relic One pricing, you'll see a billing UI like this. Convert to new pricing Some organizations are able to switch to new pricing. Learn more about switching your pricing model. User models explained In this context, the term \"user model\" refers to the structure of a New Relic user record and how it interacts with the broader New Relic organization that it's in. Our two user models are: New Relic One user model: this newer, improved user model has these major differences from the original user model: All your accounts and users are contained under a top-level organization. This gives an organization stronger control over managing users and what they can access. One impact of this is that users who work with multiple New Relic organizations may have an email address associated with multiple logins. Users on this model have a different system for managing permissions and account access. Using access grants, you assign users access to specific roles on specific accounts. Original user model: some aspects of this older model that are different from our newer model: There wasn't as much organization-level control over users. For example, a New Relic user had the ability to access multiple accounts they'd been granted access to using a single login. Users on the original user model have a different user management system. To learn more about benefits of the new model, see our blog post about user model changes and an explanation of the new account structure. For impacts and limitations, see Feature impacts. Requirements for new user model Here's a synopsis of the factors governing what organizations use the new model: All New Relic organizations that signed up after July 30 2020 have users on this model, and also have the new pricing model. Some older New Relic organizations have had their users migrated to the new model by New Relic or by using the user migration procedure. Note that switching to the new pricing model is independent from migrating users. Partner accounts (resellers, managed service providers), and organizations using the partnership account structure, cannot yet migrate their users to the new model. Determine which user model you're on To determine what user model you're on, from the account dropdown select User preferences. If you see the UI below, you're on the New Relic One user model. If you see a different UI with more content displayed, you're on the original user model (see original user docs). To determine if you can manage users on the New Relic One user model, see Manage users. The user model is independent of your pricing model. For how user model relates to pricing, see the Pricing and user model table. Feature impacts of user model The new user model offers many benefits. Here are some feature impacts of being on the New Relic One user model that may be not obvious to users accustomed to our previous user model: More separation of organizations/accounts: If you have an email address associated with multiple New Relic accounts, this may mean you need to log out and log back in. Learn more about account access. Adding accounts: Pro and Enterprise edition can have more than one account in their organization. Currently users in these organizations cannot, on their own, add accounts. They must get help from their New Relic account representative. To learn about adding users to accounts, see Manage users. Alerts-related impacts: Policy actions: For alert policies and conditions, some UI locations display the user that made the last modification. For users on the new model, it will display their user ID and not their user name. For example, a policy might read Last modified Sep 7, '20 4:26 pm by user 1234567 instead of by John Doe. If you have user management permissions, you can determine what user this is by going to the User management UI. Notifications: Users on the new model won’t show up as an option when choosing users to receive alert notifications. The result of this is that these users will not get New Relic mobile app push notifications. As a workaround, you can instead use their email address as the notification channel. You can't use the REST API to generate a list of users (only original model users). Instead you'd use the user management UI. Changing account name: These users cannot change the name of their organization after it has been created. Transition to new models Some New Relic organizations on the old models are able to transition to the new models. To learn more about this, see Transition to new models.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.73186,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Overview of changes to <em>pricing</em> and user model",
        "sections": "Overview of how <em>pricing</em> model and user model <em>relate</em>",
        "tags": "Original accounts and <em>billing</em>",
        "body": ", their users remain on our original user model. Determine <em>pricing</em> model To determine which <em>pricing</em> model you’re on: go to one.newrelic.com, select the account dropdown, and select Manage your plan. If you see <em>billing</em> information about data ingested and the number of billable users, you’re on the new"
      },
      "id": "603e97fa28ccbcb7c2eba754"
    }
  ],
  "/docs/style-guide/word-choice/usage-dictionary": [
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-25T15:04:59Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.99377,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-25T05:51:50Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.46747,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    },
    {
      "sections": [
        "Lists",
        "Tip",
        "In-line lists"
      ],
      "title": "Lists",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "c8dd72524718c4e6e1d36d0f23b9af6ab4203e2a",
      "image": "https://docs.newrelic.com/static/425a3955215de94222a432e13be5dc84/8c557/tables-example.png",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/lists/",
      "published_at": "2021-12-25T06:03:29Z",
      "updated_at": "2021-11-24T09:17:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Lists are a powerful way to organize information, but they don't always make for a pleasant reading experience. Keep these points in mind when you're writing a list: Always capitalize the first letter of the first word in each list item. Use ordered (numbered) lists for step-by-step procedures, where the order matters. Use unordered (bulleted) lists to make it easier for users to skim related information. Use OR on a separate line when there is more than one option for a numbered step or a bullet point. Use tables when your ordered or unordered list would benefit from some extra detail. Tip For punctuation guidelines, follow the Microsoft Writing Style Guide, which includes considerations for localization. Here's an example of an ordered list as a table. Because each step is a row, the table helps to structure the levels of detail. In-line lists As an alternative to using bullet point lists, you can do an in-line list, like this: C SDK | Go | Java. You might want to use an in-line list when: You're linking to further documentation. Customers will likely be selecting a single option. The list item can be displayed with a short word or phrase (like Java, or Infrastructure). You think a bullet point list takes up a lot of vertical space. This may happen in circumstances where a procedure must include several lists. Here's one example of this. There are only two or three potential options they'll be choosing from and a bullet point list seems unnecessary. Here's an example.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.46652,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " For punctuation guidelines, follow the Microsoft Writing <em>Style</em> <em>Guide</em>, which includes considerations for localization. Here&#x27;s an example of an ordered list as a table. Because each step is a row, the table helps to structure the levels of detail. In-line lists As an alternative to using bullet point"
      },
      "id": "60421e4e28ccbc71a9eba7a2"
    }
  ],
  "/docs/style-guide/word-choice/user-related-language-guidelines": [
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-12-25T14:30:48Z",
      "updated_at": "2021-12-25T14:30:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters Allowed characters: Characters must be UTF-8. When using NerdGraph to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. For APM agents, restart your service. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration, both methods require you to restart your service. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. And check out this short video on querying APM tags (3:20 minutes). Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.35608,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Team-<em>related</em> tags",
        "body": ", or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db <em>Role</em> examples: <em>roles</em>: architecture <em>roles</em>: devops <em>roles</em>: pm Region examples: region: emea region: america region: asia Environment-<em>related</em> tags You can create entities"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "image": "https://docs.newrelic.com/static/565d4ebddf52a4592c594032696516b9/c1b63/New-Relic-capabilities-UI-screenshot.png",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-user-management/new-relic-one-user-model-understand-user-structure/",
      "sections": [
        "Users, roles, permissions (New Relic One user model)",
        "Important",
        "Overview",
        "User type: basic users and full platform users",
        "Compare full vs basic capabilities",
        "Tips on choosing user type",
        "Understand user-related billing",
        "Have questions about why you can't access something?",
        "Default groups: Admin and User",
        "How do user type, roles, and groups relate to each other?",
        "Roles and capabilities",
        "Standard (default) roles",
        "Capabilities",
        "Manage users",
        "2020 user model changes"
      ],
      "published_at": "2021-12-25T14:51:54Z",
      "title": "Users, roles, permissions (New Relic One user model)",
      "updated_at": "2021-11-24T02:17:27Z",
      "type": "docs",
      "external_id": "169383c2678ce973404db07195b2dee6eda9163d",
      "document_type": "page",
      "popularity": 1,
      "body": "Your New Relic users can be on one of two user models: this doc explains the New Relic One user model. Important If your New Relic organization was created before July 30 2020 and you haven't gone through a user migration process, your users are likely on our original user model. For more on this, see User model changes. Overview This doc will explain the structure of the New Relic One user model, including: User type (basic user versus full platform user) Default user groups, including Admin and User Roles and capabilities For how to add and manage users in the UI, see User management. User type: basic users and full platform users Important This section is for users on our New Relic One user model. In November, 2021, we changed the user type \"full user\" to \"full platform user.\" A user's user type determines if they have access to our basic features (basic user) or can access all of our curated observability UI features (full platform user). The user type is something meant to be set long-term based on that user's expected New Relic responsibilities. Below are details on the two user types. Note that full platform users are billable only if you're on New Relic One pricing. Basic user. Details: These users are free and have access to a wide range of features, including setting up and configuring any New Relic data-reporting tool, running queries of your data, using our logs UI, making custom charts and dashboards, and setting up alerts. Unlike full platform users, they do not have access to our more curated observability UI experiences or some Applied Intelligence features (for a detailed comparison, see Capabilities). Basic users will see prompts to become a full platform user when they attempt to access unavailable features. For details, see Upgrade. Full platform user, also known as full user. Details: Full platform users have access to everything (depending on any role restrictions), including all our observability UI experiences, such as APM, infrastructure monitoring, browser monitoring, mobile monitoring, synthetic monitors, access to New Relic One apps, and more. For details, see Capabilities. Standard edition includes one free full platform user and up to five total full platform users. A full platform user can downgrade to a basic user twice in a 12-month period. To view and edit the user type of your users, use the User management UI. Learn more about basic user versus full platform user differences: Compare full vs basic capabilities Below is a table comparing what basic users and full platform users can do. A simple way to think about it is that full platform users have theoretical access (dependent on any chosen role restrictions) to all of our curated UI experiences, while basic users are restricted to fairly basic capabilities. Features Full platform user Basic user Observability UI experiences Application monitoring (APM) UI Infrastructure monitoring UI Digital Experience Monitoring UI, which includes: Browser monitoring UI Mobile monitoring UI Synthetic monitoring UI Synthetics checks Serverless monitoring UI Logs in context Distributed tracing UI Infinite Tracing (Pro and Enterprise edition) Assorted UI experiences, including: Kubernetes cluster explorer UI Errors Inbox Key transaction UI Workloads UI CodeStream integration (temporary preview access) Access to New Relic One apps Can build apps but can't access other apps New Relic One platform capabilities Full platform user Basic user Data ingest from any source (agents, integrations, APIs) Query data Create custom charts and dashboards Alerts and notifications APIs, including NerdGraph (basic user permissions) Query and chart log data Build New Relic One apps (but cannot access other apps) Manage New Relic data Manage other New Relic users Applied Intelligence Full platform user Basic user Acknowledge and resolve issues Root cause analysis Incident/anomaly analysis Correlation assistant Issue maps Machine learning classification Note that the pricing edition (Standard, Pro, or Enterprise) will also affect what features you have access to. For organizations with New Relic One pricing, learn more about how full platform users impact billing. Tips on choosing user type A user's user type (basic user vs full platform user) is meant to be a long-term assignment, based on the New Relic responsibilities that user is expected to perform. A full platform user can be downgraded to a basic user only twice in one year. Below are tips for why you'd choose full platform user versus basic user. Reasons to make someone a full platform user: They play a key role in the development, testing, deployment, and maintenance phases of the application development lifecycle. They break/fix code regularly; they are responsible for triaging workflows, troubleshooting, or managing users and roles for their team. They have DevOps practices like version control systems, and they implement CI/CD. They need to use New Relic's curated dashboards and experiences (not just the ability to create their own custom queries and charts); in other words, they need full access to our platform. They need to be able to manage users and/or billing. Reasons to make someone a basic user: They play a key role in the planning phase of the application development lifecycle. They use and configure New Relic agents, APIs, and integrations to send us data, and access, configure, and use alerts on such data (not necessarily responsible for triaging workflows, troubleshooting, or managing users and roles for their team). They want to see high-level analytics and business metrics for future planning (such as C-Suite executives). They do not need to use our curated experiences and dashboards, but would benefit from the ability to create their own custom queries and charts of data; in other words, they don't need full access to the platform. They don't manage users. For accounts on New Relic One pricing, learn more about user-related billing calculations. Understand user-related billing If you're on the New Relic One pricing model, full platform users are billable, and there are restrictions around how often a full platform user can downgrade to a basic user. For details, see User count billing details. For how to query and alert on usage data, see Query usage data. Have questions about why you can't access something? See Factors affecting access. Default groups: Admin and User For users on our New Relic One user model, a \"group\" is what allows the grouping together and managing of multiple users at the same time. Your New Relic users are assigned to a group, and that group is granted access to specific roles on specific accounts. We have two default groups: User: This group allows a user to use and configure monitoring/analysis features but not perform account-related tasks like managing billing or users. It has access to the All product admin role, which gives access to our observability platform tools but not to the organization and user management capabilities governed by the Organization manager and Authentication manager roles. Admin: has full access and capabilities, including the organization-level admin abilities. This is the equivalent of having the All product admin, the Billing user, the Organization manager and the Authentication domain manager roles. These groups are added inside your default authentication domain, which includes the default settings of users a) being managed via New Relic and b) logging in via standard email and password. If you add other authentication domains (for SAML SSO and/or SCIM provisioning of users), you'd have new custom groups in those new domains to govern those users. Note that groups, whether default or custom, are not what limit a user's capabilities: it is the role that is assigned to that group (with any basic user restrictions on top of that). If your organization is Pro or Enterprise edition and you want to understand how users are granted access to specific roles and accounts, see Access grants. To change the group a user is in, use the User management UI. How do user type, roles, and groups relate to each other? For users on the New Relic One user model, here's a table explaining how user type (basic vs full platform), roles, and groups relate to each other: Full platform user Basic user Group Full platform users can be assigned to default groups (User and Admin) or custom groups. When basic users are added to a group, that group's role-related restrictions apply. A basic user's capabilities can be restricted in that way, but a basic user can never be granted more capabilities than they start with. For Standard edition, basic users can't be assigned to groups. For Pro and Enterprise edition, they can. Role For an explanation of the roles our default groups have, see Default groups. Custom groups can have either our default standard roles, or custom roles. A basic user's abilities aren't directly defined by a specific role. A basic user can best be described as having the All product admin role but without access to our more curated UI experiences (learn more about user type). When basic users are added to a group, that group's role-related restrictions apply, but a basic user can never be granted more capabilities than they start with. Roles and capabilities For users on the New Relic One user model, a \"role\" can be defined as \"a set of capabilities.\" A capability is defined as the ability to do a specific New Relic task, like 'Delete alert conditions' (learn more about capabilities). Roles are assigned to user groups. Our default groups Admin and User already have our standard roles (defined below) assigned. Organizations on Pro or Enterprise edition can also create custom roles. Standard (default) roles Roles are sets of capabilities. We have several \"standard roles,\" which are roles that satisfy some commonly needed use cases. To view roles and their associated capabilities, use the Organization and access UI. Important Note that some of our standard roles have hidden, non-exposed capabilities that are not available for selection when creating a custom role. The only standard roles that can be replicated with a custom role are Standard user and Read only; all others have some hidden capabilities. Our standard roles include: Standard roles Scope Description All product admin Account Provides admin-level access to observability platform features but not organization-level and user management features. In other words, this role includes all New Relic capabilities with the exception of managing users (Authentication domain manager role), managing organization/account-structure settings (Organization manager role), and managing billing (Billing user role). Note: the Standard user role is essentially the All product admin role minus observability feature configuration capabilities. Standard user Account Provides access to observability platform features, but lacks permissions for configuring those features (for example, ability to configure synthetic monitor secure credentials) and lacks organization-level and user management permissions. Note: the Standard user role is essentially the All product admin role without that role's ability to configure platform features. Billing user Account Provides ability to manage subscriptions and billing setup, and read-only access to the rest of the platform. For organizations with multiple accounts, billing is aggregated in the primary (first-created) account, which is why assigning this role to that primary account grants billing permissions for the entire organization. Organization manager Organization Provides the ability to manage organization settings, including organization structure, name, and preferences. Due to our recent switch to the New Relic One user model, this role currently has few abilities but more will be added over time. For how to grant this role, see Add user management capability. Organization read only Organization Provides the ability to view organization-level settings. For how to grant this role, see Add user management capability. Authentication domain manager Organization Provides ability to add and manage users, and configure authentication domains for users on the New Relic One user model. For how to grant this role, see Add user management capability. Authentication domain read only Organization Provides the ability to view users in your organization and view the configuration of authentication domains. For how to grant this role, see Add user management capability. Read only Account Provides read-only access to the New Relic platform (except for synthetic monitor secure credentials). Manage v1 users Account For New Relic organizations that existed before July 30 2020 and have users on our original user model, this role lets you manage those \"v1\" users. For more about how you'd assign roles to groups and create custom roles, see the user management tutorial. Capabilities A role, whether one of our standard roles or a custom role, is defined as a set of capabilities. To view roles and their associated capabilities, use the Organization and access UI. Important Some of our standard roles have hidden capabilities that aren't available for selection when creating a custom role. For details, see Standard roles. A view of the capabilities associated with the All product admin role. When creating a custom role, you select a custom set of capabilities. Note that the capabilities we expose may change over time: this screenshot was taken in April of 2021. For how to set up roles with custom capabilities, see the user management tutorial. Manage users To learn how to add users, assign them to groups, and create custom groups and roles, see Manage users. 2020 user model changes If you'd like to understand how our user model changed in 2020 and what the impacts of that change were, see User model changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.3282,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Users</em>, <em>roles</em>, permissions (New Relic One <em>user</em> model)",
        "sections": "How do <em>user</em> type, <em>roles</em>, and groups <em>relate</em> to each other?",
        "body": ", and that group is granted access to specific <em>roles</em> on specific accounts. We have two default groups: <em>User</em>: This group allows a <em>user</em> to use and configure monitoring&#x2F;analysis features but not perform account-<em>related</em> tasks like managing billing or <em>users</em>. It has access to the All product admin <em>role</em>, which"
      },
      "id": "603e88e328ccbcfcbaeba7a8"
    },
    {
      "sections": [
        "How to manage users",
        "Important",
        "Requirements",
        "Manage users in the UI",
        "Overview of user management concepts",
        "Common user management tasks",
        "Add, edit, and delete users",
        "Edit user type (basic and full platform)",
        "Give users access to accounts and roles (access grants)",
        "Create new custom groups and roles",
        "Set up SAML SSO and/or SCIM provisioning",
        "Grant users ability to manage other users",
        "Control how basic users upgrade to full platform users",
        "Track changes",
        "User management terms and definitions"
      ],
      "title": "How to manage users",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "New Relic One user management"
      ],
      "external_id": "9e37836740ce56302734d4af636bdbe087b4dbc3",
      "image": "https://docs.newrelic.com/static/a78dad5ff794da5deaaf3b514e334ea7/c1b63/new-relic-one-user-mgmt.png",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-user-management/add-manage-users-groups-roles/",
      "published_at": "2021-12-25T15:07:39Z",
      "updated_at": "2021-11-24T14:23:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For users on our New Relic One user model, we provide various user management features, including the ability to: Use role based access control (RBAC) to assign default or custom roles to user groups Create custom user groups Grant user groups access to specific roles and accounts Important This doc applies to users on the New Relic One user model. For managing users on our original user model, see Original users. Not sure which user model you're on? See User models. Requirements To see if you can access these user management features, go to the user management UI and see what you have access to. Access requirements: These features allow managing of users on the New Relic One user model. To learn more, see User models. To avoid configuration conflicts, ensure that only one user is managing users at a time. Simultaneous configuration by more than one user may result in errors and unexpected results. Most capabilities require the Authentication domain manager role and some require the Organization manager role. For details, see Standard roles. Pricing edition requirements: To manage user groups, roles, and access grants: Pro or Enterprise edition is required. To import users from an identity provider: Enterprise is required. A New Relic user can have a maximum of either three concurrent active sessions, or three unique IP addresses in use at any given time. Manage users in the UI For users on the New Relic One user model, to find your user management options: From the account dropdown, select Administration. There are two user management UI pages there: User management: Use this to add users, update user type (basic versus full platform) and other information, and approve user type upgrade requests. Organization and access: Use this page to create and manage groups, roles, and access grants, and to set up SAML SSO and SCIM provisioning. Want to see videos of the user management UI in action? See our user management videos. Important If you can't see these UI pages, it may be because you're on our original user model or because you don't have the required user management role. Overview of user management concepts If your organization has Pro or Enterprise edition, you can create and configure access grants. An access grant gives a group of users access to a specific role on a specific account. Here's a diagram showing how access grants work and how they relate to the broader organization: A diagram explaining the concept of how access grants give a user group access to a) a role on b) a specific account. (Note that this applies to users on our New Relic One user model (and not our original user model).) When your New Relic organization is created, it starts out with some default access grants for our default User or Admin groups. Each of these groups is assigned one or more roles and granted access to the primary (first created) account: A view of the Organization and access UI, showing the default access grants associated with our default groups. If you have a relatively flat organizational structure, and are okay with all or many of your users having wide administrative access and access to all accounts, you'll probably only need at most a few access grants. For example, you might decide to add new access grants to the existing default Admin or User groups, giving those roles access to other accounts. Or, if you need more granular definition over roles and permissions, you'd create access grants that define new groups that have access to specific roles (either our standard roles or custom-defined roles). For a tutorial on how to create access grants and create custom roles, see the User management tutorial. For other examples of some common user management tasks, see Example tasks. To see the UI in action, see our user management videos. Some tips on setting up access grants: It may help to first plan out how your access grants will be organized. How many accounts will you have? What user groups will get access to which roles and which accounts? Will you use our default groups and roles or create your own custom groups and roles? If you've used automated user management to provision users via SCIM, you will have to create access grants to give those users access. A common configuration for organizations with many accounts (roughly 20 or more) is setting up groups with the more organization-scoped roles (Organization manager, Authentication domain manager, and Billing user) on the primary account, and then on other accounts, setting up groups with the more product-scoped roles (like All product admin, Standard user, or custom roles). Common user management tasks In the Organization and access UI, you can create access grants, custom groups, custom roles, and configure an authentication domain. Here are some example user management procedures: Add, edit, and delete users See the user management tutorial. Edit user type (basic and full platform) Note that there are limits around how many times full platform users can be changed to basic users. Important If you're using automated user management to provision and manage your users, you have other options for managing user type. To change the user type of one or more users: On the User management page, click the checkboxes for the users whose user type you want to edit. Once you start selecting users, an option will appear for Edit type. You can also edit the user type and group of a specific user by clicking on that user. Give users access to accounts and roles (access grants) See our user management tutorial. Create new custom groups and roles See the user management tutorial. Set up SAML SSO and/or SCIM provisioning See Get started with SAML SSO or SCIM. Grant users ability to manage other users To grant your users the ability to manage other users, you'll need to add users to a group that has the Authentication domain manager and Organization manager role. You have two options: From the User management UI, you can add a user to the default Admin group, which includes both of those roles. OR You can create a custom group and assign it these roles. For a tutorial on creating new access grants, groups, and roles, see the user management tutorial. Control how basic users upgrade to full platform users See the authentication domain settings. Track changes To see an audit log of changes to your account, including user management actions, you can query the NrAuditEvent. User management terms and definitions For an explanation of how user access to accounts and roles works, see User management concepts explained. Here are some definitions for the terms we use there: A New Relic organization is the representation of your organization, containing all your accounts, users, and data. For more information, see Organization and account structure. A capability is an ability to use or edit a specific, granular New Relic feature. Examples of capabilities: The ability to modify APM settings The ability to delete alert conditions A role is a set of capabilities. It is what gives a user their permissions. Our default standard roles have various capability sets, and you can create custom roles that have a custom set of capabilities. See some specific New Relic capabilities. A user group has one or more roles associated with it. You assign your users to a group. We have default user groups (Admin and User), and you can make your own groups. An access grant is what grants a user group access to roles and to specific New Relic accounts. An access grant essentially states, \"This group is assigned this role on this New Relic account.\" Adding a user to a group doesn’t do anything unless that group is included in an access grant. An authentication domain contains a set of users who are added to New Relic and who log in to New Relic in the same way. For example, you may have one authentication domain for users who log in via username/password and another authentication domain for users who log in via SAML. If a user is a basic user, this takes precedence over any role-related limitations. For more on this, see Basic user and roles.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.056206,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to manage <em>users</em>",
        "sections": "Give <em>users</em> access to accounts and <em>roles</em> (access grants)",
        "tags": "New Relic One <em>user</em> management",
        "body": " in the same way. For example, you may have one authentication domain for <em>users</em> who log in via username&#x2F;password and another authentication domain for <em>users</em> who log in via SAML. If a <em>user</em> is a basic <em>user</em>, this takes precedence over any <em>role</em>-<em>related</em> limitations. For more on this, see Basic <em>user</em> and <em>roles</em>."
      },
      "id": "603e7bce28ccbc415beba74c"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/agent-api-guide-template": [
    {
      "sections": [
        "Basic doc template",
        "Section example",
        "Code example",
        "List example",
        "Table example"
      ],
      "title": "Basic doc template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "13ab0e9d759903149944453fc4392998b6fab974",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/basic-doc-template/",
      "published_at": "2021-12-25T17:21:11Z",
      "updated_at": "2021-11-26T09:12:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the formatting tips in this template to organize the docs you create on the docs site. Then replace the template information with your own text, lists, and tables as needed. Before you create sections, start your doc with a brief introduction, usually no more than a paragraph, that helps readers understand what your doc will cover. Your introduction (and the structure of your doc) should help readers understand within ten seconds whether they are in the right place. Section example Begin each section with a meaningful H2 title. The docs site uses these to generate the contents, which appears automatically in the left navigation. If you want to include a screenshot with the section, provide a permalink for the Docs team to create the image for you. Due to security requirements, the Docs team manages all images on the docs site. Code example def article_url(category, article, options={}) url_for(options.reverse_merge( :controller => 'articles';, :action => 'show', :category => category, :article => article )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add require('newrelic'); as the first line of your app's main module. Use the command npm install newrelic --save for each application you want to monitor. For unordered lists, use bullets (ul in HTML or * in Markdown). For example: Black White For complex lists, consider using collapsers. Table example Tables help organize detailed lists so the information is easier to skim. Tables are easier to manage in HTML. For exammple: <table> <thead> <tr> <th width={200}> **Item** </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Some thing </td> <td> More detailed information about it </td> </tr> <tr> <td> Another thing </td> <td> More detailed information about another thing </td> </tr> </tbody> </table> Copy Tables created in Markdown use three or more hyphens --- to create each column’s header, and pipes | to separate each column. For example: | Item | Requirements ------------ | ------------ | Some thing | More detailed information about it | Another thing | More detailed information about another thing Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.48267,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Basic doc <em>template</em>",
        "sections": "Basic doc <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " <em>article</em>_url(category, <em>article</em>, options={}) url_for(options.reverse_merge( :controller =&gt; &#x27;articles&#x27;;, :action =&gt; &#x27;show&#x27;, :category =&gt; category, :<em>article</em> =&gt; <em>article</em> )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add"
      },
      "id": "61b3574c64441f1cc6aec5a4"
    },
    {
      "sections": [
        "GraphQL API tutorial template",
        "Example query #1 with GraphQL",
        "Example query #2 with GraphQL",
        "Example query #3 with GraphQL"
      ],
      "title": "GraphQL API tutorial template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "827639827da156b6a36096c0f6a3911052706a91",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/graphql-api-tutorial-template/",
      "published_at": "2021-12-25T17:21:11Z",
      "updated_at": "2021-11-26T09:09:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL API tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what problem or use case the users want to solve, or why the API can help them query to get this data Three to five query examples that show interesting data they can get from GraphQL Sample intro paragraph: You can use the New Relic GraphQL API to [ add key use cases here]. To construct these queries and see responses, you can use the New Relic GraphQL Explorer. This document explains some of the available functions to query [ data to be queried]. Example query #1 with GraphQL Add a description here for your example query. Tell users why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #2 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #3 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.47943,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "GraphQL API tutorial <em>template</em>",
        "sections": "GraphQL API tutorial <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61ab330c64441fd067927126"
    },
    {
      "sections": [
        "Add to data dictionary",
        "Data dictionary structure",
        "Add a new data type",
        "Add attributes",
        "Attribute style guidelines",
        "Using units of measurement"
      ],
      "title": "Add to data dictionary",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "05c35d88b970eee521e2af4e255666e31b915468",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/data-dictionary-style-guidelines/",
      "published_at": "2021-12-25T17:01:32Z",
      "updated_at": "2021-11-26T07:01:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We use the data dictionary to provide information about data types (for example, Transaction, Metric, Log) and attached attributes. This is exposed in the New Relic query experience, on hovering over the data types and attributes. And we also expose the dictionary to the public. This doc contains info on how to add data to the dictionary. Note that currently we don't have infrastructure integration data in the dictionary. We also have very few attributes for the Metric data type, just a few basic default ones, despite there being many potential attributes attached to that data type depending on what the data source is. Data dictionary structure The data in the data dictionary is structured like this: Data types: sometimes called \"events\" for historical reasons, these are the NRDB data objects, like Transaction, Metric, Log, Span, etc. Attributes: these are key:value pairs attached to data types. One attribute can have multiple data types listed for it. For example, appName is on multiple data types. Data source: The New Relic product from which the data originates. With the current implementation, a data type must have a single data source assigned. This isn't ideal, as theoretically a data type can come from multiple sources. Add a new data type To add a new data type: Make a new folder in this directory, alongside the other directories: src/data-dictionary/events Copy Duplicate a data type file (for example, this Metric data type), place it in the new folder, and fill it out with the new info. For how to add attributes on a new data type, keep reading. Add attributes To add attributes: Check if there's an existing attribute that has the same name and same general definition as the one you're trying to add. If it exists, edit that file to include the new data type (under events:). If an existing attribute is fairly close in definition but not exact, try to edit the definition so it works for all associated data types. If there is no existing attribute, create a new one. The easiest way is to copy an existing attribute file, edit all relevant fields to be accurate, and place it in the folder of the data type it's attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see Style. If the attribute has one of the units of measurement we use (like units: percentage (%)), add that to the front matter. For info on units, see Units. Attribute style guidelines When adding or editing attributes, some things to keep in mind: Aim for concise descriptions. Notes on this: Feel free to use sentence fragments. Feel free to edit definitions submitted from internal teams as sometimes their definitions will be overly long or have unneeded links. Some attributes are only present in some situations (for example, when a specific APM agent is used, or when a specific config option is true). We should avoid documenting most of these, with the idea that most customers will only care about the data because it's being reported for them, and won't care about the things that factor into the reasons why it wouldn't be reported. If it's thought that the addition would help customers who already have the data reporting understand the data better, you can include it. Write so it reads well as plain text. Details on this: Note that the docs site data dictionary has our usual docs styles available, but the query UI definitions have no styling available. This means that you should write definitions so that they are understandable without any styling, as plain text. You can often avoid any need for styling (for example, data types like Transaction are easy to understand as plain text, as are most phrasings that use attribute names or values. When plain text makes something too ambiguous and you need some styling, use back ticks to indicate attributes or values (for example, a definition like: Reported when ` category ` is ` http ` ). Using this also sets us up for success if we implement styling in the UI definitions in the future. We should avoid links because those aren't visible in the query UI; the query UI only displays plain text. However, every attribute entry in the query UI does display a 'See attribute in docs' link that links to the complete and normally formatted docs site entry. This means that we can use links provided that they will display in an easy to understand way in the query UI. For example, here's an example of an attribute that would read clearly in plain text despite not having a link. We should avoid using a link format like \"For more information, see Create an alert condition\", because it wouldn't read well in plain text, and would choose something like \"For more information, see our alert condition docs.\" Using units of measurement Attribute entries have an optional unit of measurement field in the front matter. For example, here the front matter for an attribute with a percent unit of measurement: --- name: cpuPercent type: attribute units: percentage (%) events: - ProcessSample --- Copy What unit of measurement to select for an attribute is sometimes obvious, like if the attribute value is measured in milliseconds (units: milliseconds (ms)) or seconds (units: seconds (s)) or a percentage (units: percentage (%)). We also have several units of measurement that are not obvious, like count, enum, rate, and ID. (Technically, these aren't actually \"units of measurement\" and are more just conceptual data types but we're doing it this way as a workaround so you can ignore the fact that units of measurement isn't actually accurate.) The main reason we want to specify this information is that this will control what kinds of queries or charts can be created or auto-suggested by New Relic. For example, the New Relic UI wouldn't want to auto-suggest a chart graphing the average of ID values because that wouldn't make any sense. So attributes with accurate units, such as data types, will help product provide more practical help/suggestions to customers in future. Here are some tips for the non-obvious unit types: count: This is a count of something, though not a count of time-based units. For a number to be a count, it must (a) only be capable of increasing during a given time/sampling period, and (b) have a theoretically uncapped range. This wouldn't be used for a count of time units; if it was a count of seconds, for example, you would just use 'seconds' as the unit of measurement. A couple of examples of a count: databaseCallCount threadConcurrency enum: enum is short for enumerated list. In other words, it is a specific range of numbers that represent other non-numeric elements. For example, an attribute that had HTTP error codes (404, 505, etc.) as possible values would be an enum. A range of numbers that represent color codes would be another example of an enum. (Theoretically, an enum can represent lists without numeric values but we have no need to categorize strings so we only care about numeric-value lists.) Example: httpResponsecode. rate: Use this for any rate (for example, count per second). These are typically for averaged rates over small units of time, like second or millisecond. We previously have used the unit of time for these attributes (for example, using seconds as the unit of measurement for a count per second rate), but now we want to use rate for these. This is necessary because the types of displays used for rates would be different than the types of displays used for a simpler duration/count measurement. Example: MySQL integration attribute db.innodb.dataReadBytesPerSecond, which has the definition \"Rate at which data is read from InnoDB tables in bytes per second.\" id: Use ID for any identification number attribute. Example: appId.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.3404,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Attribute <em>style</em> <em>guidelines</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " to be accurate, and place it in the folder of the data type it&#x27;s attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see <em>Style</em>. If the attribute has one of the units of measurement we use (like units: percentage"
      },
      "id": "61ab4782e7b9d278d80e6e03"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/agent-release-notes-template-123": [
    {
      "sections": [
        "Synthetic monitoring best practices guide",
        "1. Match your monitor type to monitoring need",
        "How to do it",
        "2. View all monitors with the Monitors index page",
        "How to view your monitors in the New Relic One:",
        "New Relic Explorer",
        "Monitors index page",
        "3. View individual monitor results",
        "How to do it:",
        "4. Understand the load-time impact of each resource",
        "5. Configure and develop a scripted browser test"
      ],
      "title": "Synthetic monitoring best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides"
      ],
      "external_id": "e76eb0669a1433bb9d0de70d90413e19749adf61",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/synthetic-monitoring-best-practices-guide/",
      "published_at": "2021-12-25T11:14:52Z",
      "updated_at": "2021-12-25T11:14:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's synthetic monitoring—powered by a Selenium-driven Chrome browser—allows you to monitor and test your apps and address issues before they affect your end users. Here are five tips to help you take immediate advantage of its full power. 1. Match your monitor type to monitoring need Synthetic monitors are virtual browsers that measure the performance of your website, recording each check in detail. They also capture aggregate numbers for load time, uptime, and average download size, as well as an overview, detailed statistics for each page resource, and downtime incidents. There are four types of synthetic monitors; the ones you deploy will depend on the things you want to monitor: Ping monitors—to ensure that your site is accessible. Simple browser monitors—to ensure end-user performance. Scripted browsers—to ensure that particular resources are present. API monitors—to ensure that your app server works as well as your website. How to do it To add a monitor, go to one.newrelic.com > Synthetics (or one.eu.newrelic.com if you have an EU-based account) and click Create monitor. Specify monitor type, name, and URL. Optional: Add a validation string (available for ping and simple browser) or advanced options, which enable substring monitoring for the following types of response validation: Verify SSL (for ping and simple browser). This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs > /dev/null Copy Bypass HEAD request (for ping). This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure (for ping). If a redirect result occurs when Redirect is Failure is enabled, Synthetics categorizes it as a failure (rather than following the redirect and checking the resulting URL). Select the locations where you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes; then from the Monitors index check your monitor. 2. View all monitors with the Monitors index page Continuous application performance monitoring is essential to ensure that web services are in place, working correctly, and error-free. Synthetic monitoring provides this type of assurance by performing automated tests on your web application for each selected location—noting downtime instances (“violations”) and collecting aggregate numbers, results, and detailed statistics for each page resource. Use the Monitors index page to get a high level view of this information, or select an individual monitor to view the Summary, for ping monitors, or Overview, for simple and scripted monitors, page and get a deeper insight into its performance over time. How to view your monitors in the New Relic One: New Relic Explorer To view a list of monitors using the New Relic One Monitors index page: Go to one.newrelic.com > Explorer > Synthetic monitors. For more information, see the documentation about navigating core UI components in New Relic One. Monitors index page To view a list of monitors using the Monitors index page: Go to one.newrelic.com > Synthetics. 3. View individual monitor results It’s not enough to understand how your web apps are performing for your West Coast customers; you need to be able to view how they’re performing across the country and around the globe. By taking advantage of synthetic monitors and visiting your Results page, you can see how everything from development to production affects user experience. You can locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. (The “Network timings” graph below provides a snapshot of webpage performance over a given period.) How to do it: Go to one.newrelic.com > Synthetics and, from the Monitors tab, select your monitor. Select Monitor > Results. Gain an up-to-the-minute view of the slowest page loads for every monitored location. 4. Understand the load-time impact of each resource Visit the synthetics Resources page to see how each resource on your website—including CSS, JavaScript, images, HTML and more—is affecting your overall load. You can drill into detailed metrics collected at run time, locate performance information for time spent by third-party resources, and identify HTTP response codes for each resource. How to do it: Go to one.newrelic.com > Synthetics and, from the Monitors drop-down menu, select your monitor. Select Monitor > Resources. 5. Configure and develop a scripted browser test Using scripted browsers, you can build complex monitoring workflows using the Selenium JavaScript Webdriver bindings. For instance, you can log in to the application, navigate to a particular link, and wait for a page element to load and add an assertion. How to do it: Go to one.newrelic.com > Synthetics. Choose your monitor type (for example, scripted browser). Enter the name and details of your monitor (for example, Sitename.com scripted browser) Select the locations from which you want your monitor to run (for example, Mumbai, Seoul, Columbus, and Montreal). Choose a frequency to determine how often each location will run your monitor (for example, five minutes). Set a notification method to alert your team when performance violations occur. You are now ready to write your script. (Below is an example of a script used to test the performance of a main navigation page.) var assert = require('chai').assert; // script-wide timeout for all wait and waitandfind functions (in ms) var default_element_timeout = 190000; //3 mins var default_pageload_timeout = 240000; //4 mins var navlinks = [\"css-locator-1\", \"css-locator-2\"]; //sets element load timeout to 3 mins $browser.manage().timeouts().implicitlyWait(default_element_timeout); //sets page load timoeout to 4 mins $browser.manage().timeouts().pageloadTimeout(default_pageload_timeout); //test all the main nav page performances $browser.get(\"http://www.sitename.com\").then(function() { return $browser.findelement($driver.by.classname(\"site-theme-example\")); }).then(function() { //verifies the nav list has loaded return $browser.findelement($driver.by.classname(\"site-nav-list-example\")); }).then(function() { //loops through the navlinks array navlinks.foreach(function(val, i, arr) { //finds and navigates to each navlink page return $browser.findelement($driver.by.classname(navlinks[i])).click().then(function() { //verifies that the nav list loaded before moving on return $browser.findelement($driver.by.classname(\"site-nav-list-example\")).then(function() { //verifies that the page logo footer at bottom of page has loaded return $browser.findelement($driver.by.classname(\"site-footer-logo\")); }); }); }); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2.2392752,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "id": "603e84bb28ccbce555eba771",
      "highlight": {}
    },
    {
      "sections": [
        "NerdGraph tutorial: APM agent configuration examples",
        "Configure server-side configuration",
        "Retrieve settings"
      ],
      "title": "NerdGraph tutorial: APM agent configuration examples",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "219a704e974c1c3cb1223fc90e50dcdf09709587",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/apm-config-nerdgraph/",
      "published_at": "2021-12-25T05:15:38Z",
      "updated_at": "2021-12-24T13:23:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc is a place for examples of configuring APM agents using our NerdGraph API. Configure server-side configuration Note that for APM agents to use configuration values changed via NerdGraph, server side configuration must be enabled. For requirements, see server-side config requirements. Here's an example query returning the status of the server side configuration setting for a given entity. query ExampleReadQuery { actor { entity(guid:\"ZjY1ODgxfEFQTXxBUFBYSUNBVElPTnz0ODEwMTY3NzZ\") { ...on ApmApplicationEntity { apmSettings { apmConfig { useServerSideConfig } } } } } } Copy Here's an example of disabling server-side configuration. Note that settings uses an array, which may be helpful if you want to update multiple entities. mutation ExampleUpdateQuery(settings: [{ guid: \"ZjY1ODgxfEFQTXxBUFBYSUNBVElPTnz0ODEwMTY3NzZ\", apmConfig: { useServerSideConfig: false }}] ) { apmSettings { apmConfig { useServerSideConfig } } errors { description } } } Copy For how to find an entity's GUID, see Find entity data. Retrieve settings Here's an example of returning an entity's transaction tracer settings: query ExampleReadQuery { actor { entity(guid:\"ZjY1ODgxfEFQTXxBUFBYSUNBVElPTnz0ODEwMTY3NzZ\") { ... on ApmApplicationEntity { guid name apmSettings { transactionTracer { enabled explainEnabled explainThresholdType explainThresholdValue } } } } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2.1238112,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "id": "61c5c9b928ccbcbd9607c57d",
      "highlight": {}
    },
    {
      "sections": [
        "Translate PromQL queries to NRQL",
        "Tip",
        "Prometheus and New Relic metric types",
        "Mapping between NRQL and our PromQL-style queries",
        "PromQL-style query example",
        "NRQL query example",
        "Filter examples",
        "PromQL-style to NRQL query examples"
      ],
      "title": "Translate PromQL queries to NRQL",
      "type": "docs",
      "tags": [
        "Integrations",
        "Prometheus integrations",
        "View and query data"
      ],
      "external_id": "a6d9e2f685b835d6d540d1b4a1bc30a99ab3bd92",
      "image": "https://docs.newrelic.com/static/PROMQL-query-2-4f5bf0fc14fc06c4e85f7bf7c4937401.png",
      "url": "https://docs.newrelic.com/docs/infrastructure/prometheus-integrations/view-query-data/translate-promql-queries-nrql/",
      "published_at": "2021-12-25T13:10:00Z",
      "updated_at": "2021-12-20T04:23:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Do you have a PromQL query you’d like to convert to NRQL? This document provides examples that show you how to convert some common PromQL queries to NRQL queries. You can use our PromQL-style query language to explore your Prometheus OpenMetrics integration data along with other data sent to New Relic. Tip To run PromQL-style queries in New Relic One, go to the query builder advanced PromQL-style mode. Prometheus and New Relic metric types The different metric types supported by Prometheus and New Relic are related to each other: New Relic Prometheus Description Count Counter The Prometheus counter is a cumulative sum while the New Relic count is a delta sum. For example, if you see 2 requests in the first reporting period and 3 requests in the second reporting period. The Prometheus counter will report 2 and then 5, while the New Relic count will report 2 and then 3. Gauge Gauge A Prometheus gauge is similar to a New Relic gauge. Multiple counts Histogram Prometheus automatically maps a histogram to a set of counters. In New Relic, these counters should be changed to deltas and reported as counts. Gauges and counts Summary Prometheus represents a Summary with a given basename as the following time series: a basename_sum a basename_count and 0 or more of basename{quantile=\".xx\"...} metrics New Relic maps the _sum as a Summary, the _count as a Counter, and each quantile metric as a Gauge. Summary (No equivalent in Prometheus) New Relic has a distinct metric type called a summary that is different than the Prometheus summary. It is designed for reporting aggregated discrete events so that you can query the count, sum, min, max, and average values. Mapping between NRQL and our PromQL-style queries Tip To see how New Relic translates PromQL-style queries to NRQL, write a query in the query builder PromQL-style tab, then switch to the NRQL tab. This table shows the mapping between NRQL and our PromQL-style queries when exploring data. For more contextual information, see the examples. Description Mapping between NRQL and PromQL-style queries Search for attributes: Explore the attributes on the container_memory_usage_bytes metric. PromQL: container_memory_usage_bytes Copy NRQL: FROM Metric SELECT keyset() WHERE metricName = 'container_memory_usage_bytes' Copy Find attribute's value: Explore the current value of the container_memory_usage_bytes metric for unique id attributes. PromQL: sum(container_memory_usage_bytes) by (id) Copy NRQL: FROM Metric SELECT latest(container_memory_usage_bytes) FACET id Copy Visualize the attribute's value: Chart the value of the container_memory_usage_bytes metric with the given id attribute value. PromQL: container_memory_usage_bytes{id=\"/\"} Copy NRQL: FROM Metric SELECT latest(container_memory_usage_bytes) WHERE id = '/' TIMESERIES Copy PromQL-style query example 1. Start your query. When exploring your data for a particular metric in PromQL, such as memory by container usage in bytes, you can start with a query such as: container_memory_usage_bytes Copy This will chart all the unique metric timeseries for the input metric. 2. Filter the query results. Looking at the data, you can add more query parameters to filter down the number of metric timeseries. For example, if you only want timeseries where the id is /, the PromQL-style query will be: container_memory_usage_bytes{id=\"/\"} Copy PromQL-style example: To filter the data, run this PromQL-style query: container_memory_usage_bytes { id=\"/\". NRQL query example 1. Query available metrics. To explore your data, start by looking at all the available metrics. Use the following NRQL query: FROM Metric SELECT uniques(metricName) Copy 2. Find unique attributes. Once you have found the metric you want to review, such as container_memory_usage_bytes, you can find the unique attributes with the following query: FROM Metric SELECT keyset() WHERE metricName = 'container_memory_usage_bytes' Copy The results will show each available attribute key and the value type (string, boolean, or number). 3. Aggregate and chart the metrics. To chart metrics using NRQL, you first need an aggregation function. For example, you can use latest for gauges, sum for counts, and average for summaries. As the following chart shows, all the unique timeseries are aggregated into one unique timeseries by default: one.newrelic.com > Query your data: This example shows the data you see after running FROM Metric SELECT keyset() WHERE metricName = 'container_memory_usage_bytes'. 4. View metrics by ID. To view the unique metric timeseries with various id values, run the following query: FROM Metric SELECT latest(container_memory_usage_bytes) FACET id Copy one.newrelic.com > Query your data: This example shows the data you see after running FROM Metric SELECT latest(container_memory_usage_bytes) FACET id. 5. Add the selected ID to the query. Next you can select an id value and put it in the NRQL where clause. FROM Metric SELECT latest(container_memory_usage_bytes) WHERE id = \"/\" timeseries Copy one.newrelic.com > Query your data: This example shows the data displayed after running From Metric select latest(container_memory_usage_bytes) where id = \"/\" timeseries. Filter examples Both our PromQL-style query language and NRQL provide syntax to filter down the number of unique metric timeseries. PromQL-style uses brackets to filter. NRQL uses a WHERE clause. Here are some example queries: Description PromQL-style and NRQL queries Select data with specific values. PromQL: go_memstats_heap_alloc_bytes{job=\"apiserver\", instance=\"1234\"}) Copy NRQL: To only select data with specific values in NRQL, use the WHERE clause with =. In this example, all data must have the selected value for job and handler. FROM Metric SELECT latest(go_memstats_heap_alloc_bytes) WHERE job = 'apiserver' AND instance = '1234' TIMESERIES Copy Select data with multiple values. PromQL: go_memstats_heap_alloc_bytes{environment=~\"staging|testing|development\",method!=\"GET\"} Copy NRQL: In NRQL use the in clause to select multiple values for an attribute and the != sign to select all values but the one listed. In this example, the environment can be staging, testing, or development, and the method cannot be GET. FROM Metric SELECT latest(go_memstats_heap_alloc_bytes) WHERE environment IN ('staging', 'testing', 'development') AND method != 'GET' TIMESERIES Copy Select data using partial string values. PromQL: go_memstats_heap_alloc_bytes{job=~\"api.*\"} Copy NRQL: In NRQL use the LIKE clause to match part of a string value. In this example, all data will be returned where the job attributes start with api. FROM Metric SELECT latest(go_memstats_heap_alloc_bytes) WHEREe job LIKE 'api%' TIMESERIES Copy PromQL-style to NRQL query examples You can simulate the following PromQL-style queries with NRQL queries: Description PromQL-style and NRQL queries Measure the per second rate over the last minute of the http_request_total metric. PromQL: sum(rate(http_requests_total[1m])) Copy NRQL: FROM Metric SELECT rate(sum(http_request_total), 1 second) TIMESERIES 1 minute Copy Chart the difference of the two metrics, then divide by 1024. PromQL: (instance_memory_limit_bytes - instance_memory_usage_bytes) / 1024 Copy NRQL: FROM Metric SELECT (latest(instance_memory_limit_bytes) - latest(instance_memory_usage_bytes)) / 1024 TIMESERIES Copy Provide the summed rate per 30-second interval by each handler. PromQL: sum(rate(http_requests_total[30s])) by (handler) Copy NRQL: FROM Metric SELECT rate(sum(http_requests_total), 30 seconds) FACET handler TIMESERIES Copy Chart the difference in the two metrics where the instance is named foo and the fstype is either ext4 or xfs. PromQL: (node_filesystem_free_bytes{instance='foo',fstype=~\"ext4|xfs\"} / node_filesystem_size_bytes{instance='foo',fstype=~\"ext4|xfs\"}) Copy NRQL: FROM Metric SELECT latest(node_filesystem_free_bytes) / latest(node_filesystem_size_bytes) WHERE instance = 'foo' AND fstype IN ('ext4', 'xfs') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1.7764372,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "id": "617daa50e7b9d2dab7c060c2",
      "highlight": {}
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/api-tutorial-template": [
    {
      "sections": [
        "apiStyleGuidelines (Example agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Return values",
        "Examples",
        "URL guidelines",
        "Title guidelines",
        "Short title guidelines",
        "Syntax guidelines",
        "Important"
      ],
      "title": "apiStyleGuidelines (Example agent API)",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "API writing guidelines"
      ],
      "external_id": "fb967e77ea9a94d7a35329c0c87062ff93ab2ff8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/apistyleguidelines-example-agent-api/",
      "published_at": "2021-12-25T17:20:58Z",
      "updated_at": "2021-11-26T09:14:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.apiStyleGuidelines(data type $parameter_name[, integer $optional_param]) newrelic.apiStyleGuidelines(data type $parameter_name, array $different_param, string $third_param) Copy Briefly describe the call. Ideally, one line or less on the \"View all methods\" page. Requirements Agent version 1.2.3.4 or higher. Additional requirements on their own line (do not use bullets). Do not use any callouts. If there are no special requirements, write: Compatible with all agent versions. Description Describe the behavior of the call with as much detail as possible. Do not describe what individual parameters do except in broad strokes; details of parameters and call variants belong under the Parameters heading. Similarly, do not describe return values. When cross-referencing another API call, format its name with code blocks, and include parentheses () like this: anotherCoolMethod(). Tip You can include callouts, but use discretion. These pages are already visually busy. Parameters If there are no parameters, leave this section blank. If there is only one call variant, do not include a syntax block in this section. Parameter Description newrelic.apiStyleGuidelines(data type $parameter_name[, integer $optional_param]) Copy $parameter_name data type Required. Brief description of parameter. $optional_param integer Optional. Brief description of parameter. newrelic.apiStyleGuidelines(data type $parameter_name, array $different_param) Copy $parameter_name data type Required. Brief description of parameter. $different_param array Required. Brief description of parameter. $third_param string Required. Brief description of parameter. Return values What does this call return, and in what circumstances? Are there any things we expect customers to do with that return value? If the call does not return anything, leave this section blank. Examples This section documents rules for oddballs that aren't self-documenting. The rest of the examples are embedded within the page itself. In general, this page is intended for style reference. For examples of how to write good API method pages, check out our existing API docs, such as the PHP API. URL guidelines For the doc's URL: Manually edit the URL slug to remove the agent name. Where the API call does not already include separators (as in newrelic_awesome_call), separate the bits with hyphens -. For example: https://docs.newrelic.com/docs/new-relic-only/advanced-style-guide/writing-guidelines/api-style-guidelines Copy Title guidelines For the doc's title: Include the method name and the agent name in parentheses. Do not include newrelic. prefixes unless they are integral to the call name (as in the PHP agent). Do not include parentheses () in the call itself. For example: apiStyleGuidelines (Example agent API) Copy Short title guidelines For the doc's short title: Include only the method name. Do not include newrelic. prefixes unless they are integral to the call name (as in the PHP agent). Do not include parentheses (). Adjust if necessary to fit on a single line in the category's sidebar. For example: apiStyleGuidelines Copy Syntax guidelines Important The Python and iOS agents use their own guidelines. For those guidelines, see the existing methods in those languages. Document each variant of a call on its own line. Do not use any formatting except italicizing the data type. Wrap optional parameters (including the comma separator) in square brackets []. Indicate the variable portion by prefacing it with a dollar sign $. If the call must be prefixed with newrelic. or similar, include that in the syntax. Optional: Include the return value, if that seems important for your particular agent. If you do, follow language conventions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.91183,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>apiStyleGuidelines</em> (Example agent <em>API</em>)",
        "sections": "URL <em>guidelines</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": ":&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;new-relic-only&#x2F;advanced-<em>style</em>-<em>guide</em>&#x2F;<em>writing</em>-<em>guidelines</em>&#x2F;<em>api</em>-<em>style</em>-<em>guidelines</em> Copy Title <em>guidelines</em> For the doc&#x27;s title: Include the method name and the agent name in parentheses. Do not include newrelic. prefixes unless they are integral to the call name (as in the PHP agent). Do"
      },
      "id": "61ab484ee7b9d293670e847e"
    },
    {
      "sections": [
        "Basic doc template",
        "Section example",
        "Code example",
        "List example",
        "Table example"
      ],
      "title": "Basic doc template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "13ab0e9d759903149944453fc4392998b6fab974",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/basic-doc-template/",
      "published_at": "2021-12-25T17:21:11Z",
      "updated_at": "2021-11-26T09:12:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the formatting tips in this template to organize the docs you create on the docs site. Then replace the template information with your own text, lists, and tables as needed. Before you create sections, start your doc with a brief introduction, usually no more than a paragraph, that helps readers understand what your doc will cover. Your introduction (and the structure of your doc) should help readers understand within ten seconds whether they are in the right place. Section example Begin each section with a meaningful H2 title. The docs site uses these to generate the contents, which appears automatically in the left navigation. If you want to include a screenshot with the section, provide a permalink for the Docs team to create the image for you. Due to security requirements, the Docs team manages all images on the docs site. Code example def article_url(category, article, options={}) url_for(options.reverse_merge( :controller => 'articles';, :action => 'show', :category => category, :article => article )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add require('newrelic'); as the first line of your app's main module. Use the command npm install newrelic --save for each application you want to monitor. For unordered lists, use bullets (ul in HTML or * in Markdown). For example: Black White For complex lists, consider using collapsers. Table example Tables help organize detailed lists so the information is easier to skim. Tables are easier to manage in HTML. For exammple: <table> <thead> <tr> <th width={200}> **Item** </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Some thing </td> <td> More detailed information about it </td> </tr> <tr> <td> Another thing </td> <td> More detailed information about another thing </td> </tr> </tbody> </table> Copy Tables created in Markdown use three or more hyphens --- to create each column’s header, and pipes | to separate each column. For example: | Item | Requirements ------------ | ------------ | Some thing | More detailed information about it | Another thing | More detailed information about another thing Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.19138,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61b3574c64441f1cc6aec5a4"
    },
    {
      "sections": [
        "GraphQL API tutorial template",
        "Example query #1 with GraphQL",
        "Example query #2 with GraphQL",
        "Example query #3 with GraphQL"
      ],
      "title": "GraphQL API tutorial template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "827639827da156b6a36096c0f6a3911052706a91",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/graphql-api-tutorial-template/",
      "published_at": "2021-12-25T17:21:11Z",
      "updated_at": "2021-11-26T09:09:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL API tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what problem or use case the users want to solve, or why the API can help them query to get this data Three to five query examples that show interesting data they can get from GraphQL Sample intro paragraph: You can use the New Relic GraphQL API to [ add key use cases here]. To construct these queries and see responses, you can use the New Relic GraphQL Explorer. This document explains some of the available functions to query [ data to be queried]. Example query #1 with GraphQL Add a description here for your example query. Tell users why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #2 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #3 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.18945,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "GraphQL <em>API</em> tutorial template",
        "sections": "GraphQL <em>API</em> tutorial template",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL <em>API</em> tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what"
      },
      "id": "61ab330c64441fd067927126"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/apistyleguidelines-example-agent-api": [
    {
      "sections": [
        "API tutorial template",
        "Introduction (this heading will not be visible)",
        "Optional: Provide an overview for complex processes",
        "Provide a procedure to accomplish the task",
        "Tip",
        "Step 1. Do something...",
        "If needed: Step 2. Do something else...",
        "If needed: Step 3. Do something else...",
        "Last step. Verify that the task was completed...",
        "Optional: Do something else with the API",
        "Optional: Large example code block",
        "Code block example",
        "Optional: Troubleshooting"
      ],
      "title": "API tutorial template  ",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "API writing guidelines"
      ],
      "external_id": "b69605a3a5585b2ee7f89c250bbdd5345c5d9311",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/api-tutorial-template/",
      "published_at": "2021-12-25T17:20:29Z",
      "updated_at": "2021-11-26T09:14:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is a template for an API tutorial document: Please skim the entire template first to understand the expected structure for this type of doc. Then, clone this doc using the Clone content link in the Page tools box. Delete all content up to Introduction (this heading won't be visible). For the doc title (the field at top of page): Doc should be named in a practical, use-case-focused way. Example: Add custom attributes to transactions Introduction (this heading will not be visible) Provide a brief explanation of what this document will teach customers, and why it is valuable for customers to know how to do that. Focus on the value the API provides to the customers and mention specific, common use cases. Any relevant notes about support/compatability should go here, too. Here's an example from the Java API asynchronous tutorial doc: New Relic for Java includes an API to instrument asynchronous activity. For supported frameworks, the Java agent usually instruments async work automatically. However, the async API can be useful for adding more detail to your data. This document provides examples of using tokens and segments to instrument your app. Optional: Provide an overview for complex processes This is an optional section for complicated tutorials that involve either using several methods in one procedure or that have different alternate steps you can take to achieve similar results. This section can link to lower-down sections to allow users to skip around as needed. For simple tutorials, this section isn't necessary. For an example, see this section of the Java async tutorial. Provide a procedure to accomplish the task Tell the user how to accomplish the task, and link to the methods necessary to accomplish that task. As much as possible, we're looking to describe tasks in \"procedures\" (procedure is tech writer jargon for a series of numbered steps). This may be tough to do for fairly open-ended/variable tasks, but it will usually be possible to chunk the content at a fairly high-level to make it into a procedure. Along the way, explain what the importance of the procedure step is, and how one might verify that the step was done correctly. For code samples, avoid using large chunks of code. Instead, use smaller pieces of code and give context for how they are being used. (If you think a large app code example would be helpful, place that later in the doc in the Example section.) Tip For an example of an open-ended task segmented into procedural chunks, see the Asynchronous doc section Connecting async threads. For another example, see this TomCat GAE Flex procedure. Base your procedure on the simple structure below. Tech writers will edit your content to match our style and formatting requirements: Step 1. Do something... Methods and example code to implement the first step. For each step, if applicable, indicate the significance of that step (why it's important) and how the user might verify that the step was done correctly (for example, something showing up in UI, or running a verification test of some sort). If needed: Step 2. Do something else... Methods and example code to implement step 2. If needed: Step 3. Do something else... Methods and example code to implement step 3. Last step. Verify that the task was completed... Explain how a user would know they'd completed the task correctly. In particular, how would the user find the new change or data in the New Relic UI. What New Relic products and pages would the change be noticed on? If new data shows up in Insights, what event types can it be found under? Optional: Do something else with the API Same as above. Make as many headings and separate procedures as needed. Optional: Large example code block If you think a large app code example would be useful, place here. Within any code block, explain all New Relic functions/methods, not just the main methods. Instead of in-line comments, consider using highlighted sections underneath the code block to give additional context. Here's an example: Code block example The following code example shows a segment starting in the storeItem method to measure how long the Lambda statement is waiting in the thread pool. To stop timing the segment, you must call either .end() or .ignore(). If you don't want to report the segment as part of its parent transaction, call .ignore(). Otherwise, to report the segment as part of its parent transaction, call .end(). private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal (DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()); // fire and forget DB_POOL.submit(() -> { segment.end(); insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For more on this method, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in APM with datastore data. For more information, see reportAsExternal API. segment.end(): Stops timing this segment. For more on this method, see the Javadoc. Optional: Troubleshooting Optional area for any common errors or troubleshooting tips.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.91162,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>API</em> tutorial template  ",
        "sections": "<em>API</em> tutorial template",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " to describe tasks in &quot;procedures&quot; (procedure is <em>tech</em> <em>writer</em> jargon for a series of numbered steps). This may be tough to do for fairly open-ended&#x2F;variable tasks, but it will usually be possible to chunk the content at a fairly high-level to make it into a procedure. Along the way, explain what"
      },
      "id": "61b35723196a675e16a5b0a4"
    },
    {
      "sections": [
        "Basic doc template",
        "Section example",
        "Code example",
        "List example",
        "Table example"
      ],
      "title": "Basic doc template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "13ab0e9d759903149944453fc4392998b6fab974",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/basic-doc-template/",
      "published_at": "2021-12-25T17:21:11Z",
      "updated_at": "2021-11-26T09:12:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the formatting tips in this template to organize the docs you create on the docs site. Then replace the template information with your own text, lists, and tables as needed. Before you create sections, start your doc with a brief introduction, usually no more than a paragraph, that helps readers understand what your doc will cover. Your introduction (and the structure of your doc) should help readers understand within ten seconds whether they are in the right place. Section example Begin each section with a meaningful H2 title. The docs site uses these to generate the contents, which appears automatically in the left navigation. If you want to include a screenshot with the section, provide a permalink for the Docs team to create the image for you. Due to security requirements, the Docs team manages all images on the docs site. Code example def article_url(category, article, options={}) url_for(options.reverse_merge( :controller => 'articles';, :action => 'show', :category => category, :article => article )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add require('newrelic'); as the first line of your app's main module. Use the command npm install newrelic --save for each application you want to monitor. For unordered lists, use bullets (ul in HTML or * in Markdown). For example: Black White For complex lists, consider using collapsers. Table example Tables help organize detailed lists so the information is easier to skim. Tables are easier to manage in HTML. For exammple: <table> <thead> <tr> <th width={200}> **Item** </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Some thing </td> <td> More detailed information about it </td> </tr> <tr> <td> Another thing </td> <td> More detailed information about another thing </td> </tr> </tbody> </table> Copy Tables created in Markdown use three or more hyphens --- to create each column’s header, and pipes | to separate each column. For example: | Item | Requirements ------------ | ------------ | Some thing | More detailed information about it | Another thing | More detailed information about another thing Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.19138,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61b3574c64441f1cc6aec5a4"
    },
    {
      "sections": [
        "GraphQL API tutorial template",
        "Example query #1 with GraphQL",
        "Example query #2 with GraphQL",
        "Example query #3 with GraphQL"
      ],
      "title": "GraphQL API tutorial template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "827639827da156b6a36096c0f6a3911052706a91",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/graphql-api-tutorial-template/",
      "published_at": "2021-12-25T17:21:11Z",
      "updated_at": "2021-11-26T09:09:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL API tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what problem or use case the users want to solve, or why the API can help them query to get this data Three to five query examples that show interesting data they can get from GraphQL Sample intro paragraph: You can use the New Relic GraphQL API to [ add key use cases here]. To construct these queries and see responses, you can use the New Relic GraphQL Explorer. This document explains some of the available functions to query [ data to be queried]. Example query #1 with GraphQL Add a description here for your example query. Tell users why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #2 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #3 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.18945,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "GraphQL <em>API</em> tutorial template",
        "sections": "GraphQL <em>API</em> tutorial template",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL <em>API</em> tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what"
      },
      "id": "61ab330c64441fd067927126"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/basic-doc-template": [
    {
      "sections": [
        "GraphQL API tutorial template",
        "Example query #1 with GraphQL",
        "Example query #2 with GraphQL",
        "Example query #3 with GraphQL"
      ],
      "title": "GraphQL API tutorial template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "827639827da156b6a36096c0f6a3911052706a91",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/graphql-api-tutorial-template/",
      "published_at": "2021-12-25T17:21:11Z",
      "updated_at": "2021-11-26T09:09:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL API tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what problem or use case the users want to solve, or why the API can help them query to get this data Three to five query examples that show interesting data they can get from GraphQL Sample intro paragraph: You can use the New Relic GraphQL API to [ add key use cases here]. To construct these queries and see responses, you can use the New Relic GraphQL Explorer. This document explains some of the available functions to query [ data to be queried]. Example query #1 with GraphQL Add a description here for your example query. Tell users why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #2 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #3 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.4794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "GraphQL API tutorial <em>template</em>",
        "sections": "GraphQL API tutorial <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61ab330c64441fd067927126"
    },
    {
      "sections": [
        "Add to data dictionary",
        "Data dictionary structure",
        "Add a new data type",
        "Add attributes",
        "Attribute style guidelines",
        "Using units of measurement"
      ],
      "title": "Add to data dictionary",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "05c35d88b970eee521e2af4e255666e31b915468",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/data-dictionary-style-guidelines/",
      "published_at": "2021-12-25T17:01:32Z",
      "updated_at": "2021-11-26T07:01:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We use the data dictionary to provide information about data types (for example, Transaction, Metric, Log) and attached attributes. This is exposed in the New Relic query experience, on hovering over the data types and attributes. And we also expose the dictionary to the public. This doc contains info on how to add data to the dictionary. Note that currently we don't have infrastructure integration data in the dictionary. We also have very few attributes for the Metric data type, just a few basic default ones, despite there being many potential attributes attached to that data type depending on what the data source is. Data dictionary structure The data in the data dictionary is structured like this: Data types: sometimes called \"events\" for historical reasons, these are the NRDB data objects, like Transaction, Metric, Log, Span, etc. Attributes: these are key:value pairs attached to data types. One attribute can have multiple data types listed for it. For example, appName is on multiple data types. Data source: The New Relic product from which the data originates. With the current implementation, a data type must have a single data source assigned. This isn't ideal, as theoretically a data type can come from multiple sources. Add a new data type To add a new data type: Make a new folder in this directory, alongside the other directories: src/data-dictionary/events Copy Duplicate a data type file (for example, this Metric data type), place it in the new folder, and fill it out with the new info. For how to add attributes on a new data type, keep reading. Add attributes To add attributes: Check if there's an existing attribute that has the same name and same general definition as the one you're trying to add. If it exists, edit that file to include the new data type (under events:). If an existing attribute is fairly close in definition but not exact, try to edit the definition so it works for all associated data types. If there is no existing attribute, create a new one. The easiest way is to copy an existing attribute file, edit all relevant fields to be accurate, and place it in the folder of the data type it's attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see Style. If the attribute has one of the units of measurement we use (like units: percentage (%)), add that to the front matter. For info on units, see Units. Attribute style guidelines When adding or editing attributes, some things to keep in mind: Aim for concise descriptions. Notes on this: Feel free to use sentence fragments. Feel free to edit definitions submitted from internal teams as sometimes their definitions will be overly long or have unneeded links. Some attributes are only present in some situations (for example, when a specific APM agent is used, or when a specific config option is true). We should avoid documenting most of these, with the idea that most customers will only care about the data because it's being reported for them, and won't care about the things that factor into the reasons why it wouldn't be reported. If it's thought that the addition would help customers who already have the data reporting understand the data better, you can include it. Write so it reads well as plain text. Details on this: Note that the docs site data dictionary has our usual docs styles available, but the query UI definitions have no styling available. This means that you should write definitions so that they are understandable without any styling, as plain text. You can often avoid any need for styling (for example, data types like Transaction are easy to understand as plain text, as are most phrasings that use attribute names or values. When plain text makes something too ambiguous and you need some styling, use back ticks to indicate attributes or values (for example, a definition like: Reported when ` category ` is ` http ` ). Using this also sets us up for success if we implement styling in the UI definitions in the future. We should avoid links because those aren't visible in the query UI; the query UI only displays plain text. However, every attribute entry in the query UI does display a 'See attribute in docs' link that links to the complete and normally formatted docs site entry. This means that we can use links provided that they will display in an easy to understand way in the query UI. For example, here's an example of an attribute that would read clearly in plain text despite not having a link. We should avoid using a link format like \"For more information, see Create an alert condition\", because it wouldn't read well in plain text, and would choose something like \"For more information, see our alert condition docs.\" Using units of measurement Attribute entries have an optional unit of measurement field in the front matter. For example, here the front matter for an attribute with a percent unit of measurement: --- name: cpuPercent type: attribute units: percentage (%) events: - ProcessSample --- Copy What unit of measurement to select for an attribute is sometimes obvious, like if the attribute value is measured in milliseconds (units: milliseconds (ms)) or seconds (units: seconds (s)) or a percentage (units: percentage (%)). We also have several units of measurement that are not obvious, like count, enum, rate, and ID. (Technically, these aren't actually \"units of measurement\" and are more just conceptual data types but we're doing it this way as a workaround so you can ignore the fact that units of measurement isn't actually accurate.) The main reason we want to specify this information is that this will control what kinds of queries or charts can be created or auto-suggested by New Relic. For example, the New Relic UI wouldn't want to auto-suggest a chart graphing the average of ID values because that wouldn't make any sense. So attributes with accurate units, such as data types, will help product provide more practical help/suggestions to customers in future. Here are some tips for the non-obvious unit types: count: This is a count of something, though not a count of time-based units. For a number to be a count, it must (a) only be capable of increasing during a given time/sampling period, and (b) have a theoretically uncapped range. This wouldn't be used for a count of time units; if it was a count of seconds, for example, you would just use 'seconds' as the unit of measurement. A couple of examples of a count: databaseCallCount threadConcurrency enum: enum is short for enumerated list. In other words, it is a specific range of numbers that represent other non-numeric elements. For example, an attribute that had HTTP error codes (404, 505, etc.) as possible values would be an enum. A range of numbers that represent color codes would be another example of an enum. (Theoretically, an enum can represent lists without numeric values but we have no need to categorize strings so we only care about numeric-value lists.) Example: httpResponsecode. rate: Use this for any rate (for example, count per second). These are typically for averaged rates over small units of time, like second or millisecond. We previously have used the unit of time for these attributes (for example, using seconds as the unit of measurement for a count per second rate), but now we want to use rate for these. This is necessary because the types of displays used for rates would be different than the types of displays used for a simpler duration/count measurement. Example: MySQL integration attribute db.innodb.dataReadBytesPerSecond, which has the definition \"Rate at which data is read from InnoDB tables in bytes per second.\" id: Use ID for any identification number attribute. Example: appId.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.34036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Attribute <em>style</em> <em>guidelines</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " to be accurate, and place it in the folder of the data type it&#x27;s attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see <em>Style</em>. If the attribute has one of the units of measurement we use (like units: percentage"
      },
      "id": "61ab4782e7b9d278d80e6e03"
    },
    {
      "sections": [
        "Troubleshooting docs guide",
        "Problem",
        "Solution",
        "Cause",
        "Related info"
      ],
      "title": "Troubleshooting docs guide",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "55f439b9842d1f5df9e5ce1b06a5c5d9ae7829f6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/troubleshooting-docs-guide/",
      "published_at": "2021-12-25T17:05:54Z",
      "updated_at": "2021-11-25T11:25:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our troubleshooting docs have these main sections: problem, solution, and (optionally) cause. Otherwise, a troubleshooting doc uses the basic doc template Problem Generally, this is the who, what, when, and where of the troubleshooting doc. Provide a clear, concise description of the problem the user is trying to solve. Include steps for reproduction, symptoms, and other key points when applicable. Re-state the problem in different ways if needed, to ensure customers can find this doc via Google. If the problem text is very short, you can include the cause text here. Solution Generally, this is the how of the troubleshooting doc. Provide an ordered list of steps to guide users through the solution. If there are multiple causes and solutions, consider creating a standard, basic page doc rather than using the troubleshooting template. Consider the best approach to help the reader, and discuss your reasoning with your peer editor. If the issue you are documenting is more of a known issue (FYI in nature), or if it doesn't solve the issue: Incorporate the information into other relevant docs. Do not refer to it as a known issue. OR Create a troubleshooting doc that describes the problem and cause. Do not include a solution. Also, include any statements promising that the issue will be fixed in a future release. Cause Generally, this is the why of the troubleshooting doc, and is optional. The Cause section is particularly useful when the product works in an unintuitive way. Provide background information or context that gives the user additional insight into the problem. If the problem and the cause text are both very short, you can include the cause in the Problem section. Related info In general, leave blank. The standard For more help footer block will appear automatically when published. If necessary, use this section to link to other, related docs if it does not make sense to refer to them within the context of other information in the troubleshooting doc itself.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.1003,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting docs <em>guide</em>",
        "sections": "Troubleshooting docs <em>guide</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": ", this is the how of the troubleshooting doc. Provide an ordered list of steps to <em>guide</em> users through the solution. If there are multiple causes and solutions, consider creating a standard, basic page doc rather than using the troubleshooting template. Consider the best approach to help the reader"
      },
      "id": "61ab4826e7b9d293010e7a46"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/data-dictionary-style-guidelines": [
    {
      "sections": [
        "Basic doc template",
        "Section example",
        "Code example",
        "List example",
        "Table example"
      ],
      "title": "Basic doc template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "13ab0e9d759903149944453fc4392998b6fab974",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/basic-doc-template/",
      "published_at": "2021-12-25T17:21:11Z",
      "updated_at": "2021-11-26T09:12:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the formatting tips in this template to organize the docs you create on the docs site. Then replace the template information with your own text, lists, and tables as needed. Before you create sections, start your doc with a brief introduction, usually no more than a paragraph, that helps readers understand what your doc will cover. Your introduction (and the structure of your doc) should help readers understand within ten seconds whether they are in the right place. Section example Begin each section with a meaningful H2 title. The docs site uses these to generate the contents, which appears automatically in the left navigation. If you want to include a screenshot with the section, provide a permalink for the Docs team to create the image for you. Due to security requirements, the Docs team manages all images on the docs site. Code example def article_url(category, article, options={}) url_for(options.reverse_merge( :controller => 'articles';, :action => 'show', :category => category, :article => article )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add require('newrelic'); as the first line of your app's main module. Use the command npm install newrelic --save for each application you want to monitor. For unordered lists, use bullets (ul in HTML or * in Markdown). For example: Black White For complex lists, consider using collapsers. Table example Tables help organize detailed lists so the information is easier to skim. Tables are easier to manage in HTML. For exammple: <table> <thead> <tr> <th width={200}> **Item** </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Some thing </td> <td> More detailed information about it </td> </tr> <tr> <td> Another thing </td> <td> More detailed information about another thing </td> </tr> </tbody> </table> Copy Tables created in Markdown use three or more hyphens --- to create each column’s header, and pipes | to separate each column. For example: | Item | Requirements ------------ | ------------ | Some thing | More detailed information about it | Another thing | More detailed information about another thing Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.4826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Basic doc <em>template</em>",
        "sections": "Basic doc <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " <em>article</em>_url(category, <em>article</em>, options={}) url_for(options.reverse_merge( :controller =&gt; &#x27;articles&#x27;;, :action =&gt; &#x27;show&#x27;, :category =&gt; category, :<em>article</em> =&gt; <em>article</em> )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add"
      },
      "id": "61b3574c64441f1cc6aec5a4"
    },
    {
      "sections": [
        "GraphQL API tutorial template",
        "Example query #1 with GraphQL",
        "Example query #2 with GraphQL",
        "Example query #3 with GraphQL"
      ],
      "title": "GraphQL API tutorial template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "827639827da156b6a36096c0f6a3911052706a91",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/graphql-api-tutorial-template/",
      "published_at": "2021-12-25T17:21:11Z",
      "updated_at": "2021-11-26T09:09:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL API tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what problem or use case the users want to solve, or why the API can help them query to get this data Three to five query examples that show interesting data they can get from GraphQL Sample intro paragraph: You can use the New Relic GraphQL API to [ add key use cases here]. To construct these queries and see responses, you can use the New Relic GraphQL Explorer. This document explains some of the available functions to query [ data to be queried]. Example query #1 with GraphQL Add a description here for your example query. Tell users why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #2 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #3 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.4794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "GraphQL API tutorial <em>template</em>",
        "sections": "GraphQL API tutorial <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61ab330c64441fd067927126"
    },
    {
      "sections": [
        "Troubleshooting docs guide",
        "Problem",
        "Solution",
        "Cause",
        "Related info"
      ],
      "title": "Troubleshooting docs guide",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "55f439b9842d1f5df9e5ce1b06a5c5d9ae7829f6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/troubleshooting-docs-guide/",
      "published_at": "2021-12-25T17:05:54Z",
      "updated_at": "2021-11-25T11:25:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our troubleshooting docs have these main sections: problem, solution, and (optionally) cause. Otherwise, a troubleshooting doc uses the basic doc template Problem Generally, this is the who, what, when, and where of the troubleshooting doc. Provide a clear, concise description of the problem the user is trying to solve. Include steps for reproduction, symptoms, and other key points when applicable. Re-state the problem in different ways if needed, to ensure customers can find this doc via Google. If the problem text is very short, you can include the cause text here. Solution Generally, this is the how of the troubleshooting doc. Provide an ordered list of steps to guide users through the solution. If there are multiple causes and solutions, consider creating a standard, basic page doc rather than using the troubleshooting template. Consider the best approach to help the reader, and discuss your reasoning with your peer editor. If the issue you are documenting is more of a known issue (FYI in nature), or if it doesn't solve the issue: Incorporate the information into other relevant docs. Do not refer to it as a known issue. OR Create a troubleshooting doc that describes the problem and cause. Do not include a solution. Also, include any statements promising that the issue will be fixed in a future release. Cause Generally, this is the why of the troubleshooting doc, and is optional. The Cause section is particularly useful when the product works in an unintuitive way. Provide background information or context that gives the user additional insight into the problem. If the problem and the cause text are both very short, you can include the cause in the Problem section. Related info In general, leave blank. The standard For more help footer block will appear automatically when published. If necessary, use this section to link to other, related docs if it does not make sense to refer to them within the context of other information in the troubleshooting doc itself.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.1003,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting docs <em>guide</em>",
        "sections": "Troubleshooting docs <em>guide</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": ", this is the how of the troubleshooting doc. Provide an ordered list of steps to <em>guide</em> users through the solution. If there are multiple causes and solutions, consider creating a standard, basic page doc rather than using the troubleshooting template. Consider the best approach to help the reader"
      },
      "id": "61ab4826e7b9d293010e7a46"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/graphql-api-tutorial-template": [
    {
      "sections": [
        "Basic doc template",
        "Section example",
        "Code example",
        "List example",
        "Table example"
      ],
      "title": "Basic doc template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "13ab0e9d759903149944453fc4392998b6fab974",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/basic-doc-template/",
      "published_at": "2021-12-25T17:21:11Z",
      "updated_at": "2021-11-26T09:12:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the formatting tips in this template to organize the docs you create on the docs site. Then replace the template information with your own text, lists, and tables as needed. Before you create sections, start your doc with a brief introduction, usually no more than a paragraph, that helps readers understand what your doc will cover. Your introduction (and the structure of your doc) should help readers understand within ten seconds whether they are in the right place. Section example Begin each section with a meaningful H2 title. The docs site uses these to generate the contents, which appears automatically in the left navigation. If you want to include a screenshot with the section, provide a permalink for the Docs team to create the image for you. Due to security requirements, the Docs team manages all images on the docs site. Code example def article_url(category, article, options={}) url_for(options.reverse_merge( :controller => 'articles';, :action => 'show', :category => category, :article => article )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add require('newrelic'); as the first line of your app's main module. Use the command npm install newrelic --save for each application you want to monitor. For unordered lists, use bullets (ul in HTML or * in Markdown). For example: Black White For complex lists, consider using collapsers. Table example Tables help organize detailed lists so the information is easier to skim. Tables are easier to manage in HTML. For exammple: <table> <thead> <tr> <th width={200}> **Item** </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Some thing </td> <td> More detailed information about it </td> </tr> <tr> <td> Another thing </td> <td> More detailed information about another thing </td> </tr> </tbody> </table> Copy Tables created in Markdown use three or more hyphens --- to create each column’s header, and pipes | to separate each column. For example: | Item | Requirements ------------ | ------------ | Some thing | More detailed information about it | Another thing | More detailed information about another thing Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.4826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Basic doc <em>template</em>",
        "sections": "Basic doc <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " <em>article</em>_url(category, <em>article</em>, options={}) url_for(options.reverse_merge( :controller =&gt; &#x27;articles&#x27;;, :action =&gt; &#x27;show&#x27;, :category =&gt; category, :<em>article</em> =&gt; <em>article</em> )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add"
      },
      "id": "61b3574c64441f1cc6aec5a4"
    },
    {
      "sections": [
        "Add to data dictionary",
        "Data dictionary structure",
        "Add a new data type",
        "Add attributes",
        "Attribute style guidelines",
        "Using units of measurement"
      ],
      "title": "Add to data dictionary",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "05c35d88b970eee521e2af4e255666e31b915468",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/data-dictionary-style-guidelines/",
      "published_at": "2021-12-25T17:01:32Z",
      "updated_at": "2021-11-26T07:01:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We use the data dictionary to provide information about data types (for example, Transaction, Metric, Log) and attached attributes. This is exposed in the New Relic query experience, on hovering over the data types and attributes. And we also expose the dictionary to the public. This doc contains info on how to add data to the dictionary. Note that currently we don't have infrastructure integration data in the dictionary. We also have very few attributes for the Metric data type, just a few basic default ones, despite there being many potential attributes attached to that data type depending on what the data source is. Data dictionary structure The data in the data dictionary is structured like this: Data types: sometimes called \"events\" for historical reasons, these are the NRDB data objects, like Transaction, Metric, Log, Span, etc. Attributes: these are key:value pairs attached to data types. One attribute can have multiple data types listed for it. For example, appName is on multiple data types. Data source: The New Relic product from which the data originates. With the current implementation, a data type must have a single data source assigned. This isn't ideal, as theoretically a data type can come from multiple sources. Add a new data type To add a new data type: Make a new folder in this directory, alongside the other directories: src/data-dictionary/events Copy Duplicate a data type file (for example, this Metric data type), place it in the new folder, and fill it out with the new info. For how to add attributes on a new data type, keep reading. Add attributes To add attributes: Check if there's an existing attribute that has the same name and same general definition as the one you're trying to add. If it exists, edit that file to include the new data type (under events:). If an existing attribute is fairly close in definition but not exact, try to edit the definition so it works for all associated data types. If there is no existing attribute, create a new one. The easiest way is to copy an existing attribute file, edit all relevant fields to be accurate, and place it in the folder of the data type it's attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see Style. If the attribute has one of the units of measurement we use (like units: percentage (%)), add that to the front matter. For info on units, see Units. Attribute style guidelines When adding or editing attributes, some things to keep in mind: Aim for concise descriptions. Notes on this: Feel free to use sentence fragments. Feel free to edit definitions submitted from internal teams as sometimes their definitions will be overly long or have unneeded links. Some attributes are only present in some situations (for example, when a specific APM agent is used, or when a specific config option is true). We should avoid documenting most of these, with the idea that most customers will only care about the data because it's being reported for them, and won't care about the things that factor into the reasons why it wouldn't be reported. If it's thought that the addition would help customers who already have the data reporting understand the data better, you can include it. Write so it reads well as plain text. Details on this: Note that the docs site data dictionary has our usual docs styles available, but the query UI definitions have no styling available. This means that you should write definitions so that they are understandable without any styling, as plain text. You can often avoid any need for styling (for example, data types like Transaction are easy to understand as plain text, as are most phrasings that use attribute names or values. When plain text makes something too ambiguous and you need some styling, use back ticks to indicate attributes or values (for example, a definition like: Reported when ` category ` is ` http ` ). Using this also sets us up for success if we implement styling in the UI definitions in the future. We should avoid links because those aren't visible in the query UI; the query UI only displays plain text. However, every attribute entry in the query UI does display a 'See attribute in docs' link that links to the complete and normally formatted docs site entry. This means that we can use links provided that they will display in an easy to understand way in the query UI. For example, here's an example of an attribute that would read clearly in plain text despite not having a link. We should avoid using a link format like \"For more information, see Create an alert condition\", because it wouldn't read well in plain text, and would choose something like \"For more information, see our alert condition docs.\" Using units of measurement Attribute entries have an optional unit of measurement field in the front matter. For example, here the front matter for an attribute with a percent unit of measurement: --- name: cpuPercent type: attribute units: percentage (%) events: - ProcessSample --- Copy What unit of measurement to select for an attribute is sometimes obvious, like if the attribute value is measured in milliseconds (units: milliseconds (ms)) or seconds (units: seconds (s)) or a percentage (units: percentage (%)). We also have several units of measurement that are not obvious, like count, enum, rate, and ID. (Technically, these aren't actually \"units of measurement\" and are more just conceptual data types but we're doing it this way as a workaround so you can ignore the fact that units of measurement isn't actually accurate.) The main reason we want to specify this information is that this will control what kinds of queries or charts can be created or auto-suggested by New Relic. For example, the New Relic UI wouldn't want to auto-suggest a chart graphing the average of ID values because that wouldn't make any sense. So attributes with accurate units, such as data types, will help product provide more practical help/suggestions to customers in future. Here are some tips for the non-obvious unit types: count: This is a count of something, though not a count of time-based units. For a number to be a count, it must (a) only be capable of increasing during a given time/sampling period, and (b) have a theoretically uncapped range. This wouldn't be used for a count of time units; if it was a count of seconds, for example, you would just use 'seconds' as the unit of measurement. A couple of examples of a count: databaseCallCount threadConcurrency enum: enum is short for enumerated list. In other words, it is a specific range of numbers that represent other non-numeric elements. For example, an attribute that had HTTP error codes (404, 505, etc.) as possible values would be an enum. A range of numbers that represent color codes would be another example of an enum. (Theoretically, an enum can represent lists without numeric values but we have no need to categorize strings so we only care about numeric-value lists.) Example: httpResponsecode. rate: Use this for any rate (for example, count per second). These are typically for averaged rates over small units of time, like second or millisecond. We previously have used the unit of time for these attributes (for example, using seconds as the unit of measurement for a count per second rate), but now we want to use rate for these. This is necessary because the types of displays used for rates would be different than the types of displays used for a simpler duration/count measurement. Example: MySQL integration attribute db.innodb.dataReadBytesPerSecond, which has the definition \"Rate at which data is read from InnoDB tables in bytes per second.\" id: Use ID for any identification number attribute. Example: appId.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.34033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Attribute <em>style</em> <em>guidelines</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " to be accurate, and place it in the folder of the data type it&#x27;s attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see <em>Style</em>. If the attribute has one of the units of measurement we use (like units: percentage"
      },
      "id": "61ab4782e7b9d278d80e6e03"
    },
    {
      "sections": [
        "Troubleshooting docs guide",
        "Problem",
        "Solution",
        "Cause",
        "Related info"
      ],
      "title": "Troubleshooting docs guide",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "55f439b9842d1f5df9e5ce1b06a5c5d9ae7829f6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/troubleshooting-docs-guide/",
      "published_at": "2021-12-25T17:05:54Z",
      "updated_at": "2021-11-25T11:25:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our troubleshooting docs have these main sections: problem, solution, and (optionally) cause. Otherwise, a troubleshooting doc uses the basic doc template Problem Generally, this is the who, what, when, and where of the troubleshooting doc. Provide a clear, concise description of the problem the user is trying to solve. Include steps for reproduction, symptoms, and other key points when applicable. Re-state the problem in different ways if needed, to ensure customers can find this doc via Google. If the problem text is very short, you can include the cause text here. Solution Generally, this is the how of the troubleshooting doc. Provide an ordered list of steps to guide users through the solution. If there are multiple causes and solutions, consider creating a standard, basic page doc rather than using the troubleshooting template. Consider the best approach to help the reader, and discuss your reasoning with your peer editor. If the issue you are documenting is more of a known issue (FYI in nature), or if it doesn't solve the issue: Incorporate the information into other relevant docs. Do not refer to it as a known issue. OR Create a troubleshooting doc that describes the problem and cause. Do not include a solution. Also, include any statements promising that the issue will be fixed in a future release. Cause Generally, this is the why of the troubleshooting doc, and is optional. The Cause section is particularly useful when the product works in an unintuitive way. Provide background information or context that gives the user additional insight into the problem. If the problem and the cause text are both very short, you can include the cause in the Problem section. Related info In general, leave blank. The standard For more help footer block will appear automatically when published. If necessary, use this section to link to other, related docs if it does not make sense to refer to them within the context of other information in the troubleshooting doc itself.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.1003,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting docs <em>guide</em>",
        "sections": "Troubleshooting docs <em>guide</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": ", this is the how of the troubleshooting doc. Provide an ordered list of steps to <em>guide</em> users through the solution. If there are multiple causes and solutions, consider creating a standard, basic page doc rather than using the troubleshooting template. Consider the best approach to help the reader"
      },
      "id": "61ab4826e7b9d293010e7a46"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/landing-page-template": [
    {
      "sections": [
        "Update the home page",
        "Update a link's URL",
        "Add a new tile to the home page",
        "Add a new section to the home page",
        "Edit the home page left nav"
      ],
      "title": "Update the home page",
      "type": "docs",
      "tags": [
        "home page",
        "landing pages"
      ],
      "external_id": "1d084fae5223f5b34cec91fcae0bcb35560c7b29",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/edit-homepage/",
      "published_at": "2021-12-25T16:54:07Z",
      "updated_at": "2021-12-04T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can't just hit the edit button docs.newrelic.com to make edits to the home page. The page that opens is index.js, the file that manages the parts of the home page, but not the content. It's rare that you'll need to make changes to this file. Most home page changes will be to add a new tile or section to the page, or update links. These types of changes are handled in two files: src/data/homepage.yml - contains home page section titles, section descriptions, and the URLs for tiles. src/i18n/translations/en/translation.json - contains tile info, including the title and short description of tiles. Update a link's URL Change or add new links using homepage.yml. In homepage.yml, search for the link you want to change. Edit the URL, save, commit, and PR the change. Add a new tile to the home page You'll make changes to both homepage.yml and translations.json On the translations.json doc, find the spot where you want to add the new tile (which section, and in what order you want it to appear), and add a new entry with this format: \"t#\": { \"title\": \"tile name\", \"description\": \"Short description.\" }, Copy Make sure you update the number on the tile. If you want to insert it in the middle of a group, update all the subsequent tile numbers as well. Save the file. Open homepage.yml, find the spot where the new tile will be, and add a new line with the relative link for the new tile. For example, - /docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster Save and check that your new tile builds properly on a local build. Commit, push, PR when you're ready. Add a new section to the home page On the translations.json page, add a new section modeled in the spot where you want the new section to appear. Include at least one title. For example, here's the TDP entry, with one tile: \"errors-inbox\": { \"title\": \"Errors Inbox\", \"description\": \"A single place to proactively detect, triage, and take action on all the errors before they impact customers.\", \"t1\": { \"title\": \"Introduction to Errors Inbox\", \"description\": \"How to manage all your monitoring in one place.\" }, Copy When you're done creating the info, save the file. In the homepage.yml page, find the corresponding location for the new section, and add the short name you provided in the translation.json file, title, description, and tile URLs. For example, here's the corresponding TDP section on homepage.yml. errors-inbox: title: Errors Inbox description: A single place to proactively detect, triage, and take action on all the errors before they impact customers. tiles: - /docs/errors-inbox/errors-inbox Copy Save, build locally, commit, PR. Edit the home page left nav The left nav of the home page is controlled by src/nav/root.yml. This is a basic yml file, similar to our taxonomy files. Each link on the left nav needs a title and a path: - title: Welcome to New Relic path: /docs/using-new-relic - title: New Relic One path: /docs/new-relic-one/use-new-relic-one - title: Guides and best practices path: /docs/new-relic-solutions - title: section-break - title: Alerts and Applied Intelligence path: /docs/alerts-applied-intelligence Copy You can add a new link by following the pattern above or delete a link by removing the corresponding title and path. Section breaks are added by including a - title: section-break line. The left nav reflects the exact order of root.yml, so it's easy to organize it as needed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.1122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update the home <em>page</em>",
        "sections": "Update the home <em>page</em>",
        "tags": "<em>landing</em> <em>pages</em>",
        "body": "You can&#x27;t just hit the edit button docs.newrelic.com to make edits to the home <em>page</em>. The <em>page</em> that opens is index.js, the file that manages the parts of the home <em>page</em>, but not the content. It&#x27;s rare that you&#x27;ll need to make changes to this file. Most home <em>page</em> changes will be to add a new tile"
      },
      "id": "61ab480264441f9ef0927fb8"
    },
    {
      "sections": [
        "Alerts and applied intelligence notification integrations",
        "Early access",
        "Integration details",
        "Atlassian Jira",
        "Permissions",
        "Set up a Jira destination",
        "Important",
        "Two-way sync",
        "Configure the message template",
        "Send a test notification",
        "ServiceNow (Incident-Management)",
        "Roles",
        "Set up a destination",
        "Slack",
        "Prerequisites",
        "Set up a Slack destination",
        "Configure the Slack message settings",
        "Webhook",
        "Set up a webhook destination",
        "Configure the webhook event template",
        "Customize the webhook payload",
        "Email",
        "Configure the email settings"
      ],
      "title": "Alerts and applied intelligence notification integrations",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident Intelligence",
        "Destinations"
      ],
      "external_id": "7220c630fc187bb61784ff2cc2213e588b269b00",
      "image": "https://docs.newrelic.com/static/d4e9baecc3a76dd1a5945f8ec0aeca66/c1b63/webhook-notification-template.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/",
      "published_at": "2021-12-25T04:31:39Z",
      "updated_at": "2021-12-19T15:28:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Early access The features described here are early access. You won't be able to use these features if you're not part of the early access program. For more information on related features, see our docs on Alerts notification channels, Incident Intelligence destinations, and Proactive Detection notifications. Alerts and Applied Intelligence notification integrations are specific services and platforms you can use to send notifications from New Relic. Integration details Read more about each of our specific notification integrations. Atlassian Jira Integrate New Relic with Atlassian Jira(Cloud) and automatically create and update Jira issues. Permissions The required permissions from the Jira API-Token are create, edit, and close tickets. To enable the two-way sync toggle, the provided Jira API-Key should have an Admin role. Set up a Jira destination Create Jira issues, then enable Jira and New Relic to share updates and stay synced. To create a Jira destination, enter the following information: Destination name: Custom name to identify the destination Jira account endpoint: the URL of the destination User-name: this will be the email address of the user making the connection API token: generated from your Atlassian account Important New Relic currently supports Atlassian-Jira Classic (company-managed) projects. Before saving the destination, we recommend you test the connection via the test connection button. Jira destination configuration. We recommand to test the connection before saving. Two-way sync You can enable a two-way integration with Jira to keep the issues' state synced with the corresponding state in New Relic. To enable two-way sync, turn on the ‘two-way integration’ toggle. When turned on, a Jira Webhook would be created in your Jira account at a later stage, for the selected project (see ‘customize a message template’). The webhook would contain access details to Newrelic (URL and Newrelic-API-KEY) Configure the message template To configure a template for a Jira issue, you first need to choose a destination. You will be able to create a new destination at this stage. Upon successful connection to the destination, you will need to choose a project, and then select the Jira issue type you would like to be used. Once the issue-type is selected, the configured project's fields are fetched from your account and automatically mapped to your Jira instance. To help you get started, we automatically present the required and recommended fields and values. Required fields must be set with a value. You can add or remove optional fields(use the X mark on their right side) Jira message template. Send a test notification You can see how the JIRA issue will appear by clicking a test notification with default field values. If successful, a JIRA issue will be created and a link will appear. ServiceNow (Incident-Management) Integrate New Relic with ServiceNow Incident-Management and automatically create and update incidents. Roles As part of the integrations, we fetch fields from the your serviceNow incident table and optional values. For this, the provided ServiceNow user details required read permissions for the tables: sys_dictionary, sys_choice, sys_user and task. A read/write permission to incident To be able to fetch users for the caller column, we required read permissions for the sys_users table. The above permissions can be achieved with the roles personalize_choices, personalize_dictionary, rest_service, itil. Read/Write permissions to the api_key_credentials table is required to enable two-way integration. This can be covered with the roles credentials_admin and discovery_admin. Set up a destination To create a ServiceNow destination, enter the following information: Destination Name: custom name to identify the destination Domain: the URL of the destination User-name: the name of the user Password: the user name’s password Before saving the destination, we recommend testing the connection by clicking the test connection button. Two-way sync You can configure a two-way integration with ServiceNow Incidents Management to keep the incidents' state synced with the corresponding state in New Relic. Here are some required steps to remember when configuring the two-way integration: Turn on the two-way integration toggle. Open and download this XML file, which includes the business rule triggering events back to New Relic One. In the ServiceNow sidebar menu, go to System Definition > Business Rules. Click the menu icon in one of the column headers, select Import XML and upload the XML file you downloaded. Once the Destination is saved, a New-Relic API-Key will be kept in the api_key_credentials. The key would sent in a header as part of the callback REST call to New-Relic Configure the message template Upon a successful connection, ServiceNow incident table columns are fetched from your account and automatically mapped to your ServiceNow instance. To help you get started, we automatically present the required and recommended fields and values. Required fields must be set with a value. You can add or remove optional fields(use the X mark on their right side) Select, edit or remove fields for the ServiceNow-Incident template. Send a test notification You can see how the ServiceNow incident will appear by clicking a test notification with default field values. If successful, an incident will be created and a link will appear. Slack Send notifications-messages to your Slack channels. Prerequisites Your Slack workspace needs to have the New Relic application installed. The application must be approved by a workspace admin before it can be individually installed by users Set up a Slack destination Click on the `one-click Slack authentication' will lead you to the Slack landing page to continue the OAuth2 authentication process. On the Slack landing page, if you're not signed into the required workspace, you're redirected to Slack to sign in. Add your workspace name or select the relevant workspace and click Continue. When signed in to the selected workspace, you are requested to allow New Relic to perform the specified actions. Clicking `Allow' will redirect you back to the Destination page. Configure the Slack message settings Select a Destination(Workspace) and select a Slack-channel where the messages will be sent. You can create a new destination if there is no pre-defined destination for the required workspace. Note that, for privacy reasons, users need to be authenticated to select private channels (one-time process) Send a test notification You can send a test notification with a pre-defined example payload to the channel. This creates a message in the selected Slack-channel. Webhook Use the webhook notifier to send the notification messages to any endpoint you like. Set up a webhook destination To create a webhook destination, you need the following: Destination Name: A unique destination name URL: the endpoint of the target application, authentication and custom headers if needed. Authorization mechanism (Optional):. Can be basic authentication or a bearer token Configure the webhook event template Pick a webhook destination from the list and configure the HTTP-POST request. The request configuration requires you to: Set a name for the template. Select a pre-configured destination from the destinations list or create a new one. Add custom headers (optional). Configure the request’s payload. Customize the webhook payload You can use the default payload or customize it to contain the required data. Pick Variables from the variables menu and apply handlebars syntax to enrich your webhook. Note that the request’s content-type is JSON by default. Hence, the payload needs to keep the JSON form. See Usage examples The ‘preview’ section on the right hand-side shows an expected payload after the template is rendered. If the eventual payload would not form a valid Json, an error will be shown and it won’t be possible to save the template. If the webhook payload conforms a valid Json, you can send a test notification to your defined webhook destination We recommend sending a test notification to make sure that everything's connected correctly. Email Send email notifications to users. Configure the email settings Add one or more recipients. Users with New Relic accounts can be found via autocomplete when searching for their name or email address. To add a user without a New Relic account or email distribution list, add the full email address. Every recipient will be translated into a 'destination'. You can follow the email notifications per destination in the notifications-log Send a test notification You can send a test notification to make sure the email notifications reach the inbox.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.53943,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Configure the message <em>template</em>",
        "body": " Click on the `one-click Slack authentication&#x27; will lead you to the Slack <em>landing</em> <em>page</em> to continue the OAuth2 authentication process. On the Slack <em>landing</em> <em>page</em>, if you&#x27;re not signed into the required workspace, you&#x27;re redirected to Slack to sign in. Add your workspace name or select the relevant"
      },
      "id": "618ff71628ccbc60710321e4"
    },
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-25T17:36:34Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.76553,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Page</em> <em>templates</em>",
        "body": "Our docs site is made up of different content types and templates. Most of the time, the default <em>page</em> content type and the basic <em>template</em> will have everything you&#x27;ll need. Read on for more information about our <em>page</em> types. Docs meta content (frontmatter) Thr top of every doc begins with a set"
      },
      "id": "61b35517196a677196a59e07"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/more-help-section": [
    {
      "sections": [
        "Node.js agent configuration",
        "Get started",
        "Configuration methods and precedence",
        "Agent configuration file",
        "Environment variables",
        "Server-side configuration",
        "Exports variables",
        "app_name (REQUIRED)",
        "Tip",
        "license_key (REQUIRED)",
        "agent_enabled",
        "allow_all_headers",
        "Caution",
        "apdex_t (DEPRECATED)",
        "certificates",
        "high_security",
        "host",
        "Important",
        "labels",
        "port",
        "proxy",
        "proxy_host",
        "proxy_pass",
        "proxy_port",
        "proxy_user",
        "Logging variables",
        "enabled",
        "level",
        "filepath",
        "Audit logging",
        "endpoints",
        "API configuration",
        "custom_attributes_enabled",
        "custom_events_enabled",
        "notice_error_enabled",
        "Attributes",
        "exclude",
        "include",
        "include_enabled",
        "Error collector variables",
        "ignore_status_codes",
        "ignore_classes",
        "ignore_messages",
        "expected_status_codes",
        "expected_classes",
        "expected_messages",
        "attributes.enabled",
        "attributes.exclude",
        "attributes.include",
        "max_event_samples_stored",
        "Transaction tracer variables",
        "explain_threshold",
        "record_sql",
        "top_n",
        "transaction_threshold",
        "hide_internals",
        "Rules variables",
        "name",
        "ignore",
        "enforce_backstop",
        "Transaction events variables",
        "max_samples_stored",
        "max_samples_stored (DEPRECATED)",
        "max_samples_per_minute (DEPRECATED)",
        "Browser monitoring variables",
        "enable",
        "debug",
        "Custom events variables",
        "Slow queries variables",
        "max_samples",
        "Custom hostname variables",
        "display_name",
        "ipv_preference",
        "Environment variable overrides",
        "NEW_RELIC_HOME",
        "NEW_RELIC_NO_CONFIG_FILE",
        "Datastore tracer variables",
        "instance_reporting.enabled",
        "database_name_reporting.enabled",
        "Cross application tracing (DEPRECATED)",
        "Error message redaction variables",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Span events",
        "Infinite Tracing",
        "trace_observer.host"
      ],
      "title": "Node.js agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "4f576eccf990e090f3c829dba158ac21583f8b5a",
      "image": "https://docs.newrelic.com/static/bab8ec5bda2eda3aaa5ddaefbed52d93/9fc4b/nodejs-configuration-precedence.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/nodejs-agent/installation-configuration/nodejs-agent-configuration/",
      "published_at": "2021-12-25T21:44:25Z",
      "updated_at": "2021-12-20T13:54:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can tailor the Node.js agent to your app's requirements by editing your newrelic.js config file or by setting an environment variable. The config file resides in the root directory of your app. You can also configure a few options from New Relic, or use the Node.js agent API. Get started You'll be able to configure our Node.js agent to suit your environnment after you create a New Relic account (it's free, forever) and install the Node.js agent. The license_key setting is required. Also, we highly recommend setting the app_name so that your app has a meaningful name instead of the default My Application. Configuration methods and precedence The primary method to configure the Node.js agent is the agent configuration file (newrelic.js). You can also configure most settings with environment variables. You can also adjust some settings with server-side configuration. The Node.js agent uses this order of precedence for configuration methods: Node.js configuration hierarchy: Server-side configuration settings override environment variables. Environment variables override the agent config file. The config file overrides the agent defaults. Here are detailed descriptions of each configuration method: Agent configuration file The config file (newrelic.js) contains every Node.js agent setting. When you install the Node.js agent, you must copy newrelic.js into your app's root directory. Most settings are empty by default; they inherit their values from config/default.js. Environment variables Most configuration settings in newrelic.js have equivalent environment variables. These are useful, for example, if your agent runs in a PaaS environment such as Heroku or Microsoft Azure. Node.js agent environment variables always start with NEW_RELIC_. Where available, these environment variables are documented below under individual config options as the Environ variable. There are also two rarely used settings that can only be configured via environment variables. If you're using New Relic APM and CodeStream, see how to associate repositories and how to associate build SHAs or release tags with errors inbox. Server-side configuration Owners and Admins can view and configure a few settings directly in New Relic. Where available, the UI labels for server-side config are listed in this document under individual config options as the Server-side label. Exports variables This section defines the Node.js agent variables in the order they typically appear in the exports.config = { section of your app's newrelic.js configuration file. app_name (REQUIRED) Type String Default \"My Application\" Environ variable NEW_RELIC_APP_NAME The name New Relic uses to identify your app. For example, app_name: ['MyNodeApp']. To use multiple names for your app, specify a comma-delimited list of names. Data for all applications with the same name will be merged in the New Relic UI, so set this carefully. We highly recommend that you replace the default name with a descriptive name to avoid confusion and unintended aggregation of data. Tip For Azure users, the Node.js agent will use APP_POOL_ID if it is set, so you can use the name you chose for your Azure Web Server without setting it twice. license_key (REQUIRED) Type String Default (none) Environ variable NEW_RELIC_LICENSE_KEY This setting is required. Your New Relic license key. For example, license_key: '40HexadecimalCharacters'. agent_enabled Type Boolean Default true Environ variable NEW_RELIC_ENABLED Set to false to stop the agent from starting up. This is useful when debugging your code requires temporarily disabling the agent. It prevents the agent from bootstrapping its instrumentation or setting up all its pieces, which prevents the agent from starting up and connecting to New Relic's servers. allow_all_headers If true, enables capture of all HTTP headers, except for those filtered by exclude rules. If false, collected headers are limited to those defined in Node.js agent attributes. Type Boolean Default false Caution Any header-related include/exclude rules must be in camelCase form to be filtered. apdex_t (DEPRECATED) Type Number Default 0.100 Server-side label Apdex T Set your Apdex T via the New Relic UI. certificates Type Array of strings Default (none) Additional certificates to trust for SSL connections, specified as an array of strings in PEM format. This affects both connections to an HTTPS proxy and connections to New Relic. Tip You can also configure the agent to read its certificates from a file: certificates: [ fs.readFileSync('myca.crt', {encoding: 'utf8'}) ] Copy high_security Type Boolean Default false Environ variable NEW_RELIC_HIGH_SECURITY When set to true, enables high security v2. You must also enable the ssl setting and enable high security in the UI. host Type String Default collector.newrelic.com Environ variable NEW_RELIC_HOST Important Do not edit this value unless New Relic Support asks you to change it. Hostname for the New Relic collector to connect to the Internet; for example, host: 'collector.newrelic.com'. labels Adds tags. Specify your tags as objects or a semicolon-delimited string of colon-separated pairs (for example, Server:One;Data Center:Primary). Type Object or string Default (none) Environ variable NEW_RELIC_LABELS port Type Integer Default 443 Environ variable NEW_RELIC_PORT Important Do not edit this value unless New Relic Support asks you to change it. Port number to connect to the New Relic collector; for example, port: 443. proxy Type String Default (none) Environ variable NEW_RELIC_PROXY_URL A URL specifying the proxy server to connect to the Internet. For example, proxy: 'http://user:pass@10.0.0.1:8000/'. Important The proxy config file setting overrides the other config file proxy settings (proxy_host, proxy_port, proxy_user, proxy_pass) if used. Similarly, the NEW_RELIC_PROXY_URL environment variable overrides the other environment variable proxy settings (NEW_RELIC_PROXY_HOST, NEW_RELIC_PROXY_PORT, NEW_RELIC_PROXY_USER, and NEW_RELIC_PROXY_PASS) if used. proxy_host Type String Default (none) Environ variable NEW_RELIC_PROXY_HOST Hostname or IP address of the proxy server to connect to the Internet. proxy_pass Type String Default (none) Environ variable NEW_RELIC_PROXY_PASS Password for authenticating to the proxy server. The agent supports only basic HTTP authentication. proxy_port Type String Default (none) Environ variable NEW_RELIC_PROXY_PORT Port number of the proxy server to connect to the Internet. proxy_user Type String Default (none) Environ variable NEW_RELIC_PROXY_USER User name for authenticating to the proxy server. The agent supports only basic HTTP authentication. Logging variables This section defines the Node.js agent variables in the order they typically appear in the logging: { section of your app's newrelic.js configuration file. enabled Type String Default true (false in serverless_mode) Environ variable NEW_RELIC_LOG_ENABLED Enables or disables agent specific logging. level Type String Default info Environ variable NEW_RELIC_LOG_LEVEL Defines the level of detail recorded in the agent logs. From least detail to most detail, possible values are fatal, error, warn, info, debug, or trace. Caution Do not use debug or trace logging unless New Relic Support asks you to use them. These levels of logging can generate excessive overhead. For most situations, use info. filepath Type String Default process.cwd() plus newrelic_agent.log Environ variable NEW_RELIC_LOG Complete path to the New Relic agent log, including the filename. Defaults to filepath: require('path').join(process.cwd(), 'newrelic_agent.log'). The agent will shut down the process if it cannot create this file. The agent creates a log file with the same permissions as the parent Node.js agent process. To write all logging to stdout, set this to stdout. To write all logging to stderr, set this to stderr. Audit logging This section defines the Node.js agent variables in the order they typically appear in the audit_log: { section of your app's newrelic.js configuration file. enabled Type Boolean Default false Environ variable NEW_RELIC_AUDIT_LOG_ENABLED When enabled, the agent logs the payloads it sends to the collector. This data is included in the main log file even when logging level is set to the lowest level. endpoints Type Array Default Empty array (include all types) Environ variable NEW_RELIC_AUDIT_LOG_ENDPOINTS The agent sends several different types of data to the collector in separate payloads. By default, all of them are included in the log file. This option makes it possible to limit logging only to specific types of data. Valid values include: agent_settings analytic_event_data connect custom_event_data error_data error_event_data metric_data preconnect shutdown span_event_data sql_trace_data transaction_sample_data API configuration This section allows you to choose which API methods are enabled. Each configuration option allows you to modularly enable API methods that are responsible for sending custom information to New Relic. Important All of these are set to false when the agent is in high security mode. custom_attributes_enabled Type Boolean Default true Environ variable NEW_RELIC_API_CUSTOM_ATTRIBUTES This option enables newrelic.addCustomAttribute and newrelic.addCustomAttributes. custom_events_enabled Type Boolean Default true Environ variable NEW_RELIC_API_CUSTOM_EVENTS This option enables recordCustomEvent. notice_error_enabled Type Boolean Default true Environ variable NEW_RELIC_API_NOTICE_ERROR This option enables newrelic.noticeError. Attributes This section defines the variables for Node.js agent attributes in the order they typically appear in the attributes: { section of your app's newrelic.js configuration file. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. enabled Type Boolean Default true Environ variable NEW_RELIC_ATTRIBUTES_ENABLED If true, enables capture of attributes for all destinations. exclude Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from all destinations. Allows * as wildcard at end. include Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_INCLUDE Prefix of attributes to include from all destinations. Allows * as wildcard at end. include_enabled Type Boolean Default true Environ variable NEW_RELIC_ATTRIBUTES_INCLUDE_ENABLED When true, patterns may be added to the attributes.include list. Error collector variables You can manage how error are handled in New Relic. This section defines the Node.js agent variables in the order they typically appear in the error_collector: { section of your app's newrelic.js configuration file. enabled Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_ENABLED Server-side label Enable error collection? When enabled, the agent collects error traces from your app. ignore_status_codes Type Array of Integers Default [404] Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES Server-side label Ignore these status codes Comma-delimited list of HTTP status codes for the error collector to ignore. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. ignore_classes Type Array|Object Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERRORS Comma-delimited list of javascript error types/classes for the error collector to ignore. The following configuration /* ... */ error_collector: { ignore_classes: [\"ReferenceError\"] } /* ... */ Copy Would ignore all reference errors. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. ignore_messages Type Object Default {} A javascript object describing a list of javascript classes tied to javascript error messages for the collector to ignore. The following configuration. /* ... */ error_collector: { /* ... */ ignore_messages: {\"Error\":[\"Undefined\", \"Out of time\"]} /* ... */ } /* ... */ Copy Would ignore all errors of type Error, with the exact (case-sensitive) message strings of Undefined and Out of time. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. expected_status_codes Type Array of integers Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_EXPECTED_ERROR_CODES Comma-delimited list of HTTP status codes for the error collector to mark as expected. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. expected_classes Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_EXPECTED_ERRORS The following configuration /* ... */ error_collector: { expected_classes: [\"ReferenceError\"] } /* ... */ Copy Would mark all reference errors as expected. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. expected_messages Type Object Default {} A javascript object describing a list of javascript classes tied to javascript error messages for the collector to ignore. The following configuration. /* ... */ error_collector: { /* ... */ expected_messages: {\"Error\":[\"Undefined\", \"Out of time\"]} /* ... */ } /* ... */ Copy Would mark all errors of type Error, with the exact (case-sensitive) message strings of Undefined and Out of time. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_ENABLED If true, the agent captures attributes from error collection. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from error collection. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_INCLUDE Prefix of attributes to include in error collection. Allows * as wildcard at end. max_event_samples_stored Type Integer Default 100 Environ variable NEW_RELIC_ERROR_COLLECTOR_MAX_EVENT_SAMPLES_STORED Defines the maximum number of events the agent collects per minute. If there are more than this number, the agent collects a statistical sampling. Transaction tracer variables The agent groups your requests into transactions, which are used to: Visualize where your app spends its time (in transaction breakdowns). Identify slow requests. Group metrics. Isolate other issues, such as slow database performance. This section defines the Node.js agent variables in the order they typically appear in the transaction_tracer: { section of your app's newrelic.js configuration file. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true Environ variable NEW_RELIC_TRACER_ENABLED Server-side label Enable transaction tracing? When enabled, the agent collects slow transaction traces. explain_threshold Type Integer Default 500 Environ variable NEW_RELIC_EXPLAIN_THRESHOLD Minimum query duration (in milliseconds) for a transaction to be eligible for slow queries in transaction traces. record_sql Type String (off, obfuscated, or raw) Default off Environ variable NEW_RELIC_RECORD_SQL This option affects both slow queries and record_sql for transaction traces. It can have one of three values: off, obfuscated, or raw. When set to off no slow queries will be captured, and backtraces and SQL will not be included in transaction traces. If set to raw or obfuscated, the agent sends raw or obfuscated SQL and a slow query sample to the collector. The agent may also send SQL when other criteria are met, such as when slow_sql.enabled is set. top_n Type Integer Default 20 Environ variable NEW_RELIC_TRACER_TOP_N Defines the maximum number of requests eligible for transaction traces. Transactions are named based on the request, and top_n refers to the \"top n slowest transactions\" grouped by these names. The module replaces a recorded trace with a new trace only if the new trace is slower than the previous slowest trace of that name. The default value for this setting is top_n: 20, because the Transactions page also defaults to the 20 slowest transactions. The Node.js agent captures at least five different slow transactions in the first harvest cycle after start up. It will also reset and capture different transactions if no slow transactions have been captured for the last five harvest cycles. This allows you to see more information about more of your app's request paths, at the possible cost of not focusing on the absolutely slowest request for that harvest cycle. Tip To record the absolute slowest transaction over the last minute, you can set top_n: 0 or top_n: 1. However, this causes one very slow route to dominate your transaction traces. transaction_threshold Type Integer or apdex_f Default apdex_f Environ variable NEW_RELIC_TRACER_THRESHOLD Server-side label Threshold Threshold of web transaction response time in seconds beyond which a transaction is eligible for transaction tracing. The default value is apdex_f; this sets the trace threshold to four times your application's Apdex T. You can also enter a specific time value in milliseconds. Example: Threshold set to apdex_f The default apdex_t is 100 milliseconds. If your transaction threshold is set to apdex_f, a \"slow\" transaction is 400 milliseconds. hide_internals Type boolean Default true Environ variable NEW_RELIC_HIDE_INTERNALS The agent uses a small amount of CPU in order to hide internal properties that are attached to the web application. If you change this configuration to false, it may slightly decrease your agent overhead, but it could also have an impact on the performance of the agent. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction traces. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction traces. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction traces. Allows * as wildcard at end. Rules variables This section defines the Node.js agent variables in the order they typically appear in the rules: { section of your app's newrelic.js configuration file. name Type Strings or regular expressions Default (none) Environ variable NEW_RELIC_NAMING_RULES A comma-delimited list of rules to match incoming request URLs and name the associated New Relic transaction. Uses the format: name: [ {pattern: 'STRING_OR_REGEX', name: 'NAME'}, {pattern: 'STRING_OR_REGEX', name: 'NAME'} ], Copy Both parameters are required. For strings, you must escape control characters. You do not need to escape control characters in regular expressions. Additional attributes are ignored. Regular expressions support JavaScript-style capture groups, and names use $1-style replacement strings. Regular expressions only find the first matching result; subsequent matches are ignored. For more information, see Node.js transaction naming API. For the NEW_RELIC_NAMING_RULES environment variable, pass the rules as comma-delimited JSON object literals: NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}' Copy ignore Type Strings or regular expressions Default Regular expression to match socket.io long-polling requests (\"^ \\ /socket \\ .io \\ /. * \\ /xhr-polling/\"). Environ variable NEW_RELIC_IGNORING_RULES Define a list of request URLs you want the agent to ignore. Specify the list as patterns, which can be strings or regular expressions. enforce_backstop Type Boolean Default true Environ variable NEW_RELIC_ENFORCE_BACKSTOP Caution Do not change this setting unless you understand metric grouping issues. When enabled, the agent renames transactions that are not affected by other naming logic (such as the API, rules, or metric normalization rules) to NormalizedUri/*. If you set this to false, the agent sets transaction names to Uri/path/to/resource. Transaction events variables This section defines the Node.js agent variables in the order they typically appear in the transaction_events: { section of your app's newrelic.js configuration file. enabled Type Boolean Default true When enabled, the agent sends transaction events to New Relic. This event data includes transaction timing, transaction name, and any custom parameters. If this is disabled, the agent does not collect this data or send it to New Relic. max_samples_stored Type Integer Default 10000 Environ variable NEW_RELIC_TRANSACTION_EVENTS_MAX_SAMPLES_STORED Defines the maximum number of events the agent collects per minute. If there are more than this number, the agent collects a statistical sampling. We do not recommend configuring past 10,000. The server will cap data at 10,000 per-minute. Important This configuration had different behavior in agent versions lower than 6.0.0. See max_samples_stored (DEPRECATED) for agent versions 5.x or lower. max_samples_stored (DEPRECATED) Type Integer Default 20000 Defines the maximum number of events the agent stores if it is unable to communicate with the New Relic collector. The values from the previous harvest cycle will be merged into the next one, with this option limiting the maximum number. Make sure this number is greater than max_samples_per_minute; for example, set it to twice as much. Consider your memory overhead before increasing this value. Caution This configuration has different behavior starting with agent version 6.0.0 and a new recommended maximum. See max_samples_stored for agent versions 6.x or higher. max_samples_per_minute (DEPRECATED) Type Integer Default 10000 Defines the maximum number of events the agent collects per minute. If there are more than this number, the agent collects a statistical sampling. Caution This configuration has been replaced with max_samples_stored starting with version 6.0.0 of the agent. See max_samples_stored for 6.x or later agents. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction events. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction events. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction events. Allows * as wildcard at end. Browser monitoring variables This section defines the Node.js agent variables in the order they typically appear in the browser_monitoring: { section of your app's newrelic.js configuration file. enable Type Boolean Default true Environ variable NEW_RELIC_BROWSER_MONITOR_ENABLE Server-side label Enable browser monitoring? Generate JavaScript headers for browser instrumentation. Although this defaults to true, the agent doesn't inject the browser JS code unless you have enabled browser monitoring. Even if you have enabled it and added the browser timing header, you can disable browser monitoring for your app by setting this to false. debug Type Boolean Default false Environ variable NEW_RELIC_BROWSER_MONITOR_DEBUG If true, request un-minified sources from the server. attributes.enabled Type Boolean Default false Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_ENABLED If true, the agent sends custom attributes to browser monitoring. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from browser monitoring. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_INCLUDE Prefix of attributes to include in browser monitoring. Allows * as wildcard at end. Custom events variables This section defines the Node.js agent variables in the order they typically appear in the custom_insights_events: { section of your app's newrelic.js configuration file. Currently there are no environment variables for custom events. enabled Type Boolean Default true When enabled, the agent sends custom events recorded with recordCustomEvent() to New Relic. If this is disabled, the agent does not collect this data or send it to New Relic. max_samples_stored Type Integer Default 1000 Environ variable NEW_RELIC_CUSTOM_INSIGHTS_EVENTS_MAX_SAMPLES_STORED Defines the maximum number of custom events the agent collects per minute. If the number of custom events exceeds this limit, the agent collects a statistical sampling. Important Increasing this limit increases memory usage. Slow queries variables This section defines the Node.js agent variables in the order they typically appear in the slow_sql: { section of your app's newrelic.js configuration file. These options control behavior for slow queries, but do not affect SQL nodes in transaction traces. enabled Type Boolean Default false Environ variable NEW_RELIC_SLOW_SQL_ENABLED When enabled, the agent collects slow query details. max_samples Type Integer Default 10 Environ variable NEW_RELIC_MAX_SQL_SAMPLES Defines the maximum number of slow queries the agent collects per minute. The agent discards additional queries after the limit is reached. Important Increasing this limit increases memory usage. Custom hostname variables This section defines the Node.js agent variables in the order they typically appear in the process_host: { section of your app's newrelic.js configuration file. These options control behavior regarding the host display name in the APM UI. display_name Type String of 255 bytes or less Default (none) Environ variable NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Specify a custom hostname for display in New Relic. If you do not set this field, New Relic will continue to use the default hostname found by calling os.hostname(). If you use the default hostname settings, New Relic finds the hostname through os.hostname(). If this call fails, New Relic uses the host's IP as the name. If you set ipv_preference: 4 or ipv_preference: 6, you can select the type of IP address (IPv4 or IPv6) that appears in the New Relic UI. ipv_preference Type Integer (4 or 6) Default 4 Environ variable NEW_RELIC_IPV_PREFERENCE Environment variable overrides This section defines two configuration options only available with environment variables. These overrides are not used in most configurations. NEW_RELIC_HOME Path to the directory containing newrelic.js. This is available only as an environment variable. You cannot set it in your config file. Type String Default (none) NEW_RELIC_NO_CONFIG_FILE If used, this prevents the agent from reading configuration settings from newrelic.js. Default values and values from environment variables will still be set. This is available only as an environment variable. You cannot set it in your config file. Type Boolean Default False Datastore tracer variables This section defines the Node.js agent variables in the order they typically appear in the datastore_tracer section of your app's newrelic.js configuration file. These options control behavior for collecting datastore instance metrics. instance_reporting.enabled Type Boolean Default true When enabled, the agent collects datastore instance metrics (such as host and port) for some database drivers. These are reported on slow query traces and transaction traces. database_name_reporting.enabled Type Boolean Default true When enabled, the agent collects database name on slow query traces and transaction traces for some database drivers. Cross application tracing (DEPRECATED) The Node.js agent variables that control cross application tracing typically appear in the cross_application_tracer section of your app's newrelic.js configuration file: enabled Type Boolean Default false When set to true, allows tracing of transactions across more than one New Relic-monitored applications. Important Cross application tracing (CAT) has been deprecated and will be removed in a future major release. For cross-service visibility, we recommend using distributed tracing, which is enabled by default as of agent version 8.3.0. Before enabling, read the transition guide. Error message redaction variables The Node.js agent variables that control error message redaction appear in the allow_raw_exception_messages section of your app's newrelic.js configuration file: enabled Type Boolean Default true Environ variable NEW_RELIC_ALLOW_RAW_EXCEPTION_MESSAGES_ENABLED When false, the agent will redact the messages of captured errors. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has effects on other APM features. Before enabling, read the transition guide. Requires Node.js agent version 4.7.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. When configuring via the config file, place the following option in the distributed_tracing section. enabled Type Boolean Default true Environ variable NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: { enabled: true } Copy exclude_newrelic_header Type Boolean Default false Set this to true to exclude the New Relic header that is attached to outbound requests, and instead only rely on W3C Trace Context Headers for distributed tracing. If this is false then both types of headers are used. For example, to enable this in the config file, you would use: distributed_tracing:{ enabled: true, exclude_newrelic_header: true } Copy Span events Span data is reported for distributed tracing. Distributed tracing must be enabled to report spans. Span configuration is set in the span_events stanza. Options include: enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ENABLED Turns reporting of span events on or off. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_ENABLED This setting can be used to turn reporting of attributes on or off for spans. If attributes.enabled at the root level is false, no attributes will be sent with spans regardless on how this is set. attributes.include Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_INCLUDE If attributes are enabled for spans, all attribute keys found in this list will be attached to spans. For more information, see the agent attribute rules. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_EXCLUDE All attribute keys found in this list will not be sent with spans. For more information, see the agent attribute rules. max_samples_stored Type Integer Default 2000 Environ variable NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED Defines the maximum number of events the agent collects per minute. If there are more than this number, the agent collects a statistical sampling. We do not recommend configuring past 10k. The server will cap data at 10k per-minute. Infinite Tracing To turn on Infinite Tracing, enable distributed tracing (set distributed_tracing to enabled: true) and add the additional settings below. For an example, see Language agents: configure distributed tracing. trace_observer.host Type String Default (none) Environ variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 68.90254,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " (DEPRECATED) The Node.js agent variables that control cross application tracing typically appear in the cross_application_tracer <em>section</em> of your app&#x27;s newrelic.js configuration file: enabled Type Boolean Default false When set to true, allows tracing of transactions across <em>more</em> than one New Relic"
      },
      "id": "617e95b528ccbc0ba67ffd8b"
    },
    {
      "sections": [
        "Configure Kubernetes with a proxy",
        "Install the infrastructure agent with a proxy",
        "Set logging with a proxy",
        "Install Kubernetes events with a proxy",
        "Install the Prometheus OpenMetrics integration with a proxy",
        "Set the synthetics minion to use a proxy"
      ],
      "title": "Configure Kubernetes with a proxy",
      "type": "docs",
      "tags": [
        "Integrations",
        "Kubernetes integration",
        "Installation"
      ],
      "external_id": "9d7794244b451d878d00db0f84c4709e43ce138c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/kubernetes-pixie/kubernetes-integration/installation/configure-kubernetes-proxy/",
      "published_at": "2021-12-25T07:57:45Z",
      "updated_at": "2021-12-25T07:57:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you are running our Kubernetes integration with a proxy, you need to configure each component (the infrastructure agent, logging, Kubernetes events, etc.) to correctly work with your proxy. Install the infrastructure agent with a proxy There are three options to install the infrastructure agent with a proxy: Installing with chart newrelic-infrastructure: The proxy can be configured setting the configuration option config.proxy as described in the values.yaml of the chart. The whole config object is used to generate a configMap that is mounted as the file /etc/newrelic-infra.yml used to configure the agent. Installing with chart nri-bundle as a dependency: The proxy can be configured setting the configuration option newrelic-infrastructure.config.proxy. The configuration option is passed down to the dependency newrelic-infrastructure modifying the values.yaml of nri-bundle: newrelic-infrastructure.config.proxy: https://user:password@hostname:port Copy Installing with manifest: When installing through the manifest, the proxy can be configured adding the NRIA_PROXY environment variable to the environment variable section of the DaemonSet configuration. The environment variable NRIA_VERBOSE in the DaemonSet YAML can be used as an example of the environment variable configuration. Set logging with a proxy If you’re using log forwarding for the Kubernetes integration, the plugin automatically detects the HTTP_PROXY and HTTPS_PROXY environment variables, and automatically uses them to set up the proxy configuration. For more information, see how to customize the proxy, or bypass it. Install Kubernetes events with a proxy There are three options to install the Kubernetes events integration with a proxy: Installing with chart nri-kube-events: The proxy can be configured setting the configuration option proxy in the values.yaml file. If set, the variable NRIA_PROXY will be added into the deployment.yaml template. Installing with chart nri-bundle as a dependency: The proxy can be configured setting the configuration option nri-kube-events.proxy. The configuration option is passed down to the dependency nri-kube-events modifying the values.yaml of nri-bundle: nri-kube-events.proxy: https://user:password@hostname:port Copy Installing with manifest: When installing through the manifest, to configure the proxy set the NRIA_PROXY in the environment variable section of the infra container. Check the deployment template of the chart as an example of environment variable configuration. Install the Prometheus OpenMetrics integration with a proxy There are three options to install the Prometheus OpenMetric integration with a proxy: Installing with charts nri-prometheus: The proxy can be configured setting the configuration option config.emitter_proxy in the values.yaml. The config object is used to generate a configMap that mounted into the deployment under /etc/nri-prometheus/. Installing with chart nri-bundle as a dependency: The proxy can be configured setting the configuration option nri-prometheus.config.emitter_proxy. The configuration option is passed down to the dependency nri-prometheus modifying the values.yaml of nri-bundle: nri-prometheus.config.emitter_proxy: \"http://localhost:8888 Copy Installing with the manifest: Configure the proxy uncommenting the emitter_proxy option directly in the manifest: # Proxy to be used by the emitters when submitting metrics. It should be # in the format [scheme]://[domain]:[port]. # The emitter is the component in charge of sending the scraped metrics. # This proxy won't be used when scraping metrics from the targets. # By default it's empty, meaning that no proxy will be used. # emitter_proxy: \"http://localhost:8888\" Copy Set the synthetics minion to use a proxy Check this README on how to set the proxy for the Synthetics minions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 68.36276,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "-infrastructure.config.proxy: https:&#x2F;&#x2F;user:password@hostname:port Copy Installing with manifest: When installing through the manifest, the proxy can be configured adding the NRIA_PROXY environment variable to the environment variable <em>section</em> of the DaemonSet configuration. The environment variable"
      },
      "id": "617d584264441f2d01fbc6d7"
    },
    {
      "sections": [
        "Observability implementation guide template",
        "Overview",
        "Desired outcome",
        "Key performance indicators",
        "KPI1 name",
        "KPI2 name",
        "Prerequisites",
        "Establish the current state",
        "Step 1",
        "Step 2",
        "Step 3",
        "Improvement process",
        "Value realization"
      ],
      "title": "Observability implementation guide template",
      "type": "docs",
      "tags": [
        "Observability maturity",
        "Value driver this applies to << change",
        "Use case name << change",
        "Implementation guide"
      ],
      "external_id": "e207c5d5d6379c5a496c46dc890bf51c60274c1c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/om-implementation-guide/",
      "published_at": "2021-12-25T16:57:04Z",
      "updated_at": "2021-12-24T13:23:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is the template for Observability maturity implementation guides. To help you along, refer to: The style guide introduction Other observability maturity implementation guides To get your implementation guide to show up in the left nav as it should, edit ~src/nav/new-relic-solutions.yml. Don't forget to add a link to it to the Observability Maturity introduction page. Overview Put in a brief, executive-level overview of what this guide achieves. Desired outcome What's the benefit of following the steps in this implementation guide? For practitioners? For the business or the organization? Key performance indicators Refer to the KPI section of the service level management (SLM) guide for what this section should look like. KPI1 name Describe the KPI Goal What is your reader trying to do? Best practices Are there any principles your reader should adopt? KPI2 name Describe the KPI Goal What is your reader trying to do? Best practices Are there any principles your reader should adopt? Prerequisites List any of the following that applies: Reading Training Instrumentation Configuration User access needed Stick to what's relevant (don't be exhaustive unless absolutely necessary) and include links wherever possible. Establish the current state Step1 Step2 Step3 If the reader needs to access a JSON file or another file type, make sure those files are available in the oma-resource-center. Step 1 Describe the step. Step 2 Describe the step. Step 3 Describe the step. Improvement process Now that the reader knows where they stand, tell them how to improve what they're trying to improve. Value realization Remind the reader why they did all this work in the first place and what they'll see as a result. Include best practices to adopt going forward so that they can continue to benefit from their hard work.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 58.267548,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "This is the template for Observability maturity implementation guides. To <em>help</em> you along, refer to: The style guide introduction Other observability maturity implementation guides To get your implementation guide to show up in the left nav as it should, edit ~src&#x2F;nav&#x2F;new-relic-solutions.yml. Don&#x27;t"
      },
      "id": "61c5c9ec28ccbccadb07ca78"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/om-implementation-guide": [
    {
      "sections": [
        "Service level management use case implementation guide",
        "Overview",
        "Desired outcome",
        "Key performance indicators",
        "Service response time",
        "Service quality",
        "Service level objective attainment",
        "Service uptime",
        "Prerequisites",
        "Establish current state",
        "Determine in-scope services",
        "Identify service boundaries",
        "Deploy instrumentation",
        "Perform SLM educational workshops",
        "Analyze KPIs and set baseline SLOs",
        "Establish or optimize alerting",
        "Build problem resolution workflows",
        "Execute continuous improvement review",
        "Next steps",
        "Value realization",
        "Additional resources"
      ],
      "title": "Service level management use case implementation guide",
      "type": "docs",
      "tags": [
        "Observability maturity",
        "Uptime, performance, and reliability",
        "Service level management",
        "Implementation guide"
      ],
      "external_id": "e3c4da80186b6d33a301db4a15c0b0cff2034131",
      "image": "https://docs.newrelic.com/static/e2478328e46923877c6dd58993aecf5f/d9199/nrSLMServiceMap.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/observability-maturity/uptime-performance-reliability/slm-implementation-guide/",
      "published_at": "2021-12-25T10:55:59Z",
      "updated_at": "2021-11-25T05:19:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Overview IT Operations is expected to provide services that meet the business’s requirements for performance and reliability. However, many ops teams attempt to measure performance and reliability using legacy methods, like measuring resource consumption. That, in turn, requires that they create complex dashboards of granular metrics which they then try to correlate with application performance and reliability. These complex dashboards require subject matter experts to interpret the results for business stakeholders. Legacy methods create barriers to understanding what a good system state looks like and how bad system states impact the business. Essentially, IT ends up not sharing a common metric vocabulary with the business. This fundamental disconnect will result in the perception that IT is not able to deliver the services that the business requires, with all the implications and impacts that perception carries. Service Level Management (SLM) eliminates that disconnect by better explaining the overall performance of a system in terms that are easily understood by both IT and the business. The intent is to show whether or not the system is meeting its performance and reliability expectations, and if it is trending toward or away from improvement, so proactive steps can be taken. The end goal is that systems are better oriented toward desired business outcomes with IT’s attention focused on issues in areas with the highest business impact. You are a good candidate for SLM if any of the following are true: The business impact of performance and reliability issues are not well understood by all stakeholders. Your MTTx is too high. You are collecting many resource consumption metrics (such as CPU, disk, or memory) or are maintaining many metric correlation rules in order to identify system problems. You can’t see the value of your observability tool(s). Desired outcome Service Level Management’s overall goal is to easily measure and communicate the overall health, performance, and quality of your digital products and services to all stakeholders. By implementing SLM at key output points in your systems, you will have a simpler and more responsive observability practice, tighter alignment with the business, and faster paths to improvement. The SLM process described in this guide will help you to identify the points in your systems where you should measure the key performance metrics of service performance and quality. It will also define and drive a simpler alerting strategy, continuous improvement methodologies, and improved problem resolution workflows. Key performance indicators You will use the SLM process to collect and measure the following KPIs, often referred to as the “Golden Signals”: Service response time Service response time measures the amount of time a service requires to process a transaction. It starts when a transaction request is received by the service and ends when the response is sent. Goal: Reduce transaction response time. Best practices: Measure response time at service boundaries. Use continuous improvement processes to drive down response times. Ensure that non-business transactions (such as health checks) are not included or measured. Map this KPI back to business impact. Report KPIs to all stakeholders. Service quality Service quality is the number of transactions that result in an unhandled error. Typically, these are transactions whose HTTP response code is greater than or equal to 400. Goal: Reduce the number of unhandled errors. Best practices: Measure error rates at service boundaries. Continually identify and remediate sources of high error volumes. Map this KPI back to business impact. Report KPIs to all stakeholders. Service level objective attainment SLO attainment is the percentage of time a business service is meeting its response time and quality goals. Goal: Improve response time and quality to ensure high SLO attainment. Best practices: Use continuous improvement processes to maintain / improve SLO attainment. Map this KPI back to business impact. Report KPIs to all stakeholders. Service uptime Service uptime is the percentage of time a service can be reached by at least one client. Typically this is measured using synthetic transactions from representative remote locations. Goal: Use continuous improvement processes to watch uptime metrics and take appropriate steps to ensure uptime meets business requirements. Best practices: Use continuous improvement processes to maintain / improve SLO attainment. Map this KPI back to business impact Report KPIs to all stakeholders. These KPIs directly measure the most important aspects of an IT service, speed and quality, in a way that is easy and intuitive to understand and communicate to technical and non-technical stakeholders. Prerequisites Before you begin, if you don’t have equivalent experience, you should complete the New Relic University (NRU) Overview Course. You should also have a basic understanding of: New Relic One APM and infrastructure monitoring New Relic One Dashboards and NRQL New Relic One alerting best practices Establish current state As with any continuous improvement process, the first step of SLM is to establish the current state of your KPIs. To do so, you will need to perform the following tasks: Determine in-scope services Identify service boundaries Deploy instrumentation Perform SLM educational workshops Analyze KPIs and set baseline SLOs Establish / optimize Alerting Build problem resolution workflows Execute continuous improvement review To help illustrate this process, we are going to apply it to an example IT service, an ecommerce site for a cellular telephone provider. Determine in-scope services You should first identify the IT services that are going to be in-scope for the initial iteration of the SLM process. These services should be key to ongoing business operations and as close to your customers as possible. Most commonly, you will be applying the SLM process to an application, since that is the service your customers are expecting you to deliver. SLM can be applied to infrastructure-based services; however, it is a more advanced application of SLM which is applicable to a much smaller set of organizations. If you are considering implementing SLM for infrastructure, you should ensure that the service(s) you are instrumenting are actually the closest to your organization’s end-customer. If your infrastructure is hosting a customer-facing app, then the app should be the target of SLM. Absent anything else, a good methodology for identifying in-scope services is to consult your disaster recovery plan. Typically, the most critical business services are prioritized there. Identify service boundaries Next, you should identify each service’s boundary, which is the service component that is closest to the client sending transaction requests. This should be the application receiving the request from the client, browser, or mobile device, and may also be known as the \"external API.\" Reverse proxies, CDNs, and load balancers are not part of the service boundary. Their service level compliance should be measured via the Uptime KPI (external test requests for connectivity). If your services are using APM, you can identify service boundaries using the service map or dependencies features. A service component is on a boundary if it has no inbound connections. In the example below (from a service map), you can see that the WebPortal is on the boundary. An example of using service maps in New Relic One to identify service boundaries. In contrast, the following screenshot (from the dependencies page) shows that the Inventory Service is not on a boundary since it has incoming connections from the WebPortal. Subsequent examples in this guide will build on the WebPortal service boundary. An example of using the dependencies UI in New Relic One to identify service boundaries. You should understand that the SLM process defines a service boundary as being downstream of any dependencies. The service boundary is the point where all the effects and impacts of dependent services are measured as they contribute to the total response time and quality of the service. By measuring service level compliance at the boundary, you will be able to see the impact that all service components upstream of the boundary have on service delivery. This means that your initial steps into SLM can focus on the services that are closest to your users, yet still capture the contribution of more distant services. As your practice matures, you will be able to identify the next round of upstream services that would benefit from direct SLM instrumentation. In our example, the WebService is downstream of the Fulfillment, Plan, Promo, Login, and Inventory services (among others). By applying SLM at the WebService, we will be seeing the impact of the upstream services on the WebService. Any impactful issues with an upstream service will be reflected in the WebService’s service level KPIs. By instrumenting one service, we are capturing the contribution of five additional services. This greatly simplifies our observability practice. In time, problematic upstream services will self-identify themselves as candidates for direct SLM instrumentation. Deploy instrumentation To collect SLM service response time and transaction success KPIs, you need to deploy instrumentation into the components of your production apps on the service boundary. If you don’t have instrumentation that can do this in production already, then you will need to engage the teams and stakeholders that can help you to get this done. For detailed information on deploying the New Relic instrumentation that can gather this information, see our APM install documentation. The uptime KPIs can be collected using synthetic transactions, which don’t require any instrumentation to be added to the service. If needed, you can start your SLM journey there while waiting for the direct instrumentation to be deployed. The uptime tests should perform a basic, yet realistic, check of the service’s functionality. For detailed information on this capability, see our synthetic monitoring documentation. Perform SLM educational workshops You should share the self-paced New Relic Essentials training course with the appropriate stakeholders so they can understand how the New Relic technology platform will aid in the SLM process. Analyze KPIs and set baseline SLOs The SLM process uses speed and quality as its key performance indicators. In technical terms, speed means response time and quality means error rate. At the end of this phase, you will have created baseline service level objectives for each service in the form of a percentage. For example: “98% of service X’s transactions will be error free and occur in less than 500 milliseconds.” For each in-scope service, you should analyze speed and quality at the service boundary. This will give you an overall understanding of how the entire service and all of its dependencies are performing. As you iterate through the SLM process, you can then identify and prioritize the upstream service components that require direct SLM instrumentation. To analyze KPIs, you should do the following for each service: Identify the volume and 95th percentile response time for each of the service’s transactions over a relatively long period of time, typically between seven days and one month. It is important that you use percentile rather than average, so you can see the entire range of response times, including outliers. If you use averages, you will hide outliers. The following is an example of the initial baseline report. Here you can see the volume, p95 response time, and error volume for the WebPortal and a few other services. The WebPortal’s p95 response time is .36 seconds (or 36 milliseconds), so we have decided to set the SLO target to 0.4 seconds. Example of an initial baseline report measuring volume and 95th percentile response time. Next you should review and identify any non-business transactions, since they should not be included in the SLO attainment calculation. For example, you should not include health check / keep alive transactions and you may not want to include administrative transactions. In the example below, we are looking at some of the transactions from the WebPortal service. We have decided that the about.jsp transaction is a non-business transaction that should not be tracked in our SLO attainment calculation. Example showing transaction breakdowns from the initial baseline report to help identify what to track (or not track) for SLO. Finally, import and edit the SLM template dashboard to exclude non-business transactions. Then use the p95 response time as your baseline response time service level objective. For the example chart, we chose 0.4 seconds as our response time threshold and set our service level objective to 95%. This means that we are expecting 95% of the WebPortal’s business transactions to complete in 0.4 seconds or less and without an error. The red line on the chart shows us our 95% service level objective. Example chart now excluding the non-business transactions. As you can see, there are periods of hours where the app is not meeting its SLOs. If we are going to maintain the 95% target, we would need to identify and fix the service components or dependencies that are causing these problems. Establish or optimize alerting After you have set your service level objectives, you will then configure alerts that will inform you when your SLO attainment has dipped below your goal. These alerts will show you when incidents with a high business impact are occurring. When they are triggered, they should be given a high priority and you should engage the proper teams to start the process of diagnosing the source of the problem. A basic starting point is to configure an alert that triggers when your SLO attainment has dipped under your baseline for more than 10 minutes. For more information, see our documentation on configuring alerts. Build problem resolution workflows As we’ve been discussing, the intent of the SLM process is to identify when business impacting issues occur in your IT services. When this occurs, a diagnostic investigation should be launched. The goal of the investigation is to identify what service element is causing the business impacting issue. SLM tells you that there is a problem with business impact, the diagnostic process helps you to find where the problem is. Typically, your high level diagnostic workflow will start at the service boundary and go as follows: Look at the service’s individual transactions and see which one(s) are departing from their performance and/or response time SLOs. Look at each service component responsible for delivering that transaction until you find the component that is failing. Use in-depth diagnostics to identify the root cause of the problem and then resolve it. Execute continuous improvement review This is an ongoing phase of the SLM process where data is reviewed and adjustments are made as required. Your KPIs should be reported to upper management to ensure that stakeholder teams are appropriately prioritizing work and that you are meeting the SLO goals you’ve set. Periodic KPIs should be recorded and retained over periods of months to years to establish a baseline and to show the rate of improvement. In addition, each time you execute the continuous improvement process, you should: Review each service’s architecture to ensure your instrumentation is deployed at the boundary and that there are no observabilty gaps. Review each service’s transactions to confirm that only business transactions are included in your SLO calculations. Review each service’s SLO and determine if it meets the business’s performance and quality requirements. If it does not, then the SLO should be changed and the appropriate stakeholders notified so they can work to improve performance and quality. Review your SLO attainment and determine if any upstream services should be added to the SLM process. Next steps After you’ve established the SLM process, you should identify other services that would benefit from SLM instrumentation. These may be other front-line services or upstream dependencies of services that are covered by SLOs that have shown themselves to be frequent contributors to SLO attainment failures. As you do this, you should start to measure and report your SLM coverage as a percentage of applications covered by SLOs. For example, you may say that 20% of your apps have established SLOs. As SLM expands into your organization and as its value is seen by management and other stakeholders, you may find that you need a dedicated team to manage the SLM process. The SLM process should also become a primary driver to help you prioritize issue resolution activities. SLO attainment failures are a direct indicator that your IT services are having a negative business impact which is visible to your customers as poor performance and/or unhandled errors. Value realization Once the SLM process is established, you will see a reduction in the effort required to identify business impacting issues, a better ability to communicate with your business stakeholders, and an easier time proving the business’ return on investment in IT services. Your SLM KPIs will provide quantifiable proof of these improvements. In addtion, you should be able to simplify your observability strategy by removing or reducing your dependency on legacy consumption metrics and the logic required to correlate them against your true goal of measuring performance and quality. Once you are firmly on the path to SLM's goals, consider moving to other use cases within the Uptime, Performance, and Reliability value stream, such as Service Level Management, or Reliability Engineering. You can also move to other observability maturity value streams, such as Customer Experience. Additional resources Need help getting started? Check out the self-paced service level management training",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.82898,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Service level management <em>use</em> <em>case</em> <em>implementation</em> <em>guide</em>",
        "sections": "Service level management <em>use</em> <em>case</em> <em>implementation</em> <em>guide</em>",
        "tags": "<em>Observability</em> <em>maturity</em>",
        "body": " on the path to SLM&#x27;s goals, consider moving to other <em>use</em> cases within the Uptime, Performance, and Reliability <em>value</em> stream, such as Service Level Management, or Reliability Engineering. You can also move to other <em>observability</em> <em>maturity</em> <em>value</em> streams, such as Customer Experience. Additional resources Need help getting started? Check out the self-paced service level management training"
      },
      "id": "61403d0464441f0457424337"
    },
    {
      "sections": [
        "Service characterization use case implementation guide",
        "Overview",
        "Desired outcome",
        "Key performance indicators",
        "Business KPIs",
        "Service quality",
        "Release frequency",
        "Practitioner KPIs",
        "Feature release frequency",
        "Mean time to close",
        "Prerequisites",
        "Establish current state",
        "Determine your instrumentation needs",
        "Decision matrix",
        "Understand endpoint testing",
        "Improvement process",
        "Config based instrumentation",
        "Create an effective service name",
        "Tip",
        "Override default agent configuration",
        "Isolate service functions",
        "Define custom transaction names",
        "Capture parameters with your transactions",
        "Measure service components",
        "Ensure your frameworks are measured",
        "Track every external service call",
        "Test your endpoints",
        "Value realization",
        "Investments",
        "Training",
        "Development and maintenance",
        "Returns",
        "AQM impact",
        "Service quality improvement",
        "Service delivery improvement"
      ],
      "title": "Service characterization use case implementation guide",
      "type": "docs",
      "tags": [
        "Observability maturity",
        "Operational efficiency",
        "Service characterization",
        "Implementation guide"
      ],
      "external_id": "6c7ba35514950d573261ef4dbc852f6b3c76433a",
      "image": "https://docs.newrelic.com/static/bd4c9daf746228eed022d0c89454469c/39c09/oma-oe-sc-service-diagram.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/observability-maturity/operational-efficiency/sc-implementation-guide/",
      "published_at": "2021-12-25T10:56:00Z",
      "updated_at": "2021-11-25T05:17:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Overview \"Do I have all the telemetry I need to adequately measure my service?\" The process of onboarding a service for production monitoring tends to start from the end and work its way to the beginning. Typically, a service is instantiated with agent based monitoring and the team responsible for service delivery needs to read the telemetry coming out of the agent like tea leaves. They work their way backward to understand how the service functions by what can be observed. At New Relic, through tens of thousands of observability deployments, we have discovered that the more involved designers, architects, and developers can be in the definition of optimal service delivery measurement, the better. The emergence of the IT aphorism shift left speaks to the need to involve developers more directly in the software lifecycle activities that happen after the development stage is complete. In the case of service observability, we find there is little specific guidance on how developers can meaningfully contribute to production telemetry definitions. This guide is intended to provide practical suggestions for developers to evaluate the state of your telemetry and suggest paths to improve it. Observability programs that closely link developer expectations with the runtime behavior of production systems are much more effective to diagnose and remediate aberrant conditions. The closer developer connection also produces services that are more robust and performant. You’re a good candidate for service characterization if any of the following are true: Your development teams are disconnected from production observability design. Your production monitoring program suffers from a lag between the introduction of new services/capabilities and their coverage with telemetry and alerting. You need to provide additional business context to your instrumentation for diagnosis and business KPI measurement. You employ a highly customized or proprietary software framework. Your service is under active development. Legacy services, and services built from commercial-off-the-shelf platforms tend to be better served with generic instrumentation options. Desired outcome This guide focuses on the metrics derived from your service’s runtime operation (its code execution) as well as external measurements of execution (through synthetic testing). Service instrumentation planning is the approach used to describe a single service runtime through telemetry. Modern monitoring systems provide deep insight into the technical details of service implementation. The power of distributed trace or bytecode instrumentation allows operations teams to quickly collect detailed service telemetry. Unfortunately, operations teams are often not in the best position to evaluate the quality of the telemetry gathered from the instrumentation. This challenge is compounded by the fact that service delivery teams are asked to implement telemetry collection for the first time in live production systems. Exposing inadequately instrumented services to production users for the purposes of refining that instrumentation creates a period that puts customer satisfaction at risk. This burn-in period often becomes difficult to escape as new features are delivered from code bases without a strong linkage between software delivery and observability programs. By having your development staff involved in improving your service instrumentation, you should realize observability benefits in the following ways. Better informed development decisions by: Detecting areas of volatility or unexpected behavior and addressing them. Understanding what dependencies in your code lack redundancy or robustness, and taking measures to refactor the service. Appreciating how end-user cohorts are employing your software. You can better understand where improvements will have the biggest impact. Improved troubleshooting: More precise and contextually relevant telemetry from your service will allow for more accurate and actionable detection of faults. With better telemetry naming, operations staff can use a common language with developers during incidents, reducing the time to triage and remediate incidents. Key performance indicators It is important to identify some simple KPIs that help to gauge the ongoing improvements in your software delivery and operations programs. The following outlines some suggested KPIs to consider as you invest in improved instrumentation. Business KPIs are aligned to your overall program objectives and should be consistently measured to demonstrate ongoing program improvement for each service. Practitioner KPIs are used to measure changes in the execution of job functions for those participating in the development and management of services. Business KPIs Service quality A metric is required to define how well your service is operating. This will depend upon the needs of your organization and the constraints of the services being monitored. Goal: Improved service quality attainment score over time. Best practices: Create a graphical representation as a trend of Service Quality achievement for defined periods (Monthly / Quarterly). Service Apdex can provide an effective Service specific quality score. (See Apdex: Measure user satisfaction.) A well defined Service Level Management (SLM) approach using SLIs that describe the level of expected operation for service boundaries can be a useful way to establish a single measurement of quality. Release frequency The number of releases for a given service. This should indicate the velocity of the software delivery organization. Often release frequency isn’t immediately comparable between development organizations. Instead, weighting high-value releases or features to bugs can provide an improved comparative context. Goal: Consistency of attainment with consistent or improving Service Quality indicator. Best practices: Can be derived from deployment markers or other events sent to New Relic. Measure directly from code or project management tools such as Jira, BitBucket, GitHub. Consider implementing a collection mechanism to capture release events and store them directly in New Relic. See NR1 CICD Innovation for example JIRA and BitBucket configs. Practitioner KPIs Feature release frequency Quantification of the percentage of releases that are directly related to new feature development versus bug fixes or technical debt retirement. The relationship to feature to fix will vary between teams and projects based on the history of the service. Goal: A consistent or improving feature release frequency consistent with the service delivery goals. Best practices: Practitioner feature release frequency is often acquired in the same manner as the broader release frequency business KPI. This metric is then made available to the development team for the service. Mean time to close Average duration of alert-driven incidents in New Relic. See Alert Quality Management Use Case Implementation Guide for more details. Goal: Steady decrease of incident close time for identified services. Best practices: Follow the Alert Quality Management Use Case Implementation Guide, understanding Service behavior through the lens of the alerts defined to help improve service delivery. Prerequisites Before you begin to introduce Service Instrumentation into your development processes, get acquainted with New Relic fundamentals available from New Relic University. In addition to NRU training, review and keep the following documentation resources handy: APM agent install and configuration Instrumentation guides: C-SDK Go Java .NET Node.js PHP Python Ruby OpenTelemetry SDKs Introduction to New Relic synthetic monitoring Establish current state Determine your instrumentation needs Understand endpoint testing Determine your instrumentation needs Instrumentation is the process to acquire telemetry from a software system and its associated services for the purpose of describing that software system's runtime behavior and business function. Monitoring systems tend to provide generic capabilities for telemetry acquisition that can be fine tuned to close gaps when monitoring the function of a software system. This use case assumes that your Observability Program has completed the Quality Foundation OMA use case implementation guide and that you have a well considered and deployed telemetry collection architecture for your services. With the possible exception of alert definition, instrumentation offers the most open-ended and customizable activities related to observability. The New Relic One platform provides features to highly customize your use of instrumentation. Because of this, you should carefully consider the amount of time and effort you’re going to put into instrumenting your services. Like all service instrumentation assets and dependencies, the introduction of instrumentation will require ongoing oversight and maintenance and therefore is a form of technical debt you will accrue for your project. As you begin the process of instrumentation, you want to continually ask yourself the question: Is the visibility I will gain from this instrumentation worth the cost of implementation and support? Decision matrix As a first step you should evaluate the default instrumentation you obtain from your Observability platform and ask yourself the question: Does the telemetry adequately describe the function and the purpose of my service? Think about what your service does. Perhaps it receives an order, needs to validate the order for integrity, conveys that order to a clearinghouse service, and receives a confirmation code that is relayed back to the requestor. This example gives a clear path to break down the function of service and evaluate if we have enough telemetry and context to make informed appraisals of how the service is functioning. Conceptual service that receives and processes http requests. If this conceptual diagram represents the implementation of the service, you need to know at any moment in time: How many requests do I receive? How many messages and HTTP requests do I send? How many requests are successful? What is the response time for a full request? What is the response time for invocation to a dependency? How much resource should this process take under what number of requests? What are all my points of failure? Most monitoring frameworks for application runtimes will gather telemetry like this as basic functionality. However, sometimes specific implementation of your service will pose a challenge to the generic instrumentation assumptions made by the monitoring software. In this case your Observability platform will need to accommodate your needs and provide an ability to modify a default monitoring configuration. The following table documents some additional situations where you would consider adding additional telemetry or metadata capture through instrumentation. The practices section that follows describes how to close those gaps to ensure your observability platform provides telemetry needed to manage your service. Considerations for instrumentation: Are my base telemetry requirements satisfied? If not, document the gaps and evaluate if they can be closed through custom configuration or additional instrumentation techniques. Can I isolate discrete user stories within the telemetry? If not, use trace capabilities of agents to capture the invocation of a discrete user story with adequate context metadata. Do I have insight into the parameters that are invoking user stories? If not, use custom attributes through agent SDKs to add context to the transactions and spans. Can I measure the major functional components of the software? If not, use instrumentation SDKs to create baseline metrics on a specific functional element of the code. (cache lookups, processing routines, or utility functions). Can I measure the client interactions from my code to external systems? If not, ensure requests and responses are encapsulated by component level tracking. If the client invocation is asynchronous, consider implementing distributed trace features to view the successive processing. Understand endpoint testing Endpoint testing is a simple and practical approach that greatly expedites how to determine the root cause of a given system failure. It allows operations and supporting teams to quickly know there is a real problem, and isolate that problem to a specific service. Modern software systems depend on a number of services to complete their tasks. Historically, the process of monitoring those service endpoints was straightforward. The architecture team would produce a well documented map of dependencies for the operations team. The operations team would dutifully create a check of the itemized endpoints. Today, with continuous delivery processes and small batch changes, new endpoints and dependencies can be created and deployed at a rate that makes it difficult for an operations team to anticipate and proactively define synthetic checks. By giving the service developers greater scope of control to define production services tests during the development phase, you will greatly increase the coverage of endpoint tests for your Observability program. Decision matrix To determine whether to create a synthetic check is straightforward. You will want to know the first occurrence of a failure for a dependency. If you answer “yes” to any of the following questions, consider creating a dedicated synthetic check. Is the end point customer facing? Does the endpoint invoke new dependencies? Is the endpoint on a different network infrastructure? Is the endpoint shared between multiple services? Is the endpoint a content origin supported by a CDN? Improvement process Config based instrumentation Isolate service functions Define custom transaction names Measure service components Ensure your frameworks are measured Track every external call Test your endpoints Config based instrumentation Each New Relic agent provides a variety of configuration options. Typically you will define a standard approach to include the agents within infrastructure hosts, application runtimes, and connections to your cloud service providers. Default agent configurations are generic and widely applicable. One of the best ways for developers to influence the applicability of deployment is by overriding the default configuration options for your service instance. The following are default instrumentation options to consider. Create an effective service name Tip New Relic agents provide a variety of mechanisms to define the Service runtime name. Please see the application naming guide to find the implementation details for your runtime environment. The name you give a service provides the namespace (where you will find the agent data). One of the most important strategies New Relic uses to understand the behavior of your services is to aggregate like things together and to use the commonalities derived from aggregation to isolate variance. Modern services are often deployed to multiple contexts to ensure capacity handling or specific functional segmentation. In order to take advantage of the benefits of aggregation, it is very important that your service runtimes are grouping instances with identical operational characteristics. Therefore, when deploying services, pay close attention to the following three criteria to help you name your deployed services: Does my service target a specific audience? Is my service running a different codebase? Is my codebase using a different runtime configuration? If you answer “yes” to any of these questions, consider creating a unique name for your service. Audience criteria Think of the audience as the group of end users or service functions. If your service is split between North American and European deployments, the runtimes in those deployments should be grouped accordingly. For example: newrelic.appname = PORTAL_AMER Copy and newrelic.appname = PORTAL_EMEA Copy This will group the telemetry created by that audience together, allowing you to better understand the contextual similarities of service problems related to a specific user audience. Sometimes the way we deploy applications divides the operational context of a service, such as a portal application with administrative functions. Maybe the admin functions are baked into the general portal codebase, but only one instance in a cluster is handling the portal admin requests. In that case you have a functional audience segmentation opportunity, so you should ensure that it is named appropriately. For example: newrelic.appname = PORTAL_MAIN Copy and newrelic.appname = PORTAL_ADMIN Copy Codebase criteria If you’re running different code versions under the guise of one service, consider segmenting those runtime instances and incorporating version naming as part of your naming scheme. When you group code together as one service name that is executing different service versions, you’re increasing the noise to signal ratio of any metrics you produce. Different code versions might use different amounts of compute resource or process data differently. It becomes very difficult to determine if a service is behaving normally when the signals you get from the metrics are due to different functional implementations. Consider adding a numeric identifier to the service name if you have multiple versions running concurrently. For example: newrelic.appname = PORTAL_MAIN_V112 Copy and newrelic.appname = PORTAL_MAIN_V115 Copy If you employ feature flag framework frameworks like LaunchDarkly or Split, you may have multiple versions of an application or service within a single codebase. Please consult the Isolating Service Functions section to address those conditions. Runtime criteria If an instance of a service is deployed to a system with different runtime constraints, it should be encapsulated in its own telemetry namespace. This can be a deployment to a different datacenter that offers network connectivity advantages to a shared resource, or perhaps the service is running on a separate compute tier with a different memory or thread configuration. These characteristics that affect the code runtime operation can cause different behaviors that lead to different operations behaviors. For example: newrelic.appname = PORTAL_NYC_DC Copy and newrelic.appname = PORTAL_REALLY_BIG_FOOTPRINT Copy Override default agent configuration Tip The New Relic agents provide a variety of options for runtime configuration. Please refer to the agent configuration guide for the options specific to your runtime. Each New Relic APM agent provides a variety of options to modify the default configuration. The most comprehensive and consistent location is the configuration file that accompanies each agent install. However, New Relic agents can also be configured by passing command line parameters directly to the service instance runtime, by using environment variables, or by calling functions within the agent's SDK at runtime. .NET agent configuration options: Using the New Relic .NET SDK API Environment variables Config file options Isolate service functions As the Create an effective service name section indicated, one of the primary objectives of instrumentation is to configure the New Relic agent to group like runtime constraints together as a single named unit. We suggest this because software systems should behave in deterministic ways. For a specific set of inputs, you should get an expected range of measurable outcomes. The degree to which we can comfortably contain these constraints into named service runtime components greatly helps us understand normal behavior and isolate aberrant behavior. Once you have settled on an effective service naming strategy, the next step is to look within the telemetry collected for the service and determine if it suitably isolates the service’s functionality. The implementation pattern we most often encounter is a series of functions being invoked by a web request. The initial receipt and handling of a web request to a service runtime results in the allocation of processing resources. New Relic defines this resource allocation and code execution as a transaction. The New Relic agent is configured with a set of assumptions that create namespaces for transactions as they are detected. Those assumptions differ between the agent language runtime. For example, a good example of how the New Relic Java agent determines the transaction name can be found in the Java agent's transaction naming documentation. However, even after the agent transaction naming protocol has been applied, it may leave you with an unsatisfactory result. By adding additional instrumentation to name the transaction to improve its context, this can greatly improve your understanding of the service’s execution behavior. The goal for transaction naming should be an APM transactions view that provides good segmentation of the services functions in an approach that is easy to understand for a non-developer. New Relic service transaction breakdown view. The transaction breakdown image is a good example of transaction segmentation. It provides detailed tracking of the amount of work being done by each transaction within the broader codebase of the service. It also displays the transaction with a plain user-friendly name that offers some hint of its business context (what the transaction does). As you learn more about naming transactions and including attributes, be sure to make your naming approach accessible for non-technical observers of the data. Transaction breakdown: the transactions in this service seem to be highly weighted to one transaction name with a pretty generic name. Breakdowns like this beg the question: \"Is this a good representation of the work my service does?\" The obtuse transaction breakdown image demonstrates a bad example of transaction name segmentation. In this case we have about 60% of the transaction volume being named OperationHandler/handle. Both the percentage attribution of the transaction volume and the generic nature of the name indicate there might be an overly zealous aggregation of transactions underneath that transaction namespace. A good way to validate your transaction naming approach is to review the distribution of response times for your transaction over a significant period of time in the service web transaction histogram dashboard. The service transaction histogram view shows the count of transactions that fall into each response time bucket. A good naming strategy tends to display a normal distribution. The service transaction image shows a wide range of transaction response rates. Although the bulk of the transactions land in the 0-200 millisecond range, it indicates values ranging from 200-1000 milliseconds. When you have a highly distributed range of responses for a transaction, you should ask yourself: What information do I have during the transaction execution that can help me name this transaction? In many cases, non-normal distributions are a direct result of the parameters being passed to a request, or the work the transaction is being asked to do. It is pretty easy to consider that a service query transaction might take a data range as a parameter. The date range when small might provide a faster lookup time. Therefore, perhaps providing a meaning scheme that is derived from some expected parameter constraints (> 1day, 1-5 days, >5 days) might provide a more meaningful segmentation. Your objective is to create a transaction name that facilitates grouping transactions with the fewest unique characteristics. A more normal distribution of transaction segmentation where individual transactions report more consistent response time attainment with fewer exceptions. The normal distribution image demonstrates more purposefully named transactions within a service. In this case the web transaction response times are more closely grouped, indicating consistent execution characteristics. By ensuring your transaction naming strategy provides a consistent mechanism to group your service’s functions by the types of operations they are performing, you will be able to quickly isolate aberrant behavior, or better understand the root cause of the variations. This will allow you to refactor your application and increase the overall predictability of your service’s functions. Define custom transaction names Tip Consult the New Relic agent API guide for your language agent to review the transaction naming procedure for your runtime. The New Relic agent transaction naming service requires the invocation of a SetName(String name) like API call to the New Relic agent SDK. Each language runtime agent has its own syntax and option for setting the name. For example, to take the value of an http request parameter and use it to name a transaction in the New Relic Java agent, you can use code similar to this: com.newrelic.agent.Agent.LOG.finer(\"[my query handler] Renaming transaction based on an important query parameter\"); com.newrelic.api.agent.NewRelic.setTransactionName(\"Query Handler_\" + (javax.servlet.http.HttpServletRequest)_servletrequest_0).getParameter(\"important_query_parm\")); Copy Please note: There is a maximum capacity to transaction names within New Relic. Your transaction naming strategy will have to trade off a degree of specificity if there are thousands of potential transaction names. When too many transaction names are being reported, New Relic will attempt to create rules to group those transaction names. More details can be found in the agent troubleshooting guide related to metric grouping issues. Should you suspect a metric grouping issue, open a support case with New Relic, and we will be happy to work with you to isolate the cause of the transaction naming issue. Capture parameters with your transactions Tip Consult the New Relic agent custom attributes guide for your agent language to review the metadata enhancement options for attribute customization. The transaction name is a powerful way for you to segment your Service’s functionality so that you can better understand its behavior. This allows you to discretely isolate functionality directly in the New Relic UI. However, there are many occasions when you will want to get some additional context on the function of your Service without resorting to isolating the transaction name. This can be accomplished by introducing attribute capture by your Service. You can add name:value pair attributes to decorate the details of each transaction. The attributes will be available in each transaction event through the APM transaction trace and errors UI, or through direct query of parameters from the NRDB transaction event type. After you select a transaction trace, you can view the custom attributes you have set for your Service’s transaction. Here is an example of the transaction trace details you can see in the APM errors UI. Custom attributes displayed in the APM errors UI. If you have developed a useful transaction name segmentation, you can use the additional context of the attributes to better understand the inputs, cohorts, or segments that led to an unexpected result. In addition to being able to understand the context of your transaction within the APM UI, the introduction of parameters is an extremely useful tool to aggregate and analyze transactions by querying transaction data directly. Custom attributes are added to each transaction, making it easy to isolate and facet on specific conditions. NRQL query expression that uses a custom attribute to facet database call duration. The parameter capture approach can also be used with feature flag systems like Split or LaunchDarkly. In this case, as you are implementing the decision handler for the feature flag, consider capturing the flag context (for example, optimized_version = on) that is being applied to the block of code controlling the version or feature the customer sees. NRQL query that demonstrates the result when the state of a feature flag is captured by a transaction custom attribute. The feature flag state attribute allows us to understand the impact of the code execution path on performance, throughput, and dependency utilization. For example, to take the value of an http request parameter and save it as a custom attribute in the New Relic Java agent, you can use code similar to this: com.newrelic.agent.Agent.LOG.finer(\"[my query handler] Adding an Attribute to transaction based on an important query parameter\"); com.newrelic.api.agent.NewRelic.addCustomParameter(\"ImportantParm\", (javax.servlet.http.HttpServletRequest)_servletrequest_0).getParameter(\"important_query_parm\")); Copy Measure service components The behavior of a specific transaction within the context of a service is a powerful way to segregate functionality and ensure a software system is operating effectively. However, another way to look at the behavior of a software system is to review the detailed component execution model of its implementation. The application framework code components are shared throughout the service, and the ongoing evaluation of component performance can provide an insight into the overall service health. Within New Relic One there are two places we can observe component execution details. The service summary dashboard in APM provides a view of the composite execution of the service broken down by its component parts (for example, garbage collection execution or database calls). This summary dashboard provides a breakdown of major component types within the application. Memcached, External Web Invocations, MySQL and Dirac are all examples of shared code frameworks that the collective transactions of the Service are using to execute their business logic. A similar breakdown is provided on a transaction by transaction basis. This single transaction summary view breaks out the contributing execution time by component. This helps you see the aggregate performance of components within a transaction. Transaction component segments will tend to demonstrate consistent performance behavior, you can use this consistency to detect a change in its fundamental behavior. This can be a good indication of an underlying issue. Resource constraints tend to manifest more obviously within component frameworks than within individual transaction details. This allows you to infer characteristics of dependencies through the common constraints being experienced by all code running within a service. Ensure your frameworks are measured Tip Consult the New Relic agent instrumentation and SDK guides under the language agent for your service runtime to find information about adding metric names to your instrumentation. The syntax for framework instrumentation is specific to the language your service is written in, but the general approach is consistent for all. Consider the threads of execution within your Services as an analogy for transactions within New Relic telemetry. Each method or function execution on the stack is an opportunity to add additional instrumentation. In this way New Relic maintains a time-annotated invocation stack for the transaction and uses those method/function start/stop timings to aggregate it into a series of component metrics. A simple Node.js application making a call to a MongoDB. The two major components of the application are the receipt of the request and get/put operations to the MongoDB. If a particular segment of logic is crucial to the function of your Service or transaction, consider wrapping that call with callbacks to the New Relic agent so that the agent can understand that it has entered a discrete code component and can aggregate the time consumed within that component accordingly. By passing a metric name to the callback, you will create a component segment metric for your service and transaction. The metric naming option is specific to the instrumentation language, so be sure to consult the specific language documentation. The New Relic agents allow you to specify a custom metric name for the instrumentation. The metricName will be used to determine the aggregated metric for the component. The following example demonstrates the metricName parameter being passed to a Java agent SDK @Trace annotation. @Weave public abstract class MQOutboundMessageContext implements OutboundTransportMessageContext { @Trace(dispatcher = true, metricName=\"MQTransport\") public void send(final TransportSendListener listener) throws TransportException { try { NewRelic.getAgent().getTracedMethod().setMetricName(\"Message\", \"MQ\", \"Produce\"); MQHelper.processSendMessage(this, NewRelic.getAgent().getTracedMethod()); } catch (Exception e) { NewRelic.getAgent().getLogger().log(Level.FINE, e, \"Unable to set metadata on outgoing MQ message\"); } Weaver.callOriginal(); } } Copy Track every external service call Tip Consult the New Relic agent instrumentation and SDK guides under the language agent for your service runtime to find the details of client library instrumentation. Client instrumentation refers to encapsulating a call from your service to an external resource. Generally, New Relic agents are aware of clients popular for HTTP, gRPC, messaging, and database protocols and will apply the appropriate instrumentation pattern to aggregate calls to those clients as external services. External service dashboard details within New Relic APM. If you have written your own client handler for a protocol, or are using something very new or somewhat niche, the New Relic agent may not recognize the client and record the behavior of the client call. To this end you should verify the external services and databases within APM to represent all expected externalities for your service. Database protocol dashboard details within New Relic APM. It is important to validate that all your services' dependencies are represented here. If you do not see your service dependencies, you will need to introduce new instrumentation to intercept the external call so that your APM agent can track it accordingly. The following example demonstrates wrapping an external call in Golang for capture by the agent. package main import ( \"net/http\" \"github.com/newrelic/go-agent/v3/newrelic\" ) func currentTransaction() *newrelic.Transaction { return nil } func main() { txn := currentTransaction() client := &http.Client{} request, _ := http.NewRequest(\"GET\", \"http://www.example.com\", nil) segment := newrelic.StartExternalSegment(txn, request) response, _ := client.Do(request) segment.Response = response segment.End() } Copy Examples of other agent API external call tracing: Go ExternalSegment Java ExternalParameters Python external_trace Test your endpoints Endpoint testing provides two benefits to your Service Instrumentation program. Defect detection: By encoding a test for an endpoint that produces a simple true/false result, it allows the operations team to isolate discrete failures to determine if the integrity of service delivery has been compromised. Baselining: Synthetic or machine tests provide a predictable set of conditions that allow you to evaluate the consistency of your service delivery from a control perspective. New Relic’s synthetic monitoring offers the ability to create a variety of testing types by employing an enhanced Selenium JavaScript SDK. Once a Selenium-based test script has been defined, New Relic will manage the location of the script execution as well as its frequency. New Relic synthetics launch dashboard. The synthetic test offers a variety of test options, each with its own focus. For more information see our synthetic monitoring documentation. From the perspective of a Service developer, the monitor type that is most frequently employed is Endpoint availability. This monitor type provides the ability to script http request conditions. These can be as simple as a POST or GET to an accessible API, or involve multiple steps where the Selenium monitoring script successively evaluates requests to ascertain functional integrity of a multi-step process. In practice, developers should consider implementing the simplest possible test to evaluate endpoint availability and integrity. For example, you have just created a new Service endpoint that provides the current exchange rate for a group of currencies. This is a simple GET at an endpoint that returns a JSON object array. Request example: http://example-ip:3000/exchange Response example: [ { \"status\": [ \"quote\" ], \"_id\": \"5b9bf97f61c22f4fb5beb5c9\", \"name\": \"cdn\", \"Created_date\": \"2021-07-12T18:10:07.488Z\", \"__v\": 1 }, { \"status\": [ \"quote\" ], \"_id\": \"5b9bfb2a61c22f4fb5beb5ca\", \"name\": \"usd\", \"Created_date\": \"2021-07-12T18:17:14.224Z\", \"__v\": 0.80 }, { \"status\": [ \"quote\" ], \"_id\": \"5b9bfb3261c22f4fb5beb5cb\", \"name\": \"eur\", \"Created_date\": \"2021-07-12T18:17:22.476Z\", \"__v\": 0.68 }, { \"status\": [ \"quote\" ], \"_id\": \"5b9bfb3761c22f4fb5beb5cc\", \"name\": \"mex\", \"Created_date\": \"2021-07-12T18:17:27.009Z\", \"__v\": 15.97 } ] Copy In order for this service to be considered operational, it needs to respond to requests but also provide the four currency responses. We’re not worried about the content at the moment, just the fact we get four elements back in the array one, for each CDN, USD, EUR and MEX currencies. Using New Relic synthetic monitoring, an API test script could look like the following: /** * This script checks to see if we get the currency data from the endpoint. */ var assert = require('assert'); var myQueryKey = 'secret_key'; var options = { uri: 'http://example_ip:3000/exchange', headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; function callback (err, response, body){ var data = JSON.parse(body); var info = body; if (Array.isArray(data)) { if (data.length !== 4) { assert.fail('Unexpected results in API Call, result was ' + JSON.stringify(data)); } } } $http.get(options, callback); Copy The synthetics script can be directly configured in the New Relic interface, but we highly recommend you maintain your endpoint tests within your source repository system and employ automation. This will help ensure your endpoint testing accompanies the new endpoint dependencies that your Services introduce to production service delivery. Value realization The impact of Service Instrumentation will be directly related to the level of attention you’re willing to invest in overseeing the process. Like the process of monitoring services, your Observability program will benefit through a dedicated team function that thinks critically about its expectations of return for its investment in effort. Here is some guidance to think about the cost of investment for your organization and expectation of benefit. The following section outlines an approach for estimating the investments and returns you should expect by incorporating Service Instrumentation into your Observability practice. Investments Training Ensure all developers are familiar with New Relic agent SDKs and platform capabilities. Cost Model: Dependent on your company's developer FTE model and project estimation. Estimation: Typically a number of hours for a developer to become effective using New Relic instrumentation features. Initial: 16 HRS Training / Exploration Recurring: 4 HRS/Q Review Per developer a yearly investment of 16-40 hours training to develop core skills and maintain skills currency for New Relic platform Development and maintenance The development effort required to implement and maintain instrumentation within a Service project. Cost Model: Dependent on your company's developer FTE model and project estimation. Estimation: This tends to be dependent on the scope of the project and the amount of instrumentation work required. Initial: 8 HRS per developer per service Recurring: 4 HRS/Q Maintenance Per developer a project estimation of 16-32 hours developing and maintaining Service instrumentation Returns AQM impact Alert Quality Management delivers significant benefit to the operations team by ensuring the alert notifications from variant system performance are dealt with swiftly. This improves service delivery and resource allocation during incident remediation. An effective instrumentation practice federated into your observability program will greatly improve your team’s ability to create meaningful alerts. KPIs: Volume: Incident Count Volume: Accumulated Incident Duration Volume: Mean-Time-To-Close (MTTC) User Engagement: Mean Time to Investigate Outcomes: Less alert noise Greater alert and incident responsiveness Less unknown root cause Increased operations productivity Improved service delivery Service quality improvement Improving your service quality will have a direct impact on the key financial metrics for your Service. This will require that you have a well rationalized financial model for your application. Typically this return can be projected by associating a currency value for each percent improvement on a core service quality measure like errors or apdex attainment. As your investment in Service Instrumentation increases, you should see improved attainment on your service quality measures. KPIs: Service Quality (Business KPI) Outcomes: Decreased number of user impacting errors More performant and resilient Service components Service delivery improvement By providing better telemetry from your Service instances, your delivery organization should be able to more quickly detect volatility or downtime and remediate faster. This will lead to better overall service delivery KPIs and decrease episodes of outage or degradation. Cost can be associated with the amount of time it takes to detect, investigate and remediate an incident. This might be related to the value the Service provides your organization that will be lost during an event, or may be related to the general cost to deal with the poorly behaving Service. KPIs: Mean time to detect (MTTD) Mean time to identify (MTTI) Mean time to resolve (MTTR) Outcomes: Decreased time to detect incidents Decreased time to resolve incidents",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.8279,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Service characterization <em>use</em> <em>case</em> <em>implementation</em> <em>guide</em>",
        "sections": "Service characterization <em>use</em> <em>case</em> <em>implementation</em> <em>guide</em>",
        "tags": "<em>Observability</em> <em>maturity</em>",
        "body": " acquisition that can be fine tuned to close gaps when monitoring the function of a software system. This <em>use</em> <em>case</em> assumes that your <em>Observability</em> Program has completed the Quality Foundation OMA <em>use</em> <em>case</em> <em>implementation</em> <em>guide</em> and that you have a well considered and deployed telemetry collection"
      },
      "id": "6147550428ccbc5d2156a821"
    },
    {
      "sections": [
        "Alert quality management use case implementation guide",
        "Overview",
        "Desired outcome",
        "Key performance indicators",
        "Incident volume",
        "Incident count KPI",
        "Accumulated incident duration KPI",
        "Mean time to close (MTTC) KPI",
        "Percent under 5 minutes KPI",
        "User engagement",
        "Percentage Acknowledged KPI",
        "Mean time to investigate (MTTI) KPI",
        "Prerequisites",
        "Establish current state",
        "Install and configure the incident event webhook",
        "Install the AQM dashboard",
        "Perform initial AQM orientation and enablement",
        "Accumulate AQM data",
        "Perform second enablement session",
        "Improvement process",
        "Value realization",
        "KPI reference",
        "Incident engagement",
        "Additional resources"
      ],
      "title": "Alert quality management use case implementation guide",
      "type": "docs",
      "tags": [
        "Observability maturity",
        "Uptime, performance, and reliability",
        "Alert quality management",
        "Implementation guide"
      ],
      "external_id": "b69abb6b9b6c1257482958e12952dc189aecec2a",
      "image": "https://docs.newrelic.com/static/2be50db00a885e2d8ada51aa391f60d1/748b0/nrAQMIncidentFlow.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/observability-maturity/uptime-performance-reliability/aqm-implementation-guide/",
      "published_at": "2021-12-25T10:55:10Z",
      "updated_at": "2021-11-25T05:13:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Overview Teams suffer from alert fatigue when they experience high alert volumes and alerts that are not aligned to business impact. As they start to believe that most alerts are false, they may prioritize easy to resolve alerts over others.  Also, they may close unresolved incidents so they can stay within their SLA targets. The result will be slower incident responses, magnified issue scope, and increased severity when true business impacting issues occur. Alert Quality Management (AQM) focuses on reducing the number of nuisance incidents so that you focus only on alerts with true business impact.  This reduces alert fatigue and ensures that you and your team focus your attention on the right places at the right times. You are a good candidate for AQM if: You have too many alerts. You have alerts that stay open for long time periods. Your alerts are not relevant. Your customers discover your issues before your monitoring tools do. You can't see the value of your observability tool(s). Desired outcome An alert strategy based on measuring business impact will result in faster response times and greater proactive awareness of critical events.  An improved alert signal to noise ratio reduces confusion and improves rapid identification and problem isolation. AQM's overall goal is to ensure that fewer, more valuable, incidents are created, resulting in: Increased uptime and availability Reduced MTTR Decreased alert volume The ability to easily identify alerts that are not valuable, so you can either make them valuable or remove them. The AQM process described in this guide generates the key performance indicators and metrics that you will use to measure progress towards these goals.  The metrics are measured in real time, published in a dashboard, and are used to drive a continuous improvement process that identifies and reduces nuisance alerts and increases user engagement in incident investigation. AQM does not encompass anomaly detection or AIOps, which are designed to detect unknown or unexpected modes of failure.  The two practices (AQM and ML/AI) work hand in hand, they are not mutually exclusive. Key performance indicators You will use the AQM process to collect and measure the following KPIs: Incident volume Incident Count Accumulated incident time Mean Time to Close (MTTC) Percent Under 5 Minutes User Engagement Mean Time to Investigate  (MTTI) % of Incidents Investigated These KPIs will help you to find the noisiest and least valuable alerts so you can improve their value or eliminate them.  You will then use the long term metric trends to show real business impact to management and stakeholders.  Detailed information on each metric follows. Incident volume You should treat incidents (with or without alerts) like a queue of tasks.  Just like a queue, the number of alerts should spend time near zero. Each incident should be a trigger for action to resolve the condition.  If an alert does not result in action, then you should question the value of the alert condition. If you see a constant rate of incidents or specific incidents that are \"always-on\", then you should question why. Are you in a constant state of business impact, or do you simply have a large volume of noise? The alert volume KPIs help you to answer those questions and to measure progress towards a healthy state of high quality alerting. Incident count KPI Incident Count is the number of incidents generated over a period of time. Typically you should compare the current and previous weeks. Goal: Reduce the number of low value / nuisance incidents. Best practices: Ensure condition settings are intended to detect real business impact. Ensure condition settings are detecting abnormal behavior. Communicate that the incident details \"Acknowledge\" feature helps measure meaningful and actionable alerts. See Percentage Incident Acknowledge KPI. Report AQM KPIs to all stakeholders. Accumulated incident duration KPI Accumulated incident duration is the total sum of minutes that all the incidents accumulated over a period of time. Typically you should compare the current and previous weeks. Goal: Reduce the total accumulated minutes of incidents. Best practices: Do not manually close incidents. Manual closure will skew the real duration of incident length. Eliminate alerts that do not result in any remediation actions from the recipients. Improve percent investigated and mean-time-to-investigate KPIs by communicating their importance in improving detection and response times. Report AQM KPIs to all Stakeholders. Mean time to close (MTTC) KPI Average duration of incidents within the period of time measured. Goal: Reduce MTTC Best practices: Do not manually close incidents. Manual closure will skew the real duration of incident length. Improve Reliability Engineering skills. Report AQM KPIs to all stakeholders. Percent under 5 minutes KPI Percentage of incidents where the duration of the incident is under five minutes. This can be an indicator of incident flapping. Goal: Minimize percentage of incidents with short durations Best practices: Ensure that conditions are detecting legitimate deviations from expected behavior. See Baselining and Service Level Management. Ensure that conditions are detecting legitimate deviations that correlate to business impact or impending business impact. User engagement You should measure the value of an incident by the amount of attention it receives.  Engagement in this context is measured by whether or not an incident has been acknowledged. The amount of engagement an individual alert receives is a direct measurement of its value.  More engagement implies a valuable alert, less (or zero) engagement implies a nuisance alert that should be modified or disabled. There is a significant difference between measuring the moment of incident awareness vs. acknowledging the moment resolution activity begins. If you are using an integration with New Relic Alerting, be sure that the \"acknowledge\" event that is sent to New Relic is triggered when resolution activity begins, not when the incident is sent to the external incident management tool.  For more information regarding the standard Incident Management process, see \"Incident Management Process: 5 Steps to Effective Resolution Posted on August 31, 2020 by OnPage Corporation. -- in reference to ITIL4\" Percentage Acknowledged KPI Incidents acknowledged identifies the percentage of incidents that have been engaged with and had their acknowledged property set to true. Typically you should compare the current and previous weeks. Goal: Increase the percentage of incident engagement. Best practices: Educate the DevOps team on when it is appropriate to acknowledge an incident alert. Gamify alert acknowledgement to drive usage. Discourage mass acknowledgement exercises. Mean time to investigate (MTTI) KPI Mean time to investigate identifies the average time it takes for an incident to be triaged. Typically you should compare the current and previous weeks. Goal: Reduce the mean time to investigate Best practices: Work at building incident responder's confidence in alerts. Ensure that valuable alerts are acknowledged. Incentivize response teams to respond quickly to alerts. Prerequisites Before you begin, if you don't have equivalent experience, complete the New Relic University (NRU) Overview Course. Also, make sure you have a basic understanding of: NR1 Alert policy and conditions configuration NR1 incident notification channel webhook configuration NR1 NRQL NR1 alerting best practices NR1 APM & Infrastructure How to baseline data in order to determine anomalies vs. normal behavior. Establish current state As with any continuous improvement process, the first step of AQM is to establish the current state of your KPIs. To do so, perform the following tasks: Install and configure the incident event webhook Install the AQM Dashboard Perform initial AQM orientation and enablement Accumulate AQM data Perform second enablement session Install and configure the incident event webhook The webhook will create New Relic events for each incident as it proceeds through its lifecycle (open, acknowledge, close). To ensure that the AQM process generates accurate and valuable findings, this webhook must be added as a notification channel to every alert policy. The AQM process requires incident, not violation data. This is why you will not be using the default NrAiIncident event, which provides violation data only.  Instead, you will use this webhook to send the required incident data to New Relic. To use the webhook, do the following: Identify your primary production account and each of your accounts that you will be analyzing with the AQM process. Install the incident event webhook into each account that will participate in the AQM process and configure the webhook to report nrAQMIncident events to your primary production account. Assign the webhook as a notification channel to every alert policy in each account. This example shows a webhook notification channel assigned to each alert policy for a New Relic account with multiple sub-accounts. The webhook, AQM dashboard, and detailed installation instructions can be found in the New Relic OMA resource center on GitHub. Install the AQM dashboard The AQM dashboard is the primary asset that drives the AQM process.  You need to install the AQM dashboard into the primary production account you identified in the \"Install and configure incident event webhook\" step you previously performed by doing the following: Download the dashboard definition JSON file from the New Relic OMA resource center GitHub repo. Import the definition into your primary production account. For more details on importing dashboards, see the New Relic Introduction to dashboards documentation Perform initial AQM orientation and enablement During this phase, your incident management team(s) and other stakeholders will learn the goals of the AQM process and the scope of their involvement in it. The most critical portion of this task is educating your team on the importance of acknowledging incident alerts, since that's how the alert's value is determined.  In general, instruct them to follow these guidelines: If you look at an alert and decide to take any sort of further investigative action, acknowledge the alert. If you typically close an alert without doing anything else, do not acknowledge the alert. If the incident alert is always on, do not close or acknowledge it. For further details, see Second Enablement Session. You can use the first session template presentation to communicate this material to your stakeholders. Accumulate AQM data The overall process requires at least two weeks of data before it can proceed.  During this time, you should periodically check the following items: Confirm that incident alert event data is accumulating. Confirm that the webhook is attached to every alert policy. Ensure that incident responders are following the alert acknowledgement guidelines. Perform second enablement session During this phase, you will introduce incident management teams and other stakeholders to the initial AQM data and the ongoing continuous  improvement process you'll be following. The process consists of four activities: Review AQM Dashboard and KPI Trending: Here you and the stakeholders will look at the AQM KPIs and identify their week over week trends.  The team should identify areas where KPIs are not improving and develop strategies to drive improvement. Identify Achievements, Challenges, and Opportunities: Here you and the stakeholders will map the current state of alert quality to business impact, identifying areas where improvement has resulted in better business outcomes and areas where problems are impacting business outcomes. Incident Policy Review: Using the AQM dashboard, you and the stakeholders will identify the noisiest incident policies.  Once identified, those policies should be evaluated as detailed in step 4 below. Alert Policy Recommendations: In this step, you and the stakeholders will review the noisiest policies using the following criteria: Do the alerts have any business impact? Are the policies properly configured? Are they telling us something about the resource that needs to be fixed? Are the policies necessary? Do they have business impact? Are the thresholds set properly? Technical recommendations: Here, you and the stakeholders will review any technical recommendations, including: Are there application / system problems for engineering to review? Are there poorly constructed policies that need to be fixed? Are there instrumentation gaps? You can use the second session template presentation to keep this part of the AQM process organized. Improvement process This is the ongoing phase of the continuous improvement process where you periodically review your accumulated AQM data and make adjustments as needed to alert policies. You should perform this step once a week until your alert volume is acceptable. You can then perform it less frequently. During this phase you should: Report your KPIs each week to upper management to ensure that the stakeholder teams are appropriately prioritizing the work and to show that progress towards the promised business outcomes are being reached. Record and retain your weekly KPIs  over periods of months to years to establish a baseline and to show the rate of improvement. You should keep in mind that this is a continuous improvment process, you will continue to collect and evaluate the KPIs over long periods of time to ensure you are meeting your AQM goals. Value realization Once the AQM process is established, you will see significant reductions in the volume of alerts while reliability and stability remain the same or improve.  In addition, you should see that your alerts have a clear and unambiguous business impact.  Your AQM KPIs will provide quantifiable proof of these improvements. Once you are firmly on the path to AQM's goals, consider moving to other use cases within the Uptime, Performance, and Reliability value stream, such as Service Level Management, or Reliability Engineering.  You can also move to other observability maturity value streams, such as Customer Experience. KPI reference Following are the descriptions of each KPI as well as sample NRQL queries that will extract them from the New Relic platform.  These KPIs are also included in the AQM dashboard that can be downloaded from the New Relic OMA resource center GitHub repo. Incident volume Incident count KPI Incident Count is the number of incidents generated over a period of time. Typically you should compare the current and previous weeks. NRQL: FROM nrAQMIncident SELECT count(*) AS 'Incident Count' WHERE current_state='open' AND severity='CRITICAL' SINCE 1 WEEK AGO COMPARE WITH 1 WEEK AGO Accumulated incident duration KPI Accumulated incident duration is the total sum of minutes that all the incidents accumulated over a period of time. Typically you should compare the current and previous weeks. NRQL: FROM nrAQMIncident SELECT sum(duration)/(1000*60) AS 'Incident Minutes' WHERE current_state='closed' AND severity='CRITICAL' SINCE 1 WEEK AGO COMPARE WITH 1 WEEK AGO Mean time to close (MTTC) KPI Average duration of incidents within the period of time measured. NRQL: FROM nrAQMIncident SELECT average(duration/(1000*60)) AS 'Incident MTTC (minutes)' WHERE current_state='closed' AND severity='CRITICAL' SINCE 1 WEEK AGO COMPARE WITH 1 WEEK AGO Percent under 5 minutes KPI Percentage of incidents where the duration of the incident is under five minutes. This can be an indicator of incident flapping. NRQL: FROM nrAQMIncident SELECT percentage(count(*), WHERE duration <= 5 * 60 * 100) AS '% Under 5min' WHERE current_state='closed' AND severity='CRITICAL' SINCE 1 WEEK AGO COMPARE WITH 1 WEEK AGO Incident engagement Percentage Acknowledged KPI Incidents acknowledged identifies the percentage of incidents that have been engaged with and had their acknowledged property set to true. Typically you should compare the current and previous weeks. NRQL: FROM nrAQMIncident SELECT filter(count(*), WHERE current_state='acknowledged')/filter(count(*), WHERE current_state='open')*100 AS '% Investigated' WHERE severity='CRITICAL' SINCE 1 WEEK AGO COMPARE WITH 1 WEEK AGO Mean time to investigate (MTTI) KPI Mean time to investigate identifies the average time it takes for an incident to be triaged. Typically you should compare the current and previous weeks. NRQL: FROM nrAQMIncident SELECT average(duration/(1000*60)) AS 'Incident MTTI (minutes)' WHERE current_state='acknowledged' AND severity='CRITICAL' SINCE 1 WEEK AGO COMPARE WITH 1 WEEK AGO Additional resources Want to get your hands dirty before you start implementing this in your account? Check out the alert quality management lab",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.82622,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Alert quality management <em>use</em> <em>case</em> <em>implementation</em> <em>guide</em>",
        "sections": "Alert quality management <em>use</em> <em>case</em> <em>implementation</em> <em>guide</em>",
        "tags": "<em>Observability</em> <em>maturity</em>",
        "body": ", such as Service Level Management, or Reliability Engineering.  You can also move to other <em>observability</em> <em>maturity</em> <em>value</em> streams, such as Customer Experience. KPI reference Following are the descriptions of each KPI as well as sample NRQL queries that will extract them from the New Relic platform"
      },
      "id": "61372f5964441f181342436d"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/troubleshooting-docs-guide": [
    {
      "sections": [
        "Basic doc template",
        "Section example",
        "Code example",
        "List example",
        "Table example"
      ],
      "title": "Basic doc template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "13ab0e9d759903149944453fc4392998b6fab974",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/basic-doc-template/",
      "published_at": "2021-12-25T17:21:11Z",
      "updated_at": "2021-11-26T09:12:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the formatting tips in this template to organize the docs you create on the docs site. Then replace the template information with your own text, lists, and tables as needed. Before you create sections, start your doc with a brief introduction, usually no more than a paragraph, that helps readers understand what your doc will cover. Your introduction (and the structure of your doc) should help readers understand within ten seconds whether they are in the right place. Section example Begin each section with a meaningful H2 title. The docs site uses these to generate the contents, which appears automatically in the left navigation. If you want to include a screenshot with the section, provide a permalink for the Docs team to create the image for you. Due to security requirements, the Docs team manages all images on the docs site. Code example def article_url(category, article, options={}) url_for(options.reverse_merge( :controller => 'articles';, :action => 'show', :category => category, :article => article )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add require('newrelic'); as the first line of your app's main module. Use the command npm install newrelic --save for each application you want to monitor. For unordered lists, use bullets (ul in HTML or * in Markdown). For example: Black White For complex lists, consider using collapsers. Table example Tables help organize detailed lists so the information is easier to skim. Tables are easier to manage in HTML. For exammple: <table> <thead> <tr> <th width={200}> **Item** </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Some thing </td> <td> More detailed information about it </td> </tr> <tr> <td> Another thing </td> <td> More detailed information about another thing </td> </tr> </tbody> </table> Copy Tables created in Markdown use three or more hyphens --- to create each column’s header, and pipes | to separate each column. For example: | Item | Requirements ------------ | ------------ | Some thing | More detailed information about it | Another thing | More detailed information about another thing Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.48254,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Basic doc <em>template</em>",
        "sections": "Basic doc <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " <em>article</em>_url(category, <em>article</em>, options={}) url_for(options.reverse_merge( :controller =&gt; &#x27;articles&#x27;;, :action =&gt; &#x27;show&#x27;, :category =&gt; category, :<em>article</em> =&gt; <em>article</em> )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add"
      },
      "id": "61b3574c64441f1cc6aec5a4"
    },
    {
      "sections": [
        "GraphQL API tutorial template",
        "Example query #1 with GraphQL",
        "Example query #2 with GraphQL",
        "Example query #3 with GraphQL"
      ],
      "title": "GraphQL API tutorial template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "827639827da156b6a36096c0f6a3911052706a91",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/graphql-api-tutorial-template/",
      "published_at": "2021-12-25T17:21:11Z",
      "updated_at": "2021-11-26T09:09:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL API tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what problem or use case the users want to solve, or why the API can help them query to get this data Three to five query examples that show interesting data they can get from GraphQL Sample intro paragraph: You can use the New Relic GraphQL API to [ add key use cases here]. To construct these queries and see responses, you can use the New Relic GraphQL Explorer. This document explains some of the available functions to query [ data to be queried]. Example query #1 with GraphQL Add a description here for your example query. Tell users why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #2 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #3 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.47934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "GraphQL API tutorial <em>template</em>",
        "sections": "GraphQL API tutorial <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61ab330c64441fd067927126"
    },
    {
      "sections": [
        "Add to data dictionary",
        "Data dictionary structure",
        "Add a new data type",
        "Add attributes",
        "Attribute style guidelines",
        "Using units of measurement"
      ],
      "title": "Add to data dictionary",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "05c35d88b970eee521e2af4e255666e31b915468",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/data-dictionary-style-guidelines/",
      "published_at": "2021-12-25T17:01:32Z",
      "updated_at": "2021-11-26T07:01:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We use the data dictionary to provide information about data types (for example, Transaction, Metric, Log) and attached attributes. This is exposed in the New Relic query experience, on hovering over the data types and attributes. And we also expose the dictionary to the public. This doc contains info on how to add data to the dictionary. Note that currently we don't have infrastructure integration data in the dictionary. We also have very few attributes for the Metric data type, just a few basic default ones, despite there being many potential attributes attached to that data type depending on what the data source is. Data dictionary structure The data in the data dictionary is structured like this: Data types: sometimes called \"events\" for historical reasons, these are the NRDB data objects, like Transaction, Metric, Log, Span, etc. Attributes: these are key:value pairs attached to data types. One attribute can have multiple data types listed for it. For example, appName is on multiple data types. Data source: The New Relic product from which the data originates. With the current implementation, a data type must have a single data source assigned. This isn't ideal, as theoretically a data type can come from multiple sources. Add a new data type To add a new data type: Make a new folder in this directory, alongside the other directories: src/data-dictionary/events Copy Duplicate a data type file (for example, this Metric data type), place it in the new folder, and fill it out with the new info. For how to add attributes on a new data type, keep reading. Add attributes To add attributes: Check if there's an existing attribute that has the same name and same general definition as the one you're trying to add. If it exists, edit that file to include the new data type (under events:). If an existing attribute is fairly close in definition but not exact, try to edit the definition so it works for all associated data types. If there is no existing attribute, create a new one. The easiest way is to copy an existing attribute file, edit all relevant fields to be accurate, and place it in the folder of the data type it's attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see Style. If the attribute has one of the units of measurement we use (like units: percentage (%)), add that to the front matter. For info on units, see Units. Attribute style guidelines When adding or editing attributes, some things to keep in mind: Aim for concise descriptions. Notes on this: Feel free to use sentence fragments. Feel free to edit definitions submitted from internal teams as sometimes their definitions will be overly long or have unneeded links. Some attributes are only present in some situations (for example, when a specific APM agent is used, or when a specific config option is true). We should avoid documenting most of these, with the idea that most customers will only care about the data because it's being reported for them, and won't care about the things that factor into the reasons why it wouldn't be reported. If it's thought that the addition would help customers who already have the data reporting understand the data better, you can include it. Write so it reads well as plain text. Details on this: Note that the docs site data dictionary has our usual docs styles available, but the query UI definitions have no styling available. This means that you should write definitions so that they are understandable without any styling, as plain text. You can often avoid any need for styling (for example, data types like Transaction are easy to understand as plain text, as are most phrasings that use attribute names or values. When plain text makes something too ambiguous and you need some styling, use back ticks to indicate attributes or values (for example, a definition like: Reported when ` category ` is ` http ` ). Using this also sets us up for success if we implement styling in the UI definitions in the future. We should avoid links because those aren't visible in the query UI; the query UI only displays plain text. However, every attribute entry in the query UI does display a 'See attribute in docs' link that links to the complete and normally formatted docs site entry. This means that we can use links provided that they will display in an easy to understand way in the query UI. For example, here's an example of an attribute that would read clearly in plain text despite not having a link. We should avoid using a link format like \"For more information, see Create an alert condition\", because it wouldn't read well in plain text, and would choose something like \"For more information, see our alert condition docs.\" Using units of measurement Attribute entries have an optional unit of measurement field in the front matter. For example, here the front matter for an attribute with a percent unit of measurement: --- name: cpuPercent type: attribute units: percentage (%) events: - ProcessSample --- Copy What unit of measurement to select for an attribute is sometimes obvious, like if the attribute value is measured in milliseconds (units: milliseconds (ms)) or seconds (units: seconds (s)) or a percentage (units: percentage (%)). We also have several units of measurement that are not obvious, like count, enum, rate, and ID. (Technically, these aren't actually \"units of measurement\" and are more just conceptual data types but we're doing it this way as a workaround so you can ignore the fact that units of measurement isn't actually accurate.) The main reason we want to specify this information is that this will control what kinds of queries or charts can be created or auto-suggested by New Relic. For example, the New Relic UI wouldn't want to auto-suggest a chart graphing the average of ID values because that wouldn't make any sense. So attributes with accurate units, such as data types, will help product provide more practical help/suggestions to customers in future. Here are some tips for the non-obvious unit types: count: This is a count of something, though not a count of time-based units. For a number to be a count, it must (a) only be capable of increasing during a given time/sampling period, and (b) have a theoretically uncapped range. This wouldn't be used for a count of time units; if it was a count of seconds, for example, you would just use 'seconds' as the unit of measurement. A couple of examples of a count: databaseCallCount threadConcurrency enum: enum is short for enumerated list. In other words, it is a specific range of numbers that represent other non-numeric elements. For example, an attribute that had HTTP error codes (404, 505, etc.) as possible values would be an enum. A range of numbers that represent color codes would be another example of an enum. (Theoretically, an enum can represent lists without numeric values but we have no need to categorize strings so we only care about numeric-value lists.) Example: httpResponsecode. rate: Use this for any rate (for example, count per second). These are typically for averaged rates over small units of time, like second or millisecond. We previously have used the unit of time for these attributes (for example, using seconds as the unit of measurement for a count per second rate), but now we want to use rate for these. This is necessary because the types of displays used for rates would be different than the types of displays used for a simpler duration/count measurement. Example: MySQL integration attribute db.innodb.dataReadBytesPerSecond, which has the definition \"Rate at which data is read from InnoDB tables in bytes per second.\" id: Use ID for any identification number attribute. Example: appId.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.3403,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Attribute <em>style</em> <em>guidelines</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " to be accurate, and place it in the folder of the data type it&#x27;s attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see <em>Style</em>. If the attribute has one of the units of measurement we use (like units: percentage"
      },
      "id": "61ab4782e7b9d278d80e6e03"
    }
  ],
  "/docs/style-guide/writing-docs/docs-translation": [
    {
      "sections": [
        "Translation disclaimer"
      ],
      "title": "Translation disclaimer",
      "type": "docs",
      "tags": [
        "Licenses",
        "License information",
        "Translation"
      ],
      "external_id": "cb23af79521feaaa6193002aef89648a9973cf1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/translated-documentation/translation-disclaimer/",
      "published_at": "2021-12-25T02:35:48Z",
      "updated_at": "2021-12-09T01:58:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The official version of the Documentation is in English. Portions of the New Relic Documentation may be translated for your convenience as shown on this site. Translated content may contain errors, discrepancies, or differences created in the translation, are not binding, and have no legal effect for enforcement or compliance purposes. New Relic does not make any warranty, express or implied, as to the accuracy, reliability, or correctness of any translated Documentation from the English original to any other language. Any guarantees or commitments in your Agreement with New Relic that the Services, products, or other offerings conform or are consistent with the Documentation do not apply to the extent to which the Documentation has been translated.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.74246,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Translation</em> disclaimer",
        "sections": "<em>Translation</em> disclaimer",
        "tags": "<em>Translation</em>",
        "body": "The official version of the Documentation is in English. Portions of the New Relic Documentation may be translated for your convenience as shown on this site. Translated content may contain errors, discrepancies, or differences created in the <em>translation</em>, are not binding, and have no legal effect"
      },
      "id": "61b162bf196a672b190d46f7"
    },
    {
      "sections": [
        "Update the home page",
        "Update a link's URL",
        "Add a new tile to the home page",
        "Add a new section to the home page",
        "Edit the home page left nav"
      ],
      "title": "Update the home page",
      "type": "docs",
      "tags": [
        "home page",
        "landing pages"
      ],
      "external_id": "1d084fae5223f5b34cec91fcae0bcb35560c7b29",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/edit-homepage/",
      "published_at": "2021-12-25T16:54:07Z",
      "updated_at": "2021-12-04T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can't just hit the edit button docs.newrelic.com to make edits to the home page. The page that opens is index.js, the file that manages the parts of the home page, but not the content. It's rare that you'll need to make changes to this file. Most home page changes will be to add a new tile or section to the page, or update links. These types of changes are handled in two files: src/data/homepage.yml - contains home page section titles, section descriptions, and the URLs for tiles. src/i18n/translations/en/translation.json - contains tile info, including the title and short description of tiles. Update a link's URL Change or add new links using homepage.yml. In homepage.yml, search for the link you want to change. Edit the URL, save, commit, and PR the change. Add a new tile to the home page You'll make changes to both homepage.yml and translations.json On the translations.json doc, find the spot where you want to add the new tile (which section, and in what order you want it to appear), and add a new entry with this format: \"t#\": { \"title\": \"tile name\", \"description\": \"Short description.\" }, Copy Make sure you update the number on the tile. If you want to insert it in the middle of a group, update all the subsequent tile numbers as well. Save the file. Open homepage.yml, find the spot where the new tile will be, and add a new line with the relative link for the new tile. For example, - /docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster Save and check that your new tile builds properly on a local build. Commit, push, PR when you're ready. Add a new section to the home page On the translations.json page, add a new section modeled in the spot where you want the new section to appear. Include at least one title. For example, here's the TDP entry, with one tile: \"errors-inbox\": { \"title\": \"Errors Inbox\", \"description\": \"A single place to proactively detect, triage, and take action on all the errors before they impact customers.\", \"t1\": { \"title\": \"Introduction to Errors Inbox\", \"description\": \"How to manage all your monitoring in one place.\" }, Copy When you're done creating the info, save the file. In the homepage.yml page, find the corresponding location for the new section, and add the short name you provided in the translation.json file, title, description, and tile URLs. For example, here's the corresponding TDP section on homepage.yml. errors-inbox: title: Errors Inbox description: A single place to proactively detect, triage, and take action on all the errors before they impact customers. tiles: - /docs/errors-inbox/errors-inbox Copy Save, build locally, commit, PR. Edit the home page left nav The left nav of the home page is controlled by src/nav/root.yml. This is a basic yml file, similar to our taxonomy files. Each link on the left nav needs a title and a path: - title: Welcome to New Relic path: /docs/using-new-relic - title: New Relic One path: /docs/new-relic-one/use-new-relic-one - title: Guides and best practices path: /docs/new-relic-solutions - title: section-break - title: Alerts and Applied Intelligence path: /docs/alerts-applied-intelligence Copy You can add a new link by following the pattern above or delete a link by removing the corresponding title and path. Section breaks are added by including a - title: section-break line. The left nav reflects the exact order of root.yml, so it's easy to organize it as needed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 65.60086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "You can&#x27;t just hit the edit button <em>docs</em>.newrelic.com to make edits to the home page. The page that opens is index.js, the file that manages the parts of the home page, but not the content. It&#x27;s rare that you&#x27;ll need to make changes to this file. Most home page changes will be to add a new tile"
      },
      "id": "61ab480264441f9ef0927fb8"
    },
    {
      "sections": [
        "Create smoother charts with sliding windows",
        "When to use sliding windows",
        "Valid NRQL syntax for SLIDE BY",
        "Translation from PromQL-style queries",
        "Use SLIDE BY with MAX and AUTO",
        "Tip"
      ],
      "title": "Create smoother charts with sliding windows",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "97fe07b51e5f2c6a2868c924d1c829d82fd8f585",
      "image": "https://docs.newrelic.com/static/9d882293c1b7b04e65b4bcf6f3ae4bbf/e5166/SlidingWindow2.jpg",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows/",
      "published_at": "2021-12-25T11:03:18Z",
      "updated_at": "2021-03-16T13:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Sliding windows are a technique for generating charts using the SLIDE BY clause in conjunction with the TIMESERIES clause. With sliding windows, data is gathered in time \"windows\" that overlap with each other. For example, in the image below, a query gathers data with 5 minute windows. The windows \"slide\" by 1 minute. Each window overlaps with the previous window by 4 minutes. 5-minute windows with 1-minute \"slide\" In contrast, with \"tumbling\" or \"cascading\" windows, the windows do not overlap. For example, in this TIMESERIES 3 minutes NRQL query, the windows are 3 minutes in length, with each beginning when the other ends. There is no overlap in the measurement interval. 3-minute windows with no overlap or \"slide\". When to use sliding windows Sliding windows are helpful when you need to smooth out \"spiky\" charts. One common use case is to use sliding windows to smooth line graphs that have a lot of variation over short periods of time in cases where the rolling aggregate (for example a rolling mean) is more important than aggregates from narrow windows of time. In the example below, data varies greatly from one minute to another, so the 1-minute tumbling window chart shows many high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are smoothed with the help of 1-minute SLIDE BY intervals. The query returns similar data but creates a much smoother chart. TIMESERIES query with SLIDE BY clause Valid NRQL syntax for SLIDE BY Valid NRQL syntax for the SLIDE BY clause will follow the format below. SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units Copy integer1 specifies the sliding window width and integer2 specifies the SLIDE BY interval. units is a time unit, such as second, minute, hour, or day. All standard NRQL time units are accepted. Here’s a real-life example. It shows 5-minute TIMESERIES windows with a 1-minute SLIDE BY interval. SELECT average(duration) from Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy Translation from PromQL-style queries When applicable, a PromQL-style query is translated into a NRQL sliding window query. For example, if your PromQL style query uses rate(request_count[5m]) for the past 60 minutes with a 1-minute window overlap, the NRQL translation would be the query below. SELECT rate(sum(request_count), 1 SECONDS) FROM Metric SINCE 3600 SECONDS AGO UNTIL NOW FACET dimensions() LIMIT 100 TIMESERIES 300000 SLIDE BY 60000 Copy In the translation output, the default unit of millisecond is used for TIMESERIES and SLIDE BY clauses. For TIMESERIES, 300000 ms is 300 seconds, or 5 minutes, specifying a window size of 5 minutes. For SLIDE BY, 60000 ms is 60 seconds, specifying a slide interval of 1 minute. Use SLIDE BY with MAX and AUTO You can combine SLIDE BY with MAX and AUTO arguments to further tailor query results, as shown in the examples below. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy Tip When paired with SLIDE BY, TIMESERIES does not support AUTO or MAX. The TIMESERIES value must be an integer time unit value. In other words, SLIDE BY AUTO or SLIDE BY MAX will work, but TIMESERIES AUTO or TIMESERIES MAX followed by SLIDE BY and MAX, AUTO, or a specific integer time unit is not supported. Tip The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which will show up as gaps and unexpected results. If you experience these issues with query results, consider checking for instances of SLIDE BY where the step interval exceeds the window size.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 55.11915,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Translation</em> from PromQL-style queries",
        "body": ", or day. All standard NRQL time units are accepted. Here’s a real-life example. It shows 5-minute TIMESERIES windows with a 1-minute SLIDE BY interval. SELECT average(duration) from Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy <em>Translation</em> from PromQL-style queries When applicable"
      },
      "id": "603e8a2528ccbc56e5eba774"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/create-edit-content": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-strategies/introduction-style-guide/",
      "sections": [
        "Introduction to the style guide"
      ],
      "published_at": "2021-12-25T15:06:49Z",
      "title": "Introduction to the style guide",
      "updated_at": "2021-11-24T09:23:43Z",
      "type": "docs",
      "external_id": "56adaf70b517da62915ac6a2a56ff50c6effb7a9",
      "document_type": "page",
      "popularity": 1,
      "body": "Welcome to New Relic's style guide. We've written these guidelines for content creators across New Relic, and for contributors to our open source content projects, like the Docs! This guide also gives you some insight into how we think about good technical writing. We focus on style and usage that's particular to New Relic. We follow American English conventions. For topics that aren't covered, please refer to the Microsoft Writing Style Guide (for guidelines on technical terminology) or the Chicago Manual of Style (for general writing and editing guidelines). Find the information you need: For our writing strategy, see docs in this section on voice, five questions for great content, how to organize your content, and more. For a quick reference for terms usage, see our Usage dictionary. For how to write and edit pages on docs.newrelic.com, see Create and edit content.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 914.6109,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ": For our writing strategy, see docs in this section on voice, five questions for great <em>content</em>, how to organize your <em>content</em>, and more. For a quick reference for terms usage, see our Usage dictionary. For how to write and <em>edit</em> pages on docs.newrelic.com, see <em>Create</em> and <em>edit</em> <em>content</em>."
      },
      "id": "619e049fe7b9d2f6effe7e25"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-strategies/organize-doc/",
      "sections": [
        "Organize your page",
        "Organize your page to make it easier to read",
        "Use action-oriented titles",
        "Start the document with an introductory paragraph",
        "Keep documents short",
        "Use the New Relic voice",
        "Change doc titles and anchors",
        "Create and edit categories",
        "Start writing and editing docs"
      ],
      "published_at": "2021-12-25T15:06:49Z",
      "title": "Organize your page",
      "updated_at": "2021-11-24T07:56:48Z",
      "type": "docs",
      "external_id": "a3e3c993c0bf65626e805676496bcae8ea8d2c64",
      "document_type": "page",
      "popularity": 1,
      "body": "These are some organization basics. Organize your page to make it easier to read Consider these organization guidelines when thinking about the order of information in a doc. By following these guidelines, you'll make it easier for readers to skim and find what they need. How to organize information Comments Separate what and why from how. Define any necessary prerequisites, policies, or background information (the what and the why) before you step through the how (step-by-step procedures). Examples: Explain what the feature is and why it matters before telling readers how to use it. Describe any limitations with user permissions or subscription levels that would prevent them from using the feature. If the feature is available for any user or subscription level, don't bother to say so. Provide a roadmap for what users will be able to accomplish, so they know before starting a procedure that they have everything they need. Front-load directions with context. Make sure readers know where they need to be, before telling them what to do. In general, use (select an app) to describe what users select from the product index. Examples: Go to one.newrelic.com > Explorer > (select an app or service). Select (account dropdown) > User preferences. On the command line, type gitk. Also, structure steps by front-loading context from the user's point of view. For example, instead of \"Go to x to do y,\" structure the step as \"To do y, go to x.\" Separate requirements from options. Example: Type the Email you use to sign in and to receive information from New Relic. Optional: Type additional user emails, separated by commas. Follow the \"five to nine\" guideline. Depending on the topic, organize the information so there is a maximum of five to nine chunks of information. For example, readers may start to get lost or overwhelmed after about five h2 sections or seven steps into a procedure. If you have more than nine h2 sections or steps, you might need to create an additional doc or procedure. Other organization tools to consider: Levels of headings Lists Collapsers Callouts Tables Code examples For more help section Use action-oriented titles Wherever possible, give your document or h2 heading a task- or action-oriented title. Focus on what users are trying to accomplish or the problem they're trying to solve. Use present-tense verbs, rather than \"-ing\" verbs. Quality Title example Bad The query history Okay View query history Good Query history: Create and edit NRQL queries Start the document with an introductory paragraph Unless the document is less than a single screen in length, begin with a brief paragraph that introduces the topic or summarizes the important points. Not sure where to start? Try writing all the content for your document first, and then add the introduction to the top to summarize your key points. Or use the introduction to expand on the text in your metaDescription in the metadata. Keep documents short The amount of content needed can help you decide whether you need one or more documents for the topic. If all of the document's contents apply directly to the title, then everything belongs in the same document. If several related sections could be logically split into individual documents, and the overall length of your document is more than about two screenfuls, split those sections into other documents. Be sure to include links to the related contents. If a large document needs to be broken into multiple smaller documents, consider whether they might be best grouped together in their own sub-category. Use the New Relic voice We strive for a voice that's approachable, expert, and visionary. Check out our voice guidelines for how to write content with these qualities. And keep in mind these essential writing tips that apply to any type of documentation. Guidelines Comments Be clear and direct. Remember to: Use present tense. Use active voice; avoid passive voice. Tell users what to do, not what they \"should\" do. If absolutely necessary, tell users what not to do in situations where unexpected results may occur. Whenever possible, provide an alternative suggestion when telling users what not to do. Example: Using active voice with an alternative suggestion for what not to do Do not use your config file to change this setting, because this could affect other processes. Instead, go to one.newrelic.com > APM > (select an app or service) > Settings > Application. Write to aid localization and translation. Do not use euphemisms, idioms, jargon, or slang. Use the same terms and wording consistently. If you need to include an abbreviation or acronym, spell it out the first time it appears in the document. Always take a moment to ask yourself whether people will really understand the terms you are using in the way you're using them. Change doc titles and anchors Because changes to doc titles, anchors, and redirects can break links to other docs, please create an issue to request these types of changes and we'll help you out with that. Create and edit categories Because changes to categories can affect large groups of docs at once, please create an issue to request these types of changes and we'll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see Create and edit content. To learn how to create and publish release notes, see Create release notes. To make it even easier to start a new doc, use templates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 587.21967,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Create</em> <em>and</em> <em>edit</em> categories",
        "body": " of docs at once, please <em>create</em> an issue to request these types of changes and we&#x27;ll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see <em>Create</em> and <em>edit</em> <em>content</em>. To learn how to <em>create</em> and publish release notes, see <em>Create</em> release notes. To make it even easier to start a new doc, use templates."
      },
      "id": "619df04028ccbc2730b9a00a"
    },
    {
      "sections": [
        "Service Levels Management: Questions and next steps",
        "BETA FEATURE",
        "What permissions do I need to use New Relic's Service Levels?",
        "How do I get support from New Relic during the public beta?",
        "Why don’t I see any data right after I create an SLI?",
        "Can I configure an SLI on any entity type?",
        "Can I get alerts on SLI data?",
        "How does New Relic calculate the remaining error budget?",
        "How can I view the queries that define an SLI from the UI?",
        "How can I view the queries that define an SLI through the API?",
        "Can I chart the SLI attainment on a dashboard?"
      ],
      "title": "Service Levels Management: Questions and next steps",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started",
        "Service Level Management"
      ],
      "external_id": "262058f4dc430fbaee0382261f79de147e348f53",
      "image": "https://docs.newrelic.com/static/763695119ceaa7668fdb3fb858c83c75/c1b63/slm_edit_menu_2.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/faqs-slm/",
      "published_at": "2021-12-25T02:33:00Z",
      "updated_at": "2021-12-25T02:33:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic's Service Levels? To use New Relic's Service Levels and see SLO results, you need a full platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify events to metric rules. If you get the following errors, check your user permissions: The UI has disabled the option to save an SLI/SLO. The API returns the error message “Cannot query field \\\"eventExportRegisterRule\\\" on type \\\"RootMutationType\\\".”. How do I get support from New Relic during the public beta? Service Levels Management is in public beta, and no official support is offered yet through the Support portal. If you have general questions and feedback, please post them on the Explorers Hub. New Relic’s community and the product team will be glad to help you there. If you have suggestions about documentation, please suggest an improvement or send your contribution using the Create issue or Edit page buttons on the top right corner in the docs UI. Why don’t I see any data right after I create an SLI? New Relic starts generating new SLI metrics from the moment that you create an SLI. This is why we need a few minutes before we can start showing the first meaningful SLI attainment results. The benefit of the new data is that it has 13 month retention by default, and it’s more efficient to query for long periods of time. Can I configure an SLI on any entity type? Yes, you can configure an SLI on any entity type, such as an APM service, a browser application, or a Lambda function. SLI queries support NRDB events. Support for dimensional metrics on SLI queries is on our roadmap. Can I get alerts on SLI data? Alerts on New Relic's Service Levels are on our roadmap. How does New Relic calculate the remaining error budget? The remaining error budget indicates what percentage of requests could still have a bad response over the SLO period without compromising the objective. Therefore, the total amount of tolerated bad responses will vary with the throughput of requests. Time-based error budgets are on our roadmap. How can I view the queries that define an SLI from the UI? To view the queries that define an SLI, you can click on the ... menu on the SLI summary card, then select the Edit option. The queries will show at the top-right corner. How can I view the queries that define an SLI through the API? To view the queries that define an SLI through the API, use Nerdgraph. In order to view the SLI configuration, you'll need to know the GUID of the entity the SLI is attached to, and replace it in the following query: { actor { entity(guid: \"{entityGuid}\") { serviceLevel { indicators { events { badEvents { where from } goodEvents { from where } validEvents { from where } } name } } } } } Copy As a response you are going to receive all the SLIs attached to the entity, the SLI name, and the queries. Keep in mind that either goodEvents or badEvents is going to have content, depending on the configuration of the SLI. Can I chart the SLI attainment on a dashboard? You can chart SLI attainment time series on your custom dashboards using the following query: FROM Metric SELECT clamp_max((count(newrelic.sli.valid) - count(newrelic.sli.bad)) / count(newrelic.sli.valid) * 100, 100) as 'SLI attainment' WHERE sli.id = '<sli.id>' UNTIL 2 MINUTES AGO TIMESERIES AUTO Copy Where sli.id is the SLI identifier. The easiest way to add a chart like this to your dashboard is by using the Add to dashboard option, available on the Details view. Alternatively, you can find the SLI id and SLI attainment query through the Nerdgraph API with the following query: { actor { entity(guid: \"{entityGuid}\") { serviceLevel { indicators { name id resultQueries { indicator { nrql } } } } } } } Copy Use the entityGuid of the entity that's associated with the SLI. On the query results, you’ll get the SLI id in the serviceLevel.indicators.id field.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.64081,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Service Levels Management: Questions <em>and</em> next steps",
        "sections": "Why don’t I see any data right after I <em>create</em> an SLI?",
        "body": " suggestions about documentation, please suggest an improvement or send your contribution using the <em>Create</em> issue or <em>Edit</em> page buttons on the top right corner in the docs UI. Why don’t I see any data right after I <em>create</em> an SLI? New Relic starts generating new SLI metrics from the moment that you <em>create</em>"
      },
      "id": "61ab3a9d28ccbc492ac23ee2"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/create-release-notes": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-strategies/organize-doc/",
      "sections": [
        "Organize your page",
        "Organize your page to make it easier to read",
        "Use action-oriented titles",
        "Start the document with an introductory paragraph",
        "Keep documents short",
        "Use the New Relic voice",
        "Change doc titles and anchors",
        "Create and edit categories",
        "Start writing and editing docs"
      ],
      "published_at": "2021-12-25T15:06:49Z",
      "title": "Organize your page",
      "updated_at": "2021-11-24T07:56:48Z",
      "type": "docs",
      "external_id": "a3e3c993c0bf65626e805676496bcae8ea8d2c64",
      "document_type": "page",
      "popularity": 1,
      "body": "These are some organization basics. Organize your page to make it easier to read Consider these organization guidelines when thinking about the order of information in a doc. By following these guidelines, you'll make it easier for readers to skim and find what they need. How to organize information Comments Separate what and why from how. Define any necessary prerequisites, policies, or background information (the what and the why) before you step through the how (step-by-step procedures). Examples: Explain what the feature is and why it matters before telling readers how to use it. Describe any limitations with user permissions or subscription levels that would prevent them from using the feature. If the feature is available for any user or subscription level, don't bother to say so. Provide a roadmap for what users will be able to accomplish, so they know before starting a procedure that they have everything they need. Front-load directions with context. Make sure readers know where they need to be, before telling them what to do. In general, use (select an app) to describe what users select from the product index. Examples: Go to one.newrelic.com > Explorer > (select an app or service). Select (account dropdown) > User preferences. On the command line, type gitk. Also, structure steps by front-loading context from the user's point of view. For example, instead of \"Go to x to do y,\" structure the step as \"To do y, go to x.\" Separate requirements from options. Example: Type the Email you use to sign in and to receive information from New Relic. Optional: Type additional user emails, separated by commas. Follow the \"five to nine\" guideline. Depending on the topic, organize the information so there is a maximum of five to nine chunks of information. For example, readers may start to get lost or overwhelmed after about five h2 sections or seven steps into a procedure. If you have more than nine h2 sections or steps, you might need to create an additional doc or procedure. Other organization tools to consider: Levels of headings Lists Collapsers Callouts Tables Code examples For more help section Use action-oriented titles Wherever possible, give your document or h2 heading a task- or action-oriented title. Focus on what users are trying to accomplish or the problem they're trying to solve. Use present-tense verbs, rather than \"-ing\" verbs. Quality Title example Bad The query history Okay View query history Good Query history: Create and edit NRQL queries Start the document with an introductory paragraph Unless the document is less than a single screen in length, begin with a brief paragraph that introduces the topic or summarizes the important points. Not sure where to start? Try writing all the content for your document first, and then add the introduction to the top to summarize your key points. Or use the introduction to expand on the text in your metaDescription in the metadata. Keep documents short The amount of content needed can help you decide whether you need one or more documents for the topic. If all of the document's contents apply directly to the title, then everything belongs in the same document. If several related sections could be logically split into individual documents, and the overall length of your document is more than about two screenfuls, split those sections into other documents. Be sure to include links to the related contents. If a large document needs to be broken into multiple smaller documents, consider whether they might be best grouped together in their own sub-category. Use the New Relic voice We strive for a voice that's approachable, expert, and visionary. Check out our voice guidelines for how to write content with these qualities. And keep in mind these essential writing tips that apply to any type of documentation. Guidelines Comments Be clear and direct. Remember to: Use present tense. Use active voice; avoid passive voice. Tell users what to do, not what they \"should\" do. If absolutely necessary, tell users what not to do in situations where unexpected results may occur. Whenever possible, provide an alternative suggestion when telling users what not to do. Example: Using active voice with an alternative suggestion for what not to do Do not use your config file to change this setting, because this could affect other processes. Instead, go to one.newrelic.com > APM > (select an app or service) > Settings > Application. Write to aid localization and translation. Do not use euphemisms, idioms, jargon, or slang. Use the same terms and wording consistently. If you need to include an abbreviation or acronym, spell it out the first time it appears in the document. Always take a moment to ask yourself whether people will really understand the terms you are using in the way you're using them. Change doc titles and anchors Because changes to doc titles, anchors, and redirects can break links to other docs, please create an issue to request these types of changes and we'll help you out with that. Create and edit categories Because changes to categories can affect large groups of docs at once, please create an issue to request these types of changes and we'll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see Create and edit content. To learn how to create and publish release notes, see Create release notes. To make it even easier to start a new doc, use templates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 563.1418,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Create</em> and edit categories",
        "body": " of docs at once, please <em>create</em> an issue to request these types of changes and we&#x27;ll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see <em>Create</em> and edit content. To learn how to <em>create</em> and publish <em>release</em> <em>notes</em>, see <em>Create</em> <em>release</em> <em>notes</em>. To make it even easier to start a new doc, use templates."
      },
      "id": "619df04028ccbc2730b9a00a"
    },
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-25T17:36:34Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 539.1945,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " list views. For more information, see Working with landing pages. <em>Release</em> <em>notes</em> This format includes specific fields for <em>release</em> <em>notes</em>. Users rely on <em>release</em> <em>notes</em> to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see <em>Create</em>"
      },
      "id": "61b35517196a677196a59e07"
    },
    {
      "sections": [
        "Security bulletins",
        "Get security notifications",
        "APM",
        "Infrastructure monitoring",
        "Browser monitoring",
        "Synthetic monitoring",
        "Security vulnerability ratings",
        "Report security vulnerabilities to New Relic"
      ],
      "title": "Security bulletins",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Information security"
      ],
      "external_id": "9fdc7f00a2f5dee1ec57904fd2b6fecfcf37d9bc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/information-security/security-bulletins/",
      "published_at": "2021-12-25T17:32:17Z",
      "updated_at": "2021-12-20T02:43:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains important information regarding security vulnerabilities that could affect some versions of New Relic products and service. Security bulletins are a way for us to let you know about security vulnerabilities, remediation strategies, and applicable updates for affected software. For more information, see our documentation about security, data privacy, and compliance, or visit the New Relic security website. Get security notifications Select the Watching option in our Explorers Hub's Security notifications community channel to receive email alerts. Or subscribe to the RSS feed. APM Security bulletins for our APM agents include a vulnerability rating. Security bulletin Summary and related release notes Rating NR21-03, original date 12/10/2021 The Java agent use of the Apache log4j logging framework and procedures to address CVE-2021-44228 and CVE-2021-45046. Bulletin includes action items and links to related release notes. Critical NR21-02, 4/26/2021 The Java agent implements a YAML parser that may lead to limited code execution when parsing a crafted YAML payload. Low NR20-02, 8/20/2020 The agent does not remove the URI from transaction traces when request.uri has been disabled in attribute configuration. See the Node.js agent release notes. Medium NR20-01, 1/16/2020 The agent may capture full SQL queries when an exception occurs. See the .NET agent release notes. Medium NR19-05, 8/26/2019 Incorrect metric names created with non-parameterized queries may contain sensitive information. See the .NET agent release notes. Medium NR19-03, 4/22/2019 Query obfuscation may fail in Microsoft SQL server. See the .NET agent release notes. Medium NR19-02, 4/1/2019 Segment attributes may include request parameters in high security mode or when using configurable security policies. See the Node.js agent release notes. Medium NR19-01, 1/9/2019 OpenRasta instrumentation may capture query strings. See the .NET agent release notes. Medium NR18-09, 5/2/2018 The agent may capture sensitive data when record_sql is set to off. See the Java agent release notes. Low NR18-08, 4/12/2018 The agent uses a vulnerable https-proxy-agent Node module. See the Node.js agent release notes. Low NR18-07, 3/7/2018 The agents may report DB query results to New Relic or reissue an SQL statement. See the release notes for the Python, Java, and .NET agents. High NR18-06, 3/5/2018 The agent may capture all transaction attributes. See the Node.js agent release notes. High NR18-04, 1/22/2018 Error messages are not removed in high security mode. See the .NET agent release notes. Medium NR18-02, 1/9/2018 The agent may not obfuscate SQL params with SQLite. See the Python agent release notes. Medium NR18-01, 1/9/2018 The agent may capture custom API parameters in high security mode. See the Python agent release notes. Medium NR17-06, 12/18/2017 The agent captures external HTTP request parameters during a transaction trace. See the .NET agent release notes. Medium NR17-05, 5/30/2017 The agent may capture full SQL queries when an exception occurs. See the Java agent release notes. High NR17-04, 5/5/2017 The agent captures WCF service request parameters during a TransactionError. See the .NET agent release notes. Medium NR17-03, 2/9/2017 MongoDB aggregate queries not obfuscated. See the Ruby agent release notes. Low NR17-02, 1/12/2017 Query parameters are not removed from the referer attribute in error trace. See the .NET agent release notes. Medium NR17-01, 1/12/2017 Query parameters are not removed from the referer attribute in error trace. See the Node.js agent release notes. Medium Infrastructure monitoring Security bulletins for infrastructure monitoring include a vulnerability rating. Security bulletin Summary and related release notes Rating NR18-12, 11/28/18 Windows agent may follow unprivileged hard links or junction folders. See the agent release notes for infrastructuring monitoring Low NR18-11, 10/8/18 Windows agent may execute privileged binaries in the system path. See the agent release notes for infrastructuring monitoring. Medium NR18-10, 6/18/18 Hard-coded file path allows for user-controlled configuration. See the agent release notes for infrastructuring monitoring. High NR18-05, 2/8/2018 Command line options may be captured. See the agent release notes for infrastructuring monitoring. High Browser monitoring Security bulletins for browser monitoring include a vulnerability rating. Security bulletin Summary and related release notes Rating NR21-01, 3/9/2021 The agent does not properly sanitize local file URIs when an instrumented HTML page is opened directly from the operating systems's filesystem. Medium Synthetic monitoring Security bulletins for synthetic monitoring include a vulnerability rating. Security bulletin Summary and related release notes Rating NR21-04, original date 12/13/2021 Containerized private minion (CPM) and procedures to address CVE-2021-44228 and CVE-2021-45046. Bulletin includes action items and links to related release notes. Critical NR19-04, 7/22/2019 Sensitive data may appear in logs. See the release notes for containerized private minions. Medium NR18-03, 1/12/2018 Update private minions for Meltdown (CVE-2017-5754). See the release notes for containerized private minions. High Security vulnerability ratings At New Relic, we use four levels to rate security vulnerability. Rating Description Critical A vulnerability in a New Relic product or service that could be exploited to compromise the confidentiality or integrity of your data. High Atypical or unintended information is likely to be received by New Relic, potentially compromising the confidentiality or integrity of your data. Medium Atypical or unintended information could be received by New Relic, but the risk of compromise is mitigated by default configuration or standard security practices. Low Atypical or unintended information may be received by New Relic, but the vulnerability would be difficult to exploit, or it would have minimal impact. Report security vulnerabilities to New Relic New Relic is committed to the security of our customers and your data. If you believe you have found a security vulnerability in one of our products, services, or websites, we welcome and greatly appreciate you reporting it to our coordinated disclosure program. For more information, see our documentation about reporting security vulnerabilities via HackerOne.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.6693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " feed. APM Security bulletins for our APM agents include a vulnerability rating. Security bulletin Summary and related <em>release</em> <em>notes</em> Rating NR21-03, original date 12&#x2F;10&#x2F;2021 The Java agent use of the Apache log4j logging framework and procedures to address CVE-2021-44228 and CVE-2021-45046. Bulletin"
      },
      "id": "6045248b196a67f158960f1b"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/delete-document": [
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-25T17:36:34Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.9688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use content types <em>and</em> text formats",
        "sections": "Use content types <em>and</em> text formats",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " release notes. What&#x27;s New posts This format includes specific fields for product announcements. What&#x27;s New posts are created by PMM for larger announcements. They&#x27;re available in the docs site, but they&#x27;re also visible in the New Relic One UI. For more information, see What&#x27;s New <em>style</em> guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs <em>guide</em>."
      },
      "id": "61b35517196a677196a59e07"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "835ddacc0acae04e05c8c2ddc694799819a7d696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-12-25T17:05:55Z",
      "updated_at": "2021-11-26T05:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.96732,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. <em>Procedures</em> are the same for both standard docs (&quot;basic pages&quot;) and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change"
      },
      "id": "61b35af428ccbca9318c6b13"
    },
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "9ec2ccd8a8509ab1b54273206e84f9571164c4f9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-12-25T17:50:00Z",
      "updated_at": "2021-11-26T05:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.96597,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Procedures</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original <em>tech</em> <em>writer</em> or docs site contributor"
      },
      "id": "61b35af4e7b9d2769c5a38f9"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist": [
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-25T17:36:34Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.9688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use content types <em>and</em> text formats",
        "sections": "Use content types <em>and</em> text formats",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " release notes. What&#x27;s New posts This format includes specific fields for product announcements. What&#x27;s New posts are created by PMM for larger announcements. They&#x27;re available in the docs site, but they&#x27;re also visible in the New Relic One UI. For more information, see What&#x27;s New <em>style</em> guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs <em>guide</em>."
      },
      "id": "61b35517196a677196a59e07"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "835ddacc0acae04e05c8c2ddc694799819a7d696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-12-25T17:05:55Z",
      "updated_at": "2021-11-26T05:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.96732,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. <em>Procedures</em> are the same for both standard docs (&quot;basic pages&quot;) and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change"
      },
      "id": "61b35af428ccbca9318c6b13"
    },
    {
      "sections": [
        "Delete a document",
        "Caution"
      ],
      "title": "Delete a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "2cd80eef8b60c58847511bbd58fd38abdac22d75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/delete-document/",
      "published_at": "2021-12-25T17:50:46Z",
      "updated_at": "2021-11-26T05:12:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Caution When you delete a document, its content and its redirects will still be available in the GitHub commit history. In general, if you're not on the New Relic Docs team, please don't delete any docs. Instead, file an issue and someone on our team will help you out. If you are certain you want to delete a document, do this: Locate the mdx file of the doc you want to delete. Take care of redirects: Find the most relevant doc to redirect readers to. Add the deleted doc's URL as a redirect. Copy any existing redirects from the deleted doc and add them to the new doc. Delete the doc's title and path from the appropriate nav file. Delete the doc mdx file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.96536,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61ab47d9196a679242d10141"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/edit-homepage": [
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-25T17:36:34Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.0187,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Page</em> templates",
        "body": " is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. <em>Landing</em> <em>pages</em> This format is for a more user-friendly and readable <em>landing</em> <em>page</em>, which replaces the standard taxonomy"
      },
      "id": "61b35517196a677196a59e07"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/landing-page-template/",
      "sections": [
        "Landing page template",
        "Important",
        "Front matter",
        "Tip",
        "Introduction section",
        "Tiles",
        "Button for viewing all docs in the category",
        "Code sample"
      ],
      "published_at": "2021-12-25T17:33:37Z",
      "title": "Landing page template",
      "updated_at": "2021-11-26T05:11:08Z",
      "type": "docs",
      "external_id": "7f97d929091de18beb47bff4f6dff62e9676bbb5",
      "document_type": "page",
      "popularity": 1,
      "body": "Landing pages are a specialized type of page that serve as the starting pages for various New Relic products. For example, you'll see landing pages for Application monitoring (APM) and Browser monitoring. Important This landing page information does not apply to the docs home page. If you need to create a new landing page, you can either copy an existing landing page, or you can modify the sample landing page shown at the bottom. The next sections look at what you need to include for each landing page. Front matter When you insert the front matter, be sure to designate the type as landingPage. Here's an example: --- title: APM type: landingPage --- Copy Tip In the front matter, the following are optional: tags, translate, and redirects. So, you can leave them out if they don't have any values. Introduction section Following the front matter, the first content section is a two-column introduction (also called the hero section). This includes the following: A <LandingPageHero> component wrapping all the introductory content. A <HeroContent> component wrapping the text portion of the introduction (the content in the left column). An image or video (appears in the right column). A caption (optional), which is wrapped by the <figcaption> component. Here's an example of the hero section that shows you where to insert your content: <LandingPageHero> <HeroContent> INSERT_PARAGRAPHS_FOR_YOUR_INTRODUCTION </HeroContent> ![INSERT_ALT-TEXT_HERE](./images/INSERT_IMAGE_FILE_NAME.png \"INSERT_THE_IMAGE_TITLE_HERE\") <figcaption> INSERT_OPTIONAL_CAPTION_USING_SAME_INDENTATION_AS_IMAGE </figcaption> </LandingPageHero> Copy Tiles Tiles are a series of boxes after the introduction. They contain the main subject areas for your product. You should just list these in order you want them to appear, and the cascading style sheet will render them across the page. Here's an example of a tile: <LandingPageTileGrid> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE.\" href=\"/docs/INSERT_THE_DIRECTORY_PATH_TO_THE_TARGET_LANDING_PAGE_INDEX.HTML\" icon=\"fe-INSERT_THE_ICON_NAME\" > INSERT_TILE_CONTENT_HERE... </LandingPageTile> ... Copy For each tile, do the following: Insert a value for title that explains the purpose of the category. Insert a value for href that links to the target landing page. If the target landing page is index.html, you can just include the directory path with no filename since index.html is the default (it doesn't cause any problems if you include index.html). Insert a value for icon by prefixing the icon name with fe- (Feather icons), logo- (third-party logos), or nr- (New Relic logos). For example, here is the format for a feather icon: fe-alert-triangle). Tip For more details about icons, see Embed images. Between the LandingPageTile tags, insert text, such as a bullet list with links to product documentation. Button for viewing all docs in the category After your tiles, you should have a single button that offers to take users to all the documentation for that category. The table of contents page that gets linked here is always at the same path as the landing page, but with /table-of-contents appended to it. These table of contents pages get built automatically for every landing page. For example, if this landing page was located at /docs/apm, this link should be /docs/apm/table-of-contents. Here's an example: <ButtonLink role=\"button\" to=\"INSERT_LINK_TO_DIRECTORY_WITH_ALL_THESE_DOCS/table-of-contents\" variant=\"normal\" > View all INSERT_YOUR_CATEGORY_HERE docs </ButtonLink> Copy Code sample Here's a sample landing page you could modify to suit your needs: --- title: INSERT_YOUR_TITLE_HERE type: landingPage --- <LandingPageHero> <HeroContent> INSERT_PARAGRAPHS_FOR_YOUR_INTRODUCTION </HeroContent> ![INSERT_ALT-TEXT_HERE](./images/INSERT_IMAGE_FILE_NAME.png \"INSERT_THE_IMAGE_TITLE_HERE\") <figcaption> INSERT_OPTIONAL_CAPTION_USING_SAME_INDENTATION_AS_IMAGE </figcaption> </LandingPageHero> <LandingPageTileGrid> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * [INSERT_LINK_NAME](INSERT_LINK_URL) Aliquam auctor mattis nisl ut iaculis. * [INSERT_LINK_NAME](INSERT_LINK_URL) Suspendisse pharetra elit sit amet risus euismod, a consectetur tortor vulputate. </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) to lectus diam, ornare vitae dui suscipit, laoreet ultrices lacus. * Mauris tempor massa ac augue mattis, nec pharetra quam mollis [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) rhoncus tortor vitae libero laoreet feugiat. * Donec dui elit, fermentum vel faucibus sed, rhoncus in felis [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) uspendisse pharetra elit sit amet risus euismod. * Pellentesque finibus magna vitae hendrerit gravida [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) Etiam imperdiet felis eu ipsum consequat tristique. * Etiam imperdiet felis eu ipsum consequat tristique [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) Quisque hendrerit, dolor sed sodales aliquet. * Vestibulum varius lectus ac velit euismod [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> </LandingPageTileGrid> <ButtonLink role=\"button\" to=\"INSERT_LINK_TO_DIRECTORY_WITH_ALL_THESE_DOCS/table-of-contents\" variant=\"normal\" > View all INSERT_YOUR_CATEGORY_HERE docs </ButtonLink> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.96809,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Landing</em> <em>page</em> template",
        "sections": "<em>Landing</em> <em>page</em> template",
        "body": "<em>Landing</em> <em>pages</em> are a specialized type of <em>page</em> that serve as the starting <em>pages</em> for various New Relic products. For example, you&#x27;ll see <em>landing</em> <em>pages</em> for Application monitoring (APM) and Browser monitoring. Important This <em>landing</em> <em>page</em> information does not apply to the docs <em>home</em> <em>page</em>. If you need"
      },
      "id": "61ab487d28ccbcd127c24e10"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/create-release-notes/",
      "sections": [
        "Create release notes",
        "New release note",
        "What makes a great release note?",
        "New release notes category",
        "Category landing page",
        "Landing page",
        "Links from other categories"
      ],
      "published_at": "2021-12-25T17:50:00Z",
      "title": "Create release notes",
      "updated_at": "2021-11-26T05:11:39Z",
      "type": "docs",
      "external_id": "ed8f28b2ba2020f4e61fd1499c5bc9c97472857b",
      "document_type": "page",
      "popularity": 1,
      "body": "This page is for release notes for downloadable software. For product announcements, see What's new style guidelines. New release note To add a release note to the docs site: Find the most recent release note for your agent, and make a copy of it in the same folder. When you rename your copy, avoid potential version naming conflicts by using a - separator in your file name. For example, instead of agent-123, use agent-1-2-3 for version 1.2.3 and agent-12-3 for version 12.3. Fill in the subject, releaseDate, and version. If applicable, include the downloadLink field. Using our standard headings for New features, Improvements, and Bug fixes, add enough summary information in these sections to make a great release note. Link to docs or other resources where they can learn more. Commit your changes and submit a pull request. If your release is date-sensitive, make a note in your PR. A Tech Docs hero will review your release note content and approve your PR to get it published. You can also request others on your team to review your PR. We build and deploy the docs site a few times a day, and sometimes builds can take a few hours to complete. If your release is time-sensitive, ensure you've planned for enough time to get your docs live. What makes a great release note? Great release notes help users quickly become familiar with your important update, so they know why it matters. Great release notes also help our support and security teams. By encouraging users to keep current with your latest release, this reduces support time to solve problems on outdated versions. It also mitigates risks if any potential vulnerabilities have been resolved with your latest version. To write a great release note, be as specific as possible. For example: Briefly describe new functionality. Give an example of the value it provides, and link to more detailed information. Don't use vague wording such as \"various bug fixes.\" Instead, clearly state what has been improved, so readers will know if an issue they’ve experienced has been resolved. New release notes category This information is primarily for the Tech Docs team's use. To add a new release notes category, update the following areas of the docs site. (You do not need to update the releaseNote.js or releaseNoteLandingPage.js files in the nav/templates folder.) Before you submit your pull request to the GitHub docs site, check that the landing pages and placeholder release note build correctly in your localhost. Category landing page In /src/content/docs/release-notes, add the following: A folder for your new release notes category. The RSS feed link, page format, and date order for release notes listed on this page are generated automatically. For example, see the C SDK category landing page format. An index.mdx file in your new folder containing the subject. The subject is the name that will appear on the Release notes landing page. A placeholder release note in this folder for the agent team to fill out. If used, the downloadLink field in the release note will be formatted automatically in the published release note. Before the new category goes live, check with the team's Product Marketing Management (PMM) rep whether they want to include the link in an upcoming What's new post. Landing page In /src/content/docs/release-notes/index.mdx, add a new tile section in alphabetical order for your release notes category. Example: <TechTile name=\"Logs\" icon=\"logo-newrelic\" to=\"/docs/release-notes/logs-release-notes\" /> Copy Logos come from @newrelic/gatsby-theme-newrelic/icons/logo/. If a logo does not already exist for the new agent, use the standard logo-newrelic icon or an image in @newrelic/gatsby-theme-newrelic/icons/feathers.js. If you need other options, talk to the team's designer. Links from other categories Add a link to your new release notes category in the agent's documentation, typically in its Get started category. For more information, see our documentation about docs in multiple menus. Optional: Add a link in the agent's landing page text by updating the index.mdx file in its taxonomy.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 55.017838,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Category <em>landing</em> <em>page</em>",
        "body": " that the <em>landing</em> <em>pages</em> and placeholder release note build correctly in your localhost. Category <em>landing</em> <em>page</em> In &#x2F;src&#x2F;content&#x2F;docs&#x2F;release-notes, add the following: A folder for your new release notes category. The RSS feed link, <em>page</em> format, and date order for release notes listed on this <em>page</em>"
      },
      "id": "61ab4941e7b9d25eae0e8af0"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document": [
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-25T17:36:34Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.9688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use content types <em>and</em> text formats",
        "sections": "Use content types <em>and</em> text formats",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " release notes. What&#x27;s New posts This format includes specific fields for product announcements. What&#x27;s New posts are created by PMM for larger announcements. They&#x27;re available in the docs site, but they&#x27;re also visible in the New Relic One UI. For more information, see What&#x27;s New <em>style</em> guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs <em>guide</em>."
      },
      "id": "61b35517196a677196a59e07"
    },
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "9ec2ccd8a8509ab1b54273206e84f9571164c4f9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-12-25T17:50:00Z",
      "updated_at": "2021-11-26T05:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.96594,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Procedures</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original <em>tech</em> <em>writer</em> or docs site contributor"
      },
      "id": "61b35af4e7b9d2769c5a38f9"
    },
    {
      "sections": [
        "Delete a document",
        "Caution"
      ],
      "title": "Delete a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "2cd80eef8b60c58847511bbd58fd38abdac22d75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/delete-document/",
      "published_at": "2021-12-25T17:50:46Z",
      "updated_at": "2021-11-26T05:12:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Caution When you delete a document, its content and its redirects will still be available in the GitHub commit history. In general, if you're not on the New Relic Docs team, please don't delete any docs. Instead, file an issue and someone on our team will help you out. If you are certain you want to delete a document, do this: Locate the mdx file of the doc you want to delete. Take care of redirects: Find the most relevant doc to redirect readers to. Add the deleted doc's URL as a redirect. Copy any existing redirects from the deleted doc and add them to the new doc. Delete the doc's title and path from the appropriate nav file. Delete the doc mdx file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.96536,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61ab47d9196a679242d10141"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/understand-edit-docs-site-structure": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/writer-workflow/github-history/",
      "sections": [
        "GitHub history and deleted files",
        "Check the edit history of a doc or file",
        "Docs site history before October 2021",
        "How to find deleted files",
        "Finding the deletion PR",
        "Search through release PRs",
        "Use git log"
      ],
      "published_at": "2021-12-25T17:36:34Z",
      "title": "GitHub history and deleted files",
      "updated_at": "2021-12-19T04:32:24Z",
      "type": "docs",
      "external_id": "d9eb61c221f5fec6251786c5a927f6326b399963",
      "document_type": "page",
      "popularity": 1,
      "body": "GitHub's version control features allow us to see the complete history of a doc, access a doc at any point in time, and find deleted docs without manual backups. Check the edit history of a doc or file Use any of these options to check or \"diff\" the history of a file. Option 1: GitHub history tab Navigate to the doc on the doc site and click Edit page in the right nav. Click History in the top right corner of the doc. Option 2: githistory.xy Navigate to your specific file on GitHub.com: https://github.com/newrelic/docs-website/blob/develop/src/content/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action.mdx Copy In the url, replace github.com with github.githistory.xyz: https://github.githistory.xyz/newrelic/docs-website/blob/develop/src/content/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action.mdx Copy It will take you to a site which presents the visual history of that specific file. You can view changes by clicking through the commit history at the top of your page. Option 3: Git blame Follow GitHub's documentation. Alternatively, you can use the following command in your terminal: git log --follow \"**/file_name_here.mdx\" Copy This will output the commit history of that file. By default, it only shows the first few commits. You can scroll by pressing Return multiple times. For example, to find the commit history for vmware-vsphere-monitoring-integration.mdx, I would run: git log --follow \"**/vmware-vsphere-monitoring-integration.mdx\" Copy Docs site history before October 2021 We had a large site restructure in October 2021 which lost most of the file history for our docs. You can find an archived version of our site pre-rework in the pre-IA-2021 branch. By navigating the pre-rework version of our repo, you can find file history and more. How to find deleted files There are multiple ways to find deleted files. These are roughly ordered by complexity: Finding the deletion PR The easiest way to find a deleted file is to find the pull request that deleted it. There are multiple ways to accomplish this; here are some ideas: Use GitHub's search feature to search for relevant keywords. You can filter search results to only include PRs. If you have a rough idea of when the doc was deleted, you could try finding the pull request in the pull request tab. This list has thousands of PRs, so this may take some time. Lots of docs are deleted because of a Jira ticket. Search Jira for the ticket, where you will find the rough time the doc was deleted and hopefully a link to the PR itself. Ask in #doc_talk! Search through release PRs By searching through release PRs, you can eventually find a branch created before the doc was deleted. You can find a list of release PRs in the GitHub PR tab. A few tips: Search by intervals of a month first. Once you find a branch that contains the doc, you can scope down to a week and then to a day. By decreasing the scope, you will eventually find the deleted doc in it's exact state before deletion. To access the branch a PR comes from, go to that pull request's page and click on the branch name underneath the title and PR number. Use git log The most powerful and realiable way to find deleted files is to use git log. See stackoverflow for more details.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.53766,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "GitHub history <em>and</em> deleted <em>files</em>",
        "sections": "Check the <em>edit</em> history of a <em>doc</em> or <em>file</em>",
        "body": " Navigate to the <em>doc</em> on the <em>doc</em> <em>site</em> and click <em>Edit</em> page in the right <em>nav</em>. Click History in the top right corner of the <em>doc</em>. Option 2: githistory.xy Navigate to your specific <em>file</em> on GitHub.com: https:&#x2F;&#x2F;github.com&#x2F;newrelic&#x2F;<em>docs</em>-website&#x2F;blob&#x2F;develop&#x2F;src&#x2F;content&#x2F;<em>docs</em>&#x2F;browser&#x2F;new-relic-browser&#x2F;browser"
      },
      "id": "61beb5d864441f378699fc79"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "835ddacc0acae04e05c8c2ddc694799819a7d696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-12-25T17:05:55Z",
      "updated_at": "2021-11-26T05:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.9863,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Rename or redirect a <em>document</em>",
        "sections": "Rename or redirect a <em>document</em>",
        "tags": "Processes <em>and</em> procedures",
        "body": " a document title, change the title being used in the title field in the frontmatter at the top of the <em>doc</em>. If you want to update a title in the <em>sidebar</em>, change the title for that <em>doc</em> in the <em>nav</em> <em>file</em>. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser"
      },
      "id": "61b35af428ccbca9318c6b13"
    },
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-25T17:36:34Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.59354,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use content types <em>and</em> text formats",
        "sections": "<em>Docs</em> meta content (frontmatter)",
        "tags": "Processes <em>and</em> procedures",
        "body": " not capitalize any other word in the title unless it&#x27;s a proper noun, such as a specific product name, or it follows a colon (:). If you&#x27;re looking for ideas on how to choose a title, browse the titles of similar <em>docs</em>. The title used in the <em>sidebar</em> (left navigation pane) is set in the <em>nav</em> <em>file</em>. type"
      },
      "id": "61b35517196a677196a59e07"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats": [
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "835ddacc0acae04e05c8c2ddc694799819a7d696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-12-25T17:05:55Z",
      "updated_at": "2021-11-26T05:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.9673,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. <em>Procedures</em> are the same for both standard docs (&quot;basic pages&quot;) and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change"
      },
      "id": "61b35af428ccbca9318c6b13"
    },
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "9ec2ccd8a8509ab1b54273206e84f9571164c4f9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-12-25T17:50:00Z",
      "updated_at": "2021-11-26T05:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.96594,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Procedures</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original <em>tech</em> <em>writer</em> or docs site contributor"
      },
      "id": "61b35af4e7b9d2769c5a38f9"
    },
    {
      "sections": [
        "Delete a document",
        "Caution"
      ],
      "title": "Delete a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "2cd80eef8b60c58847511bbd58fd38abdac22d75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/delete-document/",
      "published_at": "2021-12-25T17:50:46Z",
      "updated_at": "2021-11-26T05:12:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Caution When you delete a document, its content and its redirects will still be available in the GitHub commit history. In general, if you're not on the New Relic Docs team, please don't delete any docs. Instead, file an issue and someone on our team will help you out. If you are certain you want to delete a document, do this: Locate the mdx file of the doc you want to delete. Take care of redirects: Find the most relevant doc to redirect readers to. Add the deleted doc's URL as a redirect. Copy any existing redirects from the deleted doc and add them to the new doc. Delete the doc's title and path from the appropriate nav file. Delete the doc mdx file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 260.96533,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61ab47d9196a679242d10141"
    }
  ],
  "/docs/style-guide/writing-docs/writer-workflow/github-history": [
    {
      "sections": [
        "Delete a document",
        "Caution"
      ],
      "title": "Delete a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "2cd80eef8b60c58847511bbd58fd38abdac22d75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/delete-document/",
      "published_at": "2021-12-25T17:50:46Z",
      "updated_at": "2021-11-26T05:12:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Caution When you delete a document, its content and its redirects will still be available in the GitHub commit history. In general, if you're not on the New Relic Docs team, please don't delete any docs. Instead, file an issue and someone on our team will help you out. If you are certain you want to delete a document, do this: Locate the mdx file of the doc you want to delete. Take care of redirects: Find the most relevant doc to redirect readers to. Add the deleted doc's URL as a redirect. Copy any existing redirects from the deleted doc and add them to the new doc. Delete the doc's title and path from the appropriate nav file. Delete the doc mdx file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.15668,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Delete</em> a document",
        "sections": "<em>Delete</em> a document",
        "tags": "Processes <em>and</em> procedures",
        "body": "Caution When you delete a document, its content and its redirects will still be available in the <em>GitHub</em> commit <em>history</em>. In general, if you&#x27;re not on the New Relic Docs team, please don&#x27;t delete any docs. Instead, <em>file</em> an issue and someone on our team will help you out. If you are certain you want"
      },
      "id": "61ab47d9196a679242d10141"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/writer-workflow/github-intro/",
      "sections": [
        "Get around GitHub",
        "Who is who in an issue/PR?",
        "Track issues in the board",
        "Deal with references in GitHub (and the style guide)",
        "Merge releases into main work (or, when do we publish?)",
        "GitHub labels"
      ],
      "published_at": "2021-12-25T17:33:47Z",
      "title": "Get around GitHub",
      "updated_at": "2021-12-20T04:59:44Z",
      "type": "docs",
      "external_id": "539ae5620ae9be8f8c3752fd3eda664186fbb5c4",
      "document_type": "page",
      "popularity": 1,
      "body": "As tech doc writers (TW) we edit docs, do peer edits, or use the Docs Team GitHub board to track the status of issues and pull requests (PR). Who is who in an issue/PR? GitHub keeps track of all activity concerning an issue or PR, including, of course, the people involved. When a new issue or PR is filed, check on the filer’s username and see if they're listed as a member of the New Relic organization. If they aren't, try to find them on Slack based on their username. If you're not sure about someone's affiliation, treat them as external until you know otherwise. People in an issue/PR include: Creator: The person who opened the issue or PR. This could be a writer, a Relic, or an external user. We'll label the issue or PR differently depending on who created it. If you're not sure if a user is a Relic, a good trick is to click on their profile and see if they're a member of the New Relic GitHub org. Assignee: The person taking responsibility for a PR or issue. This will usually be used by the Hero or Sidekick to assign non-TW PRs and issues to themselves. It can also be used to take a TW’s PR or issue over from them. Reviewer: The person who reviews or peer edits the code/document and approves the changes. Not necessarily the person responsible for that area or responsible for merging the commit. You can pre-assign up to 100 reviewers to a given issue. Track issues in the board The docs board has the following columns: Column Description Needs triage The Hero or Sidekick review and label issues and PRs in this column, then drag them to the appropriate column. If a PR or issue is labeled eng, the Hero/Sidekick can go ahead and click its ellipses icon to archive it. Hero: to do PRs that the Hero needs to review, publish, and follow up with SMEs as needed. Hero: Assign yourself as Assignee. In review (Hero or any TW) Drag PRs to this column when they are being reviewed. This shows who is reviewing and what is being reviewed, so two writers don’t mistakenly work on the same PR. Any TW: Writer needs PR review PRs from Tech Docs team members that need a light edit pass to make sure everything in GitHub is correct. This should be checked by other writers every few hours so PRs don’t get stale. If you have a PR that’s been lingering here too long, ask for a reviewer in #doc_sprint_talk. Whoever takes it: assign yourself as Reviewer. Any TW: needs peer edit Like our Needs Peer Edit column in Jira: A writer has requested a review of their PR. Review their PR in GitHub and leave comments. Whoever takes it: assign yourself as Reviewer. Waiting on SME/Blocked For PRs that are blocked by need for SME info or confirmation (for example, as Hero you are waiting on an answer from the person who sent in a Hero pull request). Waiting on TW to merge All reviews are complete. The TW who created the PR (or who is assigned the issue) needs to merge this work into develop. Drafts A draft is a way to open a PR while indicating that the work is still in progress and not necessarily ready to merge immediately. You can't merge a Draft PR directly. Instead, you must move it out of draft status first. When you see a draft PR (especially from outside the team!), treat it as though it's a working draft, and reach out to the creator to discuss. Read more on GitHub's drafts. As a Hero, make sure you attend to the following throughout your day: Check in with the previous Hero at the start of your day (especially on Monday at the start of the week). Don’t forget to sync with the BCN Hero if necessary. Watch for incoming PRs in #docs_deploys, and review everything in the Needs triage column. Drag cards from that column to the appropriate column. Work through the cards in the Hero: to do column. Everyone on the team helps keep things moving: All writers should keep an eye on both Any TW columns. There's one column for PRs that need a simpler review before merging (typo fixes, drive-by edits, etc), and another column for PRs that need a peer edit. There are also two blocked columns: One for PRs blocked on a SME, and another column where we're waiting on the TW who created the PR to review feedback and/or merge. After merging, remove your ticket from the board. Deal with references in GitHub (and the style guide) Don't link to anything non-public from a public place. You can reference Jira tickets, but reference tickets by issue key (DOC-1234 is ok) rather than a link (https://newrelic.atlassian.net/browse/DOC-1234 is not). Don't mention traffic or usage numbers publicly. Don't reference internal people by name. If they have a GH account, @mention their GH handle. If they don't, talk instead about teams (\"talk to a browser team engineer\" or \"Support Engineer\") rather than people. You can mention the #documentation channel and hero. Merge releases into main work (or, when do we publish?) The Hero currently merges three times a day: At 9 AM (morning), 12 PM (noon), and 3 PM (evening) Pacific. We merge release branches into main to avoid interuptions when someone merges into develop during a release. To learn more about this workflow, see the gitflow documentation in Atlassian. To start a release: Create a branch based off develop Github Desktop by clicking Current Branch in the top header, clicking New Branch in the dropdown, and then selecting Develop. Name the branch following this pattern: daily-release/mm-dd-yy-morning/noon/evening. Here's an example: daily-release/10-27-21-morning. Push your changes by clicking Push Origin in GitHub Desktop. Create a pull request into main from your new daily release branch by clicking Create Pull Request. This will open a pull request screen on github.com. Pull requests default to merging into develop, so select main as the base branch in the left side of the page and then click Submit Pull Request. Wait until all the checks complete, and then merge the pull request. All branches that follow the daily-release/mm-dd-yy-morning pattern are protected branches. This means the branches can't be deleted or pushed to by non-admins. GitHub labels Every issue needs labels to help us triage and track the health of our backlog: content: Always add, this indicates the issue is content-related rather than a design or engineering issue. pg_*: Always add to indicate the product group. For full definitions, see the \"Doc Jira and GitHub fields\" doc in the internal team Google Drive. Indicate who created the issue: from_internal: A Relic created it. from_external: A user opened it in the repo OR it came in through #customer-feedback process. from_tw: One of us created it (unless we were passing along #customer-feedback). Optionally: docs-issues-migrate: Issues that are too large in scope for the docs team to handle without product team expertise. This label alerts the docs issues team to migrate these issues into the customer feedback channel where they will be triaged and sent to product teams. Jira’d: Issues that have a corresponding Jira ticket. Make sure you leave the Jira number in the comments of the issue (for example, DOC-1234). Every pull request needs these labels so we can see where our contributions come from: content: Always add, this indicates the PR is content-related rather than design or engineering. Indicate who created the pull request: from_internal: A Relic created it. from_external: A user opened it in the repo OR it came in through #customer-feedback process. from_tw: One of us created it (unless we were passing along #customer-feedback). If the PR fixes an external issue, label it as from_tw since the work was done by a tech writer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 197.65659,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get around <em>GitHub</em>",
        "sections": "Deal with references in <em>GitHub</em> (<em>and</em> the style guide)",
        "body": " be <em>deleted</em> or pushed to by non-admins. <em>GitHub</em> labels Every issue needs labels to help us triage and track the health of our backlog: content: Always add, this indicates the issue is content-related rather than a design or engineering issue. pg_*: Always add to indicate the product group. For full"
      },
      "id": "61ab4782196a672667d0efa1"
    },
    {
      "sections": [
        "SNMP device profiles",
        "Get started",
        "Tip",
        "Make requests through GitHub",
        "Contribute profiles and modifications publicly",
        "What kinds of OIDs should I actually include in a profile?",
        "Use custom profiles privately"
      ],
      "title": "SNMP device profiles",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "9b38a960070da5782cfd75e087db62f15fb71223",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/snmp-profiles/",
      "published_at": "2021-12-25T06:01:06Z",
      "updated_at": "2021-12-15T00:37:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Profiles define what SNMP OIDs we want to collect and send to your New Relic account. This document explains how to modify an existing profile or create a new profile. Get started If you've decided to build a custom profile or modify one of our open source profiles, you need a few essential tools: A GitHub account: This enables you to raise issues and contribute changes to Kentik's open source profiles. An SNMP walk from a network device where you want to work on a profile. For more information, see our documentation on setting up SNMP and using snmpwalk. Permissions to perform Docker pull on the server that hosts your ktranslate container. This document covers: Making requests for new or modified profiles through GitHub to be worked on by the maintainers Contributing your own profiles and modifications publicly Using custom profiles privately Tip Support for all things relating to kentik/snmp-profiles is handled through GitHub issues. New Relic technical support is not able to provide any additional help beyond redirecting you back to raise an issue there. Make requests through GitHub This is the most common and simple scenario, for cases where you don't have the time or expertise with SNMP to do these yourself. After you provide the relevant data, our team will build the profile for you. Log into GitHub and go to the snmp-profiles repo. Click the Issues tab near the top. Click New issue. To request a new profile, look for the SNMP Profile Request section, and click Get started. Provide all requested information in the template, such as the device vendor, model, snmp object identifier, and a sanitized SNMP walk. For all other requests, use Open a blank issue. Tip Providing an SNMP walk is critical as we cannot do any work on the profile without these. This is not the same as an MIB file. The maintainers of the repo will review the information you provided and, if there is anything missing, they will follow up with you. Once all the necessary data is provided, they will add it to the queue of profiles to be built. After it is added to the repo, the issue will be closed, and all you have to do is update the ktranslate docker container on your end, and the newest profiles will automatically be loaded. Contribute profiles and modifications publicly We gladly accept contributions from anyone who wants to help out to either create new profiles or improve the existing profiles. To familiarize yourself with the structure of a profile, review this highly commented template.yml on GitHub. Log into GitHub and go to the snmp-profiles repo. To create a copy of the same information in your account, click the fork button near the top. Within your fork,make necessary changes to the files, or create new vendor directories and profiles as needed. Be sure to pass your profile through a YAML validator, such as codebeautify, before submitting a pull request. When you are done with your changes, submit a pull request to the upstream repo. The maintainers will review the change, and discuss any necessary feedback. When everyone is aligned, it will be merged. Shortly after a merge, new SNMP profiles are automatically available by pulling the new version of the Docker image and launching a new container in your environment. For more information, see our documentation about SNMP manual setup. Tip Be sure to sync your fork regularly to keep it up to date with changes in the upstream repo. What kinds of OIDs should I actually include in a profile? In many cases SNMP offers a lot of data, but much of that data does not provide actionable information. Or, the data provides value that is so uncommon and low impact, it might not be worth bringing into your New Relic account. You want to focus on collecting data that lets you know if there is anything that would stop the device from being able to perform whatever functions you expect it to perform. Building on from that, you should collect measurements that tell you how well it is performing those functions. Example 1: For a device operating as a VPN concentrator, we would collect high-level system metrics like: CPU and memory utilization Hardware sensor information to make sure that the device isn't going to shut itself down due to things like fan failures OIDs that tell us about the aggregated connections and throughput Example 2: An example of data that is available but provides very poor value is an OID table that lists all the running processes on a network appliance. Coming from a server admin perspective, that might sound useful, but since this is an appliance, you normally do not have the capability or the need to do anything with the processes that run inside it. Polling and storing tables with hundreds of items that you can't actually do anything with would not be efficient. Use custom profiles privately For cases where you want to make a change to a profile, but you know that it is a scenario that is very unique and would not apply to other customers you can locally edit the profiles. The way this is done is by using Docker's volume mount to pass in your customized files to the ktranslate container inside the etc/ktranslate/profiles/ directory. There are other ways you could accomplish this but in this example we will demonstrate using a git fork and clone. Ensure you are in the directory you want to keep the files in, then clone your fork of the GitHub repo to your Docker host: git clone https://github.com/<YourGitUser>/snmp-profiles.git Copy Get the command you would normally use to launch the SNMP container, and add a second volume mount argument after the one where we passed in the snmp-base.yaml. -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ Copy The mount command replaces the built-in profiles directory with your customized data. The end result will be be similar to this: docker run -ti --name ktranslate-discovery --rm --net=host \\ --user `id -u`:`id -g` \\ -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ kentik/ktranslate:v2 \\ -snmp /snmp-base.yaml \\ -log_level info \\ -snmp_discovery=true Copy Tip Be sure to pass your custom version of the profiles in every time you launch a discovery container or SNMP polling container. If you don't use it consistently for all SNMP instances sets, this can cause unreliable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.96942,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Make requests through <em>GitHub</em>",
        "body": " to the ktranslate container inside the etc&#x2F;ktranslate&#x2F;profiles&#x2F; directory. There are other ways you could accomplish this but in this example we will demonstrate using a <em>git</em> fork and clone. Ensure you are in the directory you want to keep the <em>files</em> in, then clone your fork of the <em>GitHub</em> repo to your"
      },
      "id": "61b33254196a67414ea5c67b"
    }
  ],
  "/docs/style-guide/writing-docs/writer-workflow/github-intro": [
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "d883a07b7ede4c3beaba4077c507b95f9a228435",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-12-25T05:42:59Z",
      "updated_at": "2021-12-19T14:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our primary data ingest APIs: the Metric API, Trace API, Log API, and Event API. If our pre-built solutions don't meet your needs, our Telemetry SDKs are one way to create a custom telemetry solution (see other solutions for reporting custom data). Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.42836,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on <em>GitHub</em>. Use the language-specific <em>GitHub</em> links below to <em>get</em> library details, coding examples, and procedures for how to use"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/writer-workflow/github-history/",
      "sections": [
        "GitHub history and deleted files",
        "Check the edit history of a doc or file",
        "Docs site history before October 2021",
        "How to find deleted files",
        "Finding the deletion PR",
        "Search through release PRs",
        "Use git log"
      ],
      "published_at": "2021-12-25T17:36:34Z",
      "title": "GitHub history and deleted files",
      "updated_at": "2021-12-19T04:32:24Z",
      "type": "docs",
      "external_id": "d9eb61c221f5fec6251786c5a927f6326b399963",
      "document_type": "page",
      "popularity": 1,
      "body": "GitHub's version control features allow us to see the complete history of a doc, access a doc at any point in time, and find deleted docs without manual backups. Check the edit history of a doc or file Use any of these options to check or \"diff\" the history of a file. Option 1: GitHub history tab Navigate to the doc on the doc site and click Edit page in the right nav. Click History in the top right corner of the doc. Option 2: githistory.xy Navigate to your specific file on GitHub.com: https://github.com/newrelic/docs-website/blob/develop/src/content/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action.mdx Copy In the url, replace github.com with github.githistory.xyz: https://github.githistory.xyz/newrelic/docs-website/blob/develop/src/content/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action.mdx Copy It will take you to a site which presents the visual history of that specific file. You can view changes by clicking through the commit history at the top of your page. Option 3: Git blame Follow GitHub's documentation. Alternatively, you can use the following command in your terminal: git log --follow \"**/file_name_here.mdx\" Copy This will output the commit history of that file. By default, it only shows the first few commits. You can scroll by pressing Return multiple times. For example, to find the commit history for vmware-vsphere-monitoring-integration.mdx, I would run: git log --follow \"**/vmware-vsphere-monitoring-integration.mdx\" Copy Docs site history before October 2021 We had a large site restructure in October 2021 which lost most of the file history for our docs. You can find an archived version of our site pre-rework in the pre-IA-2021 branch. By navigating the pre-rework version of our repo, you can find file history and more. How to find deleted files There are multiple ways to find deleted files. These are roughly ordered by complexity: Finding the deletion PR The easiest way to find a deleted file is to find the pull request that deleted it. There are multiple ways to accomplish this; here are some ideas: Use GitHub's search feature to search for relevant keywords. You can filter search results to only include PRs. If you have a rough idea of when the doc was deleted, you could try finding the pull request in the pull request tab. This list has thousands of PRs, so this may take some time. Lots of docs are deleted because of a Jira ticket. Search Jira for the ticket, where you will find the rough time the doc was deleted and hopefully a link to the PR itself. Ask in #doc_talk! Search through release PRs By searching through release PRs, you can eventually find a branch created before the doc was deleted. You can find a list of release PRs in the GitHub PR tab. A few tips: Search by intervals of a month first. Once you find a branch that contains the doc, you can scope down to a week and then to a day. By decreasing the scope, you will eventually find the deleted doc in it's exact state before deletion. To access the branch a PR comes from, go to that pull request's page and click on the branch name underneath the title and PR number. Use git log The most powerful and realiable way to find deleted files is to use git log. See stackoverflow for more details.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.08832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>GitHub</em> history and deleted files",
        "sections": "<em>GitHub</em> history and deleted files",
        "body": "<em>GitHub</em>&#x27;s version control features allow us to see the complete history of a doc, access a doc at any point in time, and find deleted docs without manual backups. Check the edit history of a doc or file Use any of these options to check or &quot;diff&quot; the history of a file. Option 1: <em>GitHub</em> history tab"
      },
      "id": "61beb5d864441f378699fc79"
    },
    {
      "sections": [
        "SNMP device profiles",
        "Get started",
        "Tip",
        "Make requests through GitHub",
        "Contribute profiles and modifications publicly",
        "What kinds of OIDs should I actually include in a profile?",
        "Use custom profiles privately"
      ],
      "title": "SNMP device profiles",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "9b38a960070da5782cfd75e087db62f15fb71223",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/advanced/snmp-profiles/",
      "published_at": "2021-12-25T06:01:06Z",
      "updated_at": "2021-12-15T00:37:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Profiles define what SNMP OIDs we want to collect and send to your New Relic account. This document explains how to modify an existing profile or create a new profile. Get started If you've decided to build a custom profile or modify one of our open source profiles, you need a few essential tools: A GitHub account: This enables you to raise issues and contribute changes to Kentik's open source profiles. An SNMP walk from a network device where you want to work on a profile. For more information, see our documentation on setting up SNMP and using snmpwalk. Permissions to perform Docker pull on the server that hosts your ktranslate container. This document covers: Making requests for new or modified profiles through GitHub to be worked on by the maintainers Contributing your own profiles and modifications publicly Using custom profiles privately Tip Support for all things relating to kentik/snmp-profiles is handled through GitHub issues. New Relic technical support is not able to provide any additional help beyond redirecting you back to raise an issue there. Make requests through GitHub This is the most common and simple scenario, for cases where you don't have the time or expertise with SNMP to do these yourself. After you provide the relevant data, our team will build the profile for you. Log into GitHub and go to the snmp-profiles repo. Click the Issues tab near the top. Click New issue. To request a new profile, look for the SNMP Profile Request section, and click Get started. Provide all requested information in the template, such as the device vendor, model, snmp object identifier, and a sanitized SNMP walk. For all other requests, use Open a blank issue. Tip Providing an SNMP walk is critical as we cannot do any work on the profile without these. This is not the same as an MIB file. The maintainers of the repo will review the information you provided and, if there is anything missing, they will follow up with you. Once all the necessary data is provided, they will add it to the queue of profiles to be built. After it is added to the repo, the issue will be closed, and all you have to do is update the ktranslate docker container on your end, and the newest profiles will automatically be loaded. Contribute profiles and modifications publicly We gladly accept contributions from anyone who wants to help out to either create new profiles or improve the existing profiles. To familiarize yourself with the structure of a profile, review this highly commented template.yml on GitHub. Log into GitHub and go to the snmp-profiles repo. To create a copy of the same information in your account, click the fork button near the top. Within your fork,make necessary changes to the files, or create new vendor directories and profiles as needed. Be sure to pass your profile through a YAML validator, such as codebeautify, before submitting a pull request. When you are done with your changes, submit a pull request to the upstream repo. The maintainers will review the change, and discuss any necessary feedback. When everyone is aligned, it will be merged. Shortly after a merge, new SNMP profiles are automatically available by pulling the new version of the Docker image and launching a new container in your environment. For more information, see our documentation about SNMP manual setup. Tip Be sure to sync your fork regularly to keep it up to date with changes in the upstream repo. What kinds of OIDs should I actually include in a profile? In many cases SNMP offers a lot of data, but much of that data does not provide actionable information. Or, the data provides value that is so uncommon and low impact, it might not be worth bringing into your New Relic account. You want to focus on collecting data that lets you know if there is anything that would stop the device from being able to perform whatever functions you expect it to perform. Building on from that, you should collect measurements that tell you how well it is performing those functions. Example 1: For a device operating as a VPN concentrator, we would collect high-level system metrics like: CPU and memory utilization Hardware sensor information to make sure that the device isn't going to shut itself down due to things like fan failures OIDs that tell us about the aggregated connections and throughput Example 2: An example of data that is available but provides very poor value is an OID table that lists all the running processes on a network appliance. Coming from a server admin perspective, that might sound useful, but since this is an appliance, you normally do not have the capability or the need to do anything with the processes that run inside it. Polling and storing tables with hundreds of items that you can't actually do anything with would not be efficient. Use custom profiles privately For cases where you want to make a change to a profile, but you know that it is a scenario that is very unique and would not apply to other customers you can locally edit the profiles. The way this is done is by using Docker's volume mount to pass in your customized files to the ktranslate container inside the etc/ktranslate/profiles/ directory. There are other ways you could accomplish this but in this example we will demonstrate using a git fork and clone. Ensure you are in the directory you want to keep the files in, then clone your fork of the GitHub repo to your Docker host: git clone https://github.com/<YourGitUser>/snmp-profiles.git Copy Get the command you would normally use to launch the SNMP container, and add a second volume mount argument after the one where we passed in the snmp-base.yaml. -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ Copy The mount command replaces the built-in profiles directory with your customized data. The end result will be be similar to this: docker run -ti --name ktranslate-discovery --rm --net=host \\ --user `id -u`:`id -g` \\ -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ kentik/ktranslate:v2 \\ -snmp /snmp-base.yaml \\ -log_level info \\ -snmp_discovery=true Copy Tip Be sure to pass your custom version of the profiles in every time you launch a discovery container or SNMP polling container. If you don't use it consistently for all SNMP instances sets, this can cause unreliable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.85934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Make requests through <em>GitHub</em>",
        "body": " or expertise with SNMP to do these yourself. After you provide the relevant data, our team will build the profile for you. Log into <em>GitHub</em> and go to the snmp-profiles repo. Click the Issues tab near the top. Click New issue. To request a new profile, look for the SNMP Profile Request section, and click <em>Get</em>"
      },
      "id": "61b33254196a67414ea5c67b"
    }
  ],
  "/docs/style-guide/writing-docs/writer-workflow/github-troubleshooting": [
    {
      "sections": [
        "Diagnostics CLI (nrdiag)",
        "Compatibility",
        "Get started"
      ],
      "title": "Diagnostics CLI (nrdiag)",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Diagnostics CLI (nrdiag)"
      ],
      "external_id": "a49c65c83dc0ad7450935af104e8fcb0d7490e2c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/solve-common-issues/diagnostics-cli-nrdiag/diagnostics-cli-nrdiag/",
      "published_at": "2021-12-25T10:55:10Z",
      "updated_at": "2021-12-14T04:11:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Download latest version The Diagnostics CLI (nrdiag) is a utility that automatically detects common problems with New Relic products. If the Diagnostics CLI detects a problem, it suggests troubleshooting steps. The Diagnostics CLI can automatically upload troubleshooting data to a New Relic account. The Diagnostics CLI is open source and is located in GitHub. For additional troubleshooting steps for your agent, check out Not seeing data. Here's an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped troubleshooting logs that are ready to be attached to support tickets. Compatibility The Diagnostics CLI is available for Linux, macOS, and Windows. It can detect common configuration issues for: APM: Available for all APM agents except C SDK. For the Go agent, only basic connectivity checks are available. Browser monitoring: Browser agent detection Infrastructure monitoring: Linux and Windows agents Mobile agents: iOS and Android Synthetic monitoring: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those permissions for some checks. It will return an error if it does not have permissions to read the files it scans. Get started To use the Diagnostics CLI: Run the Diagnostics CLI, including task suites and command line options as needed. Supply the -attach flag for uploading results to your New Relic account. Optional: Validate your config file settings. Interpret the output. Like any other New Relic tool, the Diagnostics CLI service is designed to protect you and your customers' data privacy. For detailed information, see our Diagnostics CLI licensing and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 831.1981,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". The Diagnostics CLI is open source and is located in <em>GitHub</em>. For additional <em>troubleshooting</em> steps for your agent, check out Not seeing data. Here&#x27;s an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped"
      },
      "id": "604469f8e7b9d2abb65799f0"
    },
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "d883a07b7ede4c3beaba4077c507b95f9a228435",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-12-25T05:42:59Z",
      "updated_at": "2021-12-19T14:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our primary data ingest APIs: the Metric API, Trace API, Log API, and Event API. If our pre-built solutions don't meet your needs, our Telemetry SDKs are one way to create a custom telemetry solution (see other solutions for reporting custom data). Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.5376,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on <em>GitHub</em>. Use the language-specific <em>GitHub</em> links below to get library details, coding examples, and procedures for how to use"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/writer-workflow/github-history/",
      "sections": [
        "GitHub history and deleted files",
        "Check the edit history of a doc or file",
        "Docs site history before October 2021",
        "How to find deleted files",
        "Finding the deletion PR",
        "Search through release PRs",
        "Use git log"
      ],
      "published_at": "2021-12-25T17:36:34Z",
      "title": "GitHub history and deleted files",
      "updated_at": "2021-12-19T04:32:24Z",
      "type": "docs",
      "external_id": "d9eb61c221f5fec6251786c5a927f6326b399963",
      "document_type": "page",
      "popularity": 1,
      "body": "GitHub's version control features allow us to see the complete history of a doc, access a doc at any point in time, and find deleted docs without manual backups. Check the edit history of a doc or file Use any of these options to check or \"diff\" the history of a file. Option 1: GitHub history tab Navigate to the doc on the doc site and click Edit page in the right nav. Click History in the top right corner of the doc. Option 2: githistory.xy Navigate to your specific file on GitHub.com: https://github.com/newrelic/docs-website/blob/develop/src/content/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action.mdx Copy In the url, replace github.com with github.githistory.xyz: https://github.githistory.xyz/newrelic/docs-website/blob/develop/src/content/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action.mdx Copy It will take you to a site which presents the visual history of that specific file. You can view changes by clicking through the commit history at the top of your page. Option 3: Git blame Follow GitHub's documentation. Alternatively, you can use the following command in your terminal: git log --follow \"**/file_name_here.mdx\" Copy This will output the commit history of that file. By default, it only shows the first few commits. You can scroll by pressing Return multiple times. For example, to find the commit history for vmware-vsphere-monitoring-integration.mdx, I would run: git log --follow \"**/vmware-vsphere-monitoring-integration.mdx\" Copy Docs site history before October 2021 We had a large site restructure in October 2021 which lost most of the file history for our docs. You can find an archived version of our site pre-rework in the pre-IA-2021 branch. By navigating the pre-rework version of our repo, you can find file history and more. How to find deleted files There are multiple ways to find deleted files. These are roughly ordered by complexity: Finding the deletion PR The easiest way to find a deleted file is to find the pull request that deleted it. There are multiple ways to accomplish this; here are some ideas: Use GitHub's search feature to search for relevant keywords. You can filter search results to only include PRs. If you have a rough idea of when the doc was deleted, you could try finding the pull request in the pull request tab. This list has thousands of PRs, so this may take some time. Lots of docs are deleted because of a Jira ticket. Search Jira for the ticket, where you will find the rough time the doc was deleted and hopefully a link to the PR itself. Ask in #doc_talk! Search through release PRs By searching through release PRs, you can eventually find a branch created before the doc was deleted. You can find a list of release PRs in the GitHub PR tab. A few tips: Search by intervals of a month first. Once you find a branch that contains the doc, you can scope down to a week and then to a day. By decreasing the scope, you will eventually find the deleted doc in it's exact state before deletion. To access the branch a PR comes from, go to that pull request's page and click on the branch name underneath the title and PR number. Use git log The most powerful and realiable way to find deleted files is to use git log. See stackoverflow for more details.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.08826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>GitHub</em> history and deleted files",
        "sections": "<em>GitHub</em> history and deleted files",
        "body": "<em>GitHub</em>&#x27;s version control features allow us to see the complete history of a doc, access a doc at any point in time, and find deleted docs without manual backups. Check the edit history of a doc or file Use any of these options to check or &quot;diff&quot; the history of a file. Option 1: <em>GitHub</em> history tab"
      },
      "id": "61beb5d864441f378699fc79"
    }
  ],
  "/docs/style-guide/writing-docs/writer-workflow/peer-editor-workflow": [
    {
      "image": "https://docs.newrelic.com/static/aa5797a9c6aaadf52a7bac18b3ac8e83/c1b63/dealing_with_interrupts.png",
      "url": "https://docs.newrelic.com/docs/agile-handbook/sprint-mechanics/sprint-workflow-and-jira-boards/",
      "sections": [
        "Sprint workflow",
        "Planned work",
        "Unplanned work (surprises!)",
        "Jira boards: Backlog and future sprints",
        "Jira boards: Current sprint",
        "Proposed",
        "In Progress",
        "Needs Peer Editor",
        "In Peer Edit",
        "Peer Edit Done",
        "Blocked",
        "Done",
        "Incomplete (\"carry-over\") tickets",
        "Tip"
      ],
      "published_at": "2021-12-25T05:55:30Z",
      "title": "Sprint workflow",
      "updated_at": "2021-11-06T12:49:01Z",
      "type": "docs",
      "external_id": "e18dcb23b9a43a083a2c4496d6fb9a20b9efc496",
      "document_type": "page",
      "popularity": 1,
      "body": "All of our sprint work is tracked in Jira. The workflow depends on what type of work we're dealing with: Planned or unplanned (\"surprise!\") work. Planned work Planned work includes all work that is currently in our backlog or has been added to the current sprint as a result of a Sprint Planning session. This could include writing or updating documentation, research, meeting with SMEs, information architecture, incorporating peer edits, SME review, and so on. Unplanned work (surprises!) Usually, we get notified of major requests far enough in advance that we can include them in liaison project plans, backlog grooming, and sprint planning. Occasionally, something bigger surprises us that needs emergency support. Follow this process with new docs asks to assess the scope of work and ensure we address valid docs needs within a reasonable amount of time. Our goal is to treat the sprint as sacred and insulate against \"surprise\" work that is not absolutely crucial. But we also want to ensure we're providing good internal customer service, and not getting hung up on process niceties for things that are small. Jira boards: Backlog and future sprints This is where the vast majority of tickets spend their time. Most tickets (even for active projects) spend at least a little time here before moving into a sprint to be actively worked. Being in the backlog doesn't mean something isn't important---just that we haven't committed to it yet.  You can also add tickets straight to a future sprint. This is where tickets tentatively assigned to a future sprint will be found. Tickets can be assigned here to be held for backlog grooming and sprint planning.  Jira boards: Current sprint Proposed This step is for work that has been assigned to the current sprint during Sprint Planning and is available to be picked up by a tech writer. When you're ready to take on a new ticket, try to work the queue from the top-down and avoid cherry picking. It's also better to pick up Needs Peer Edit tickets before committing to a new ticket. Something that needs a peer edit is close to done, and helping things across the finish line helps get value into users hands, and frees us up to think about new problems. In Progress This step is for all of the work to be done by the assignee: Research, meeting with SMEs, information architecture, writing, incorporating peer edits, SME review, and so on. Tickets are moved to this step once work is started by the TW, and remain here until the work is either complete, ready for peer review, or it becomes blocked. If additional large edits are needed after the peer review, the ticket can be moved back to In Progress for those edits. Needs Peer Editor Work that is ready for a peer edit. Once a peer editor picks it up, they move it into In Peer Edit. In Peer Edit This step is for a peer editor to review docs before they go live. Follow the Peer editor workflow, then move the ticket into Peer Edit Done.  Peer Edit Done This step is a holding state once peer editing is complete. After completing their peer edit and delivering their feedback, the peer editor moves the ticket into Peer Edit Done. From there, the assignee on the ticket (not the peer editor) moves the ticket into the appropriate column (In Progress, Blocked, or Closed). Minor edits can be completed from this column but for major doc rework, the ticket should be moved back into the In Progress column. Blocked This step is for tickets that cannot be moved forward by the team. This could be because we're waiting for a response from a SME, or for a feature to deploy, or for final signoff. The team keeps an eye on this column for tickets that may need escalation. Putting something in Blocked rather than In Progress lets us see the status of every ticket at a glance. This column can also be used for extended time out of the office for the assigned writer, if it's work that can be safely held. (If the work cannot be held while you're out, find another writer to step in and take over.) Once you're un-blocked, move the ticket to the appropriate column. If the ticket remains blocked at the end of the current sprint, it will need to be re-reviewed during backlog grooming to determine if the ticket will carry-over into the upcoming sprint, or return to the backlog until a future sprint. Done This step is for work that is 100% finished. Work gets cleared out this column before we start a new sprint. Incomplete (\"carry-over\") tickets Ticket don't carry over automatically between sprints. Instead, any ticket that gets carried over is treated as a \"new\" ticket in the next sprint planning. Before sprint planning, review any open tickets in the board that are assigned to you and figure out what to do with them. For each open ticket assigned to you (or \"carry over\"), decide if you should: Recommended: Clone the ticket and close the old one. This is the best option for partially completed work because it makes metrics easier. If you do: Clone the ticket. Note why we closed the ticket. Add an estimate of points completed in the Points Completed field. Create a follow-up ticket if necessary. Move the ticket to the next sprint. If you do: Review the ticket's action items and description to make sure they're still current. Clear out the ticket points. Move the ticket back to the backlog. If you do: Update the action items and description to make sure they're still current. Note why we moved to the backlog rather than carry over. ← Planning poker Liaisonships → Tip We welcome thoughts or questions on our handbook! The easiest way to get in touch is to file a GitHub issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 727.8573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Sprint <em>workflow</em>",
        "sections": "Needs <em>Peer</em> <em>Editor</em>",
        "body": " that is ready for a <em>peer</em> edit. Once a <em>peer</em> <em>editor</em> picks it up, they move it into In <em>Peer</em> Edit. In <em>Peer</em> Edit This step is for a <em>peer</em> <em>editor</em> to review docs before they go live. Follow the <em>Peer</em> <em>editor</em> <em>workflow</em>, then move the ticket into <em>Peer</em> Edit Done.  <em>Peer</em> Edit Done This step is a holding state once"
      },
      "id": "616c0dc0196a67e6583c8164"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/writer-workflow/github-intro/",
      "sections": [
        "Get around GitHub",
        "Who is who in an issue/PR?",
        "Track issues in the board",
        "Deal with references in GitHub (and the style guide)",
        "Merge releases into main work (or, when do we publish?)",
        "GitHub labels"
      ],
      "published_at": "2021-12-25T17:33:47Z",
      "title": "Get around GitHub",
      "updated_at": "2021-12-20T04:59:44Z",
      "type": "docs",
      "external_id": "539ae5620ae9be8f8c3752fd3eda664186fbb5c4",
      "document_type": "page",
      "popularity": 1,
      "body": "As tech doc writers (TW) we edit docs, do peer edits, or use the Docs Team GitHub board to track the status of issues and pull requests (PR). Who is who in an issue/PR? GitHub keeps track of all activity concerning an issue or PR, including, of course, the people involved. When a new issue or PR is filed, check on the filer’s username and see if they're listed as a member of the New Relic organization. If they aren't, try to find them on Slack based on their username. If you're not sure about someone's affiliation, treat them as external until you know otherwise. People in an issue/PR include: Creator: The person who opened the issue or PR. This could be a writer, a Relic, or an external user. We'll label the issue or PR differently depending on who created it. If you're not sure if a user is a Relic, a good trick is to click on their profile and see if they're a member of the New Relic GitHub org. Assignee: The person taking responsibility for a PR or issue. This will usually be used by the Hero or Sidekick to assign non-TW PRs and issues to themselves. It can also be used to take a TW’s PR or issue over from them. Reviewer: The person who reviews or peer edits the code/document and approves the changes. Not necessarily the person responsible for that area or responsible for merging the commit. You can pre-assign up to 100 reviewers to a given issue. Track issues in the board The docs board has the following columns: Column Description Needs triage The Hero or Sidekick review and label issues and PRs in this column, then drag them to the appropriate column. If a PR or issue is labeled eng, the Hero/Sidekick can go ahead and click its ellipses icon to archive it. Hero: to do PRs that the Hero needs to review, publish, and follow up with SMEs as needed. Hero: Assign yourself as Assignee. In review (Hero or any TW) Drag PRs to this column when they are being reviewed. This shows who is reviewing and what is being reviewed, so two writers don’t mistakenly work on the same PR. Any TW: Writer needs PR review PRs from Tech Docs team members that need a light edit pass to make sure everything in GitHub is correct. This should be checked by other writers every few hours so PRs don’t get stale. If you have a PR that’s been lingering here too long, ask for a reviewer in #doc_sprint_talk. Whoever takes it: assign yourself as Reviewer. Any TW: needs peer edit Like our Needs Peer Edit column in Jira: A writer has requested a review of their PR. Review their PR in GitHub and leave comments. Whoever takes it: assign yourself as Reviewer. Waiting on SME/Blocked For PRs that are blocked by need for SME info or confirmation (for example, as Hero you are waiting on an answer from the person who sent in a Hero pull request). Waiting on TW to merge All reviews are complete. The TW who created the PR (or who is assigned the issue) needs to merge this work into develop. Drafts A draft is a way to open a PR while indicating that the work is still in progress and not necessarily ready to merge immediately. You can't merge a Draft PR directly. Instead, you must move it out of draft status first. When you see a draft PR (especially from outside the team!), treat it as though it's a working draft, and reach out to the creator to discuss. Read more on GitHub's drafts. As a Hero, make sure you attend to the following throughout your day: Check in with the previous Hero at the start of your day (especially on Monday at the start of the week). Don’t forget to sync with the BCN Hero if necessary. Watch for incoming PRs in #docs_deploys, and review everything in the Needs triage column. Drag cards from that column to the appropriate column. Work through the cards in the Hero: to do column. Everyone on the team helps keep things moving: All writers should keep an eye on both Any TW columns. There's one column for PRs that need a simpler review before merging (typo fixes, drive-by edits, etc), and another column for PRs that need a peer edit. There are also two blocked columns: One for PRs blocked on a SME, and another column where we're waiting on the TW who created the PR to review feedback and/or merge. After merging, remove your ticket from the board. Deal with references in GitHub (and the style guide) Don't link to anything non-public from a public place. You can reference Jira tickets, but reference tickets by issue key (DOC-1234 is ok) rather than a link (https://newrelic.atlassian.net/browse/DOC-1234 is not). Don't mention traffic or usage numbers publicly. Don't reference internal people by name. If they have a GH account, @mention their GH handle. If they don't, talk instead about teams (\"talk to a browser team engineer\" or \"Support Engineer\") rather than people. You can mention the #documentation channel and hero. Merge releases into main work (or, when do we publish?) The Hero currently merges three times a day: At 9 AM (morning), 12 PM (noon), and 3 PM (evening) Pacific. We merge release branches into main to avoid interuptions when someone merges into develop during a release. To learn more about this workflow, see the gitflow documentation in Atlassian. To start a release: Create a branch based off develop Github Desktop by clicking Current Branch in the top header, clicking New Branch in the dropdown, and then selecting Develop. Name the branch following this pattern: daily-release/mm-dd-yy-morning/noon/evening. Here's an example: daily-release/10-27-21-morning. Push your changes by clicking Push Origin in GitHub Desktop. Create a pull request into main from your new daily release branch by clicking Create Pull Request. This will open a pull request screen on github.com. Pull requests default to merging into develop, so select main as the base branch in the left side of the page and then click Submit Pull Request. Wait until all the checks complete, and then merge the pull request. All branches that follow the daily-release/mm-dd-yy-morning pattern are protected branches. This means the branches can't be deleted or pushed to by non-admins. GitHub labels Every issue needs labels to help us triage and track the health of our backlog: content: Always add, this indicates the issue is content-related rather than a design or engineering issue. pg_*: Always add to indicate the product group. For full definitions, see the \"Doc Jira and GitHub fields\" doc in the internal team Google Drive. Indicate who created the issue: from_internal: A Relic created it. from_external: A user opened it in the repo OR it came in through #customer-feedback process. from_tw: One of us created it (unless we were passing along #customer-feedback). Optionally: docs-issues-migrate: Issues that are too large in scope for the docs team to handle without product team expertise. This label alerts the docs issues team to migrate these issues into the customer feedback channel where they will be triaged and sent to product teams. Jira’d: Issues that have a corresponding Jira ticket. Make sure you leave the Jira number in the comments of the issue (for example, DOC-1234). Every pull request needs these labels so we can see where our contributions come from: content: Always add, this indicates the PR is content-related rather than design or engineering. Indicate who created the pull request: from_internal: A Relic created it. from_external: A user opened it in the repo OR it came in through #customer-feedback process. from_tw: One of us created it (unless we were passing along #customer-feedback). If the PR fixes an external issue, label it as from_tw since the work was done by a tech writer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.755554,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "As tech doc writers (TW) we edit docs, do <em>peer</em> edits, or use the Docs Team GitHub board to track the status of issues and pull requests (PR). Who is who in an issue&#x2F;PR? GitHub keeps track of all activity concerning an issue or PR, including, of course, the people involved. When a new issue or PR"
      },
      "id": "61ab4782196a672667d0efa1"
    },
    {
      "sections": [
        "Workflows variables",
        "Variables",
        "Workflow data enrichment examples",
        "Query for when application traffic drops",
        "Non-web transactions time",
        "Throughput",
        "Error rate",
        "Query for transaction failures",
        "Query for Kubernetes consumption overview"
      ],
      "title": "Workflows variables",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "workflows",
        "Enrichments",
        "Issues"
      ],
      "external_id": "48f9db1f21750574985a1563c6b2dad8f4dcb2ce",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-workflows/custom-variables-incident-workflows/",
      "published_at": "2021-12-25T15:00:26Z",
      "updated_at": "2021-12-25T15:00:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "An explanation of the variables used for incident workflows. Variables Use the variables from the issue entity to select the kind of issues you would like to send as well as the message template which appear on the notifications. Here's a comprehensive list of variables: Key (First word will be used for grouping) Display Name (First word will be used for grouping) Description accumulations.conditionName Alert Condition Names New Relic violated condition accumulations.origin Issue Origin New Relic or third party source that created the issue accumulations.policyName Alert Policy Names Incident detection policy name that generated the violation accumulations.source Issue Source The target system reported by the source activatedAt Issue Activated At Timestamp of Issue activation annotations.description Issue Description List of all incident descriptions annotations.title Issue Title List of all incident titles closedAt Issue ClosedAt Timestamp of Issue closure, null if the issue is not closed createdAt Issue CreatedAt Timestamp of Issue creation entitiesData.entities Impacted Entities Data A list of objects describing the impacted entity name, id, type and kind entitiesData.ids Impacted Entities IDs A set of all impacted entity ids entitiesData.kinds Impacted Entities Kinds A set of all impacted entity kinds entitiesData.names Impacted Entities Names A set of all impacted entity names entitiesData.types Impacted Entities Types A set of all impacted entity types incidentIds Incident IDs A list of all the issue's aggregated incidents isCorrelated Issue Is Correlated Is Issue correlated issue.pageUrl Issue Page URL A direct link to the relevant issue Page issueActivatedAtUtc Issue ActivatedAt UTC string String format of issue activation in UTC issueClosedAtUtc Issue ClosedAt UTC string String format of issue closure in UTC issueCreatedAtUtc Issue CreatedAt UTC string String format of issue creation in UTC issueId Issue ID The unique id of the issue labels.accountIds Issue Environment Associated Account ID New Relic AI's enviroinments associated account ID labels.aggregationKeys Labels Alerts Aggregation Key New Relic Incident detection original incident ID labels.originalAccountIds Labels Account IDs Incident detection policy's account ID labels.policyIds Labels Alert Policy IDs Incident detection policy IDs that generated the violation priority Issue Priority Issue's priority level priorityText Issue Priority text Issue priority in lower case state Issue State Issue's current state stateText Issue state text Issue's state in lower case status Issue Status Issue's current status totalIncidents Incident Count The number of incidents that are aggregated or correlated in the issue triggeredAt Issue Triggered At Timestamp of Issue notification triggered triggerEvent Issue Notification Trigger Event The notification trigger event updatedAt Issue Updated At Timestamp of Issue last updated workflowName Workflow Name The name of the workflow that was triggered Workflow data enrichment examples To get information about the entity that violated a condition, you can use custom variables as part of the where statement of the query. For example, to get the state of the EC2 instance use: SELECT latest(ec2State) FROM ComputeSample where provider = 'Ec2Instance' and entityName in {{entitiesData.names}} Copy This query returns a single value (for example, stopped), as the query only uses a single field. The variable entitiesData.names is a list of identifiers for the entities. You can use any other entity properties in the same way. You can use custom variables to enrich your workflow data queries in different ways: Query for when application traffic drops There are times when you want to know when traffic to your application drops. You can use the { { entitiesData.names}} variable in place of your application's name. SELECT count(*) FROM Transaction WHERE appName in {{entitiesData.names}} since 10 minutes ago Copy Non-web transactions time Average time the impacted entities spend processing requests/transactions, broken down by process type SELECT average(apm.service.overview.other) * 1000 FROM Metric WHERE appName IN {{entitiesData.names}} FACET `segmentName` TIMESERIES Copy Throughput Number of requests per minute the impacted enitities process SELECT rate(count(apm.service.transaction.duration), 1 minute) as 'Non-web throughput' FROM Metric WHERE (appName IN {{entitiesData.names}}) AND (transactionType = 'Other') TIMESERIES Copy Error rate Ratio of errors to the total number of requests processes by the impacted entities SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) as 'Non-web errors' FROM Metric WHERE (appName IN {{entitiesData.names}}) AND (transactionType = 'Other') TIMESERIES Copy Query for transaction failures There are times when you want to know when your application transactions have failed. This query shows the latest HTTP status code responses filtered by the { { entitiesData.names}} variable that violated your alert policy threshold. From Transaction select latest(httpResponseCode), average(duration) where appName in {{entitiesData.names}} Copy Query for Kubernetes consumption overview Use a query like this to get the number of entities and their ingest times within a Kubernetes pod. By identifying what entities have large ingest times, you can begin to address that issue and find a potential remedy. SELECT uniqueCount(displayName), sum(nr.ingestTimeMs) from K8sServiceSample where entityName = {{entitiesData.names}} since 1 hour ago. Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.750626,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Workflows</em> variables",
        "sections": "<em>Workflows</em> variables",
        "tags": "<em>workflows</em>",
        "body": " or correlated in the issue triggeredAt Issue Triggered At Timestamp of Issue notification triggered triggerEvent Issue Notification Trigger Event The notification trigger event updatedAt Issue Updated At Timestamp of Issue last updated <em>workflow</em>Name <em>Workflow</em> Name The name of the <em>workflow</em>"
      },
      "id": "603e7a6528ccbcad47eba77f"
    }
  ],
  "/docs/style-guide/writing-docs/writer-workflow/tech-writer-workflow": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/writer-workflow/peer-editor-workflow/",
      "sections": [
        "Peer editor workflow",
        "Peer editing workflow in GitHub",
        "Developmental edit pass",
        "Copy edit workflow"
      ],
      "published_at": "2021-12-25T16:57:05Z",
      "title": "Peer editor workflow",
      "updated_at": "2021-11-26T05:18:04Z",
      "type": "docs",
      "external_id": "2445f390d928b9af124196fb5aaed74597083b36",
      "document_type": "page",
      "popularity": 1,
      "body": "Use this document to learn how to review and peer edit docs for you fellow writers in GitHub. Check the Tech Writer workflow doc for info on how to set up your local environment. To troubleshoot GitHub issues, see our guide. Peer editing workflow in GitHub If you’re peer editing a doc or have been otherwise assigned to a PR as a reviewer, you have a few choices for how and where to do the work. The most streamlined and open-source approach is to do the edit using GitHub options, rather than copying the file to Google Docs and editing there. Developmental edit pass For cases where you have questions and suggestions rather than straight copy edits, follow these steps. Open the PR that you’re assigned to review. On the Files changed tab, you can either: Click Review changes and then select one of the following: Comment - use if you have a comment that doesn’t require follow up. Approve - use if you just want to approve the PR. You can request changes in the Leave a comment area, and select Approve if you want to let the writer make the edits and merge the file without a follow-up review from you. Request changes - use for times when you want to make sure the changes you request are included. You’ll be notified with any updates that the writer makes. OR, start making comments on lines or sections of the doc. To do this, click the add comment icon , and leave an edit or comment for that specific line in the page. With this option, you get the choice between adding a single comment or starting a review. If you’re going to make comments throughout a doc, choose Start a review so the comments will all be rolled into one commit. Click Finish your review to complete your review. This triggers a notification to the writer alerting them that you’ve made suggestions. Copy edit workflow If you have copy edits for a file rather than comments and suggestions, you can make the changes to the file in different ways. Here are two main options: Edit using the GitHub browser: On the Files changed tab, in the diff window click the editing button (three dots). When you finish your edits, add a comment at the bottom of the file and choose to either commit the changes directly, or create a branch and start a pull request. Choose to branch and start a pull request if you expect a writer to review the diff and accept or revise your edits. Edit locally: Check out the branch containing the file you want to edit. In GitHub Desktop, click the Current branch down arrow and select the branch. Then, make the edits on your local drive, save, and commit your changes to the branch. Note that this approach adds your edits to the open pull request. You can now see the changes you added to the file on the Files changed tab in the PR. These are just a few of many editing options. You’ll find your preferred way, just as with any other tool.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1003.3167,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Peer editor <em>workflow</em>",
        "sections": "Peer editor <em>workflow</em>",
        "body": "Use this document to learn how to review and peer edit docs for you fellow writers in GitHub. Check the <em>Tech</em> <em>Writer</em> <em>workflow</em> doc for info on how to set up your local environment. To troubleshoot GitHub issues, see our guide. Peer editing <em>workflow</em> in GitHub If you’re peer editing a doc or have been"
      },
      "id": "61b35900196a67bd1da5b38b"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/create-edit-content/",
      "sections": [
        "Create and edit content",
        "Edit a doc",
        "Create new docs",
        "Clone (copy) an existing doc",
        "For bigger projects",
        "Delete pages",
        "Private edits",
        "Request a future publication date (for New Relic employees)"
      ],
      "published_at": "2021-12-25T18:02:57Z",
      "title": "Create and edit content",
      "updated_at": "2021-11-26T09:11:58Z",
      "type": "docs",
      "external_id": "aa49bd1d71b168fd3da1eaaf781f230c6e603a81",
      "document_type": "page",
      "popularity": 1,
      "body": "We welcome your contributions, whether you are a New Relic employee or a New Relic user! And we don't want you to worry about style. When you edit a file, tech writers on our team review it for style, grammar, and formatting. That said, if you're curious about our style guidelines, you're welcome (but not obligated) to take a look. Edit a doc If you see a minor problem in our documentation that you want to quickly fix, you can use GitHub to edit the file and submit your pull request. A member of the Docs team will review your edit and publish your changes. We'll follow up with you if we have any questions. To edit existing content without building the site locally: On the docs site, navigate to the doc you'd like to edit. Click Edit page on the top corner of the right nav. A GitHub page will open with the source of the doc. Click the pencil icon in the top right. Make your edits (don't worry too much about formatting or grammar, we're happy to take care of that). At the bottom of the page, enter a commit message that describes your change, then click Commit changes. Follow the prompts to submit your pull request. A member of the Docs team will review your pull request and comment with any feedback. Once we've merged your pull request into the Develop branch, your changes will go live with our next deploy (usually within a few hours). Create new docs You can use article templates or clone an existing doc as a template. To create a new doc: Clone the repo on your computer. In /src/content/docs/, find a good location for your doc. Using your text editor, create a new .mdx file or copy an existing doc. Write your content. Optional: Add your doc to the right nav .yml file. The navigation files can be a bit hard to work with, so feel free to leave this step for a Docs writer to handle when they review your pull request. Commit your changes and create a pull request. The Tech Docs team has two heroes watching for new pull requests. We'll help you get the content finalized and make sure that it's in the right place. Clone (copy) an existing doc Once you've cloned the docs-website repository, use your text editor to copy an existing doc. Rename and edit the copy and then save it as a new doc. Your cloned doc automatically inherits the original doc's frontmatter content. Make sure to change that, too. If you want your cloned doc to be translated, follow standard procedures to request translation. For bigger projects If you're making larger changes like adding a whole new doc or editing many existing docs, it can be helpful to run the site locally. For instructions, see Tech writer workflow. Delete pages If you are comfortable with deleting the page yourself, go for it. If not, ask us by: File an issue in the docs-website repo, or contact the @hero in the #documentation channel if you're a New Relic employee. We'll take a look at your issue and help out. Private edits If you need to stage content for a private beta or limited release, contact the docs hero in the #documentation Slack channel. Request a future publication date (for New Relic employees) If your draft needs to be released on a specific date or within a specific timeframe (for example, right before a release), contact the Tech Docs @hero in the #documentation Slack channel. If you're not a New Relic employee, please create a GitHub issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 985.6916,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " procedures to request translation. For bigger projects If you&#x27;re making larger changes like adding a whole new doc or editing many existing docs, it can be helpful to run the site locally. For instructions, see <em>Tech</em> <em>writer</em> <em>workflow</em>. Delete pages If you are comfortable with deleting the page yourself, go"
      },
      "id": "61b35a97196a67b744a5b860"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/writer-workflow/github-intro/",
      "sections": [
        "Get around GitHub",
        "Who is who in an issue/PR?",
        "Track issues in the board",
        "Deal with references in GitHub (and the style guide)",
        "Merge releases into main work (or, when do we publish?)",
        "GitHub labels"
      ],
      "published_at": "2021-12-25T17:33:47Z",
      "title": "Get around GitHub",
      "updated_at": "2021-12-20T04:59:44Z",
      "type": "docs",
      "external_id": "539ae5620ae9be8f8c3752fd3eda664186fbb5c4",
      "document_type": "page",
      "popularity": 1,
      "body": "As tech doc writers (TW) we edit docs, do peer edits, or use the Docs Team GitHub board to track the status of issues and pull requests (PR). Who is who in an issue/PR? GitHub keeps track of all activity concerning an issue or PR, including, of course, the people involved. When a new issue or PR is filed, check on the filer’s username and see if they're listed as a member of the New Relic organization. If they aren't, try to find them on Slack based on their username. If you're not sure about someone's affiliation, treat them as external until you know otherwise. People in an issue/PR include: Creator: The person who opened the issue or PR. This could be a writer, a Relic, or an external user. We'll label the issue or PR differently depending on who created it. If you're not sure if a user is a Relic, a good trick is to click on their profile and see if they're a member of the New Relic GitHub org. Assignee: The person taking responsibility for a PR or issue. This will usually be used by the Hero or Sidekick to assign non-TW PRs and issues to themselves. It can also be used to take a TW’s PR or issue over from them. Reviewer: The person who reviews or peer edits the code/document and approves the changes. Not necessarily the person responsible for that area or responsible for merging the commit. You can pre-assign up to 100 reviewers to a given issue. Track issues in the board The docs board has the following columns: Column Description Needs triage The Hero or Sidekick review and label issues and PRs in this column, then drag them to the appropriate column. If a PR or issue is labeled eng, the Hero/Sidekick can go ahead and click its ellipses icon to archive it. Hero: to do PRs that the Hero needs to review, publish, and follow up with SMEs as needed. Hero: Assign yourself as Assignee. In review (Hero or any TW) Drag PRs to this column when they are being reviewed. This shows who is reviewing and what is being reviewed, so two writers don’t mistakenly work on the same PR. Any TW: Writer needs PR review PRs from Tech Docs team members that need a light edit pass to make sure everything in GitHub is correct. This should be checked by other writers every few hours so PRs don’t get stale. If you have a PR that’s been lingering here too long, ask for a reviewer in #doc_sprint_talk. Whoever takes it: assign yourself as Reviewer. Any TW: needs peer edit Like our Needs Peer Edit column in Jira: A writer has requested a review of their PR. Review their PR in GitHub and leave comments. Whoever takes it: assign yourself as Reviewer. Waiting on SME/Blocked For PRs that are blocked by need for SME info or confirmation (for example, as Hero you are waiting on an answer from the person who sent in a Hero pull request). Waiting on TW to merge All reviews are complete. The TW who created the PR (or who is assigned the issue) needs to merge this work into develop. Drafts A draft is a way to open a PR while indicating that the work is still in progress and not necessarily ready to merge immediately. You can't merge a Draft PR directly. Instead, you must move it out of draft status first. When you see a draft PR (especially from outside the team!), treat it as though it's a working draft, and reach out to the creator to discuss. Read more on GitHub's drafts. As a Hero, make sure you attend to the following throughout your day: Check in with the previous Hero at the start of your day (especially on Monday at the start of the week). Don’t forget to sync with the BCN Hero if necessary. Watch for incoming PRs in #docs_deploys, and review everything in the Needs triage column. Drag cards from that column to the appropriate column. Work through the cards in the Hero: to do column. Everyone on the team helps keep things moving: All writers should keep an eye on both Any TW columns. There's one column for PRs that need a simpler review before merging (typo fixes, drive-by edits, etc), and another column for PRs that need a peer edit. There are also two blocked columns: One for PRs blocked on a SME, and another column where we're waiting on the TW who created the PR to review feedback and/or merge. After merging, remove your ticket from the board. Deal with references in GitHub (and the style guide) Don't link to anything non-public from a public place. You can reference Jira tickets, but reference tickets by issue key (DOC-1234 is ok) rather than a link (https://newrelic.atlassian.net/browse/DOC-1234 is not). Don't mention traffic or usage numbers publicly. Don't reference internal people by name. If they have a GH account, @mention their GH handle. If they don't, talk instead about teams (\"talk to a browser team engineer\" or \"Support Engineer\") rather than people. You can mention the #documentation channel and hero. Merge releases into main work (or, when do we publish?) The Hero currently merges three times a day: At 9 AM (morning), 12 PM (noon), and 3 PM (evening) Pacific. We merge release branches into main to avoid interuptions when someone merges into develop during a release. To learn more about this workflow, see the gitflow documentation in Atlassian. To start a release: Create a branch based off develop Github Desktop by clicking Current Branch in the top header, clicking New Branch in the dropdown, and then selecting Develop. Name the branch following this pattern: daily-release/mm-dd-yy-morning/noon/evening. Here's an example: daily-release/10-27-21-morning. Push your changes by clicking Push Origin in GitHub Desktop. Create a pull request into main from your new daily release branch by clicking Create Pull Request. This will open a pull request screen on github.com. Pull requests default to merging into develop, so select main as the base branch in the left side of the page and then click Submit Pull Request. Wait until all the checks complete, and then merge the pull request. All branches that follow the daily-release/mm-dd-yy-morning pattern are protected branches. This means the branches can't be deleted or pushed to by non-admins. GitHub labels Every issue needs labels to help us triage and track the health of our backlog: content: Always add, this indicates the issue is content-related rather than a design or engineering issue. pg_*: Always add to indicate the product group. For full definitions, see the \"Doc Jira and GitHub fields\" doc in the internal team Google Drive. Indicate who created the issue: from_internal: A Relic created it. from_external: A user opened it in the repo OR it came in through #customer-feedback process. from_tw: One of us created it (unless we were passing along #customer-feedback). Optionally: docs-issues-migrate: Issues that are too large in scope for the docs team to handle without product team expertise. This label alerts the docs issues team to migrate these issues into the customer feedback channel where they will be triaged and sent to product teams. Jira’d: Issues that have a corresponding Jira ticket. Make sure you leave the Jira number in the comments of the issue (for example, DOC-1234). Every pull request needs these labels so we can see where our contributions come from: content: Always add, this indicates the PR is content-related rather than design or engineering. Indicate who created the pull request: from_internal: A Relic created it. from_external: A user opened it in the repo OR it came in through #customer-feedback process. from_tw: One of us created it (unless we were passing along #customer-feedback). If the PR fixes an external issue, label it as from_tw since the work was done by a tech writer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.19328,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " yourself as Assignee. In review (Hero or any TW) Drag PRs to this column when they are being reviewed. This shows who is reviewing and what is being reviewed, so two writers don’t mistakenly work on the same PR. Any TW: <em>Writer</em> needs PR review PRs from <em>Tech</em> Docs team members that need a light edit pass"
      },
      "id": "61ab4782196a672667d0efa1"
    }
  ],
  "/docs/style-guide/writing-strategies/five-questions-help-write-docs": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-strategies/introduction-style-guide/",
      "sections": [
        "Introduction to the style guide"
      ],
      "published_at": "2021-12-25T15:06:49Z",
      "title": "Introduction to the style guide",
      "updated_at": "2021-11-24T09:23:43Z",
      "type": "docs",
      "external_id": "56adaf70b517da62915ac6a2a56ff50c6effb7a9",
      "document_type": "page",
      "popularity": 1,
      "body": "Welcome to New Relic's style guide. We've written these guidelines for content creators across New Relic, and for contributors to our open source content projects, like the Docs! This guide also gives you some insight into how we think about good technical writing. We focus on style and usage that's particular to New Relic. We follow American English conventions. For topics that aren't covered, please refer to the Microsoft Writing Style Guide (for guidelines on technical terminology) or the Chicago Manual of Style (for general writing and editing guidelines). Find the information you need: For our writing strategy, see docs in this section on voice, five questions for great content, how to organize your content, and more. For a quick reference for terms usage, see our Usage dictionary. For how to write and edit pages on docs.newrelic.com, see Create and edit content.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.87897,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction <em>to</em> the style guide",
        "sections": "Introduction <em>to</em> the style guide",
        "body": ": For our writing strategy, see <em>docs</em> in this section on voice, <em>five</em> <em>questions</em> for great content, how to organize your content, and more. For a quick reference for terms usage, see our Usage dictionary. For how to <em>write</em> and edit pages on <em>docs</em>.newrelic.com, see Create and edit content."
      },
      "id": "619e049fe7b9d2f6effe7e25"
    },
    {
      "sections": [
        "Synthetic monitoring best practices guide",
        "1. Match your monitor type to monitoring need",
        "How to do it",
        "2. View all monitors with the Monitors index page",
        "How to view your monitors in the New Relic One:",
        "New Relic Explorer",
        "Monitors index page",
        "3. View individual monitor results",
        "How to do it:",
        "4. Understand the load-time impact of each resource",
        "5. Configure and develop a scripted browser test"
      ],
      "title": "Synthetic monitoring best practices guide",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "Best practices guides"
      ],
      "external_id": "e76eb0669a1433bb9d0de70d90413e19749adf61",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/best-practices-guides/full-stack-observability/synthetic-monitoring-best-practices-guide/",
      "published_at": "2021-12-25T11:14:52Z",
      "updated_at": "2021-12-25T11:14:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's synthetic monitoring—powered by a Selenium-driven Chrome browser—allows you to monitor and test your apps and address issues before they affect your end users. Here are five tips to help you take immediate advantage of its full power. 1. Match your monitor type to monitoring need Synthetic monitors are virtual browsers that measure the performance of your website, recording each check in detail. They also capture aggregate numbers for load time, uptime, and average download size, as well as an overview, detailed statistics for each page resource, and downtime incidents. There are four types of synthetic monitors; the ones you deploy will depend on the things you want to monitor: Ping monitors—to ensure that your site is accessible. Simple browser monitors—to ensure end-user performance. Scripted browsers—to ensure that particular resources are present. API monitors—to ensure that your app server works as well as your website. How to do it To add a monitor, go to one.newrelic.com > Synthetics (or one.eu.newrelic.com if you have an EU-based account) and click Create monitor. Specify monitor type, name, and URL. Optional: Add a validation string (available for ping and simple browser) or advanced options, which enable substring monitoring for the following types of response validation: Verify SSL (for ping and simple browser). This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs > /dev/null Copy Bypass HEAD request (for ping). This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure (for ping). If a redirect result occurs when Redirect is Failure is enabled, Synthetics categorizes it as a failure (rather than following the redirect and checking the resulting URL). Select the locations where you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes; then from the Monitors index check your monitor. 2. View all monitors with the Monitors index page Continuous application performance monitoring is essential to ensure that web services are in place, working correctly, and error-free. Synthetic monitoring provides this type of assurance by performing automated tests on your web application for each selected location—noting downtime instances (“violations”) and collecting aggregate numbers, results, and detailed statistics for each page resource. Use the Monitors index page to get a high level view of this information, or select an individual monitor to view the Summary, for ping monitors, or Overview, for simple and scripted monitors, page and get a deeper insight into its performance over time. How to view your monitors in the New Relic One: New Relic Explorer To view a list of monitors using the New Relic One Monitors index page: Go to one.newrelic.com > Explorer > Synthetic monitors. For more information, see the documentation about navigating core UI components in New Relic One. Monitors index page To view a list of monitors using the Monitors index page: Go to one.newrelic.com > Synthetics. 3. View individual monitor results It’s not enough to understand how your web apps are performing for your West Coast customers; you need to be able to view how they’re performing across the country and around the globe. By taking advantage of synthetic monitors and visiting your Results page, you can see how everything from development to production affects user experience. You can locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. (The “Network timings” graph below provides a snapshot of webpage performance over a given period.) How to do it: Go to one.newrelic.com > Synthetics and, from the Monitors tab, select your monitor. Select Monitor > Results. Gain an up-to-the-minute view of the slowest page loads for every monitored location. 4. Understand the load-time impact of each resource Visit the synthetics Resources page to see how each resource on your website—including CSS, JavaScript, images, HTML and more—is affecting your overall load. You can drill into detailed metrics collected at run time, locate performance information for time spent by third-party resources, and identify HTTP response codes for each resource. How to do it: Go to one.newrelic.com > Synthetics and, from the Monitors drop-down menu, select your monitor. Select Monitor > Resources. 5. Configure and develop a scripted browser test Using scripted browsers, you can build complex monitoring workflows using the Selenium JavaScript Webdriver bindings. For instance, you can log in to the application, navigate to a particular link, and wait for a page element to load and add an assertion. How to do it: Go to one.newrelic.com > Synthetics. Choose your monitor type (for example, scripted browser). Enter the name and details of your monitor (for example, Sitename.com scripted browser) Select the locations from which you want your monitor to run (for example, Mumbai, Seoul, Columbus, and Montreal). Choose a frequency to determine how often each location will run your monitor (for example, five minutes). Set a notification method to alert your team when performance violations occur. You are now ready to write your script. (Below is an example of a script used to test the performance of a main navigation page.) var assert = require('chai').assert; // script-wide timeout for all wait and waitandfind functions (in ms) var default_element_timeout = 190000; //3 mins var default_pageload_timeout = 240000; //4 mins var navlinks = [\"css-locator-1\", \"css-locator-2\"]; //sets element load timeout to 3 mins $browser.manage().timeouts().implicitlyWait(default_element_timeout); //sets page load timoeout to 4 mins $browser.manage().timeouts().pageloadTimeout(default_pageload_timeout); //test all the main nav page performances $browser.get(\"http://www.sitename.com\").then(function() { return $browser.findelement($driver.by.classname(\"site-theme-example\")); }).then(function() { //verifies the nav list has loaded return $browser.findelement($driver.by.classname(\"site-nav-list-example\")); }).then(function() { //loops through the navlinks array navlinks.foreach(function(val, i, arr) { //finds and navigates to each navlink page return $browser.findelement($driver.by.classname(navlinks[i])).click().then(function() { //verifies that the nav list loaded before moving on return $browser.findelement($driver.by.classname(\"site-nav-list-example\")).then(function() { //verifies that the page logo footer at bottom of page has loaded return $browser.findelement($driver.by.classname(\"site-footer-logo\")); }); }); }); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.05128,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "1. Match your monitor type <em>to</em> monitoring need",
        "body": "New Relic&#x27;s synthetic monitoring—powered by a Selenium-driven Chrome browser—allows you to monitor and test your apps and address issues before they affect your end users. Here are <em>five</em> tips to <em>help</em> you take immediate advantage of its full power. 1. Match your monitor type to monitoring need"
      },
      "id": "603e84bb28ccbce555eba771"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-strategies/organize-doc/",
      "sections": [
        "Organize your page",
        "Organize your page to make it easier to read",
        "Use action-oriented titles",
        "Start the document with an introductory paragraph",
        "Keep documents short",
        "Use the New Relic voice",
        "Change doc titles and anchors",
        "Create and edit categories",
        "Start writing and editing docs"
      ],
      "published_at": "2021-12-25T15:06:49Z",
      "title": "Organize your page",
      "updated_at": "2021-11-24T07:56:48Z",
      "type": "docs",
      "external_id": "a3e3c993c0bf65626e805676496bcae8ea8d2c64",
      "document_type": "page",
      "popularity": 1,
      "body": "These are some organization basics. Organize your page to make it easier to read Consider these organization guidelines when thinking about the order of information in a doc. By following these guidelines, you'll make it easier for readers to skim and find what they need. How to organize information Comments Separate what and why from how. Define any necessary prerequisites, policies, or background information (the what and the why) before you step through the how (step-by-step procedures). Examples: Explain what the feature is and why it matters before telling readers how to use it. Describe any limitations with user permissions or subscription levels that would prevent them from using the feature. If the feature is available for any user or subscription level, don't bother to say so. Provide a roadmap for what users will be able to accomplish, so they know before starting a procedure that they have everything they need. Front-load directions with context. Make sure readers know where they need to be, before telling them what to do. In general, use (select an app) to describe what users select from the product index. Examples: Go to one.newrelic.com > Explorer > (select an app or service). Select (account dropdown) > User preferences. On the command line, type gitk. Also, structure steps by front-loading context from the user's point of view. For example, instead of \"Go to x to do y,\" structure the step as \"To do y, go to x.\" Separate requirements from options. Example: Type the Email you use to sign in and to receive information from New Relic. Optional: Type additional user emails, separated by commas. Follow the \"five to nine\" guideline. Depending on the topic, organize the information so there is a maximum of five to nine chunks of information. For example, readers may start to get lost or overwhelmed after about five h2 sections or seven steps into a procedure. If you have more than nine h2 sections or steps, you might need to create an additional doc or procedure. Other organization tools to consider: Levels of headings Lists Collapsers Callouts Tables Code examples For more help section Use action-oriented titles Wherever possible, give your document or h2 heading a task- or action-oriented title. Focus on what users are trying to accomplish or the problem they're trying to solve. Use present-tense verbs, rather than \"-ing\" verbs. Quality Title example Bad The query history Okay View query history Good Query history: Create and edit NRQL queries Start the document with an introductory paragraph Unless the document is less than a single screen in length, begin with a brief paragraph that introduces the topic or summarizes the important points. Not sure where to start? Try writing all the content for your document first, and then add the introduction to the top to summarize your key points. Or use the introduction to expand on the text in your metaDescription in the metadata. Keep documents short The amount of content needed can help you decide whether you need one or more documents for the topic. If all of the document's contents apply directly to the title, then everything belongs in the same document. If several related sections could be logically split into individual documents, and the overall length of your document is more than about two screenfuls, split those sections into other documents. Be sure to include links to the related contents. If a large document needs to be broken into multiple smaller documents, consider whether they might be best grouped together in their own sub-category. Use the New Relic voice We strive for a voice that's approachable, expert, and visionary. Check out our voice guidelines for how to write content with these qualities. And keep in mind these essential writing tips that apply to any type of documentation. Guidelines Comments Be clear and direct. Remember to: Use present tense. Use active voice; avoid passive voice. Tell users what to do, not what they \"should\" do. If absolutely necessary, tell users what not to do in situations where unexpected results may occur. Whenever possible, provide an alternative suggestion when telling users what not to do. Example: Using active voice with an alternative suggestion for what not to do Do not use your config file to change this setting, because this could affect other processes. Instead, go to one.newrelic.com > APM > (select an app or service) > Settings > Application. Write to aid localization and translation. Do not use euphemisms, idioms, jargon, or slang. Use the same terms and wording consistently. If you need to include an abbreviation or acronym, spell it out the first time it appears in the document. Always take a moment to ask yourself whether people will really understand the terms you are using in the way you're using them. Change doc titles and anchors Because changes to doc titles, anchors, and redirects can break links to other docs, please create an issue to request these types of changes and we'll help you out with that. Create and edit categories Because changes to categories can affect large groups of docs at once, please create an issue to request these types of changes and we'll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see Create and edit content. To learn how to create and publish release notes, see Create release notes. To make it even easier to start a new doc, use templates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 72.27317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Start <em>writing</em> and editing <em>docs</em>",
        "body": " you&#x27;re using them. Change <em>doc</em> titles and anchors Because changes to <em>doc</em> titles, anchors, and redirects can break links to other <em>docs</em>, please create an issue to request these types of changes and we&#x27;ll <em>help</em> you out with that. Create and edit categories Because changes to categories can affect large groups"
      },
      "id": "619df04028ccbc2730b9a00a"
    }
  ],
  "/docs/style-guide/writing-strategies/introduction-style-guide": [
    {
      "sections": [
        "Observability implementation guide template",
        "Overview",
        "Desired outcome",
        "Key performance indicators",
        "KPI1 name",
        "KPI2 name",
        "Prerequisites",
        "Establish the current state",
        "Step 1",
        "Step 2",
        "Step 3",
        "Improvement process",
        "Value realization"
      ],
      "title": "Observability implementation guide template",
      "type": "docs",
      "tags": [
        "Observability maturity",
        "Value driver this applies to << change",
        "Use case name << change",
        "Implementation guide"
      ],
      "external_id": "e207c5d5d6379c5a496c46dc890bf51c60274c1c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/om-implementation-guide/",
      "published_at": "2021-12-25T16:57:04Z",
      "updated_at": "2021-12-24T13:23:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is the template for Observability maturity implementation guides. To help you along, refer to: The style guide introduction Other observability maturity implementation guides To get your implementation guide to show up in the left nav as it should, edit ~src/nav/new-relic-solutions.yml. Don't forget to add a link to it to the Observability Maturity introduction page. Overview Put in a brief, executive-level overview of what this guide achieves. Desired outcome What's the benefit of following the steps in this implementation guide? For practitioners? For the business or the organization? Key performance indicators Refer to the KPI section of the service level management (SLM) guide for what this section should look like. KPI1 name Describe the KPI Goal What is your reader trying to do? Best practices Are there any principles your reader should adopt? KPI2 name Describe the KPI Goal What is your reader trying to do? Best practices Are there any principles your reader should adopt? Prerequisites List any of the following that applies: Reading Training Instrumentation Configuration User access needed Stick to what's relevant (don't be exhaustive unless absolutely necessary) and include links wherever possible. Establish the current state Step1 Step2 Step3 If the reader needs to access a JSON file or another file type, make sure those files are available in the oma-resource-center. Step 1 Describe the step. Step 2 Describe the step. Step 3 Describe the step. Improvement process Now that the reader knows where they stand, tell them how to improve what they're trying to improve. Value realization Remind the reader why they did all this work in the first place and what they'll see as a result. Include best practices to adopt going forward so that they can continue to benefit from their hard work.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 950.98413,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Observability implementation <em>guide</em> template",
        "sections": "Observability implementation <em>guide</em> template",
        "tags": "Implementation <em>guide</em>",
        "body": "This is the template for Observability maturity implementation guides. To help you along, refer to: The <em>style</em> <em>guide</em> <em>introduction</em> Other observability maturity implementation guides To get your implementation <em>guide</em> to show up in the left nav as it should, edit ~src&#x2F;nav&#x2F;new-relic-solutions.yml. Don&#x27;t"
      },
      "id": "61c5c9ec28ccbccadb07ca78"
    },
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-25T06:04:19Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.42029,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>introduction</em>",
        "tags": "Basic <em>style</em> <em>guide</em>",
        "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft <em>Style</em> <em>Guide</em>, which is based on the Chicago Manual of <em>Style</em>. We follow American English conventions, rather than British English ones. We defer to the official product names"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-25T15:04:59Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.30107,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Basic <em>style</em> <em>guide</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    }
  ],
  "/docs/style-guide/writing-strategies/organize-doc": [
    {
      "sections": [
        "Use tags to help organize and find your data",
        "Tip",
        "Tag format and limits",
        "Best practices and tips",
        "Tips on keeping tags simple:",
        "Tips on using tags consistently:",
        "Tips on cross-team implementation:",
        "Tag examples",
        "Team-related tags",
        "Environment-related tags",
        "Criticality-related tags",
        "How tags are added",
        "Add tags via UI or API",
        "APM agent tags",
        "Infrastructure data tags",
        "Automate tags with our CLI",
        "Use tags to filter the UI",
        "Custom queries, charts, and alerts",
        "Query and alert on APM tags",
        "Throughput across shards",
        "Transactions per team",
        "Alert on error rate for teams",
        "Query and alert on attributes"
      ],
      "title": "Use tags to help organize and find your data",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "e2e2d53776b9109965df9de2a20660e9f60bd479",
      "image": "https://docs.newrelic.com/static/529f55ef72f3e366e6cb4a7be67229b6/c1b63/new-relic-tags-workloads_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/use-tags-help-organize-find-your-data/",
      "published_at": "2021-12-25T14:30:48Z",
      "updated_at": "2021-12-25T14:30:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the software industry, a tag typically refers to a piece of metadata added to a data set for the purpose of improving data organization and findability. At New Relic, our tags are key:value pairs (like team: operations) added to various sets of data, like monitored apps and hosts, agents, dashboards, and workloads. We make some important attributes available as tags (for example, app metadata like app name and language, and host metadata like host name and AWS region). You can also add your own custom tags. You can use tags in the UI to filter down to relevant data. Here is an example: Here you can see an accountId tag being used to filter workloads to a specific account. Tags help you to: Organize data coming from a large number of sources and/or to a large number of New Relic accounts. Identify teams, roles, environments, or regions to know who’s responsible for what (see example use cases). Better organize and search dashboards and workloads. Query and chart APM data. Tags are useful for organizing data at a high level. If you want to add more fine-grained detail, like capturing user names or other high-cardinality values, custom attributes or custom events are a better solution. Tip Tags were previously called labels in the New Relic UI. You may sometimes see labelin our code; for example, some of our APM agent config files use a label config option for tags. Tag format and limits Format requirements and limits for tags: The UI has limits on the total number of tags it can display per entity: Limit of 100 for tags reported by default or added via agent/integration configuration. Limit of 100 for custom tags added via UI or API. The following are maximum character length for tags: Key: 128 characters Value: 256 characters Allowed characters: Characters must be UTF-8. When using NerdGraph to add tags, a dash (-) in a tag key is interpreted as a minus symbol. If your tag key has a dash, use back ticks around it (like `key-name`). Best practices and tips Before adding tags, we recommend first seeing how our default tags work for you. When you're ready to add your own tags, review the following best practices tips to get the most out of them. Tips on keeping tags simple: Start by adding only tags you know you’ll definitely use. Unused tags create noise and may add confusion. Try to use short tags. Shorter tags are easier to parse, and also the UI may sometimes truncate longer tags. (See character limits.) When possible, use keys and values that are human-readable (for example, region: EMEA is better than Param8323 : 1229072). Avoid including several values like regions: EMEA | US | LATAM in a single tag. We recommend using three different tags for that, like region: emea, region: us, and region: latam. If you want to match multiple tags, you can do that using the advanced options in the filter UI. Tips on using tags consistently: Try to be consistent with tag language across your teams and entities. Be consistent with naming. For example, avoid using both region: emea and reg: emea. Be consistent with format. For example, avoid using both camelCase and kebab-case. Although tag searching is not case-sensitive in the UI and API, try to be consistent with capitalization. For example, avoid using both env: staging and env: Staging. Tips on cross-team implementation: Tags help improve observability and cost allocation. For this reason, responsibility for tag implementation is often assigned to an observability team, SREs, a group of architects, or a cross-team task force. We recommend the people responsible for implementing tags meet and create an internal policy to describe how the tags are defined and which conventions are to be used. Then: Keep this reference manual up to date. Automate the definition of tags when you deploy New Relic agents, at the cloud provider, or through New Relic automation tools, such as the API or Terraform. Create recurring reports that identify entities that are non-compliant with your tagging standards. Tag examples Here are some examples of common ways to use tags to organize data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department, or region was responsible for a change that led to a performance issue. Team examples: team: backend team: frontend team: db Role examples: roles: architecture roles: devops roles: pm Region examples: region: emea region: america region: asia Environment-related tags You can create entities for the environment they belong to. Examples: env: production env: qa env: development env: staging Criticality-related tags You can create tags related to criticality levels, which lets you easier track the most critical issues. Examples: layer: level1 layer: level2 layer: level3 How tags are added Some important attributes, by default, are available for use as tags. For example, the account name, the account ID, and some basic host/server metadata are available as default tags. You can't remove these available-by-default tags. Here are some details about how tags are added for some specific data sources: Add tags via UI or API When you add tags via the UI or API, this occurs at the entity level. This means that, for example, if you have multiple APM agents monitoring a single entity and apply a tag via the UI, that tag is available for all data coming from that entity. To add or delete tags via the UI: Select a monitored entity, like a monitored app or host. Near the entity’s name at the top of the page, select the See metadata and manage tags menu. In the menu that pops up, add or delete a tag. For APM agents, restart your service. To manage tags via API: see our NerdGraph tagging docs. For a guide to using our CLI to automate tagging, see our developer site. APM agent tags You can add tags via the UI and API or you can add tags using APM agent configuration, both methods require you to restart your service. There are differences in how these apply tags: Via agent config: These tags are applied at the agent-level, not the entity/application level. This would be a good option if you have multiple agents monitoring different aspects of the same app (for example, a blue-green deployment model). Via the UI or API: These tags are applied at the entity/application level. Here are links to the agent configuration options: C SDK: not available Java Go .NET Node.js PHP Python Ruby For information on querying APM tags, see Query APM tags. And check out this short video on querying APM tags (3:20 minutes). Infrastructure data tags There are several ways tags are added to infrastructure entities and services: Use the UI or API to add tags at the entity level. Infrastructure agent: some attributes are available by default as tags. You can also add custom attributes, which are also available as tags in the UI. On-host integrations: some attributes are available by default as tags. You can also add tags by using integration-specific labels config options (for an example, see the labels config for the Apache integration). Cloud service integrations: by default we report tags and labels that are defined in the cloud service. To add tags, you'd add them on the cloud-service-side. Automate tags with our CLI For a guide to automating tags using our CLI tool, see our developer site. Use tags to filter the UI Use the filter field at the top of the New Relic Explorer to filter down to the entities you care about. You can use multiple filter conditions. To filter down to certain entities using tags: From one.newrelic.com, click Explorer. Click the Filter by... field to see a dropdown of available attributes and tags. You can filter by multiple elements and use advanced search options. To find an entity’s metadata and tags from the UI, here are two options: From a list of entities in the UI, at the far right, select an entity's icon. OR Select an entity. Near the top of the page, select the icon. To use the API to view tags, see our NerdGraph docs. Learn about how to use tags with dashboards and how to use tags with workloads. Custom queries, charts, and alerts Different features handle tags differently. Here are some details about how you can use NRQL to query tag data, or create NRQL condition alerts. Query and alert on APM tags You can query APM tags using NRQL. Minimum agent versions: C: not available Go: 2.3.0 Java: 4.9.0 .NET: 8.17 Node: v4.13.0 PHP: not available Python: v4.10.0.112 Ruby: 6.1.0.352 Here are some query examples: Throughput across shards Given a service that is distributed across nine shards, each shard assigned as an environment, we can plot the transaction throughput on all shards using a wildcard query like: SELECT rate(count(apm.service.transaction.duration), 1 minute) FROM Metric WHERE appName LIKE 'MyApp (%' AND transactionType = 'Other' FACET tags.Environment TIMESERIES Copy Transactions per team To see the number of transactions per service for a specific team, we might use a query like: FROM Transaction SELECT count(*) WHERE tags.Team = 'team-a' FACET tags.Project TIMESERIES Copy Alert on error rate for teams You can use a query for your services’ error rate for setting an alert without having to create a rule for each service. Here is the error rate for all services on a team called team-b. And this alert will automatically monitor any new app names added with the team tag. FROM Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Team = 'team-b' FACET appName Copy Related to this, you might create a general rule for a specific service deployed across several environments, so that we have an alarm for a single service monitoring each environment individually: From Metric SELECT count(apm.service.error.count) / count(apm.service.transaction.duration) WHERE tags.Project = 'MyProject' FACET tags.Environment Copy Query and alert on attributes As explained in the tag sources information, some important attributes are used as tags. You can query all attributes and create custom charts using NRQL, and create NRQL alert conditions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.873695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use tags to help <em>organize</em> and find <em>your</em> data",
        "sections": "Use tags to help <em>organize</em> and find <em>your</em> data",
        "body": " or Terraform. Create recurring reports that identify entities that are non-compliant with <em>your</em> tagging standards. Tag examples Here are some examples of common ways to use tags to <em>organize</em> data: Team-related tags Creating tags for team names can be helpful to understand which team, group, department"
      },
      "id": "603ebd1228ccbc6278eba754"
    },
    {
      "sections": [
        "Update the home page",
        "Update a link's URL",
        "Add a new tile to the home page",
        "Add a new section to the home page",
        "Edit the home page left nav"
      ],
      "title": "Update the home page",
      "type": "docs",
      "tags": [
        "home page",
        "landing pages"
      ],
      "external_id": "1d084fae5223f5b34cec91fcae0bcb35560c7b29",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/edit-homepage/",
      "published_at": "2021-12-25T16:54:07Z",
      "updated_at": "2021-12-04T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can't just hit the edit button docs.newrelic.com to make edits to the home page. The page that opens is index.js, the file that manages the parts of the home page, but not the content. It's rare that you'll need to make changes to this file. Most home page changes will be to add a new tile or section to the page, or update links. These types of changes are handled in two files: src/data/homepage.yml - contains home page section titles, section descriptions, and the URLs for tiles. src/i18n/translations/en/translation.json - contains tile info, including the title and short description of tiles. Update a link's URL Change or add new links using homepage.yml. In homepage.yml, search for the link you want to change. Edit the URL, save, commit, and PR the change. Add a new tile to the home page You'll make changes to both homepage.yml and translations.json On the translations.json doc, find the spot where you want to add the new tile (which section, and in what order you want it to appear), and add a new entry with this format: \"t#\": { \"title\": \"tile name\", \"description\": \"Short description.\" }, Copy Make sure you update the number on the tile. If you want to insert it in the middle of a group, update all the subsequent tile numbers as well. Save the file. Open homepage.yml, find the spot where the new tile will be, and add a new line with the relative link for the new tile. For example, - /docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster Save and check that your new tile builds properly on a local build. Commit, push, PR when you're ready. Add a new section to the home page On the translations.json page, add a new section modeled in the spot where you want the new section to appear. Include at least one title. For example, here's the TDP entry, with one tile: \"errors-inbox\": { \"title\": \"Errors Inbox\", \"description\": \"A single place to proactively detect, triage, and take action on all the errors before they impact customers.\", \"t1\": { \"title\": \"Introduction to Errors Inbox\", \"description\": \"How to manage all your monitoring in one place.\" }, Copy When you're done creating the info, save the file. In the homepage.yml page, find the corresponding location for the new section, and add the short name you provided in the translation.json file, title, description, and tile URLs. For example, here's the corresponding TDP section on homepage.yml. errors-inbox: title: Errors Inbox description: A single place to proactively detect, triage, and take action on all the errors before they impact customers. tiles: - /docs/errors-inbox/errors-inbox Copy Save, build locally, commit, PR. Edit the home page left nav The left nav of the home page is controlled by src/nav/root.yml. This is a basic yml file, similar to our taxonomy files. Each link on the left nav needs a title and a path: - title: Welcome to New Relic path: /docs/using-new-relic - title: New Relic One path: /docs/new-relic-one/use-new-relic-one - title: Guides and best practices path: /docs/new-relic-solutions - title: section-break - title: Alerts and Applied Intelligence path: /docs/alerts-applied-intelligence Copy You can add a new link by following the pattern above or delete a link by removing the corresponding title and path. Section breaks are added by including a - title: section-break line. The left nav reflects the exact order of root.yml, so it's easy to organize it as needed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.692444,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update the home <em>page</em>",
        "sections": "Update the home <em>page</em>",
        "tags": "home <em>page</em>",
        "body": "-faster Save and check that <em>your</em> new tile builds properly on a local build. Commit, push, PR when you&#x27;re ready. Add a new section to the home <em>page</em> On the translations.json <em>page</em>, add a new section modeled in the spot where you want the new section to appear. Include at least one title. For example, here"
      },
      "id": "61ab480264441f9ef0927fb8"
    },
    {
      "sections": [
        "Infrastructure agent overhead",
        "Linux single-task host",
        "Linux Docker host",
        "Windows host",
        "Linux ARM64 host",
        "Manage data",
        "Resource utilization"
      ],
      "title": "Infrastructure agent overhead",
      "type": "docs",
      "tags": [
        "Infrastructure",
        "Install the infrastructure agent",
        "Manage your agent"
      ],
      "external_id": "cd4b0d49bf6d11a12ff3a8357b223786b4c3f881",
      "image": "",
      "url": "https://docs.newrelic.com/docs/infrastructure/install-infrastructure-agent/manage-your-agent/infrastructure-agent-performance-overhead/",
      "published_at": "2021-12-25T15:24:36Z",
      "updated_at": "2021-12-25T15:24:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The infrastructure agent is a lightweight piece of software, designed to minimize its impact on the performance of your hosts. However, the exact load varies depending on your host's workload, particularly on the number of processes running on the host. This is because the agent collects detailed data from each individual process. As a general guideline, New Relic has collected benchmarks for some common types of hosts: Linux single-task host The agent has very low performance overhead on a classic, single-task host. For example, a server running Apache, Unicorn, or a single Java application. Our benchmarks for this type of host are based on an Amazon EC2 t3.2xlarge: vCPUs: 8 vCPUs Memory: 32.0 GB Storage: 160.0 GB Operating system: CentOS 7 For this type of classic, single-task host, typical usage is: CPU: about 0.3% Virtual memory: about 1 GB Resident memory: 25 to 35 MB Storage on disk: about 50 MB Linux Docker host The agent has very low performance overhead on a host running Docker, with exact usage depending on the number of Docker containers your machine hosts, and whether those processes are long- or short-lived. Our benchmarks for this type of host are based on an Amazon EC2 t3.2xlarge: vCPUs: 8 vCPUs Memory: 32.0 GB Storage: 160.0 GB Number of containers: 25 containers, about 100 long-lived processes running in containers Operating system: CentOS 7 For this type of Docker host, typical usage is: CPU: about 0.8% Virtual memory: about 1 GB Resident memory: 25 to 35 MB Storage on disk: about 50 MB Windows host The agent has very low performance overhead on a typical Windows host serving web apps and running the Windows/IIS stack. Our benchmarks for this type of host are based on an Amazon EC2 t2.small: vCPUs: 1 Memory: 2.0 GB Storage: 30.0 GB Operating system: Windows Server 2012 R2 For this type of Windows host, typical usage is: CPU: 2 to 3% Resident Memory: 30 MB Storage on disk: about 50 MB Linux ARM64 host The agent has similar performance overhead on an ARM64 (Graviton 2) host on EC2 when compared with AMD64 machines. The benchmark is based on Amazon EC2 t3.2xlarge vs. t4g.2xlarge instances. Amazon Linux 2 EC2 instance with infrastructure agent default settings: CPU: about 0.1% on ARM vs 0.13% AMD Virtual memory: about 0.75GB ARM vs 1 GB AMD Resident memory: 20MB ARM vs 22 MB AMD We are always improving the performance of the infrastructure agent. If you see unusually high agent performance overhead, get support at support.newrelic.com. Manage data To learn how to adjust how much data our infrastructure monitoring ingests and reports, see Manage infrastructure data. Resource utilization On Linux systems, infrastructure is installed with default settings for each supported service manager. A memory limit of 1 Gigabyte is enforced. Please consider reviewing and adjusting the default configuration based on your system requirements.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 70.66263,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Manage <em>your</em> agent",
        "body": "The infrastructure agent is a lightweight piece of software, designed to minimize its impact on the performance of <em>your</em> hosts. However, the exact load varies depending on <em>your</em> host&#x27;s workload, particularly on the number of processes running on the host. This is because the agent collects detailed"
      },
      "id": "6043fa3464441f329a378f18"
    }
  ],
  "/docs/style-guide/writing-strategies/voice-strategies-docs-sound-new-relic": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2021-12-26T01:41:11Z",
      "title": "Collect data",
      "updated_at": "2021-12-22T01:38:12Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.73467,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Monitor your network devices with <em>New</em> <em>Relic</em>",
        "body": "Through our opensource agents or APIs, <em>New</em> <em>Relic</em> makes it easy to collect data from any source. The guides in this section provide <em>strategies</em> for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "image": "https://developer.newrelic.com/static/developer-champions-c61b7fb3b08d228679edab34b2d15a0e.jpg",
      "url": "https://developer.newrelic.com/developer-champion/",
      "sections": [
        "New Relic Developer Champions",
        "What do Developer Champions do?",
        "Open-source contributions",
        "Content creation",
        "Community engagement",
        "Why should you join and how will we support?",
        "Developer Champions benefits:"
      ],
      "published_at": "2021-12-25T01:50:50Z",
      "title": "New Relic Developers",
      "updated_at": "2020-12-04T01:45:02Z",
      "type": "developer",
      "external_id": "2cef9996dadc081ed4331e85992a4af9defc87ff",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Champions are the voice of the developer community. As experts and innovators, they are given the resources to not only share the newest product innovations and updates but also to provide feedback of the community back to New Relic product and engineering teams. Champions solve big problems using New Relic as their toolkit and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion What do Developer Champions do? New Relic Champions demonstrate expertise in using New Relic products by solving large problems and positioning New Relic as a central force in their strategies. The New Relic Champions is a recognition and partnership program designed to acknowledge the developers that are driving innovation within their companies and making top contributions to the developer community.They also commit to making their work public by: Open-source contributions Serving as an open-source author or maintainer for an accepted public project related to New Relic One Content creation Authoring two pieces of content in the New Relic Explorers Hub / Dev website Community engagement Delivering and/or organizing two events focused on an observability platform theme in which New Relic plays a crucial role Nominate a Developer Champion Why should you join and how will we support? As a benefit of being a Developer Champion, New Relic provides unique access to our Developer Advocacy team and the resources of our product organization, as well as specialized recognition and rewards. Developer Champions benefits: Formal, specialized access to the New Relic Product organization Champions have direct access to the New Relic’s Developer Ecosystem team Custom badge to wear with pride at events Public recognition on the New Relic Developer website and badging in the New Relic Explorers Hub as a Champion Exclusive Champion-only swag Early access program for some of our products (under NDA) Priority access to off-site FutureHack events (including when Lew is participating) Increased Explorer’s Hub support SLA Access to private Developer Champion Explorer’s Hub group",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.95264,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> Developer Champions",
        "body": "<em>New</em> <em>Relic</em> Champions are the <em>voice</em> of the developer community. As experts and innovators, they are given the resources to not only share the newest product innovations and updates but also to provide feedback of the community back to <em>New</em> <em>Relic</em> product and engineering teams. Champions solve big"
      },
      "id": "5efa993c64441fc2a25f7e65"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-strategies/organize-doc/",
      "sections": [
        "Organize your page",
        "Organize your page to make it easier to read",
        "Use action-oriented titles",
        "Start the document with an introductory paragraph",
        "Keep documents short",
        "Use the New Relic voice",
        "Change doc titles and anchors",
        "Create and edit categories",
        "Start writing and editing docs"
      ],
      "published_at": "2021-12-25T15:06:49Z",
      "title": "Organize your page",
      "updated_at": "2021-11-24T07:56:48Z",
      "type": "docs",
      "external_id": "a3e3c993c0bf65626e805676496bcae8ea8d2c64",
      "document_type": "page",
      "popularity": 1,
      "body": "These are some organization basics. Organize your page to make it easier to read Consider these organization guidelines when thinking about the order of information in a doc. By following these guidelines, you'll make it easier for readers to skim and find what they need. How to organize information Comments Separate what and why from how. Define any necessary prerequisites, policies, or background information (the what and the why) before you step through the how (step-by-step procedures). Examples: Explain what the feature is and why it matters before telling readers how to use it. Describe any limitations with user permissions or subscription levels that would prevent them from using the feature. If the feature is available for any user or subscription level, don't bother to say so. Provide a roadmap for what users will be able to accomplish, so they know before starting a procedure that they have everything they need. Front-load directions with context. Make sure readers know where they need to be, before telling them what to do. In general, use (select an app) to describe what users select from the product index. Examples: Go to one.newrelic.com > Explorer > (select an app or service). Select (account dropdown) > User preferences. On the command line, type gitk. Also, structure steps by front-loading context from the user's point of view. For example, instead of \"Go to x to do y,\" structure the step as \"To do y, go to x.\" Separate requirements from options. Example: Type the Email you use to sign in and to receive information from New Relic. Optional: Type additional user emails, separated by commas. Follow the \"five to nine\" guideline. Depending on the topic, organize the information so there is a maximum of five to nine chunks of information. For example, readers may start to get lost or overwhelmed after about five h2 sections or seven steps into a procedure. If you have more than nine h2 sections or steps, you might need to create an additional doc or procedure. Other organization tools to consider: Levels of headings Lists Collapsers Callouts Tables Code examples For more help section Use action-oriented titles Wherever possible, give your document or h2 heading a task- or action-oriented title. Focus on what users are trying to accomplish or the problem they're trying to solve. Use present-tense verbs, rather than \"-ing\" verbs. Quality Title example Bad The query history Okay View query history Good Query history: Create and edit NRQL queries Start the document with an introductory paragraph Unless the document is less than a single screen in length, begin with a brief paragraph that introduces the topic or summarizes the important points. Not sure where to start? Try writing all the content for your document first, and then add the introduction to the top to summarize your key points. Or use the introduction to expand on the text in your metaDescription in the metadata. Keep documents short The amount of content needed can help you decide whether you need one or more documents for the topic. If all of the document's contents apply directly to the title, then everything belongs in the same document. If several related sections could be logically split into individual documents, and the overall length of your document is more than about two screenfuls, split those sections into other documents. Be sure to include links to the related contents. If a large document needs to be broken into multiple smaller documents, consider whether they might be best grouped together in their own sub-category. Use the New Relic voice We strive for a voice that's approachable, expert, and visionary. Check out our voice guidelines for how to write content with these qualities. And keep in mind these essential writing tips that apply to any type of documentation. Guidelines Comments Be clear and direct. Remember to: Use present tense. Use active voice; avoid passive voice. Tell users what to do, not what they \"should\" do. If absolutely necessary, tell users what not to do in situations where unexpected results may occur. Whenever possible, provide an alternative suggestion when telling users what not to do. Example: Using active voice with an alternative suggestion for what not to do Do not use your config file to change this setting, because this could affect other processes. Instead, go to one.newrelic.com > APM > (select an app or service) > Settings > Application. Write to aid localization and translation. Do not use euphemisms, idioms, jargon, or slang. Use the same terms and wording consistently. If you need to include an abbreviation or acronym, spell it out the first time it appears in the document. Always take a moment to ask yourself whether people will really understand the terms you are using in the way you're using them. Change doc titles and anchors Because changes to doc titles, anchors, and redirects can break links to other docs, please create an issue to request these types of changes and we'll help you out with that. Create and edit categories Because changes to categories can affect large groups of docs at once, please create an issue to request these types of changes and we'll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see Create and edit content. To learn how to create and publish release notes, see Create release notes. To make it even easier to start a new doc, use templates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 65.08913,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use the <em>New</em> <em>Relic</em> <em>voice</em>",
        "body": " of <em>docs</em> at once, please create an issue to request these types of changes and we&#x27;ll help you out with that. Start writing and editing <em>docs</em> You are ready to start writing and editing <em>New</em> <em>Relic</em> <em>docs</em>! To learn the steps for basic <em>docs</em>, see Create and edit content. To learn how to create and publish release notes, see Create release notes. To make it even easier to start a <em>new</em> <em>doc</em>, use templates."
      },
      "id": "619df04028ccbc2730b9a00a"
    }
  ],
  "/docs/synthetics/index": [
    {
      "sections": [
        "Monitor private locations",
        "Prerequisites",
        "Private Minion dashboard JSON",
        "Tip",
        "Are my private minions online?",
        "Does my private location need more minions?",
        "Can I check the status of a specific minion directly?"
      ],
      "title": "Monitor private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "d38b5c957ec41b25199f4d093eb2f6083a5ff351",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/monitor-private-locations/",
      "published_at": "2021-12-25T18:33:22Z",
      "updated_at": "2021-12-15T12:32:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using synthetic monitoring's private locations with New Relic's alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic dashboards and NRQL alerts: Are my private minions online? Does my private location need more minions? Can I check the status of a specific minion directly? Prerequisites Before following the instructions in this guide, ensure you have: A synthetic private location At least one private minion installed at that location Checks scheduled to run at that location An alert policy for the private location, with a configured notification channel to notify your team when a violation occurs The following Private Minion dashboard example JSON can be imported to your account using: the Import a dashboard button the Dashboard API Private Minion dashboard JSON { \"name\": \"Synthetics Private Minions\", \"description\": \"Details on events from SyntheticPrivateLocationStatus, SyntheticsPrivateMinion, SyntheticCheck, SyntheticRequest, NrAuditEvent, plus a page for Performance Analysis.\", \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"SyntheticPrivateLocationStatus\", \"description\": \"Details on the private location queue.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 8, \"width\": 3 }, \"title\": \"pending checks by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(checksPending) FROM SyntheticsPrivateLocationStatus FACET name\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 4, \"width\": 9 }, \"title\": \"private location queue\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES max SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 5, \"height\": 4, \"width\": 9 }, \"title\": \"rate of queue growth\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(checksPending,1 minute),0) as 'queue growth rate' FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 9, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'PRIVATE_LOCATION' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticsPrivateMinion\", \"description\": \"Details on the minion instances.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 3 }, \"title\": \"private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(timestamp),uniqueCount(minionId) - 1 as 'restarts' from SyntheticsPrivateMinion since 2 days ago FACET minionLocation\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 3, \"width\": 7 }, \"title\": \"minion details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionId),latest(timestamp) as 'last seen',latest(minionStartTimestamp) as 'started',uniqueCount(minionId) - 1 as 'restarts',latest(minionIpv4),latest(minionJobsQueued),latest(minionJobsFinished),100*latest(minionJobsFailed)/latest(minionJobsQueued) as 'job failure rate',latest(minionJobsRunning),latest(minionJobsTimedout),latest(minionJobsSkipped),latest(minionJobsInternalEngineError),latest(minionWorkers),latest(minionProcessors),latest(minionPhysicalMemoryUsedBytes/(1024*1024*1024)) as 'used memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024)) as 'total memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024))/latest(minionWorkers) as 'memory (GiB) per heavy worker' FROM SyntheticsPrivateMinion FACET minionBuildNumber,minionLocation,minionOsVersion,minionContainerSystemVersion,minionHostname LIMIT 100 SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"minion instances over time\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' from SyntheticsPrivateMinion since 2 days ago TIMESERIES MAX \" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"CPU utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionProcessorsUsagePercentage) AS 'CPU load %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"memory utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryUsedPercentage) AS 'used memory %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"free memory (GiB)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryFreeBytes / (1024*1024*1024)) AS 'free (GiB)' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(minionJobsFinished,1 minute),0) FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"skipped jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsSkipped) as 'skipped jobs' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 2 weeks ago TIMESERIES MAX\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"count of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsInternalEngineError) as 'IEE',average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.stacked-bar\" }, \"layout\": { \"column\": 9, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"rate of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*average(minionJobsInternalEngineError)/average(minionJobsFailed) as 'IEE',100*(average(minionJobsFailed)-average(minionJobsInternalEngineError))/average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES AUTO SINCE 2 weeks ago\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticCheck\", \"description\": \"Details on job results.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 non-ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type != 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type = 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type = 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 6, \"width\": 6 }, \"title\": \"monitor details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(id) as 'results',uniqueCount(location)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET monitorName,monitorId,type LIMIT MAX\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 7, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 errors by monitor type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE error IS NOT NULL AND location NOT LIKE 'AWS%' FACET error,type TIMESERIES AUTO SINCE 2 weeks ago LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 10, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping duration with monitor count\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)',uniqueCount(monitorId) as 'monitor count' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job results\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET type TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type = 'SIMPLE' as 'ping',WHERE type != 'SIMPLE' as 'non-ping') TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 11, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type, result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type != 'SIMPLE' as 'non-ping',WHERE type = 'SIMPLE' as 'ping'),result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticRequest\", \"description\": \"Details on responses.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 6, \"width\": 5 }, \"title\": \"jobs per minion\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(jobId) as 'jobs' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' FACET location,minion,minionId\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 6, \"row\": 1, \"height\": 6, \"width\": 4 }, \"title\": \"top 5 error response codes\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(responseCode) as 'responses' FROM SyntheticRequest WHERE responseCode NOT IN (200,201,202,203,204,300,301,302,303,304) AND responseCode IS NOT NULL AND location NOT LIKE 'AWS%' FACET responseCode,responseStatus TIMESERIES AUTO LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 10, \"row\": 1, \"height\": 6, \"width\": 3 }, \"title\": \"job rate\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(jobId), 1 minute) as 'job rate' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'MONITOR' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"Performance Analysis\", \"description\": \"Determine if there are enough heavy worker threads.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"minions (hosts) by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"count of heavy worker threads and cpu cores\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionWorkers),latest(minionProcessors) FROM SyntheticsPrivateMinion FACET minionHostname,minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.markdown\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"\", \"rawConfiguration\": { \"text\": \"See [this Google sheet](https://docs.google.com/spreadsheets/d/1k2Aw11r6-S8pIpXQUINQZ0T5qlxS8iSwSo9t9GKDvzc/edit?usp=sharing) to assist in calculating how many workers will be needed based on the values on this page. This will help you to assess the required size of each host (scaling up) and how many hosts you need (scaling out).\\n\\nFor more info: \\nhttps://discuss.newrelic.com/t/relic-solution-scaling-and-rightsizing-for-the-cpm/123999\" }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'non-ping monitors' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping avg job duration and timeout\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average((nr.internalQueueDuration+nr.executionDuration)/1e3) FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location,cases(WHERE error NOT LIKE '%timeout%' as 'job duration (s)', WHERE error LIKE '%timeout%' as 'job timeout (s)') SINCE 2 days ago TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"job timeout rate by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*latest(minionJobsTimedout)/latest(minionJobsReceived) as 'job timeout rate' FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES AUTO SINCE 2 days ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Steps to import: Copy the Dashboard JSON and paste into a text editor. Replace \"accountId\": 1, with your New Relic account ID for each occurrence in the JSON code. Copy the Dashboard JSON from your text editor and import using one of the methods described above. Edit any charts that you'd like to use facet filtering with. Tip If your private locations exist in a parent account and Synthetics monitors in a sub account, insert the parent account ID for NRQL queries that use SyntheticPrivateLocationStatus and SyntheticsPrivateMinion, and the sub account ID for queries that use SyntheticCheck and SyntheticRequest. Are my private minions online? To answer this question, you can rely on attributes from the SyntheticsPrivateMinionevent. Private minions send this event to New Relic every 30 seconds. A simple way to check if your minions are online is to compare the unique count of minion IDs with the number of minions you expect to be online. To understand how many minions are reporting, run this example NRQL query: SELECT uniqueCount(minionId) FROM SyntheticsPrivateMinion WHERE minionLocation = '1-acme_okc_dc-309' Copy Using this query, you can create an alert condition to notify your team when fewer minions are reporting than expected. This condition is configured with a static threshold of 2 units, which means you will receive an alert if any of your minions are offline. You can verify that the alert policy works as expected by manually stopping one of your minions. Then, when the alert violation occurs, you will be notified by any notification channels that have been set up. Once the minion is restarted and it comes back online, the alert will recover. There are more robust ways to check whether minions are functioning correctly, but this query and condition simply and successfully handle the case where a machine fails, is accidentally decommissioned, or the minion process crashes. It also ensures that the minion can communicate with New Relic. Does my private location need more minions? To answer this question, you can use the checksPending attribute of the SyntheticsPrivateLocationStatus event. The checksPending attribute reflects the number of monitor checks that are scheduled (or \"queued\") but have yet to be accepted by a minion in the designated location. For a location with scheduled checks and no minions, this graph would grow linearly up and to the right. This metric is more complicated to monitor than uniqueCount(minionId) because a high value does not necessarily mean the location is in a bad state. As long as the metric is not growing linearly up and to the right (and checks are being run on schedule), the location is in a good state. This use case is perfect for baseline NRQL alert conditions, which allow you to monitor the deviation of a metric rather than its static value. For example: SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus WHERE name = '1-acme_tokyo_dc-512' Copy To test this alert condition, schedule one-minute, browser-based monitors to run from your location. Browser-based jobs consume more resources than ping jobs, which is why they are a better fit for load simulation. New Relic will quickly notify you of a growing number of pending checks. After doubling the number of minions to handle the load, the alert recovers. For example, using the Synthetics private location dashboard example, notice the growth and decline of pending checks over the course of the incident and recovery. By using the NRQL condition, New Relic will notify you if and when the location needs more minion capacity. Can I check the status of a specific minion directly? You can also check how a minion is operating by contacting it directly. You can use a set of HTTP endpoints exposed by the minion to determine what the application is doing. In order to access these endpoints, bind ports 8080 and 8180 to ports on the host. For example, for Docker, use docker run -p 80:8080 -p 81:8180 ...): :8080/status/check: Details about internal health-checks the minion performs; HTTP 200 means \"healthy.\" :8080/status: Details about a minion's status; the same data is then published to Insights as a SyntheticsPrivateMinion event. :8180/: JVM application admin endpoints; an advanced view of a minion's internal state. This approach is not as automated or flexible as the checksPending example. However, if you have total network connectivity failure, this manual approach can help troubleshoot the situation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 57.522736,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetics</em>",
        "body": " the Dashboard API Private Minion dashboard JSON { &quot;name&quot;: &quot;<em>Synthetics</em> Private Minions&quot;, &quot;description&quot;: &quot;Details on events from SyntheticPrivateLocationStatus, <em>Synthetics</em>PrivateMinion, SyntheticCheck, SyntheticRequest, NrAuditEvent, plus a page for Performance Analysis.&quot;, &quot;permissions"
      },
      "id": "604525f164441f7fd7378ef9"
    },
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-25T17:37:54Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 49.65421,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> monitoring",
        "sections": "User roles in <em>synthetic</em> monitoring",
        "tags": "<em>Synthetics</em>"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Synthetic monitoring: Aggregate monitor metrics",
        "View synthetic monitoring SLA reports",
        "Understand SLA report metrics",
        "Use page functions",
        "Generate SLA values"
      ],
      "title": "Synthetic monitoring: Aggregate monitor metrics",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "bbead36a5b36d126243f0beb2d60e9ccf23763f5",
      "image": "https://docs.newrelic.com/static/d0dc46884c112568daf4e491098e1951/c1b63/sla-report.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-aggregate-monitor-metrics/",
      "published_at": "2021-12-25T17:22:13Z",
      "updated_at": "2021-11-15T07:04:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View synthetic monitoring SLA reports To view your account-wide SLA report: Go to one.newrelic.com > Synthetics > SLA Report. Choose from reports aggregated by day, week, or month by selecting Daily, Weekly, or Monthly as appropriate. You can also view SLA reports for individual monitors: Go to one.newrelic.com > Synthetics > (select a monitor) > SLA. one.newrelic.com > Synthetics > SLA Report: Use SLA reports to understand your monitors' performance over time. Understand SLA report metrics Use SLA reports to view aggregated performance metrics for a single monitor, or for all your monitors from the account-wide SLA Reports page. SLA reports include the following metrics: Duration: The average duration across all monitor results. Uptime: The percentage of all monitor results that ended successfully. For example, Monitor A might check 50 times per day, and Monitor B might check 150 times per day. If Monitor A has 29 successes out of 50 and Monitor B has 148 successes out of 150, the Uptime would be 88.5: (29+148)/(50+150)=88.5 For individual SLA reports, the uptime score only includes the selected monitor. Apdex: The average Apdex across all monitors. Monitors have a default Apdex T of 7 seconds, but you can customize Apdex T for individual monitors by editing their settings. Apdex F, which defines a frustrating result, is always four times Apdex T. For more information about Apdex, see Apdex: Measuring user satisfaction. For individual SLA reports, the Apdex score only includes the selected monitor. % Satisfied: The percentage of monitor results which complete in a \"satisfying\" time. A satisfying time is defined as a monitor result that completes in Apdex T or less. % Toleration: The percentage of monitor results which complete in a \"tolerable\" time. A tolerable time is greater than Apdex T, but less than Apdex F (four times Apdex T). % Frustrated: The percentage of monitor results which complete in a \"frustrating\" time. A frustrating time is greater than Apdex F (four times Apdex T). The account-wide SLA report includes all monitor types (ping, simple browser, scripted browser, and API test). Use page functions SLA reports support the following features: If you want to... Do this... View the report in Excel or an external program Select Download this report as .csv to download a copy of your SLA data. Open the file in Excel, Google Drive, or another spreadsheet editor to analyze your data. Change your Apdex targets The default Apdex T for all monitors is 7 seconds. You can customize your Apdex T target for individual monitors by editing your monitor. Change the time frame Choose from daily, weekly, or monthly aggregation by selecting the appropriate tab. Make the report public Change the Public SLA setting to ON to allow non-authenticated users to view the report. Select Share Report to get the public URL to share. Generate SLA values The values in the SLA report are generated from Insights queries against the available synthetic monitoring data. You can easily recreate these values and modify the queries to meet your needs. This query returns the average duration, the apdex, and the uptime. Substitute your values for the variables highlighted and described below. SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod Copy Variable Value t: Supply the Apdex T that you would like to calculate your apdex against. The duration attribute in the SyntheticCheck event is stored in milliseconds, so an Apdex T value of 7 seconds should be included as 7000. timeperiod This is the period that you would like to calculate on. For a daily report, facet on dateOf(timestamp), for a weekly report facet on weekOf(timestamp) and for a monthly report facet on monthOf(timestamp). NRQL queries default to querying against the last hour of data. In order to widen the scope of your data you will need to include a SINCE clause at the end of your query. Example #1: Daily report for the last week To generate a daily report for the last week you would add SINCE 1 week ago: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET dateOf(timestamp) SINCE 1 week ago Copy Example #2: Report for a particular monitor To scope the results to a particular monitor you can edit the below query to include a specific monitor name: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName = 'mymonitorname' Copy Example #3: Report for multiple monitors To scope the results to a collection of monitors: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName IN ('mymonitor1', 'mymonitor2', 'mymonitor3') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 47.381577,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> monitoring: Aggregate monitor metrics",
        "sections": "<em>Synthetic</em> monitoring: Aggregate monitor metrics",
        "tags": "<em>Synthetics</em>",
        "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View synthetic monitoring SLA reports To view your account-wide SLA report: Go to one.newrelic.com &gt; <em>Synthetics</em>"
      },
      "id": "603ec399196a67e073a83d96"
    }
  ],
  "/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs": [
    {
      "sections": [
        "Synthetic monitoring: Aggregate monitor metrics",
        "View synthetic monitoring SLA reports",
        "Understand SLA report metrics",
        "Use page functions",
        "Generate SLA values"
      ],
      "title": "Synthetic monitoring: Aggregate monitor metrics",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "bbead36a5b36d126243f0beb2d60e9ccf23763f5",
      "image": "https://docs.newrelic.com/static/d0dc46884c112568daf4e491098e1951/c1b63/sla-report.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-aggregate-monitor-metrics/",
      "published_at": "2021-12-25T17:22:13Z",
      "updated_at": "2021-11-15T07:04:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View synthetic monitoring SLA reports To view your account-wide SLA report: Go to one.newrelic.com > Synthetics > SLA Report. Choose from reports aggregated by day, week, or month by selecting Daily, Weekly, or Monthly as appropriate. You can also view SLA reports for individual monitors: Go to one.newrelic.com > Synthetics > (select a monitor) > SLA. one.newrelic.com > Synthetics > SLA Report: Use SLA reports to understand your monitors' performance over time. Understand SLA report metrics Use SLA reports to view aggregated performance metrics for a single monitor, or for all your monitors from the account-wide SLA Reports page. SLA reports include the following metrics: Duration: The average duration across all monitor results. Uptime: The percentage of all monitor results that ended successfully. For example, Monitor A might check 50 times per day, and Monitor B might check 150 times per day. If Monitor A has 29 successes out of 50 and Monitor B has 148 successes out of 150, the Uptime would be 88.5: (29+148)/(50+150)=88.5 For individual SLA reports, the uptime score only includes the selected monitor. Apdex: The average Apdex across all monitors. Monitors have a default Apdex T of 7 seconds, but you can customize Apdex T for individual monitors by editing their settings. Apdex F, which defines a frustrating result, is always four times Apdex T. For more information about Apdex, see Apdex: Measuring user satisfaction. For individual SLA reports, the Apdex score only includes the selected monitor. % Satisfied: The percentage of monitor results which complete in a \"satisfying\" time. A satisfying time is defined as a monitor result that completes in Apdex T or less. % Toleration: The percentage of monitor results which complete in a \"tolerable\" time. A tolerable time is greater than Apdex T, but less than Apdex F (four times Apdex T). % Frustrated: The percentage of monitor results which complete in a \"frustrating\" time. A frustrating time is greater than Apdex F (four times Apdex T). The account-wide SLA report includes all monitor types (ping, simple browser, scripted browser, and API test). Use page functions SLA reports support the following features: If you want to... Do this... View the report in Excel or an external program Select Download this report as .csv to download a copy of your SLA data. Open the file in Excel, Google Drive, or another spreadsheet editor to analyze your data. Change your Apdex targets The default Apdex T for all monitors is 7 seconds. You can customize your Apdex T target for individual monitors by editing your monitor. Change the time frame Choose from daily, weekly, or monthly aggregation by selecting the appropriate tab. Make the report public Change the Public SLA setting to ON to allow non-authenticated users to view the report. Select Share Report to get the public URL to share. Generate SLA values The values in the SLA report are generated from Insights queries against the available synthetic monitoring data. You can easily recreate these values and modify the queries to meet your needs. This query returns the average duration, the apdex, and the uptime. Substitute your values for the variables highlighted and described below. SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod Copy Variable Value t: Supply the Apdex T that you would like to calculate your apdex against. The duration attribute in the SyntheticCheck event is stored in milliseconds, so an Apdex T value of 7 seconds should be included as 7000. timeperiod This is the period that you would like to calculate on. For a daily report, facet on dateOf(timestamp), for a weekly report facet on weekOf(timestamp) and for a monthly report facet on monthOf(timestamp). NRQL queries default to querying against the last hour of data. In order to widen the scope of your data you will need to include a SINCE clause at the end of your query. Example #1: Daily report for the last week To generate a daily report for the last week you would add SINCE 1 week ago: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET dateOf(timestamp) SINCE 1 week ago Copy Example #2: Report for a particular monitor To scope the results to a particular monitor you can edit the below query to include a specific monitor name: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName = 'mymonitorname' Copy Example #3: Report for multiple monitors To scope the results to a collection of monitors: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName IN ('mymonitor1', 'mymonitor2', 'mymonitor3') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.90604,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View <em>synthetic</em> <em>monitoring</em> SLA reports To view your account-wide SLA report: Go to one.newrelic.com &gt; <em>Synthetics</em>"
      },
      "id": "603ec399196a67e073a83d96"
    },
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-12-25T17:34:22Z",
      "updated_at": "2021-11-07T09:25:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. Avoid extra noise and get notified after three failures Read our blog post on the three strikes rule.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.86954,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures <em>page</em> To access your <em>monitor</em>&#x27;s failures: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Failures. Hover the mouse over a failure to get"
      },
      "id": "603e9efd64441faf344e8865"
    },
    {
      "sections": [
        "Synthetic monitoring: Understand load times",
        "View the Resources page",
        "Understand resource metrics",
        "View detailed resource metrics",
        "View individual resource loads",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Understand load times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "a6d91eef3b89f682ce06d4408928f0c8b70b90e6",
      "image": "https://docs.newrelic.com/static/fe6794ec2ba009717f08a91fae4841fc/8c557/resource-load.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-understand-load-times/",
      "published_at": "2021-12-25T17:02:20Z",
      "updated_at": "2021-10-31T07:59:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Resources page to understand the load time impact of each resource on your website. Use the resources load time, time spent by third parties, and irregular response codes graphs for a high-level overview, and use the resources list to identify high-impact resources such as large CSS files or images. You can also investigate a specific resource with detailed resource metrics, which aggregate performance information for a single resource. Go even deeper and view one load of that resource, using the exact request and response headers to pinpoint a performance issue. View the Resources page To access your monitor's Resources page: Go to one.newrelic.com > Synthetics > (select a monitor) > Resources. one.newrelic.com > Synthetics > (select a monitor) > Resources: Use the Resources page to analyze the performance of each resource on your website, and to access detailed metrics with individual resource loads. Understand resource metrics Use the Resources page to understand the performance impact of each resource on your website: Resources list: Lists the resources on your monitored website by average download time. Use this list to optimize your website's performance by reducing download times. You can also view the load time for any particular resource by searching for it in the Search all resources field. Select a resource to view individual resource metrics. Load time: Graphs the average load time for all resources, broken down by resource type (such as jpeg, json, or javascript). Use this graph to understand how the load time of your website changes over time. Time spent by third parties: Graphs the average load time of all third-party resources, such as web fonts, an embedded Twitter timeline, or an externally hosted image. Use this graph to see if third-party websites are affecting your website's performance. Irregular response codes: Graphs the number of negative HTTP response codes (also called HTTP status codes) received by the monitor. This graph includes all responses in the 300 (redirection), 400 (client error), and 500 (server error) ranges. It does not count responses in the 100 or 200 ranges. Synthetics also collects a number of custom response codes. By analyzing these metrics, you can track down troublesome resources and improve their performance. For example, an unoptimized logo image might cause slowdowns for every visitor of your site, while a tracker that is served only from a US-based server could result in slow performance for non-US visitors. View detailed resource metrics You can also view detailed metrics for each resource on your site. To view detailed metrics, locate a specific resource, or simply select an interesting resource from the Resources page. After selecting a resource, you can view overview metrics for that resource, or view an individual resource load: Max duration, Min duration, Avg duration: Load time metrics for this resource over the selected time frame. For 50% of requests: The maximum download time for the fastest 50% of requests. This means that 50% of requests for this resource were completed in the specified time or faster. For 95% of requests: The maximum download time for the fastest 95% of requests. This means that 95% of requests for this resource were completed in the specified time or faster. Average load time: Graphs the average load time for this resource over the selected time frame. Use this graph to verify that optimizations to your website (such as decreasing the size of an image or minifying your CSS) are working. You can also hide and unhide chart elements, filter by location, and sort the resource results list by Download time or DNS lookup. Mouse over the resource name to view the full path (useful with very long dynamically generated resource names). View individual resource loads After viewing detailed metrics for a particular resource, you can select an individual resource load for an in-depth understanding of one poor performance incident. You can then view a breakdown of the total connection time to understand where the issue occurred, and examine request and response headers. one.newrelic.com > Synthetics > (select a monitor) > Resources > (select a resource) > (select a resource load): Select an individual resource load to see a detailed breakdown of connection time, request headers, and response headers. Network timing structure taken from the HTTP Archive 1.2 specification. Use page functions The Resources page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select a sort option: Sort by Average download time to view your slowest-loading resources. Sort by Average size to view your largest resources. Hide and unhide chart elements Select chart elements to hide and unhide them. Locate a specific resource Enter part of your resource name in the Search all resources field (for example, search-icon.png or latest.json). Select the resource to view detailed metrics for that resource. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.10622,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Understand load times",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Understand load times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>page</em> To access your <em>monitor</em>&#x27;s Resources <em>page</em>: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Resources. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Resources: Use the Resources <em>page</em> to analyze the performance of each resource on your website, and to access detailed metrics"
      },
      "id": "604525b864441f0943378ebb"
    }
  ],
  "/docs/synthetics/new-relic-synthetics/synthetics-api/synthetics-rest-api-version-1": [
    {
      "sections": [
        "Payload attributes for the Synthetics REST API",
        "Synthetic monitoring attributes",
        "Specific monitor endpoint"
      ],
      "title": "Payload attributes for the Synthetics REST API",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "ed3202f6715ae367d5c7c58d63a332d073535995",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/payload-attributes-synthetics-rest-api/",
      "published_at": "2021-12-25T06:08:49Z",
      "updated_at": "2021-10-31T04:10:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For REST API requirements for synthetics, see Use the API. Synthetic monitoring attributes Here are the attributes that can be used when creating and managing monitors with the Synthetics REST API: Synthetics API attribute Definition apiVersion String: The version number. count Integer: The number of monitors returned. emails Array of strings: Email addresses for alert notifications with New Relic. frequency Integer: Number of minutes between checks. Valid values include 1, 5, 15, 30, 60, 360, 720, and 1440. id The UUID for the specific synthetic monitor. locations Array of strings: Array of locations by full label. name String: The monitor's name. scriptLocations String: The name and hmac values for private locations using Verified Script Execution. scriptText String: The BASE64 encoded text for scripted monitors. slaThreshold Double: Value for the Synthetics SLA report, in seconds. status String: Valid values include ENABLED, MUTED, and DISABLED. type String: Type of monitor. Valid values include: SIMPLE (Ping) BROWSER SCRIPT_BROWSER SCRIPT_API uri String: The URI for SIMPLE and BROWSER monitor types; for example, http://my-site.com. Optional for SCRIPT_BROWSER and SCRIPT_API. userID Integer: The specific user ID. options Object: options for SIMPLE and BROWSER monitor types. Options include: validationString: string verifySSL: boolean (true, false) bypassHEADRequest: boolean (true, false) treatRedirectAsFailure: boolean (true, false) Specific monitor endpoint When making REST API calls for a specific monitor, include the monitor_uuid as part of the endpoint. The monitor_uuid is the GUID which is part of the URL. For example, a selected synthetic monitor has this URL: https://synthetics.newrelic.com/accounts/nnnn/monitors/ab123-c456d-e78-90123-f45g Copy The monitor_uuid is the value that follows /monitors/.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.09857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Payload attributes for the <em>Synthetics</em> <em>REST</em> <em>API</em>",
        "sections": "Payload attributes for the <em>Synthetics</em> <em>REST</em> <em>API</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " <em>REST</em> <em>API</em> calls for a specific <em>monitor</em>, include the <em>monitor</em>_uuid as part of the endpoint. The <em>monitor</em>_uuid is the GUID which is part of the URL. For example, a selected synthetic <em>monitor</em> has this URL: https:&#x2F;&#x2F;<em>synthetics</em>.newrelic.com&#x2F;accounts&#x2F;nnnn&#x2F;monitors&#x2F;ab123-c456d-e78-90123-f45g Copy The <em>monitor</em>_uuid is the value that follows &#x2F;monitors&#x2F;."
      },
      "id": "6043f9ae28ccbc98002c607a"
    },
    {
      "sections": [
        "Manage synthetic monitors via REST API",
        "Features",
        "Monitor types in API",
        "Use the API",
        "Caution",
        "Get all monitors",
        "Get a specific monitor",
        "Create a monitor",
        "Update an existing monitor",
        "Patch an existing monitor",
        "Delete an existing monitor",
        "Get a list of valid locations",
        "Script API for scripted browser and API test monitors",
        "Get monitor script",
        "Add scripted monitor",
        "Update monitor script",
        "Using private location scripts with verified script execution",
        "Important",
        "Scripted browser example",
        "Scripted browser API example",
        "Bash script example",
        "Tip"
      ],
      "title": "Manage synthetic monitors via REST API",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "83a3e8ad751c7f0865785a1c2fad193604a7f7da",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/manage-synthetics-monitors-rest-api/",
      "published_at": "2021-12-25T06:08:49Z",
      "updated_at": "2021-09-14T18:17:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Synthetics REST API to create and manage synthetic monitors of all types: ping, simple browser, scripted browser, and API test monitors. All synthetic monitoring data is available via the REST API. To use the Synthetics REST API, you must have a user role that allows that capability and a user key. For an overview of all available New Relic APIs, see Intro to APIs. Features The newest version of the Synthetics API (v3) adds these features: Synthetics API (v3) Features Options field for POST and PUT request You can specify the options for SIMPLE and BROWSER type monitors, similar to the way these options are available in the UI. PATCH request You can update only the fields of a monitor you want to change, rather than having to specify the entire monitor entity in a PUT. You can also specify the OPTION, assuming you are using the appropriate type of monitor. More detail with 400 Bad Request errors As of v3, the Synthetics API attempts to return as much information as possible when a validation failure occurs. This will help you figure out what might be wrong with the request. The API runs all validations and returns any failed validation messages, rather than failing on the first validation error as occurred in previous API versions. Pagination Large API responses are properly paginated. You can also use NRQL queries to analyze past changes made via the API. Monitor types in API These are the monitor types and how they're referred to in the API: Monitor type API name Ping SIMPLE Simple browser BROWSER Scripted browser SCRIPT_BROWSER API test SCRIPT_API Use the API To use the Synthetics REST API, you must have the ability to manage synthetics monitors and use a user key (the REST API key won't work). This API can be used for all Synthetics monitors. (Additional API methods for scripted browser and API test monitors are also available to update the script associated with those monitors.) All Synthetics data is available via the API. API examples show cURL commands. For US-based accounts, use the following endpoint: https://synthetics.newrelic.com/synthetics/api Copy For EU-based accounts, use the following endpoint: https://synthetics.eu.newrelic.com/synthetics/api Copy Caution The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Get all monitors To view a list of all the monitors in your New Relic account, send a GET request to $API_ENDPOINT/v3/monitors. For example: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"monitors\": [ { \"id\": \"2a1bc369-7654-489d-918e-f6g135h7i2jk\", \"name\": \"monitor1\", \"type\": \"BROWSER\", \"frequency\": 60, \"uri\": \"http://example.com\", \"locations\": [ \"AWS_US_WEST_1\" ], \"status\": \"DISABLED\", \"slaThreshold\": 7, \"options\": {}, \"modifiedAt\": \"2016-09-26T23:12:46.981+0000\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"userId\": 0, \"apiVersion\": \"0.2.2\" } ], \"count\": 1 } Copy Query arguments: offset: The monitor count offset. Defaults to 0. For example, if you have 40 monitors and you use an offset value of 20, it will return monitors 21-40. limit: The number of results per page, maximum 100. Defaults to 50. You can include these in your cURL command as follows: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors \\ -G -d 'offset=20&limit=100' Copy The headers include a Link to help you easily page your monitors. For example: <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=0&limit=20>; rel=\"first\", <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=40&limit=20>; rel=\"last\" Copy Get a specific monitor To view a single Synthetics monitor, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } Copy An invalid monitor ID will return 404 Not Found: The specified monitor doesn't exist. Create a monitor To add a new monitor to your Synthetics account, send a POST request to $API_ENDPOINT/v3/monitors with a JSON payload that describes the monitor. All fields in the following example are required unless stated otherwise: { \"name\": string [required], \"type\": string (SIMPLE, BROWSER, SCRIPT_API, SCRIPT_BROWSER) [required], \"frequency\": integer (minutes) [required, must be one of 1, 5, 10, 15, 30, 60, 360, 720, or 1440], \"uri\": string [required for SIMPLE and BROWSER type], \"locations\": array of strings [at least one required], \"status\": string (ENABLED, MUTED, DISABLED) [required], \"slaThreshold\": double, \"options\": { \"validationString\": string [only valid for SIMPLE and BROWSER types], \"verifySSL\": boolean (true, false) [only valid for SIMPLE and BROWSER types], \"bypassHEADRequest\": boolean (true, false) [only valid for SIMPLE types], \"treatRedirectAsFailure\": boolean (true, false) [only valid for SIMPLE types] } } Copy In addition, to add the script for a scripted monitor via the REST API, call an additional API endpoint to send the script for the monitor just created. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Replace the Synthetics REST API attributes in the following example with your specific values: curl -v \\ -X POST -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors \\ -d '{ \"name\" : \"monitor1\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"type\" : \"browser\", \"status\" : \"enabled\", \"slaThreshold\" : \"1.0\"}' Copy A successful request will return a 201 Created response, with the URI of the newly-created monitor specified in the location header. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example: the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 402 Payment Required: Creating the monitor will increase your scheduled checks past your account's purchased check limit. Update an existing monitor To update an existing monitor in New Relic, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. In addition, for scripted monitors, follow the procedures to update the BASE64 encoded script. All fields are required. However, the TYPE of the monitor cannot be changed. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PUT -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\", \"type\": \"monitor type\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com/\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"status\" : \"enabled\", \"slaThreshold\": \"7.0\" }' Copy PUT requests are intended to replace target entities, so all attributes required in the JSON payload when creating a new monitor are also required when updating an existing monitor. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Patch an existing monitor To patch an existing monitor in New Relic, send a PATCH request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PATCH -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\" }' Copy PATCH requests are intended to update individual attributes of your New Relic Synthetics monitor rather than updating the entire entity, so you may provide only the attributes you want to update. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds, or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Delete an existing monitor To delete an existing monitor in New Relic Synthetics, send a DELETE request to $API_ENDPOINT/v3/monitors/$MONITOR_ID: curl -v \\ -H 'Api-Key:$API_KEY' \\ -X DELETE $API_ENDPOINT/v3/monitors/$MONITOR_ID Copy A successful request will return a 204 No Content response, with an empty body. An unsuccessful request will return the response 404 Not Found: The specified monitor does not exist. Get a list of valid locations To retrieve the list of valid locations in New Relic Synthetics, use the following command: curl -v \\ -X GET -H 'Api-Key:$API_KEY' $API_ENDPOINT/v1/locations Copy Script API for scripted browser and API test monitors In addition to the general API, there are several API methods for the scripted browsers (SCRIPT_BROWSER) and API test browsers (SCRIPT_API). These examples show cURL commands. Get monitor script To view the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script. For example: curl -v -H 'Api-Key: $API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID/script Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"scriptText\": BASE64 encoded string } Copy Possible error codes include: 403 Forbidden: The specified monitor is not of type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor doesn't exist or the script associated with the monitor doesn't exist. Add scripted monitor To add a new scripted monitor to New Relic Synthetics with the REST API: Follow standard API procedures to add a new monitor, and identify the type as a SCRIPT_BROWSER or SCRIPT_API. Update the new monitor with a BASE64 encoded version of the script to the $MONITOR_UUID/script endpoint. For more information, refer to the example. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Update monitor script To update the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script with a JSON payload that contains the scriptText (required). scriptPayload='{\"scriptText\":BASE64 encoded string}' curl -v -X PUT \\ -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' \\ $API_ENDPOINT/v3/monitors/$MONITOR_UUID/script \\ -d $scriptPayload Copy If you are using private locations with verified script execution enabled, see script locations with verified script execution. A successful request will return a 204 No Content response with an empty body. Possible error codes include: 400 Bad Request: Invalid BASE64 encoded string for scriptText or hmac. 403 Forbidden: The specified monitor is not of the type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor does not exist. Using private location scripts with verified script execution When creating or updating monitors for private locations that have verified script execution turned on, you must use scriptLocations to set the password: { \"scriptText\": BASE64 encoded String, \"scriptLocations\": [ { \"name\": Location name, \"hmac\" BASE64 encoded String of SHA256 HMAC for location } ] } Copy The password used to generate the HMAC string must match the password set for the private location. If you have multiple locations with Verified script execution enabled each location must have the HMAC calculated. When generating the HMAC string, use the SHA256 algorithm with the script and password. Here's an example for the script: var assert = require('assert'); assert.equal('1', '1'); Copy This example uses password as the password for the scriptLocation: curl -v -X PUT -H 'Api-Key: '$API_KEY' -H 'content-type: application/json' $API_ENDPOINT}/v3/monitors/$MONITOR_ID/script -d '{ \"scriptText\": \"dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOw0KYXNzZXJ0LmVxdWFsKCcxJywgJzEnKTs=\",\"scriptLocations\": [ { \"name\": \"my_vse_enabled_location\", \"hmac\": \"MjhiNGE4MjVlMDE1N2M4NDQ4MjNjNDFkZDEyYTRjMmUzZDE3NGJlNjU0MWFmOTJlMzNiODExOGU2ZjhkZTY4ZQ==\"} ]}' Copy Important You must remove the last newline character from both the script and the calculated HMAC value before encoding in BASE64. Calculation steps: Calculate the HMAC value from the script. One way is to use: cat script | openssl dgst -sha256 -hmac \"password\" > hmac Remove the newline character if one was added by openssl. Encode the HMAC in BASE64 without line breaks. Scripted browser example Here is an example of using New Relic's REST API and the bash script to create a scripted browser monitor. Scripted browser API example The following example shows cURL commands to create a scripted browser monitor. At the top of the script, replace the variables with your specific values. For the scriptfile variable, identify the filename for the script to be created. Here is a sample script that can be saved as sample_synth_script.js to use in the example: var assert = require(\"assert\"); $browser.get(\"http://example.com\").then(function(){ // Check the H1 title matches \"Example Domain\" return $browser.findElement($driver.By.css(\"h1\")).then(function(element){ return element.getText().then(function(text){ assert.equal(\"Example Domain\", text, \"Page H1 title did not match\"); }); }); }).then(function(){ // Check that the external link matches \"http://www.iana.org/domains/example\" return $browser.findElement($driver.By.css(\"div > p > a\")).then(function(element){ return element.getAttribute(\"href\").then(function(link){ assert.equal(\"http://www.iana.org/domains/example\", link, \"More information link did not match\"); }); }); }); Copy Bash script example This example shows the bash script that will create the SCRIPTED_BROWSER monitor. Tip In some cases you may want to use -w 0, which will disable line wrapping: base64 -w 0 $scriptfile #!/bin/bash # API key from your account settings API_KEY='' # Other attributes found at https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/attributes-synthetics-rest-api#api-attributes monitorName='Test API Script' monitorType='SCRIPT_BROWSER' frequency=1440 locations='\"AWS_US_WEST_1\", \"AWS_US_EAST_1\"' slaThreshold=7.0 # Location of the file with your script scriptfile=sample_synth_script.js # Test that the script file exists (does not validate content) if [ -e \"$scriptfile\" ] then script=$(cat \"$scriptfile\") payload=\"{ \\\"name\\\" : \\\"$monitorName\\\", \\\"frequency\\\" : $frequency, \\\"locations\\\" : [ $locations ], \\\"status\\\" : \\\"ENABLED\\\", \\\"type\\\" : \\\"$monitorType\\\", \\\"slaThreshold\\\" : $slaThreshold, \\\"uri\\\":\\\"\\\"}\" echo \"Creating monitor\" # Make cURL call to API and parse response headers to get monitor UUID shopt -s extglob # Required to trim whitespace; see below while IFS=':' read key value; do # trim whitespace in \"value\" value=${value##+([[:space:]])}; value=${value%%+([[:space:]])} case \"$key\" in location) LOCATION=\"$value\" ;; HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\" ;; esac done < <(curl -sS -i -X POST -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' https://synthetics.newrelic.com/synthetics/api/v3/monitors -d \"$payload\") # Validate monitor creation & add script unless it failed if [ $STATUS = 201 ]; then echo \"Monitor created, $LOCATION \" echo \"Uploading script\" # base64 encode script encoded=`echo \"$script\" | base64` scriptPayload=\"{\\\"scriptText\\\":\\\"$encoded\\\"}\" curl -s -X PUT -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' \"$LOCATION/script\" -d $scriptPayload echo \"Script uploaded\" else echo \"Monitor creation failed\" fi else echo \"script file not found, not creating monitor\" fi Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.16827,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>synthetic</em> <em>monitors</em> via <em>REST</em> <em>API</em>",
        "sections": "Manage <em>synthetic</em> <em>monitors</em> via <em>REST</em> <em>API</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " will disable line wrapping: base64 -w 0 $scriptfile #!&#x2F;bin&#x2F;bash # <em>API</em> key from your account settings <em>API</em>_KEY=&#x27;&#x27; # Other attributes found at https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>apis</em>&#x2F;<em>synthetics</em>-<em>rest</em>-<em>api</em>&#x2F;<em>monitor</em>-<em>examples</em>&#x2F;attributes-<em>synthetics</em>-<em>rest</em>-<em>api</em>#<em>api</em>-attributes <em>monitor</em>Name=&#x27;Test <em>API</em> Script&#x27; <em>monitor</em>"
      },
      "id": "60440d4628ccbc74532c606a"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "APIs for data ingest",
        "NerdGraph (GraphQL)",
        "REST API",
        "APIs by feature",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-12-25T04:32:43Z",
      "updated_at": "2021-12-19T15:29:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Send data to New Relic. Retrieve data from New Relic. View and configure settings. This document provides examples and reference information for our APIs. APIs for data ingest Our four primary data ingest APIs are some of the many solutions for reporting data to New Relic. These APIs can be used directly, but they're also the underlying ingest route for any of our tools that use those APIs (for example, our OpenTelemetry integration, or our Telemetry SDKs). API type Description Metric API Send dimensional metrics to New Relic from any source (including other telemetry monitoring services). Event API Send custom event data to New Relic without the use of an agent or integration. Log API Send log data to New Relic. Trace API Send distributed tracing data (also referred to as \"spans\") to New Relic without the use of an agent or integration. NerdGraph (GraphQL) NerdGraph is the API we recommend for querying New Relic data, querying account information, and making a range of feature configurations. To learn what you can do, check out the NerdGraph tutorials. NerdGraph is our newest API and is our attempt to bring together in one place some of our older APIs, like our REST API. Note that there is still some functionality you can do with REST APIs that can't yet be done with NerdGraph, and this is why some New Relic organizations still use the REST API. REST API Our REST API is our older API for querying and configuration, which NerdGraph is in the process of replacing. The REST API has some configuration abilities that NerdGraph doesn't yet have, but when possible you should use NerdGraph. The REST API can be used for a wide range of features: for detail, see APIs by feature. APIs by feature New Relic tools and features, like APM, infrastructure monitoring, browser monitoring, and alerts, are often used together, and sometimes can overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use NerdGraph. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The browser API resources include: Resource Details Browser agent API Use the browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To query New Relic data, use NerdGraph. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To query New Relic data, use NerdGraph. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To query New Relic data, use NerdGraph. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To query New Relic data, use NerdGraph. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage (original pricing model) For organizations on our original pricing model, you can use NerdGraph to query subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API If you're a New Relic partnership organization, you can use the Partner API to retrieve data and make configurations. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing models that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API Our Insights Query API is mostly deprecated. Instead, use NerdGraph for querying your New Relic data. Dashboard API Use the Dashboards API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.26544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>APIs</em>",
        "sections": "<em>REST</em> <em>API</em>",
        "tags": "<em>APIs</em>",
        "body": " rate data. Manage New Relic alerts conditions for your mobile apps. Query <em>API</em> To query New Relic data, use NerdGraph. Account management <em>APIs</em> For account-related <em>APIs</em>, see Account <em>APIs</em>. Synthetic monitoring <em>Synthetics</em> <em>API</em> resources include: Resource Details <em>Synthetics</em> <em>REST</em> <em>API</em> The <em>Synthetics</em> <em>REST</em>"
      },
      "id": "609fa5cf196a67066022b194"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring": [
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-25T17:37:54Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.435,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Synthetic monitor public minion IPs",
        "IP addresses are not personal data",
        "Daily JSON listings for IP addresses",
        "Important",
        "Tip",
        "Public minion locations and location labels"
      ],
      "title": "Synthetic monitor public minion IPs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "773534b4f076c3b421b6e0ca0dfc26f1e1ef6f73",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/",
      "published_at": "2021-12-25T17:07:19Z",
      "updated_at": "2021-08-08T21:09:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic uses a group of minions to execute your synthetic monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses are publicly available in JSON format, so you can easily read and parse them. Recommendation: For easier maintenance, use these options: Automate your rules for your allow list based on these files. Add the IP addresses to your allow list by using a custom header. IP addresses are not personal data Minions are deployed on servers, and the agents are expected to be activated using non-personal credentials. IP addresses associated with minions running on servers are not personal data under data protection and privacy laws. For more information, see the Synthetic's security documentation. Daily JSON listings for IP addresses IP addresses for released locations are subject to change. If a change is needed, we'll attempt to proactively notify customers prior to any changes via e-mail. You can also check the Explorers Hub for updates. Important Synthetics is adding new IP addresses on July 15 2021. Tip In the S3 URL paths for this feature, production represents US-based accounts and eu represents EU-based accounts. US accounts IP-only list DNS name-only list IP and DNS name list EU accounts IP-only list DNS name-only list IP and DNS name list Public minion locations and location labels The following table cross-references the synthetic's public minion locations with their location labels. You can query the location and locationLabel attributes from the SyntheticCheck and SyntheticRequest events. Public minion location Location label AWS_AP_EAST_1 \"Hong Kong, HK\" AWS_AP_SOUTH_1 \"Mumbai, IN\" AWS_AP_SOUTHEAST_1 \"Singapore, SG\" AWS_AP_NORTHEAST_2 \"Seoul, KR\" AWS_AP_NORTHEAST_1 \"Tokyo, JP\" AWS_AP_SOUTHEAST_2 \"Sydney, AU\" AWS_US_WEST_1 \"San Francisco, CA, USA\" AWS_US_WEST_2 \"Portland, OR, USA\" AWS_US_EAST_2 \"Columbus, OH, USA\" AWS_US_EAST_1 \"Washington, DC, USA\" AWS_CA_CENTRAL_1 \"Montreal, Québec, CA\" AWS_SA_EAST_1 \"São Paulo, BR\" AWS_EU_WEST_1 \"Dublin, IE\" AWS_EU_WEST_2 \"London, England, UK\" AWS_EU_WEST_3 \"Paris, FR\" AWS_EU_CENTRAL_1 \"Frankfurt, DE\" AWS_EU_NORTH_1 \"Stockholm, SE\" AWS_EU_SOUTH_1 \"Milan, IT\" AWS_ME_SOUTH_1 \"Manama, BH\" AWS_AF_SOUTH_1 \"Cape Town, ZA\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.9277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "sections": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "New Relic uses a group of minions to execute your <em>synthetic</em> monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses"
      },
      "id": "6045257d28ccbcdc552c60a5"
    },
    {
      "sections": [
        "Upcoming synthetic monitor public minion IP addresses",
        "US public minions: Upcoming IP addresses",
        "EU public minions: Upcoming IP addresses"
      ],
      "title": "Upcoming synthetic monitor public minion IP addresses",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "81c0e0d3f87a627ad01f220f215f7b848f54608d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/new-synthetic-public-minion-ips/",
      "published_at": "2021-12-25T16:54:52Z",
      "updated_at": "2021-04-04T20:14:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "On July 15 2021, we'll be adding new IP addresses for several synthetics locations for both US locations and EU locations. To ensure your monitors are not affected by these changes, please add the appropriate IP addresses to your firewalls allow list. For the current list of IP addresses and more about this topic, see Synthetic monitor public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 54.250.11.193 3.113.102.86 52.193.74.189 18.177.40.17 ec2-54-250-11-193.ap-northeast-1.compute.amazonaws.com ec2-3-113-102-86.ap-northeast-1.compute.amazonaws.com ec2-52-193-74-189.ap-northeast-1.compute.amazonaws.com ec2-18-177-40-17.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 3.34.173.249 52.79.48.153 ec2-3-34-173-249.ap-northeast-2.compute.amazonaws.com ec2-52-79-48-153.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 65.1.222.35 ec2-65-1-222-35.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 52.76.41.181 54.179.195.220 18.138.16.42 ec2-52-76-41-181.ap-southeast-1.compute.amazonaws.com ec2-54-179-195-220.ap-southeast-1.compute.amazonaws.com ec2-18-138-16-42.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 3.96.243.128 3.97.226.155 ec2-3-96-243-128.ca-central-1.compute.amazonaws.com ec2-3-97-226-155.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.94.27.80 18.229.241.206 ec2-54-94-27-80.sa-east-1.compute.amazonaws.com ec2-18-229-241-206.sa-east-1.compute.amazonaws.com AWS_US_WEST_2 \"Portland, OR, USA\" 44.236.111.66 54.203.108.135 ec2-44-236-111-66.us-west-2.compute.amazonaws.com ec2-54-203-108-135.us-west-2.compute.amazonaws.com EU public minions: Upcoming IP addresses The following table lists the upcoming IP addresses that will be added to public minions on July 15 2021 for EU customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 35.72.129.240 35.73.187.89 ec2-35-72-129-240.ap-northeast-1.compute.amazonaws.com ec2-35-73-187-89.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 13.125.155.211 15.164.119.0 ec2-13-125-155-211.ap-northeast-2.compute.amazonaws.com ec2-15-164-119-0.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 15.207.93.61 ec2-15-207-93-61.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 3.0.28.216 ec2-3-0-28-216.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 99.79.17.185 ec2-99-79-17-185.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.207.198.234 ec2-54-207-198-234.sa-east-1.compute.amazonaws.com",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.3917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "sections": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " about this topic, see <em>Synthetic</em> <em>monitor</em> public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses"
      },
      "id": "606a1e4364441fbec2617a7c"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/identify-synthetic-monitoring-requests-your-app": [
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-25T17:37:54Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.435,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Synthetic monitor public minion IPs",
        "IP addresses are not personal data",
        "Daily JSON listings for IP addresses",
        "Important",
        "Tip",
        "Public minion locations and location labels"
      ],
      "title": "Synthetic monitor public minion IPs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "773534b4f076c3b421b6e0ca0dfc26f1e1ef6f73",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/",
      "published_at": "2021-12-25T17:07:19Z",
      "updated_at": "2021-08-08T21:09:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic uses a group of minions to execute your synthetic monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses are publicly available in JSON format, so you can easily read and parse them. Recommendation: For easier maintenance, use these options: Automate your rules for your allow list based on these files. Add the IP addresses to your allow list by using a custom header. IP addresses are not personal data Minions are deployed on servers, and the agents are expected to be activated using non-personal credentials. IP addresses associated with minions running on servers are not personal data under data protection and privacy laws. For more information, see the Synthetic's security documentation. Daily JSON listings for IP addresses IP addresses for released locations are subject to change. If a change is needed, we'll attempt to proactively notify customers prior to any changes via e-mail. You can also check the Explorers Hub for updates. Important Synthetics is adding new IP addresses on July 15 2021. Tip In the S3 URL paths for this feature, production represents US-based accounts and eu represents EU-based accounts. US accounts IP-only list DNS name-only list IP and DNS name list EU accounts IP-only list DNS name-only list IP and DNS name list Public minion locations and location labels The following table cross-references the synthetic's public minion locations with their location labels. You can query the location and locationLabel attributes from the SyntheticCheck and SyntheticRequest events. Public minion location Location label AWS_AP_EAST_1 \"Hong Kong, HK\" AWS_AP_SOUTH_1 \"Mumbai, IN\" AWS_AP_SOUTHEAST_1 \"Singapore, SG\" AWS_AP_NORTHEAST_2 \"Seoul, KR\" AWS_AP_NORTHEAST_1 \"Tokyo, JP\" AWS_AP_SOUTHEAST_2 \"Sydney, AU\" AWS_US_WEST_1 \"San Francisco, CA, USA\" AWS_US_WEST_2 \"Portland, OR, USA\" AWS_US_EAST_2 \"Columbus, OH, USA\" AWS_US_EAST_1 \"Washington, DC, USA\" AWS_CA_CENTRAL_1 \"Montreal, Québec, CA\" AWS_SA_EAST_1 \"São Paulo, BR\" AWS_EU_WEST_1 \"Dublin, IE\" AWS_EU_WEST_2 \"London, England, UK\" AWS_EU_WEST_3 \"Paris, FR\" AWS_EU_CENTRAL_1 \"Frankfurt, DE\" AWS_EU_NORTH_1 \"Stockholm, SE\" AWS_EU_SOUTH_1 \"Milan, IT\" AWS_ME_SOUTH_1 \"Manama, BH\" AWS_AF_SOUTH_1 \"Cape Town, ZA\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.9277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "sections": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "New Relic uses a group of minions to execute your <em>synthetic</em> monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses"
      },
      "id": "6045257d28ccbcdc552c60a5"
    },
    {
      "sections": [
        "Compare page load performance in browser and synthetic monitoring",
        "Compare performance and trends",
        "What you need",
        "Enable comparison data",
        "Enable comparative charting from Synthetics UI",
        "Enable comparative charting from browser monitoring UI",
        "View comparison data",
        "Hide or return comparison data",
        "Data sources"
      ],
      "title": "Compare page load performance in browser and synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "a789c407a0fecbd2ce888fdee7805abe8152f0a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring/",
      "published_at": "2021-12-25T17:13:10Z",
      "updated_at": "2021-07-09T23:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring regularly checks your websites, critical business transactions, and API endpoints to measure optimal performance. Browser monitoring tracks the actual results of webpage performance across all variations of devices, browsers, and connection speeds. Used together, they provide a direct page load time comparison between real user (browser) interactions and the synthetic monitors. Compare performance and trends New Relic's comparative charting feature helps operations managers and teams by providing: Benchmarks for page load times Additional insights to help you plan where to optimize your site Comparisons of synthetic trends vs. actual browser performance without needing to switch between our monitoring capabilities. For example, during a page outage, you can compare synthetic monitoring trends to actual browser monitoring comparisons to see if an issue is also visible in Synthetics UI, or if it is caused by variables outside of New Relic. This helps you more efficiently know where to take action. What you need The comparative charting feature requires: Browser monitoring enabled with the browser SPA agent (version 885 or higher). A synthetic browser or scripted monitor with one or more tests on the same URLs monitored by the browser agent. After you enable the comparative charting feature either from synthetic or from browser monitoring, no additional setup is required. The comparative charting feature will appear when New Relic finds matching URLs. Enable comparison data After you enable the comparative charting feature from either synthetic or browser monitoring, no additional setup is required. The comparative charting feature will appear whenever synthetics or browser monitoring finds matching URLs. Enable comparative charting from Synthetics UI To enable the comparative charting feature from Synthetics UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. Above the selected monitor's Availability chart, select the ellipsis icon. Select Enable Synthetics comparison. Enable comparative charting from browser monitoring UI To enable the comparison data feature from browser monitoring: Go to one.newrelic.com > Browser > (select a browser app) > Page views. Select a page monitored by synthetic monitoring. From the selected page's Performance tab, select the ellipsis icon. Select Enable Synthetics comparison. View comparison data The comparative charting feature appears whenever synthetic monitoring identifies a URL match with browser monitoring and can compare it. You can compare browser and synthetic's performance either from the synthetic monitoring Summary page or from the browser monitoring Page views page (for browser apps or single page apps) without needing to switch between New Relic capabilities. Based on the selected data sources, the summary shows: Overall speed percentage comparison between browser (real user) page views and any matching URLs found in synthetic monitors that the user has permissions to view Number of URLs found in synthetic monitors that match the browser rollup URL To view the comparative charting summary: From synthetic monitoring UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. OR From browser monitoring UI: Go to one.newrelic.com > Browser > (select a browser app) > Page views, then select a page monitored by synthetic monitoring. Review the comparative charting feature's summary of overall speed percentage and number of matching URLs. To view additional details, select the summary's right arrow icon. Please note that in some cases the simple browser monitor ends before the browser agent has had a chance to collect the BrowserInteraction event. In this case, no comparative charting data is displayed in the UI. In order to resolve this issue, create a scripted browser monitor instead, and add a call to wait (sleep) after the page is loaded. Here is an example: $browser.get('https://www.mywebsite.com').then(function(){ return $browser.sleep(1000); }) Copy Hide or return comparison data To hide the comparative charting feature, select the ellipsis icon. To keep it visible but move it away from the top of the page, select Move to bottom. To return it to its original place on the page, select Move to top. To remove it from the page, select Hide all Synthetics/Browser comparisons. To return it to the page after removing it, follow standard procedures to enable comparison charting. Data sources New Relic uses these data sources for the synthetics and browser comparison in the UI. For deeper analysis of the comparative chart data you see in the UI, use the query builder to run NRQL queries. Variable Description Monitor account ID The account from which you are running the monitor: SELECT monitorAccountId FROM BrowserInteraction Copy Monitor ID The unique ID assigned to your synthetic monitor: SELECT monitorId FROM BrowserInteraction Copy Monitor job ID The ID of a single synthetics monitor run, which began at a specific time and originated from a specific location: SELECT monitorJobId FROM BrowserInteraction LIMIT 1 Copy Real user average The average page load time for real users viewing your website (excludes synthetic monitors). Real user page views Page view details coming from visitors to your website (exclude synthetic monitors). Synthetic's average The average page load time from the synthetic simple or scripted monitors that ran on your website. Synthetic's page views Only traffic generated by synthetic simple or scripted monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.26802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "sections": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " permissions to view Number of URLs found in <em>synthetic</em> monitors that match the browser rollup URL To view the comparative charting summary: From <em>synthetic</em> <em>monitoring</em> UI: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Summary. OR From browser <em>monitoring</em> UI: Go to one.newrelic.com &gt; Browser"
      },
      "id": "604525b7e7b9d251f85799e1"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/new-synthetic-public-minion-ips": [
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-25T17:37:54Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.43498,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Synthetic monitor public minion IPs",
        "IP addresses are not personal data",
        "Daily JSON listings for IP addresses",
        "Important",
        "Tip",
        "Public minion locations and location labels"
      ],
      "title": "Synthetic monitor public minion IPs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "773534b4f076c3b421b6e0ca0dfc26f1e1ef6f73",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/",
      "published_at": "2021-12-25T17:07:19Z",
      "updated_at": "2021-08-08T21:09:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic uses a group of minions to execute your synthetic monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses are publicly available in JSON format, so you can easily read and parse them. Recommendation: For easier maintenance, use these options: Automate your rules for your allow list based on these files. Add the IP addresses to your allow list by using a custom header. IP addresses are not personal data Minions are deployed on servers, and the agents are expected to be activated using non-personal credentials. IP addresses associated with minions running on servers are not personal data under data protection and privacy laws. For more information, see the Synthetic's security documentation. Daily JSON listings for IP addresses IP addresses for released locations are subject to change. If a change is needed, we'll attempt to proactively notify customers prior to any changes via e-mail. You can also check the Explorers Hub for updates. Important Synthetics is adding new IP addresses on July 15 2021. Tip In the S3 URL paths for this feature, production represents US-based accounts and eu represents EU-based accounts. US accounts IP-only list DNS name-only list IP and DNS name list EU accounts IP-only list DNS name-only list IP and DNS name list Public minion locations and location labels The following table cross-references the synthetic's public minion locations with their location labels. You can query the location and locationLabel attributes from the SyntheticCheck and SyntheticRequest events. Public minion location Location label AWS_AP_EAST_1 \"Hong Kong, HK\" AWS_AP_SOUTH_1 \"Mumbai, IN\" AWS_AP_SOUTHEAST_1 \"Singapore, SG\" AWS_AP_NORTHEAST_2 \"Seoul, KR\" AWS_AP_NORTHEAST_1 \"Tokyo, JP\" AWS_AP_SOUTHEAST_2 \"Sydney, AU\" AWS_US_WEST_1 \"San Francisco, CA, USA\" AWS_US_WEST_2 \"Portland, OR, USA\" AWS_US_EAST_2 \"Columbus, OH, USA\" AWS_US_EAST_1 \"Washington, DC, USA\" AWS_CA_CENTRAL_1 \"Montreal, Québec, CA\" AWS_SA_EAST_1 \"São Paulo, BR\" AWS_EU_WEST_1 \"Dublin, IE\" AWS_EU_WEST_2 \"London, England, UK\" AWS_EU_WEST_3 \"Paris, FR\" AWS_EU_CENTRAL_1 \"Frankfurt, DE\" AWS_EU_NORTH_1 \"Stockholm, SE\" AWS_EU_SOUTH_1 \"Milan, IT\" AWS_ME_SOUTH_1 \"Manama, BH\" AWS_AF_SOUTH_1 \"Cape Town, ZA\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.9277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "sections": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "New Relic uses a group of minions to execute your <em>synthetic</em> monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses"
      },
      "id": "6045257d28ccbcdc552c60a5"
    },
    {
      "sections": [
        "Compare page load performance in browser and synthetic monitoring",
        "Compare performance and trends",
        "What you need",
        "Enable comparison data",
        "Enable comparative charting from Synthetics UI",
        "Enable comparative charting from browser monitoring UI",
        "View comparison data",
        "Hide or return comparison data",
        "Data sources"
      ],
      "title": "Compare page load performance in browser and synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "a789c407a0fecbd2ce888fdee7805abe8152f0a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring/",
      "published_at": "2021-12-25T17:13:10Z",
      "updated_at": "2021-07-09T23:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring regularly checks your websites, critical business transactions, and API endpoints to measure optimal performance. Browser monitoring tracks the actual results of webpage performance across all variations of devices, browsers, and connection speeds. Used together, they provide a direct page load time comparison between real user (browser) interactions and the synthetic monitors. Compare performance and trends New Relic's comparative charting feature helps operations managers and teams by providing: Benchmarks for page load times Additional insights to help you plan where to optimize your site Comparisons of synthetic trends vs. actual browser performance without needing to switch between our monitoring capabilities. For example, during a page outage, you can compare synthetic monitoring trends to actual browser monitoring comparisons to see if an issue is also visible in Synthetics UI, or if it is caused by variables outside of New Relic. This helps you more efficiently know where to take action. What you need The comparative charting feature requires: Browser monitoring enabled with the browser SPA agent (version 885 or higher). A synthetic browser or scripted monitor with one or more tests on the same URLs monitored by the browser agent. After you enable the comparative charting feature either from synthetic or from browser monitoring, no additional setup is required. The comparative charting feature will appear when New Relic finds matching URLs. Enable comparison data After you enable the comparative charting feature from either synthetic or browser monitoring, no additional setup is required. The comparative charting feature will appear whenever synthetics or browser monitoring finds matching URLs. Enable comparative charting from Synthetics UI To enable the comparative charting feature from Synthetics UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. Above the selected monitor's Availability chart, select the ellipsis icon. Select Enable Synthetics comparison. Enable comparative charting from browser monitoring UI To enable the comparison data feature from browser monitoring: Go to one.newrelic.com > Browser > (select a browser app) > Page views. Select a page monitored by synthetic monitoring. From the selected page's Performance tab, select the ellipsis icon. Select Enable Synthetics comparison. View comparison data The comparative charting feature appears whenever synthetic monitoring identifies a URL match with browser monitoring and can compare it. You can compare browser and synthetic's performance either from the synthetic monitoring Summary page or from the browser monitoring Page views page (for browser apps or single page apps) without needing to switch between New Relic capabilities. Based on the selected data sources, the summary shows: Overall speed percentage comparison between browser (real user) page views and any matching URLs found in synthetic monitors that the user has permissions to view Number of URLs found in synthetic monitors that match the browser rollup URL To view the comparative charting summary: From synthetic monitoring UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. OR From browser monitoring UI: Go to one.newrelic.com > Browser > (select a browser app) > Page views, then select a page monitored by synthetic monitoring. Review the comparative charting feature's summary of overall speed percentage and number of matching URLs. To view additional details, select the summary's right arrow icon. Please note that in some cases the simple browser monitor ends before the browser agent has had a chance to collect the BrowserInteraction event. In this case, no comparative charting data is displayed in the UI. In order to resolve this issue, create a scripted browser monitor instead, and add a call to wait (sleep) after the page is loaded. Here is an example: $browser.get('https://www.mywebsite.com').then(function(){ return $browser.sleep(1000); }) Copy Hide or return comparison data To hide the comparative charting feature, select the ellipsis icon. To keep it visible but move it away from the top of the page, select Move to bottom. To return it to its original place on the page, select Move to top. To remove it from the page, select Hide all Synthetics/Browser comparisons. To return it to the page after removing it, follow standard procedures to enable comparison charting. Data sources New Relic uses these data sources for the synthetics and browser comparison in the UI. For deeper analysis of the comparative chart data you see in the UI, use the query builder to run NRQL queries. Variable Description Monitor account ID The account from which you are running the monitor: SELECT monitorAccountId FROM BrowserInteraction Copy Monitor ID The unique ID assigned to your synthetic monitor: SELECT monitorId FROM BrowserInteraction Copy Monitor job ID The ID of a single synthetics monitor run, which began at a specific time and originated from a specific location: SELECT monitorJobId FROM BrowserInteraction LIMIT 1 Copy Real user average The average page load time for real users viewing your website (excludes synthetic monitors). Real user page views Page view details coming from visitors to your website (exclude synthetic monitors). Synthetic's average The average page load time from the synthetic simple or scripted monitors that ran on your website. Synthetic's page views Only traffic generated by synthetic simple or scripted monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.26802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "sections": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " permissions to view Number of URLs found in <em>synthetic</em> monitors that match the browser rollup URL To view the comparative charting summary: From <em>synthetic</em> <em>monitoring</em> UI: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Summary. OR From browser <em>monitoring</em> UI: Go to one.newrelic.com &gt; Browser"
      },
      "id": "604525b7e7b9d251f85799e1"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/synthetic-monitoring-audit-log-track-changes-made-users": [
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-25T17:37:54Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.43498,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Synthetic monitor public minion IPs",
        "IP addresses are not personal data",
        "Daily JSON listings for IP addresses",
        "Important",
        "Tip",
        "Public minion locations and location labels"
      ],
      "title": "Synthetic monitor public minion IPs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "773534b4f076c3b421b6e0ca0dfc26f1e1ef6f73",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/",
      "published_at": "2021-12-25T17:07:19Z",
      "updated_at": "2021-08-08T21:09:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic uses a group of minions to execute your synthetic monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses are publicly available in JSON format, so you can easily read and parse them. Recommendation: For easier maintenance, use these options: Automate your rules for your allow list based on these files. Add the IP addresses to your allow list by using a custom header. IP addresses are not personal data Minions are deployed on servers, and the agents are expected to be activated using non-personal credentials. IP addresses associated with minions running on servers are not personal data under data protection and privacy laws. For more information, see the Synthetic's security documentation. Daily JSON listings for IP addresses IP addresses for released locations are subject to change. If a change is needed, we'll attempt to proactively notify customers prior to any changes via e-mail. You can also check the Explorers Hub for updates. Important Synthetics is adding new IP addresses on July 15 2021. Tip In the S3 URL paths for this feature, production represents US-based accounts and eu represents EU-based accounts. US accounts IP-only list DNS name-only list IP and DNS name list EU accounts IP-only list DNS name-only list IP and DNS name list Public minion locations and location labels The following table cross-references the synthetic's public minion locations with their location labels. You can query the location and locationLabel attributes from the SyntheticCheck and SyntheticRequest events. Public minion location Location label AWS_AP_EAST_1 \"Hong Kong, HK\" AWS_AP_SOUTH_1 \"Mumbai, IN\" AWS_AP_SOUTHEAST_1 \"Singapore, SG\" AWS_AP_NORTHEAST_2 \"Seoul, KR\" AWS_AP_NORTHEAST_1 \"Tokyo, JP\" AWS_AP_SOUTHEAST_2 \"Sydney, AU\" AWS_US_WEST_1 \"San Francisco, CA, USA\" AWS_US_WEST_2 \"Portland, OR, USA\" AWS_US_EAST_2 \"Columbus, OH, USA\" AWS_US_EAST_1 \"Washington, DC, USA\" AWS_CA_CENTRAL_1 \"Montreal, Québec, CA\" AWS_SA_EAST_1 \"São Paulo, BR\" AWS_EU_WEST_1 \"Dublin, IE\" AWS_EU_WEST_2 \"London, England, UK\" AWS_EU_WEST_3 \"Paris, FR\" AWS_EU_CENTRAL_1 \"Frankfurt, DE\" AWS_EU_NORTH_1 \"Stockholm, SE\" AWS_EU_SOUTH_1 \"Milan, IT\" AWS_ME_SOUTH_1 \"Manama, BH\" AWS_AF_SOUTH_1 \"Cape Town, ZA\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.9277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "sections": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "New Relic uses a group of minions to execute your <em>synthetic</em> monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses"
      },
      "id": "6045257d28ccbcdc552c60a5"
    },
    {
      "sections": [
        "Compare page load performance in browser and synthetic monitoring",
        "Compare performance and trends",
        "What you need",
        "Enable comparison data",
        "Enable comparative charting from Synthetics UI",
        "Enable comparative charting from browser monitoring UI",
        "View comparison data",
        "Hide or return comparison data",
        "Data sources"
      ],
      "title": "Compare page load performance in browser and synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "a789c407a0fecbd2ce888fdee7805abe8152f0a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring/",
      "published_at": "2021-12-25T17:13:10Z",
      "updated_at": "2021-07-09T23:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring regularly checks your websites, critical business transactions, and API endpoints to measure optimal performance. Browser monitoring tracks the actual results of webpage performance across all variations of devices, browsers, and connection speeds. Used together, they provide a direct page load time comparison between real user (browser) interactions and the synthetic monitors. Compare performance and trends New Relic's comparative charting feature helps operations managers and teams by providing: Benchmarks for page load times Additional insights to help you plan where to optimize your site Comparisons of synthetic trends vs. actual browser performance without needing to switch between our monitoring capabilities. For example, during a page outage, you can compare synthetic monitoring trends to actual browser monitoring comparisons to see if an issue is also visible in Synthetics UI, or if it is caused by variables outside of New Relic. This helps you more efficiently know where to take action. What you need The comparative charting feature requires: Browser monitoring enabled with the browser SPA agent (version 885 or higher). A synthetic browser or scripted monitor with one or more tests on the same URLs monitored by the browser agent. After you enable the comparative charting feature either from synthetic or from browser monitoring, no additional setup is required. The comparative charting feature will appear when New Relic finds matching URLs. Enable comparison data After you enable the comparative charting feature from either synthetic or browser monitoring, no additional setup is required. The comparative charting feature will appear whenever synthetics or browser monitoring finds matching URLs. Enable comparative charting from Synthetics UI To enable the comparative charting feature from Synthetics UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. Above the selected monitor's Availability chart, select the ellipsis icon. Select Enable Synthetics comparison. Enable comparative charting from browser monitoring UI To enable the comparison data feature from browser monitoring: Go to one.newrelic.com > Browser > (select a browser app) > Page views. Select a page monitored by synthetic monitoring. From the selected page's Performance tab, select the ellipsis icon. Select Enable Synthetics comparison. View comparison data The comparative charting feature appears whenever synthetic monitoring identifies a URL match with browser monitoring and can compare it. You can compare browser and synthetic's performance either from the synthetic monitoring Summary page or from the browser monitoring Page views page (for browser apps or single page apps) without needing to switch between New Relic capabilities. Based on the selected data sources, the summary shows: Overall speed percentage comparison between browser (real user) page views and any matching URLs found in synthetic monitors that the user has permissions to view Number of URLs found in synthetic monitors that match the browser rollup URL To view the comparative charting summary: From synthetic monitoring UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. OR From browser monitoring UI: Go to one.newrelic.com > Browser > (select a browser app) > Page views, then select a page monitored by synthetic monitoring. Review the comparative charting feature's summary of overall speed percentage and number of matching URLs. To view additional details, select the summary's right arrow icon. Please note that in some cases the simple browser monitor ends before the browser agent has had a chance to collect the BrowserInteraction event. In this case, no comparative charting data is displayed in the UI. In order to resolve this issue, create a scripted browser monitor instead, and add a call to wait (sleep) after the page is loaded. Here is an example: $browser.get('https://www.mywebsite.com').then(function(){ return $browser.sleep(1000); }) Copy Hide or return comparison data To hide the comparative charting feature, select the ellipsis icon. To keep it visible but move it away from the top of the page, select Move to bottom. To return it to its original place on the page, select Move to top. To remove it from the page, select Hide all Synthetics/Browser comparisons. To return it to the page after removing it, follow standard procedures to enable comparison charting. Data sources New Relic uses these data sources for the synthetics and browser comparison in the UI. For deeper analysis of the comparative chart data you see in the UI, use the query builder to run NRQL queries. Variable Description Monitor account ID The account from which you are running the monitor: SELECT monitorAccountId FROM BrowserInteraction Copy Monitor ID The unique ID assigned to your synthetic monitor: SELECT monitorId FROM BrowserInteraction Copy Monitor job ID The ID of a single synthetics monitor run, which began at a specific time and originated from a specific location: SELECT monitorJobId FROM BrowserInteraction LIMIT 1 Copy Real user average The average page load time for real users viewing your website (excludes synthetic monitors). Real user page views Page view details coming from visitors to your website (exclude synthetic monitors). Synthetic's average The average page load time from the synthetic simple or scripted monitors that ran on your website. Synthetic's page views Only traffic generated by synthetic simple or scripted monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.26802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "sections": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " permissions to view Number of URLs found in <em>synthetic</em> monitors that match the browser rollup URL To view the comparative charting summary: From <em>synthetic</em> <em>monitoring</em> UI: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Summary. OR From browser <em>monitoring</em> UI: Go to one.newrelic.com &gt; Browser"
      },
      "id": "604525b7e7b9d251f85799e1"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips": [
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-25T17:37:54Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.43498,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Compare page load performance in browser and synthetic monitoring",
        "Compare performance and trends",
        "What you need",
        "Enable comparison data",
        "Enable comparative charting from Synthetics UI",
        "Enable comparative charting from browser monitoring UI",
        "View comparison data",
        "Hide or return comparison data",
        "Data sources"
      ],
      "title": "Compare page load performance in browser and synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "a789c407a0fecbd2ce888fdee7805abe8152f0a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring/",
      "published_at": "2021-12-25T17:13:10Z",
      "updated_at": "2021-07-09T23:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring regularly checks your websites, critical business transactions, and API endpoints to measure optimal performance. Browser monitoring tracks the actual results of webpage performance across all variations of devices, browsers, and connection speeds. Used together, they provide a direct page load time comparison between real user (browser) interactions and the synthetic monitors. Compare performance and trends New Relic's comparative charting feature helps operations managers and teams by providing: Benchmarks for page load times Additional insights to help you plan where to optimize your site Comparisons of synthetic trends vs. actual browser performance without needing to switch between our monitoring capabilities. For example, during a page outage, you can compare synthetic monitoring trends to actual browser monitoring comparisons to see if an issue is also visible in Synthetics UI, or if it is caused by variables outside of New Relic. This helps you more efficiently know where to take action. What you need The comparative charting feature requires: Browser monitoring enabled with the browser SPA agent (version 885 or higher). A synthetic browser or scripted monitor with one or more tests on the same URLs monitored by the browser agent. After you enable the comparative charting feature either from synthetic or from browser monitoring, no additional setup is required. The comparative charting feature will appear when New Relic finds matching URLs. Enable comparison data After you enable the comparative charting feature from either synthetic or browser monitoring, no additional setup is required. The comparative charting feature will appear whenever synthetics or browser monitoring finds matching URLs. Enable comparative charting from Synthetics UI To enable the comparative charting feature from Synthetics UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. Above the selected monitor's Availability chart, select the ellipsis icon. Select Enable Synthetics comparison. Enable comparative charting from browser monitoring UI To enable the comparison data feature from browser monitoring: Go to one.newrelic.com > Browser > (select a browser app) > Page views. Select a page monitored by synthetic monitoring. From the selected page's Performance tab, select the ellipsis icon. Select Enable Synthetics comparison. View comparison data The comparative charting feature appears whenever synthetic monitoring identifies a URL match with browser monitoring and can compare it. You can compare browser and synthetic's performance either from the synthetic monitoring Summary page or from the browser monitoring Page views page (for browser apps or single page apps) without needing to switch between New Relic capabilities. Based on the selected data sources, the summary shows: Overall speed percentage comparison between browser (real user) page views and any matching URLs found in synthetic monitors that the user has permissions to view Number of URLs found in synthetic monitors that match the browser rollup URL To view the comparative charting summary: From synthetic monitoring UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. OR From browser monitoring UI: Go to one.newrelic.com > Browser > (select a browser app) > Page views, then select a page monitored by synthetic monitoring. Review the comparative charting feature's summary of overall speed percentage and number of matching URLs. To view additional details, select the summary's right arrow icon. Please note that in some cases the simple browser monitor ends before the browser agent has had a chance to collect the BrowserInteraction event. In this case, no comparative charting data is displayed in the UI. In order to resolve this issue, create a scripted browser monitor instead, and add a call to wait (sleep) after the page is loaded. Here is an example: $browser.get('https://www.mywebsite.com').then(function(){ return $browser.sleep(1000); }) Copy Hide or return comparison data To hide the comparative charting feature, select the ellipsis icon. To keep it visible but move it away from the top of the page, select Move to bottom. To return it to its original place on the page, select Move to top. To remove it from the page, select Hide all Synthetics/Browser comparisons. To return it to the page after removing it, follow standard procedures to enable comparison charting. Data sources New Relic uses these data sources for the synthetics and browser comparison in the UI. For deeper analysis of the comparative chart data you see in the UI, use the query builder to run NRQL queries. Variable Description Monitor account ID The account from which you are running the monitor: SELECT monitorAccountId FROM BrowserInteraction Copy Monitor ID The unique ID assigned to your synthetic monitor: SELECT monitorId FROM BrowserInteraction Copy Monitor job ID The ID of a single synthetics monitor run, which began at a specific time and originated from a specific location: SELECT monitorJobId FROM BrowserInteraction LIMIT 1 Copy Real user average The average page load time for real users viewing your website (excludes synthetic monitors). Real user page views Page view details coming from visitors to your website (exclude synthetic monitors). Synthetic's average The average page load time from the synthetic simple or scripted monitors that ran on your website. Synthetic's page views Only traffic generated by synthetic simple or scripted monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.26802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "sections": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " permissions to view Number of URLs found in <em>synthetic</em> monitors that match the browser rollup URL To view the comparative charting summary: From <em>synthetic</em> <em>monitoring</em> UI: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Summary. OR From browser <em>monitoring</em> UI: Go to one.newrelic.com &gt; Browser"
      },
      "id": "604525b7e7b9d251f85799e1"
    },
    {
      "sections": [
        "Upcoming synthetic monitor public minion IP addresses",
        "US public minions: Upcoming IP addresses",
        "EU public minions: Upcoming IP addresses"
      ],
      "title": "Upcoming synthetic monitor public minion IP addresses",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "81c0e0d3f87a627ad01f220f215f7b848f54608d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/new-synthetic-public-minion-ips/",
      "published_at": "2021-12-25T16:54:52Z",
      "updated_at": "2021-04-04T20:14:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "On July 15 2021, we'll be adding new IP addresses for several synthetics locations for both US locations and EU locations. To ensure your monitors are not affected by these changes, please add the appropriate IP addresses to your firewalls allow list. For the current list of IP addresses and more about this topic, see Synthetic monitor public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 54.250.11.193 3.113.102.86 52.193.74.189 18.177.40.17 ec2-54-250-11-193.ap-northeast-1.compute.amazonaws.com ec2-3-113-102-86.ap-northeast-1.compute.amazonaws.com ec2-52-193-74-189.ap-northeast-1.compute.amazonaws.com ec2-18-177-40-17.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 3.34.173.249 52.79.48.153 ec2-3-34-173-249.ap-northeast-2.compute.amazonaws.com ec2-52-79-48-153.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 65.1.222.35 ec2-65-1-222-35.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 52.76.41.181 54.179.195.220 18.138.16.42 ec2-52-76-41-181.ap-southeast-1.compute.amazonaws.com ec2-54-179-195-220.ap-southeast-1.compute.amazonaws.com ec2-18-138-16-42.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 3.96.243.128 3.97.226.155 ec2-3-96-243-128.ca-central-1.compute.amazonaws.com ec2-3-97-226-155.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.94.27.80 18.229.241.206 ec2-54-94-27-80.sa-east-1.compute.amazonaws.com ec2-18-229-241-206.sa-east-1.compute.amazonaws.com AWS_US_WEST_2 \"Portland, OR, USA\" 44.236.111.66 54.203.108.135 ec2-44-236-111-66.us-west-2.compute.amazonaws.com ec2-54-203-108-135.us-west-2.compute.amazonaws.com EU public minions: Upcoming IP addresses The following table lists the upcoming IP addresses that will be added to public minions on July 15 2021 for EU customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 35.72.129.240 35.73.187.89 ec2-35-72-129-240.ap-northeast-1.compute.amazonaws.com ec2-35-73-187-89.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 13.125.155.211 15.164.119.0 ec2-13-125-155-211.ap-northeast-2.compute.amazonaws.com ec2-15-164-119-0.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 15.207.93.61 ec2-15-207-93-61.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 3.0.28.216 ec2-3-0-28-216.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 99.79.17.185 ec2-99-79-17-185.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.207.198.234 ec2-54-207-198-234.sa-east-1.compute.amazonaws.com",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.3917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "sections": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " about this topic, see <em>Synthetic</em> <em>monitor</em> public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses"
      },
      "id": "606a1e4364441fbec2617a7c"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring": [
    {
      "sections": [
        "Synthetic monitor public minion IPs",
        "IP addresses are not personal data",
        "Daily JSON listings for IP addresses",
        "Important",
        "Tip",
        "Public minion locations and location labels"
      ],
      "title": "Synthetic monitor public minion IPs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "773534b4f076c3b421b6e0ca0dfc26f1e1ef6f73",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/",
      "published_at": "2021-12-25T17:07:19Z",
      "updated_at": "2021-08-08T21:09:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic uses a group of minions to execute your synthetic monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses are publicly available in JSON format, so you can easily read and parse them. Recommendation: For easier maintenance, use these options: Automate your rules for your allow list based on these files. Add the IP addresses to your allow list by using a custom header. IP addresses are not personal data Minions are deployed on servers, and the agents are expected to be activated using non-personal credentials. IP addresses associated with minions running on servers are not personal data under data protection and privacy laws. For more information, see the Synthetic's security documentation. Daily JSON listings for IP addresses IP addresses for released locations are subject to change. If a change is needed, we'll attempt to proactively notify customers prior to any changes via e-mail. You can also check the Explorers Hub for updates. Important Synthetics is adding new IP addresses on July 15 2021. Tip In the S3 URL paths for this feature, production represents US-based accounts and eu represents EU-based accounts. US accounts IP-only list DNS name-only list IP and DNS name list EU accounts IP-only list DNS name-only list IP and DNS name list Public minion locations and location labels The following table cross-references the synthetic's public minion locations with their location labels. You can query the location and locationLabel attributes from the SyntheticCheck and SyntheticRequest events. Public minion location Location label AWS_AP_EAST_1 \"Hong Kong, HK\" AWS_AP_SOUTH_1 \"Mumbai, IN\" AWS_AP_SOUTHEAST_1 \"Singapore, SG\" AWS_AP_NORTHEAST_2 \"Seoul, KR\" AWS_AP_NORTHEAST_1 \"Tokyo, JP\" AWS_AP_SOUTHEAST_2 \"Sydney, AU\" AWS_US_WEST_1 \"San Francisco, CA, USA\" AWS_US_WEST_2 \"Portland, OR, USA\" AWS_US_EAST_2 \"Columbus, OH, USA\" AWS_US_EAST_1 \"Washington, DC, USA\" AWS_CA_CENTRAL_1 \"Montreal, Québec, CA\" AWS_SA_EAST_1 \"São Paulo, BR\" AWS_EU_WEST_1 \"Dublin, IE\" AWS_EU_WEST_2 \"London, England, UK\" AWS_EU_WEST_3 \"Paris, FR\" AWS_EU_CENTRAL_1 \"Frankfurt, DE\" AWS_EU_NORTH_1 \"Stockholm, SE\" AWS_EU_SOUTH_1 \"Milan, IT\" AWS_ME_SOUTH_1 \"Manama, BH\" AWS_AF_SOUTH_1 \"Cape Town, ZA\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.92769,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "sections": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "New Relic uses a group of minions to execute your <em>synthetic</em> monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses"
      },
      "id": "6045257d28ccbcdc552c60a5"
    },
    {
      "sections": [
        "Compare page load performance in browser and synthetic monitoring",
        "Compare performance and trends",
        "What you need",
        "Enable comparison data",
        "Enable comparative charting from Synthetics UI",
        "Enable comparative charting from browser monitoring UI",
        "View comparison data",
        "Hide or return comparison data",
        "Data sources"
      ],
      "title": "Compare page load performance in browser and synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "a789c407a0fecbd2ce888fdee7805abe8152f0a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring/",
      "published_at": "2021-12-25T17:13:10Z",
      "updated_at": "2021-07-09T23:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring regularly checks your websites, critical business transactions, and API endpoints to measure optimal performance. Browser monitoring tracks the actual results of webpage performance across all variations of devices, browsers, and connection speeds. Used together, they provide a direct page load time comparison between real user (browser) interactions and the synthetic monitors. Compare performance and trends New Relic's comparative charting feature helps operations managers and teams by providing: Benchmarks for page load times Additional insights to help you plan where to optimize your site Comparisons of synthetic trends vs. actual browser performance without needing to switch between our monitoring capabilities. For example, during a page outage, you can compare synthetic monitoring trends to actual browser monitoring comparisons to see if an issue is also visible in Synthetics UI, or if it is caused by variables outside of New Relic. This helps you more efficiently know where to take action. What you need The comparative charting feature requires: Browser monitoring enabled with the browser SPA agent (version 885 or higher). A synthetic browser or scripted monitor with one or more tests on the same URLs monitored by the browser agent. After you enable the comparative charting feature either from synthetic or from browser monitoring, no additional setup is required. The comparative charting feature will appear when New Relic finds matching URLs. Enable comparison data After you enable the comparative charting feature from either synthetic or browser monitoring, no additional setup is required. The comparative charting feature will appear whenever synthetics or browser monitoring finds matching URLs. Enable comparative charting from Synthetics UI To enable the comparative charting feature from Synthetics UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. Above the selected monitor's Availability chart, select the ellipsis icon. Select Enable Synthetics comparison. Enable comparative charting from browser monitoring UI To enable the comparison data feature from browser monitoring: Go to one.newrelic.com > Browser > (select a browser app) > Page views. Select a page monitored by synthetic monitoring. From the selected page's Performance tab, select the ellipsis icon. Select Enable Synthetics comparison. View comparison data The comparative charting feature appears whenever synthetic monitoring identifies a URL match with browser monitoring and can compare it. You can compare browser and synthetic's performance either from the synthetic monitoring Summary page or from the browser monitoring Page views page (for browser apps or single page apps) without needing to switch between New Relic capabilities. Based on the selected data sources, the summary shows: Overall speed percentage comparison between browser (real user) page views and any matching URLs found in synthetic monitors that the user has permissions to view Number of URLs found in synthetic monitors that match the browser rollup URL To view the comparative charting summary: From synthetic monitoring UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. OR From browser monitoring UI: Go to one.newrelic.com > Browser > (select a browser app) > Page views, then select a page monitored by synthetic monitoring. Review the comparative charting feature's summary of overall speed percentage and number of matching URLs. To view additional details, select the summary's right arrow icon. Please note that in some cases the simple browser monitor ends before the browser agent has had a chance to collect the BrowserInteraction event. In this case, no comparative charting data is displayed in the UI. In order to resolve this issue, create a scripted browser monitor instead, and add a call to wait (sleep) after the page is loaded. Here is an example: $browser.get('https://www.mywebsite.com').then(function(){ return $browser.sleep(1000); }) Copy Hide or return comparison data To hide the comparative charting feature, select the ellipsis icon. To keep it visible but move it away from the top of the page, select Move to bottom. To return it to its original place on the page, select Move to top. To remove it from the page, select Hide all Synthetics/Browser comparisons. To return it to the page after removing it, follow standard procedures to enable comparison charting. Data sources New Relic uses these data sources for the synthetics and browser comparison in the UI. For deeper analysis of the comparative chart data you see in the UI, use the query builder to run NRQL queries. Variable Description Monitor account ID The account from which you are running the monitor: SELECT monitorAccountId FROM BrowserInteraction Copy Monitor ID The unique ID assigned to your synthetic monitor: SELECT monitorId FROM BrowserInteraction Copy Monitor job ID The ID of a single synthetics monitor run, which began at a specific time and originated from a specific location: SELECT monitorJobId FROM BrowserInteraction LIMIT 1 Copy Real user average The average page load time for real users viewing your website (excludes synthetic monitors). Real user page views Page view details coming from visitors to your website (exclude synthetic monitors). Synthetic's average The average page load time from the synthetic simple or scripted monitors that ran on your website. Synthetic's page views Only traffic generated by synthetic simple or scripted monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.26802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "sections": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " permissions to view Number of URLs found in <em>synthetic</em> monitors that match the browser rollup URL To view the comparative charting summary: From <em>synthetic</em> <em>monitoring</em> UI: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Summary. OR From browser <em>monitoring</em> UI: Go to one.newrelic.com &gt; Browser"
      },
      "id": "604525b7e7b9d251f85799e1"
    },
    {
      "sections": [
        "Upcoming synthetic monitor public minion IP addresses",
        "US public minions: Upcoming IP addresses",
        "EU public minions: Upcoming IP addresses"
      ],
      "title": "Upcoming synthetic monitor public minion IP addresses",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "81c0e0d3f87a627ad01f220f215f7b848f54608d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/new-synthetic-public-minion-ips/",
      "published_at": "2021-12-25T16:54:52Z",
      "updated_at": "2021-04-04T20:14:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "On July 15 2021, we'll be adding new IP addresses for several synthetics locations for both US locations and EU locations. To ensure your monitors are not affected by these changes, please add the appropriate IP addresses to your firewalls allow list. For the current list of IP addresses and more about this topic, see Synthetic monitor public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 54.250.11.193 3.113.102.86 52.193.74.189 18.177.40.17 ec2-54-250-11-193.ap-northeast-1.compute.amazonaws.com ec2-3-113-102-86.ap-northeast-1.compute.amazonaws.com ec2-52-193-74-189.ap-northeast-1.compute.amazonaws.com ec2-18-177-40-17.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 3.34.173.249 52.79.48.153 ec2-3-34-173-249.ap-northeast-2.compute.amazonaws.com ec2-52-79-48-153.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 65.1.222.35 ec2-65-1-222-35.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 52.76.41.181 54.179.195.220 18.138.16.42 ec2-52-76-41-181.ap-southeast-1.compute.amazonaws.com ec2-54-179-195-220.ap-southeast-1.compute.amazonaws.com ec2-18-138-16-42.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 3.96.243.128 3.97.226.155 ec2-3-96-243-128.ca-central-1.compute.amazonaws.com ec2-3-97-226-155.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.94.27.80 18.229.241.206 ec2-54-94-27-80.sa-east-1.compute.amazonaws.com ec2-18-229-241-206.sa-east-1.compute.amazonaws.com AWS_US_WEST_2 \"Portland, OR, USA\" 44.236.111.66 54.203.108.135 ec2-44-236-111-66.us-west-2.compute.amazonaws.com ec2-54-203-108-135.us-west-2.compute.amazonaws.com EU public minions: Upcoming IP addresses The following table lists the upcoming IP addresses that will be added to public minions on July 15 2021 for EU customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 35.72.129.240 35.73.187.89 ec2-35-72-129-240.ap-northeast-1.compute.amazonaws.com ec2-35-73-187-89.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 13.125.155.211 15.164.119.0 ec2-13-125-155-211.ap-northeast-2.compute.amazonaws.com ec2-15-164-119-0.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 15.207.93.61 ec2-15-207-93-61.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 3.0.28.216 ec2-3-0-28-216.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 99.79.17.185 ec2-99-79-17-185.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.207.198.234 ec2-54-207-198-234.sa-east-1.compute.amazonaws.com",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.3917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "sections": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " about this topic, see <em>Synthetic</em> <em>monitor</em> public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses"
      },
      "id": "606a1e4364441fbec2617a7c"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/getting-started/get-started-synthetic-monitoring": [
    {
      "sections": [
        "Types of synthetic monitors",
        "Types of monitors"
      ],
      "title": "Types of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "f7fe7faff740058c77bdf27b2c1bfb5c6a206b40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/types-synthetic-monitors/",
      "published_at": "2021-12-25T16:57:52Z",
      "updated_at": "2021-10-18T21:27:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can proactively monitor your website or API endpoints with synthetic monitors. Depending on the type of monitor, you can: Add and edit monitors. Use the Synthetics REST API to manage monitors. Set up monitors from specific locations or for private servers. You can also use the host not reporting feature in infrastructure monitoring. This allows you to take advantage of enhanced monitoring options and be notified when New Relic has stopped receiving data from your hosts. Types of monitors These are the seven types of synthetic monitors: Type of synthetic monitor Description Broken links monitor API name: SCRIPT_API Provide a url and this monitor will test all the links on the page for success. If a failure is detected you can view the individual non-successful links that caused the failure. Certificate check monitor API name: SCRIPT_API Proactively ping your domain certificates based on a configurable threshold. Pair with an alert to ensure you are notified when your certificates need renewed. Ping monitor API name: SIMPLE Ping monitors are the simplest type of monitor. They simply check to see if an application is online. The synthetic ping monitor uses a simple Java HTTP client to make requests to your site. For consistency with other synthetic monitor types, the user agent is identified as Google Chrome. However, the HTTP client is not a full browser, and it does not execute JavaScript. If you need JavaScript functionality, use a simple browser monitor. Step monitor API name: STEP_MONITOR Step monitors are advanced monitors which require no code to set up. The monitor can be configured to: Assert modal Assert text Assert title Assert an element Click an element Dismiss a modal Double click an element Enter a secure credential Hover over an element Locate an element by CSS class, HTML ID, link text, Xpath, or value Navigate to a URL Select from a dropdown Type text Simple browser monitors API name: BROWSER Simple browser monitors essentially are simple, pre-built scripted browser monitors. They make a request to your site using an instance of Google Chrome. Compared to a simple ping monitor, this is a more accurate emulation of an actual customer visit. The user agent is identified as Google Chrome. Scripted browser monitors API name: SCRIPT_BROWSER Scripted browser monitors are used for more sophisticated, customized monitoring. You can create a custom script that navigates your website, takes specific actions, and ensures specific resources are present. The monitor uses Google Chrome browser. You can also use a variety of third-party modules to build your custom monitor. API tests API name: SCRIPT_API API tests are used to monitor your API endpoints. This can ensure that your app server works in addition to your website. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.44391,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Types of <em>synthetic</em> <em>monitors</em>",
        "sections": "Types of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can proactively <em>monitor</em> your website or API endpoints with <em>synthetic</em> monitors. Depending on the type of <em>monitor</em>, you can: Add and edit monitors. Use the <em>Synthetics</em> REST API to manage monitors. Set up monitors from specific locations or for private servers. You can also use the host"
      },
      "id": "603e873864441f3e154e888f"
    },
    {
      "sections": [
        "Security for synthetic monitoring",
        "What we do",
        "What you can do"
      ],
      "title": "Security for synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "c36cbaf0bec47e56e54e66f7eb39484a3ef7f426",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/security-synthetic-monitoring/",
      "published_at": "2021-12-25T18:29:31Z",
      "updated_at": "2021-07-27T18:44:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's synthetic monitoring uses monitors distributed throughout data centers around the world. By design, it captures what is essentially performance data for simulated traffic. It does not capture or handle any personal data by default. All data handled by synthetic monitors is expected to be non-personal. This document provides additional details about what we do to ensure data privacy and security with synthetic monitoring, plus additional options you can use. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. What we do Here's a summary of the data privacy and security measures that New Relic provides for you. Data privacy and security Comments No personal data By definition, all data collected through synthetic monitoring is test data created for the purpose of monitoring. None of this data includes personal data from any individual. TLS TLS encryption is required for all domains. This applies to public locations and private locations. Authentication Synthetic monitoring supports a variety of authentication mechanisms, including Basic, Digest, NTLM, and NTLMv2. Available options depend on the type of monitor you choose. Data collection The data transferred to the synthetic endpoint includes: Monitor run results, including full request and response headers of all requests, a complete HAR file of the session, and any screenshots captured (on failure or manually) Polling for available jobs in the private location's queue Private minion \"heartbeat\" every 30 seconds The SyntheticsPrivateMinion event contains basic minion status, including job success and failure counts, queue size, minion version, etc. Data received Data received from the synthetic monitoring endpoint contains the scheduled check's details. This includes the information necessary to complete the check for the minion: Target URL Validation text Full script (for synthetic scripted browser monitors) Data storage location Data collected by synthetic monitoring is stored in the region selected by each customer for their account (US or EU). Monitor configuration details (including frequency, check locations, target URL, and the full script for any scripted browser or API test monitors) are stored on our end. We also store all monitor check results for each monitor type. Data storage by monitor type For ping monitors, data storage includes the HAR file, which includes all requests and responses made during the check. For simple browsers, scripted browsers, and API tests, data storage includes the following: The HAR file includes full request and response headers for all requests made during the check. Any screenshots taken during the check are automatically included for simple and scripted browser monitors only on failure. However, you can manually configure this with scripting. The browser log (JS console) is automatically included for simple and scripted browsers. Any script output is included for scripted browsers and API test monitors. Response bodies New Relic never stores response bodies from requests originated by synthetic monitoring, unless you have manually configured a monitor script to do so. IP addresses Synthetic public minions are expected to be activated using non-personal credentials. Their IP addresses are not defined as personal data under data protection and privacy laws. What you can do For additional levels of security and data privacy, consider using these options. Additional measures Comments User access To control which of your users can access your monitors and private locations, set up role-based synthetic monitoring permissions and user groups. In addition, to track and be notified about changes, use audit logs and alert notifications. Passwords, API keys, user names, etc. To securely store sensitive information, use secured credentials for scripted browsers and API tests. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). Sites behind firewalls To control what sites you want to monitor behind your firewall, you can: Add the synthetic public minion IP addresses to your allow list or deny list. Use private locations to monitor sites or endpoints. This can provide an extra layer of security when monitoring your internally hosted sites and services. Web pages behind login pages If you configure synthetic monitoring to track website areas that are located behind a login page, be sure to create a non-personal login specifically for this purpose. This unique login will reduce the risk of unintended personal data exposure. Proxy configuration Aside from the target URLs monitored by New Relic, private minions will regularly send data to and receive from the synthetic monitoring endpoint. To configure a proxy for all traffic to and from this endpoint, set the MINION_API_PROXY environment variable on the minion host. Private minions security To ensure that only the scripts you intend to run are allowed to run on private minions, use verified script execution.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.64221,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for <em>synthetic</em> <em>monitoring</em>",
        "sections": "Security for <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " for available jobs in the private location&#x27;s queue Private minion &quot;heartbeat&quot; every 30 seconds The <em>Synthetics</em>PrivateMinion event contains basic minion status, including job success and failure counts, queue size, minion version, etc. Data received Data received from the <em>synthetic</em> <em>monitoring</em> endpoint"
      },
      "id": "604525b8e7b9d270a35799c8"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "APIs for data ingest",
        "NerdGraph (GraphQL)",
        "REST API",
        "APIs by feature",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-12-25T04:32:43Z",
      "updated_at": "2021-12-19T15:29:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Send data to New Relic. Retrieve data from New Relic. View and configure settings. This document provides examples and reference information for our APIs. APIs for data ingest Our four primary data ingest APIs are some of the many solutions for reporting data to New Relic. These APIs can be used directly, but they're also the underlying ingest route for any of our tools that use those APIs (for example, our OpenTelemetry integration, or our Telemetry SDKs). API type Description Metric API Send dimensional metrics to New Relic from any source (including other telemetry monitoring services). Event API Send custom event data to New Relic without the use of an agent or integration. Log API Send log data to New Relic. Trace API Send distributed tracing data (also referred to as \"spans\") to New Relic without the use of an agent or integration. NerdGraph (GraphQL) NerdGraph is the API we recommend for querying New Relic data, querying account information, and making a range of feature configurations. To learn what you can do, check out the NerdGraph tutorials. NerdGraph is our newest API and is our attempt to bring together in one place some of our older APIs, like our REST API. Note that there is still some functionality you can do with REST APIs that can't yet be done with NerdGraph, and this is why some New Relic organizations still use the REST API. REST API Our REST API is our older API for querying and configuration, which NerdGraph is in the process of replacing. The REST API has some configuration abilities that NerdGraph doesn't yet have, but when possible you should use NerdGraph. The REST API can be used for a wide range of features: for detail, see APIs by feature. APIs by feature New Relic tools and features, like APM, infrastructure monitoring, browser monitoring, and alerts, are often used together, and sometimes can overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use NerdGraph. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The browser API resources include: Resource Details Browser agent API Use the browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To query New Relic data, use NerdGraph. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To query New Relic data, use NerdGraph. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To query New Relic data, use NerdGraph. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To query New Relic data, use NerdGraph. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage (original pricing model) For organizations on our original pricing model, you can use NerdGraph to query subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API If you're a New Relic partnership organization, you can use the Partner API to retrieve data and make configurations. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing models that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API Our Insights Query API is mostly deprecated. Instead, use NerdGraph for querying your New Relic data. Dashboard API Use the Dashboards API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.15325,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Synthetic</em> <em>monitoring</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": " rate data. Manage New Relic alerts conditions for your mobile apps. Query API To query New Relic data, use NerdGraph. Account management APIs For account-related APIs, see Account APIs. <em>Synthetic</em> <em>monitoring</em> <em>Synthetics</em> API resources include: Resource Details <em>Synthetics</em> REST API The <em>Synthetics</em> REST"
      },
      "id": "609fa5cf196a67066022b194"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/getting-started/security-synthetic-monitoring": [
    {
      "sections": [
        "Get started with synthetic monitoring",
        "Why it matters",
        "Advanced testing",
        "Enhanced monitoring and reporting",
        "Additional features",
        "Data protection and privacy",
        "Compatibility and requirements",
        "Important",
        "Permissions"
      ],
      "title": "Get started with synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "0e5bba5ee7c140314180bff96253dce241ced14f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/get-started-synthetic-monitoring/",
      "published_at": "2021-12-26T01:49:37Z",
      "updated_at": "2021-11-25T01:41:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring is a suite of automated, scriptable tools to monitor your websites, critical business transactions, and API endpoints. You can simulate user traffic to proactively detect and resolve outages and poor performance of critical endpoints before your customers notice. Why it matters With synthetic monitoring, you can: Get the context of failures by connecting the availability and performance of endpoints to the underlying applications and infrastructure. Easily diagnose if an issue stems from the network or AWS location, a slow third party resource, or the health of backend services or infrastructure. Add synthetic monitoring into build automation and CI/CD pipelines to automatically track performance and check functionality for each deployment. Expand your monitoring further with real, Selenium-powered scripted browsers, which test login procedures, searches, and other critical business transactions. Monitor your API endpoints with API tests. Ready to get started? If you don't already have one, sign up for a New Relic account. It's free, forever! Advanced testing Synthetic monitoring allows you to proactively monitor your website or API endpoint to ensure your content is not only available, but fully functional. Synthetic monitoring browser tests send real, Selenium-powered Google Chrome browsers to your site from locations around the world to ensure your content is always up, everywhere. Scripted browsers expand your testing capabilities, so you can test uncommon user flows or beta-test complex procedures. For example, ensure your users are able to sign up for your newsletter, add an item to their cart, or search for and find a piece of critical content with a simple JavaScript-like language. Test your backend with API monitors, which allow you to run scripted tests against any API endpoint. Enhanced monitoring and reporting Synthetic monitoring aggregates the results of each check into metrics, allowing you to see patterns and identify causes of poor performance. Synthetic monitoring also stores each and every monitor result, so you can see exactly where your website broke down. Alerts notify you if your website or API endpoint is inaccessible. You can even expand your geographical coverage or monitor internal websites by creating private locations. You can also query your monitor results for a closer look. New Relic retains monitor results for thirteen months, ensuring you can compare usage year over year. Additional features Synthetic monitoring includes the following features: Feature Description Real browsers With simple browser and scripted browser monitors, synthetic monitoring doesn't simply check that your host is up. It loads the actual page content in a real, fully virtualized Google Chrome browser (powered by Selenium) to provide testing that mirrors your users' actions. Detailed results view Synthetic monitoring stores every single run of your monitor for 13 months, so you can view a detailed breakdown of each and every check. You can get a snapshot of your website's performance and availability, or hunt down specific problems. Comparative charts with browser monitoring Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the synthetic monitors. For example, during a page outage, you can compare trends to see if an issue is also visible in synthetic monitoring, or if it is caused by other variables. Advanced scripted monitoring Use scripted browsers to run complex test cases against your website. Ensure critical processes like checkout and login are always running smoothly, and build a baseline to compare against when things go wrong. With a built-in scripting IDE based on Node.js, create scripts quickly without leaving your browser. Global test coverage Check coverage from locations around the world to ensure your users can access your website from anywhere, anytime. Monitor sites behind your firewall by adding the synthetic monitoring static IP addresses to your allow list. Use private locations to monitor internal sites or to expand your coverage to new locations. Compatibility with popular analytics platforms Synthetic monitoring specifically excludes scripts for popular analytics services, like Google Analytics. This ensures your analytics tools continue to receive the exact same data, even with thousands of monitors checking your website each month. You can unblock any of the services blocked by default, or block additional services. REST API functions Synthetic monitoring includes a REST API, which you can use to manage: Simple monitors and scripted monitors Categories and labels for monitors Alert notifications Data protection and privacy The data from synthetic monitoring is test data, representing typical interaction with the webpage or application. It is never actual data from human beings. The data collected when you use synthetic monitoring therefore is not personal data. For more information, see the Synthetic monitoring security documentation. Compatibility and requirements Synthetic monitoring does not require any software except a supported browser. Important To monitor a site behind your firewall, add the synthetic monitoring public minion IP addresses to your allow list. Permissions By default, all users in your account can: View synthetic monitoring pages. Add, edit, and delete monitors. For more fine-grained control, you can enable the optional permissions system. The permissions system allows you to manage the level of access for users to view and edit within synthetic monitoring (for example, monitors and private locations).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.44225,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with <em>synthetic</em> <em>monitoring</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " critical business transactions. <em>Monitor</em> your API endpoints with API tests. Ready to <em>get</em> <em>started</em>? If you don&#x27;t already have one, sign up for a New Relic account. It&#x27;s free, forever! Advanced testing <em>Synthetic</em> <em>monitoring</em> allows you to proactively <em>monitor</em> your website or API endpoint to ensure your"
      },
      "id": "6045257e64441fa637378efe"
    },
    {
      "sections": [
        "Types of synthetic monitors",
        "Types of monitors"
      ],
      "title": "Types of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "f7fe7faff740058c77bdf27b2c1bfb5c6a206b40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/types-synthetic-monitors/",
      "published_at": "2021-12-25T16:57:52Z",
      "updated_at": "2021-10-18T21:27:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can proactively monitor your website or API endpoints with synthetic monitors. Depending on the type of monitor, you can: Add and edit monitors. Use the Synthetics REST API to manage monitors. Set up monitors from specific locations or for private servers. You can also use the host not reporting feature in infrastructure monitoring. This allows you to take advantage of enhanced monitoring options and be notified when New Relic has stopped receiving data from your hosts. Types of monitors These are the seven types of synthetic monitors: Type of synthetic monitor Description Broken links monitor API name: SCRIPT_API Provide a url and this monitor will test all the links on the page for success. If a failure is detected you can view the individual non-successful links that caused the failure. Certificate check monitor API name: SCRIPT_API Proactively ping your domain certificates based on a configurable threshold. Pair with an alert to ensure you are notified when your certificates need renewed. Ping monitor API name: SIMPLE Ping monitors are the simplest type of monitor. They simply check to see if an application is online. The synthetic ping monitor uses a simple Java HTTP client to make requests to your site. For consistency with other synthetic monitor types, the user agent is identified as Google Chrome. However, the HTTP client is not a full browser, and it does not execute JavaScript. If you need JavaScript functionality, use a simple browser monitor. Step monitor API name: STEP_MONITOR Step monitors are advanced monitors which require no code to set up. The monitor can be configured to: Assert modal Assert text Assert title Assert an element Click an element Dismiss a modal Double click an element Enter a secure credential Hover over an element Locate an element by CSS class, HTML ID, link text, Xpath, or value Navigate to a URL Select from a dropdown Type text Simple browser monitors API name: BROWSER Simple browser monitors essentially are simple, pre-built scripted browser monitors. They make a request to your site using an instance of Google Chrome. Compared to a simple ping monitor, this is a more accurate emulation of an actual customer visit. The user agent is identified as Google Chrome. Scripted browser monitors API name: SCRIPT_BROWSER Scripted browser monitors are used for more sophisticated, customized monitoring. You can create a custom script that navigates your website, takes specific actions, and ensures specific resources are present. The monitor uses Google Chrome browser. You can also use a variety of third-party modules to build your custom monitor. API tests API name: SCRIPT_API API tests are used to monitor your API endpoints. This can ensure that your app server works in addition to your website. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.44391,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Types of <em>synthetic</em> <em>monitors</em>",
        "sections": "Types of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can proactively <em>monitor</em> your website or API endpoints with <em>synthetic</em> monitors. Depending on the type of <em>monitor</em>, you can: Add and edit monitors. Use the <em>Synthetics</em> REST API to manage monitors. Set up monitors from specific locations or for private servers. You can also use the host"
      },
      "id": "603e873864441f3e154e888f"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "APIs for data ingest",
        "NerdGraph (GraphQL)",
        "REST API",
        "APIs by feature",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-12-25T04:32:43Z",
      "updated_at": "2021-12-19T15:29:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Send data to New Relic. Retrieve data from New Relic. View and configure settings. This document provides examples and reference information for our APIs. APIs for data ingest Our four primary data ingest APIs are some of the many solutions for reporting data to New Relic. These APIs can be used directly, but they're also the underlying ingest route for any of our tools that use those APIs (for example, our OpenTelemetry integration, or our Telemetry SDKs). API type Description Metric API Send dimensional metrics to New Relic from any source (including other telemetry monitoring services). Event API Send custom event data to New Relic without the use of an agent or integration. Log API Send log data to New Relic. Trace API Send distributed tracing data (also referred to as \"spans\") to New Relic without the use of an agent or integration. NerdGraph (GraphQL) NerdGraph is the API we recommend for querying New Relic data, querying account information, and making a range of feature configurations. To learn what you can do, check out the NerdGraph tutorials. NerdGraph is our newest API and is our attempt to bring together in one place some of our older APIs, like our REST API. Note that there is still some functionality you can do with REST APIs that can't yet be done with NerdGraph, and this is why some New Relic organizations still use the REST API. REST API Our REST API is our older API for querying and configuration, which NerdGraph is in the process of replacing. The REST API has some configuration abilities that NerdGraph doesn't yet have, but when possible you should use NerdGraph. The REST API can be used for a wide range of features: for detail, see APIs by feature. APIs by feature New Relic tools and features, like APM, infrastructure monitoring, browser monitoring, and alerts, are often used together, and sometimes can overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use NerdGraph. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The browser API resources include: Resource Details Browser agent API Use the browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To query New Relic data, use NerdGraph. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To query New Relic data, use NerdGraph. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To query New Relic data, use NerdGraph. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To query New Relic data, use NerdGraph. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage (original pricing model) For organizations on our original pricing model, you can use NerdGraph to query subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API If you're a New Relic partnership organization, you can use the Partner API to retrieve data and make configurations. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing models that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API Our Insights Query API is mostly deprecated. Instead, use NerdGraph for querying your New Relic data. Dashboard API Use the Dashboards API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.15321,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Synthetic</em> <em>monitoring</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": " rate data. Manage New Relic alerts conditions for your mobile apps. Query API To query New Relic data, use NerdGraph. Account management APIs For account-related APIs, see Account APIs. <em>Synthetic</em> <em>monitoring</em> <em>Synthetics</em> API resources include: Resource Details <em>Synthetics</em> REST API The <em>Synthetics</em> REST"
      },
      "id": "609fa5cf196a67066022b194"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/getting-started/types-synthetic-monitors": [
    {
      "sections": [
        "Get started with synthetic monitoring",
        "Why it matters",
        "Advanced testing",
        "Enhanced monitoring and reporting",
        "Additional features",
        "Data protection and privacy",
        "Compatibility and requirements",
        "Important",
        "Permissions"
      ],
      "title": "Get started with synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "0e5bba5ee7c140314180bff96253dce241ced14f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/get-started-synthetic-monitoring/",
      "published_at": "2021-12-26T01:49:37Z",
      "updated_at": "2021-11-25T01:41:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring is a suite of automated, scriptable tools to monitor your websites, critical business transactions, and API endpoints. You can simulate user traffic to proactively detect and resolve outages and poor performance of critical endpoints before your customers notice. Why it matters With synthetic monitoring, you can: Get the context of failures by connecting the availability and performance of endpoints to the underlying applications and infrastructure. Easily diagnose if an issue stems from the network or AWS location, a slow third party resource, or the health of backend services or infrastructure. Add synthetic monitoring into build automation and CI/CD pipelines to automatically track performance and check functionality for each deployment. Expand your monitoring further with real, Selenium-powered scripted browsers, which test login procedures, searches, and other critical business transactions. Monitor your API endpoints with API tests. Ready to get started? If you don't already have one, sign up for a New Relic account. It's free, forever! Advanced testing Synthetic monitoring allows you to proactively monitor your website or API endpoint to ensure your content is not only available, but fully functional. Synthetic monitoring browser tests send real, Selenium-powered Google Chrome browsers to your site from locations around the world to ensure your content is always up, everywhere. Scripted browsers expand your testing capabilities, so you can test uncommon user flows or beta-test complex procedures. For example, ensure your users are able to sign up for your newsletter, add an item to their cart, or search for and find a piece of critical content with a simple JavaScript-like language. Test your backend with API monitors, which allow you to run scripted tests against any API endpoint. Enhanced monitoring and reporting Synthetic monitoring aggregates the results of each check into metrics, allowing you to see patterns and identify causes of poor performance. Synthetic monitoring also stores each and every monitor result, so you can see exactly where your website broke down. Alerts notify you if your website or API endpoint is inaccessible. You can even expand your geographical coverage or monitor internal websites by creating private locations. You can also query your monitor results for a closer look. New Relic retains monitor results for thirteen months, ensuring you can compare usage year over year. Additional features Synthetic monitoring includes the following features: Feature Description Real browsers With simple browser and scripted browser monitors, synthetic monitoring doesn't simply check that your host is up. It loads the actual page content in a real, fully virtualized Google Chrome browser (powered by Selenium) to provide testing that mirrors your users' actions. Detailed results view Synthetic monitoring stores every single run of your monitor for 13 months, so you can view a detailed breakdown of each and every check. You can get a snapshot of your website's performance and availability, or hunt down specific problems. Comparative charts with browser monitoring Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the synthetic monitors. For example, during a page outage, you can compare trends to see if an issue is also visible in synthetic monitoring, or if it is caused by other variables. Advanced scripted monitoring Use scripted browsers to run complex test cases against your website. Ensure critical processes like checkout and login are always running smoothly, and build a baseline to compare against when things go wrong. With a built-in scripting IDE based on Node.js, create scripts quickly without leaving your browser. Global test coverage Check coverage from locations around the world to ensure your users can access your website from anywhere, anytime. Monitor sites behind your firewall by adding the synthetic monitoring static IP addresses to your allow list. Use private locations to monitor internal sites or to expand your coverage to new locations. Compatibility with popular analytics platforms Synthetic monitoring specifically excludes scripts for popular analytics services, like Google Analytics. This ensures your analytics tools continue to receive the exact same data, even with thousands of monitors checking your website each month. You can unblock any of the services blocked by default, or block additional services. REST API functions Synthetic monitoring includes a REST API, which you can use to manage: Simple monitors and scripted monitors Categories and labels for monitors Alert notifications Data protection and privacy The data from synthetic monitoring is test data, representing typical interaction with the webpage or application. It is never actual data from human beings. The data collected when you use synthetic monitoring therefore is not personal data. For more information, see the Synthetic monitoring security documentation. Compatibility and requirements Synthetic monitoring does not require any software except a supported browser. Important To monitor a site behind your firewall, add the synthetic monitoring public minion IP addresses to your allow list. Permissions By default, all users in your account can: View synthetic monitoring pages. Add, edit, and delete monitors. For more fine-grained control, you can enable the optional permissions system. The permissions system allows you to manage the level of access for users to view and edit within synthetic monitoring (for example, monitors and private locations).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.44225,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with <em>synthetic</em> <em>monitoring</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " critical business transactions. <em>Monitor</em> your API endpoints with API tests. Ready to <em>get</em> <em>started</em>? If you don&#x27;t already have one, sign up for a New Relic account. It&#x27;s free, forever! Advanced testing <em>Synthetic</em> <em>monitoring</em> allows you to proactively <em>monitor</em> your website or API endpoint to ensure your"
      },
      "id": "6045257e64441fa637378efe"
    },
    {
      "sections": [
        "Security for synthetic monitoring",
        "What we do",
        "What you can do"
      ],
      "title": "Security for synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "c36cbaf0bec47e56e54e66f7eb39484a3ef7f426",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/security-synthetic-monitoring/",
      "published_at": "2021-12-25T18:29:31Z",
      "updated_at": "2021-07-27T18:44:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's synthetic monitoring uses monitors distributed throughout data centers around the world. By design, it captures what is essentially performance data for simulated traffic. It does not capture or handle any personal data by default. All data handled by synthetic monitors is expected to be non-personal. This document provides additional details about what we do to ensure data privacy and security with synthetic monitoring, plus additional options you can use. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. What we do Here's a summary of the data privacy and security measures that New Relic provides for you. Data privacy and security Comments No personal data By definition, all data collected through synthetic monitoring is test data created for the purpose of monitoring. None of this data includes personal data from any individual. TLS TLS encryption is required for all domains. This applies to public locations and private locations. Authentication Synthetic monitoring supports a variety of authentication mechanisms, including Basic, Digest, NTLM, and NTLMv2. Available options depend on the type of monitor you choose. Data collection The data transferred to the synthetic endpoint includes: Monitor run results, including full request and response headers of all requests, a complete HAR file of the session, and any screenshots captured (on failure or manually) Polling for available jobs in the private location's queue Private minion \"heartbeat\" every 30 seconds The SyntheticsPrivateMinion event contains basic minion status, including job success and failure counts, queue size, minion version, etc. Data received Data received from the synthetic monitoring endpoint contains the scheduled check's details. This includes the information necessary to complete the check for the minion: Target URL Validation text Full script (for synthetic scripted browser monitors) Data storage location Data collected by synthetic monitoring is stored in the region selected by each customer for their account (US or EU). Monitor configuration details (including frequency, check locations, target URL, and the full script for any scripted browser or API test monitors) are stored on our end. We also store all monitor check results for each monitor type. Data storage by monitor type For ping monitors, data storage includes the HAR file, which includes all requests and responses made during the check. For simple browsers, scripted browsers, and API tests, data storage includes the following: The HAR file includes full request and response headers for all requests made during the check. Any screenshots taken during the check are automatically included for simple and scripted browser monitors only on failure. However, you can manually configure this with scripting. The browser log (JS console) is automatically included for simple and scripted browsers. Any script output is included for scripted browsers and API test monitors. Response bodies New Relic never stores response bodies from requests originated by synthetic monitoring, unless you have manually configured a monitor script to do so. IP addresses Synthetic public minions are expected to be activated using non-personal credentials. Their IP addresses are not defined as personal data under data protection and privacy laws. What you can do For additional levels of security and data privacy, consider using these options. Additional measures Comments User access To control which of your users can access your monitors and private locations, set up role-based synthetic monitoring permissions and user groups. In addition, to track and be notified about changes, use audit logs and alert notifications. Passwords, API keys, user names, etc. To securely store sensitive information, use secured credentials for scripted browsers and API tests. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). Sites behind firewalls To control what sites you want to monitor behind your firewall, you can: Add the synthetic public minion IP addresses to your allow list or deny list. Use private locations to monitor sites or endpoints. This can provide an extra layer of security when monitoring your internally hosted sites and services. Web pages behind login pages If you configure synthetic monitoring to track website areas that are located behind a login page, be sure to create a non-personal login specifically for this purpose. This unique login will reduce the risk of unintended personal data exposure. Proxy configuration Aside from the target URLs monitored by New Relic, private minions will regularly send data to and receive from the synthetic monitoring endpoint. To configure a proxy for all traffic to and from this endpoint, set the MINION_API_PROXY environment variable on the minion host. Private minions security To ensure that only the scripts you intend to run are allowed to run on private minions, use verified script execution.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.64221,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for <em>synthetic</em> <em>monitoring</em>",
        "sections": "Security for <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " for available jobs in the private location&#x27;s queue Private minion &quot;heartbeat&quot; every 30 seconds The <em>Synthetics</em>PrivateMinion event contains basic minion status, including job success and failure counts, queue size, minion version, etc. Data received Data received from the <em>synthetic</em> <em>monitoring</em> endpoint"
      },
      "id": "604525b8e7b9d270a35799c8"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "APIs for data ingest",
        "NerdGraph (GraphQL)",
        "REST API",
        "APIs by feature",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-12-25T04:32:43Z",
      "updated_at": "2021-12-19T15:29:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Send data to New Relic. Retrieve data from New Relic. View and configure settings. This document provides examples and reference information for our APIs. APIs for data ingest Our four primary data ingest APIs are some of the many solutions for reporting data to New Relic. These APIs can be used directly, but they're also the underlying ingest route for any of our tools that use those APIs (for example, our OpenTelemetry integration, or our Telemetry SDKs). API type Description Metric API Send dimensional metrics to New Relic from any source (including other telemetry monitoring services). Event API Send custom event data to New Relic without the use of an agent or integration. Log API Send log data to New Relic. Trace API Send distributed tracing data (also referred to as \"spans\") to New Relic without the use of an agent or integration. NerdGraph (GraphQL) NerdGraph is the API we recommend for querying New Relic data, querying account information, and making a range of feature configurations. To learn what you can do, check out the NerdGraph tutorials. NerdGraph is our newest API and is our attempt to bring together in one place some of our older APIs, like our REST API. Note that there is still some functionality you can do with REST APIs that can't yet be done with NerdGraph, and this is why some New Relic organizations still use the REST API. REST API Our REST API is our older API for querying and configuration, which NerdGraph is in the process of replacing. The REST API has some configuration abilities that NerdGraph doesn't yet have, but when possible you should use NerdGraph. The REST API can be used for a wide range of features: for detail, see APIs by feature. APIs by feature New Relic tools and features, like APM, infrastructure monitoring, browser monitoring, and alerts, are often used together, and sometimes can overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use NerdGraph. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The browser API resources include: Resource Details Browser agent API Use the browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To query New Relic data, use NerdGraph. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To query New Relic data, use NerdGraph. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To query New Relic data, use NerdGraph. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To query New Relic data, use NerdGraph. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage (original pricing model) For organizations on our original pricing model, you can use NerdGraph to query subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API If you're a New Relic partnership organization, you can use the Partner API to retrieve data and make configurations. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing models that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API Our Insights Query API is mostly deprecated. Instead, use NerdGraph for querying your New Relic data. Dashboard API Use the Dashboards API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.15321,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Synthetic</em> <em>monitoring</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": " rate data. Manage New Relic alerts conditions for your mobile apps. Query API To query New Relic data, use NerdGraph. Account management APIs For account-related APIs, see Account APIs. <em>Synthetic</em> <em>monitoring</em> <em>Synthetics</em> API resources include: Resource Details <em>Synthetics</em> REST API The <em>Synthetics</em> REST"
      },
      "id": "609fa5cf196a67066022b194"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-aggregate-monitor-metrics": [
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-12-25T17:34:22Z",
      "updated_at": "2021-11-07T09:25:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. Avoid extra noise and get notified after three failures Read our blog post on the three strikes rule.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.8695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures <em>page</em> To access your <em>monitor</em>&#x27;s failures: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Failures. Hover the mouse over a failure to get"
      },
      "id": "603e9efd64441faf344e8865"
    },
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-25T17:06:36Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.13728,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results <em>page</em> To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results <em>page</em> to locate interesting runs of your <em>monitor</em> for troubleshooting"
      },
      "id": "603eb5da64441f07ae4e8850"
    },
    {
      "sections": [
        "Synthetic monitoring: Understand load times",
        "View the Resources page",
        "Understand resource metrics",
        "View detailed resource metrics",
        "View individual resource loads",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Understand load times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "a6d91eef3b89f682ce06d4408928f0c8b70b90e6",
      "image": "https://docs.newrelic.com/static/fe6794ec2ba009717f08a91fae4841fc/8c557/resource-load.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-understand-load-times/",
      "published_at": "2021-12-25T17:02:20Z",
      "updated_at": "2021-10-31T07:59:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Resources page to understand the load time impact of each resource on your website. Use the resources load time, time spent by third parties, and irregular response codes graphs for a high-level overview, and use the resources list to identify high-impact resources such as large CSS files or images. You can also investigate a specific resource with detailed resource metrics, which aggregate performance information for a single resource. Go even deeper and view one load of that resource, using the exact request and response headers to pinpoint a performance issue. View the Resources page To access your monitor's Resources page: Go to one.newrelic.com > Synthetics > (select a monitor) > Resources. one.newrelic.com > Synthetics > (select a monitor) > Resources: Use the Resources page to analyze the performance of each resource on your website, and to access detailed metrics with individual resource loads. Understand resource metrics Use the Resources page to understand the performance impact of each resource on your website: Resources list: Lists the resources on your monitored website by average download time. Use this list to optimize your website's performance by reducing download times. You can also view the load time for any particular resource by searching for it in the Search all resources field. Select a resource to view individual resource metrics. Load time: Graphs the average load time for all resources, broken down by resource type (such as jpeg, json, or javascript). Use this graph to understand how the load time of your website changes over time. Time spent by third parties: Graphs the average load time of all third-party resources, such as web fonts, an embedded Twitter timeline, or an externally hosted image. Use this graph to see if third-party websites are affecting your website's performance. Irregular response codes: Graphs the number of negative HTTP response codes (also called HTTP status codes) received by the monitor. This graph includes all responses in the 300 (redirection), 400 (client error), and 500 (server error) ranges. It does not count responses in the 100 or 200 ranges. Synthetics also collects a number of custom response codes. By analyzing these metrics, you can track down troublesome resources and improve their performance. For example, an unoptimized logo image might cause slowdowns for every visitor of your site, while a tracker that is served only from a US-based server could result in slow performance for non-US visitors. View detailed resource metrics You can also view detailed metrics for each resource on your site. To view detailed metrics, locate a specific resource, or simply select an interesting resource from the Resources page. After selecting a resource, you can view overview metrics for that resource, or view an individual resource load: Max duration, Min duration, Avg duration: Load time metrics for this resource over the selected time frame. For 50% of requests: The maximum download time for the fastest 50% of requests. This means that 50% of requests for this resource were completed in the specified time or faster. For 95% of requests: The maximum download time for the fastest 95% of requests. This means that 95% of requests for this resource were completed in the specified time or faster. Average load time: Graphs the average load time for this resource over the selected time frame. Use this graph to verify that optimizations to your website (such as decreasing the size of an image or minifying your CSS) are working. You can also hide and unhide chart elements, filter by location, and sort the resource results list by Download time or DNS lookup. Mouse over the resource name to view the full path (useful with very long dynamically generated resource names). View individual resource loads After viewing detailed metrics for a particular resource, you can select an individual resource load for an in-depth understanding of one poor performance incident. You can then view a breakdown of the total connection time to understand where the issue occurred, and examine request and response headers. one.newrelic.com > Synthetics > (select a monitor) > Resources > (select a resource) > (select a resource load): Select an individual resource load to see a detailed breakdown of connection time, request headers, and response headers. Network timing structure taken from the HTTP Archive 1.2 specification. Use page functions The Resources page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select a sort option: Sort by Average download time to view your slowest-loading resources. Sort by Average size to view your largest resources. Hide and unhide chart elements Select chart elements to hide and unhide them. Locate a specific resource Enter part of your resource name in the Search all resources field (for example, search-icon.png or latest.json). Select the resource to view detailed metrics for that resource. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.1062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Understand load times",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Understand load times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>page</em> To access your <em>monitor</em>&#x27;s Resources <em>page</em>: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Resources. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Resources: Use the Resources <em>page</em> to analyze the performance of each resource on your website, and to access detailed metrics"
      },
      "id": "604525b864441f0943378ebb"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary": [
    {
      "sections": [
        "Synthetic monitoring: Aggregate monitor metrics",
        "View synthetic monitoring SLA reports",
        "Understand SLA report metrics",
        "Use page functions",
        "Generate SLA values"
      ],
      "title": "Synthetic monitoring: Aggregate monitor metrics",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "bbead36a5b36d126243f0beb2d60e9ccf23763f5",
      "image": "https://docs.newrelic.com/static/d0dc46884c112568daf4e491098e1951/c1b63/sla-report.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-aggregate-monitor-metrics/",
      "published_at": "2021-12-25T17:22:13Z",
      "updated_at": "2021-11-15T07:04:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View synthetic monitoring SLA reports To view your account-wide SLA report: Go to one.newrelic.com > Synthetics > SLA Report. Choose from reports aggregated by day, week, or month by selecting Daily, Weekly, or Monthly as appropriate. You can also view SLA reports for individual monitors: Go to one.newrelic.com > Synthetics > (select a monitor) > SLA. one.newrelic.com > Synthetics > SLA Report: Use SLA reports to understand your monitors' performance over time. Understand SLA report metrics Use SLA reports to view aggregated performance metrics for a single monitor, or for all your monitors from the account-wide SLA Reports page. SLA reports include the following metrics: Duration: The average duration across all monitor results. Uptime: The percentage of all monitor results that ended successfully. For example, Monitor A might check 50 times per day, and Monitor B might check 150 times per day. If Monitor A has 29 successes out of 50 and Monitor B has 148 successes out of 150, the Uptime would be 88.5: (29+148)/(50+150)=88.5 For individual SLA reports, the uptime score only includes the selected monitor. Apdex: The average Apdex across all monitors. Monitors have a default Apdex T of 7 seconds, but you can customize Apdex T for individual monitors by editing their settings. Apdex F, which defines a frustrating result, is always four times Apdex T. For more information about Apdex, see Apdex: Measuring user satisfaction. For individual SLA reports, the Apdex score only includes the selected monitor. % Satisfied: The percentage of monitor results which complete in a \"satisfying\" time. A satisfying time is defined as a monitor result that completes in Apdex T or less. % Toleration: The percentage of monitor results which complete in a \"tolerable\" time. A tolerable time is greater than Apdex T, but less than Apdex F (four times Apdex T). % Frustrated: The percentage of monitor results which complete in a \"frustrating\" time. A frustrating time is greater than Apdex F (four times Apdex T). The account-wide SLA report includes all monitor types (ping, simple browser, scripted browser, and API test). Use page functions SLA reports support the following features: If you want to... Do this... View the report in Excel or an external program Select Download this report as .csv to download a copy of your SLA data. Open the file in Excel, Google Drive, or another spreadsheet editor to analyze your data. Change your Apdex targets The default Apdex T for all monitors is 7 seconds. You can customize your Apdex T target for individual monitors by editing your monitor. Change the time frame Choose from daily, weekly, or monthly aggregation by selecting the appropriate tab. Make the report public Change the Public SLA setting to ON to allow non-authenticated users to view the report. Select Share Report to get the public URL to share. Generate SLA values The values in the SLA report are generated from Insights queries against the available synthetic monitoring data. You can easily recreate these values and modify the queries to meet your needs. This query returns the average duration, the apdex, and the uptime. Substitute your values for the variables highlighted and described below. SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod Copy Variable Value t: Supply the Apdex T that you would like to calculate your apdex against. The duration attribute in the SyntheticCheck event is stored in milliseconds, so an Apdex T value of 7 seconds should be included as 7000. timeperiod This is the period that you would like to calculate on. For a daily report, facet on dateOf(timestamp), for a weekly report facet on weekOf(timestamp) and for a monthly report facet on monthOf(timestamp). NRQL queries default to querying against the last hour of data. In order to widen the scope of your data you will need to include a SINCE clause at the end of your query. Example #1: Daily report for the last week To generate a daily report for the last week you would add SINCE 1 week ago: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET dateOf(timestamp) SINCE 1 week ago Copy Example #2: Report for a particular monitor To scope the results to a particular monitor you can edit the below query to include a specific monitor name: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName = 'mymonitorname' Copy Example #3: Report for multiple monitors To scope the results to a collection of monitors: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName IN ('mymonitor1', 'mymonitor2', 'mymonitor3') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.906,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View <em>synthetic</em> <em>monitoring</em> SLA reports To view your account-wide SLA report: Go to one.newrelic.com &gt; <em>Synthetics</em>"
      },
      "id": "603ec399196a67e073a83d96"
    },
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-12-25T17:34:22Z",
      "updated_at": "2021-11-07T09:25:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. Avoid extra noise and get notified after three failures Read our blog post on the three strikes rule.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.8695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures <em>page</em> To access your <em>monitor</em>&#x27;s failures: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Failures. Hover the mouse over a failure to get"
      },
      "id": "603e9efd64441faf344e8865"
    },
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-25T17:06:36Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.13728,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results <em>page</em> To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results <em>page</em> to locate interesting runs of your <em>monitor</em> for troubleshooting"
      },
      "id": "603eb5da64441f07ae4e8850"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime": [
    {
      "sections": [
        "Synthetic monitoring: Aggregate monitor metrics",
        "View synthetic monitoring SLA reports",
        "Understand SLA report metrics",
        "Use page functions",
        "Generate SLA values"
      ],
      "title": "Synthetic monitoring: Aggregate monitor metrics",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "bbead36a5b36d126243f0beb2d60e9ccf23763f5",
      "image": "https://docs.newrelic.com/static/d0dc46884c112568daf4e491098e1951/c1b63/sla-report.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-aggregate-monitor-metrics/",
      "published_at": "2021-12-25T17:22:13Z",
      "updated_at": "2021-11-15T07:04:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View synthetic monitoring SLA reports To view your account-wide SLA report: Go to one.newrelic.com > Synthetics > SLA Report. Choose from reports aggregated by day, week, or month by selecting Daily, Weekly, or Monthly as appropriate. You can also view SLA reports for individual monitors: Go to one.newrelic.com > Synthetics > (select a monitor) > SLA. one.newrelic.com > Synthetics > SLA Report: Use SLA reports to understand your monitors' performance over time. Understand SLA report metrics Use SLA reports to view aggregated performance metrics for a single monitor, or for all your monitors from the account-wide SLA Reports page. SLA reports include the following metrics: Duration: The average duration across all monitor results. Uptime: The percentage of all monitor results that ended successfully. For example, Monitor A might check 50 times per day, and Monitor B might check 150 times per day. If Monitor A has 29 successes out of 50 and Monitor B has 148 successes out of 150, the Uptime would be 88.5: (29+148)/(50+150)=88.5 For individual SLA reports, the uptime score only includes the selected monitor. Apdex: The average Apdex across all monitors. Monitors have a default Apdex T of 7 seconds, but you can customize Apdex T for individual monitors by editing their settings. Apdex F, which defines a frustrating result, is always four times Apdex T. For more information about Apdex, see Apdex: Measuring user satisfaction. For individual SLA reports, the Apdex score only includes the selected monitor. % Satisfied: The percentage of monitor results which complete in a \"satisfying\" time. A satisfying time is defined as a monitor result that completes in Apdex T or less. % Toleration: The percentage of monitor results which complete in a \"tolerable\" time. A tolerable time is greater than Apdex T, but less than Apdex F (four times Apdex T). % Frustrated: The percentage of monitor results which complete in a \"frustrating\" time. A frustrating time is greater than Apdex F (four times Apdex T). The account-wide SLA report includes all monitor types (ping, simple browser, scripted browser, and API test). Use page functions SLA reports support the following features: If you want to... Do this... View the report in Excel or an external program Select Download this report as .csv to download a copy of your SLA data. Open the file in Excel, Google Drive, or another spreadsheet editor to analyze your data. Change your Apdex targets The default Apdex T for all monitors is 7 seconds. You can customize your Apdex T target for individual monitors by editing your monitor. Change the time frame Choose from daily, weekly, or monthly aggregation by selecting the appropriate tab. Make the report public Change the Public SLA setting to ON to allow non-authenticated users to view the report. Select Share Report to get the public URL to share. Generate SLA values The values in the SLA report are generated from Insights queries against the available synthetic monitoring data. You can easily recreate these values and modify the queries to meet your needs. This query returns the average duration, the apdex, and the uptime. Substitute your values for the variables highlighted and described below. SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod Copy Variable Value t: Supply the Apdex T that you would like to calculate your apdex against. The duration attribute in the SyntheticCheck event is stored in milliseconds, so an Apdex T value of 7 seconds should be included as 7000. timeperiod This is the period that you would like to calculate on. For a daily report, facet on dateOf(timestamp), for a weekly report facet on weekOf(timestamp) and for a monthly report facet on monthOf(timestamp). NRQL queries default to querying against the last hour of data. In order to widen the scope of your data you will need to include a SINCE clause at the end of your query. Example #1: Daily report for the last week To generate a daily report for the last week you would add SINCE 1 week ago: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET dateOf(timestamp) SINCE 1 week ago Copy Example #2: Report for a particular monitor To scope the results to a particular monitor you can edit the below query to include a specific monitor name: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName = 'mymonitorname' Copy Example #3: Report for multiple monitors To scope the results to a collection of monitors: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName IN ('mymonitor1', 'mymonitor2', 'mymonitor3') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.906,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View <em>synthetic</em> <em>monitoring</em> SLA reports To view your account-wide SLA report: Go to one.newrelic.com &gt; <em>Synthetics</em>"
      },
      "id": "603ec399196a67e073a83d96"
    },
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-25T17:06:36Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.13728,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results <em>page</em> To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results <em>page</em> to locate interesting runs of your <em>monitor</em> for troubleshooting"
      },
      "id": "603eb5da64441f07ae4e8850"
    },
    {
      "sections": [
        "Synthetic monitoring: Understand load times",
        "View the Resources page",
        "Understand resource metrics",
        "View detailed resource metrics",
        "View individual resource loads",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Understand load times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "a6d91eef3b89f682ce06d4408928f0c8b70b90e6",
      "image": "https://docs.newrelic.com/static/fe6794ec2ba009717f08a91fae4841fc/8c557/resource-load.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-understand-load-times/",
      "published_at": "2021-12-25T17:02:20Z",
      "updated_at": "2021-10-31T07:59:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Resources page to understand the load time impact of each resource on your website. Use the resources load time, time spent by third parties, and irregular response codes graphs for a high-level overview, and use the resources list to identify high-impact resources such as large CSS files or images. You can also investigate a specific resource with detailed resource metrics, which aggregate performance information for a single resource. Go even deeper and view one load of that resource, using the exact request and response headers to pinpoint a performance issue. View the Resources page To access your monitor's Resources page: Go to one.newrelic.com > Synthetics > (select a monitor) > Resources. one.newrelic.com > Synthetics > (select a monitor) > Resources: Use the Resources page to analyze the performance of each resource on your website, and to access detailed metrics with individual resource loads. Understand resource metrics Use the Resources page to understand the performance impact of each resource on your website: Resources list: Lists the resources on your monitored website by average download time. Use this list to optimize your website's performance by reducing download times. You can also view the load time for any particular resource by searching for it in the Search all resources field. Select a resource to view individual resource metrics. Load time: Graphs the average load time for all resources, broken down by resource type (such as jpeg, json, or javascript). Use this graph to understand how the load time of your website changes over time. Time spent by third parties: Graphs the average load time of all third-party resources, such as web fonts, an embedded Twitter timeline, or an externally hosted image. Use this graph to see if third-party websites are affecting your website's performance. Irregular response codes: Graphs the number of negative HTTP response codes (also called HTTP status codes) received by the monitor. This graph includes all responses in the 300 (redirection), 400 (client error), and 500 (server error) ranges. It does not count responses in the 100 or 200 ranges. Synthetics also collects a number of custom response codes. By analyzing these metrics, you can track down troublesome resources and improve their performance. For example, an unoptimized logo image might cause slowdowns for every visitor of your site, while a tracker that is served only from a US-based server could result in slow performance for non-US visitors. View detailed resource metrics You can also view detailed metrics for each resource on your site. To view detailed metrics, locate a specific resource, or simply select an interesting resource from the Resources page. After selecting a resource, you can view overview metrics for that resource, or view an individual resource load: Max duration, Min duration, Avg duration: Load time metrics for this resource over the selected time frame. For 50% of requests: The maximum download time for the fastest 50% of requests. This means that 50% of requests for this resource were completed in the specified time or faster. For 95% of requests: The maximum download time for the fastest 95% of requests. This means that 95% of requests for this resource were completed in the specified time or faster. Average load time: Graphs the average load time for this resource over the selected time frame. Use this graph to verify that optimizations to your website (such as decreasing the size of an image or minifying your CSS) are working. You can also hide and unhide chart elements, filter by location, and sort the resource results list by Download time or DNS lookup. Mouse over the resource name to view the full path (useful with very long dynamically generated resource names). View individual resource loads After viewing detailed metrics for a particular resource, you can select an individual resource load for an in-depth understanding of one poor performance incident. You can then view a breakdown of the total connection time to understand where the issue occurred, and examine request and response headers. one.newrelic.com > Synthetics > (select a monitor) > Resources > (select a resource) > (select a resource load): Select an individual resource load to see a detailed breakdown of connection time, request headers, and response headers. Network timing structure taken from the HTTP Archive 1.2 specification. Use page functions The Resources page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select a sort option: Sort by Average download time to view your slowest-loading resources. Sort by Average size to view your largest resources. Hide and unhide chart elements Select chart elements to hide and unhide them. Locate a specific resource Enter part of your resource name in the Search all resources field (for example, search-icon.png or latest.json). Select the resource to view detailed metrics for that resource. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.1062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Understand load times",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Understand load times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>page</em> To access your <em>monitor</em>&#x27;s Resources <em>page</em>: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Resources. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Resources: Use the Resources <em>page</em> to analyze the performance of each resource on your website, and to access detailed metrics"
      },
      "id": "604525b864441f0943378ebb"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-understand-load-times": [
    {
      "sections": [
        "Synthetic monitoring: Aggregate monitor metrics",
        "View synthetic monitoring SLA reports",
        "Understand SLA report metrics",
        "Use page functions",
        "Generate SLA values"
      ],
      "title": "Synthetic monitoring: Aggregate monitor metrics",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "bbead36a5b36d126243f0beb2d60e9ccf23763f5",
      "image": "https://docs.newrelic.com/static/d0dc46884c112568daf4e491098e1951/c1b63/sla-report.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-aggregate-monitor-metrics/",
      "published_at": "2021-12-25T17:22:13Z",
      "updated_at": "2021-11-15T07:04:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View synthetic monitoring SLA reports To view your account-wide SLA report: Go to one.newrelic.com > Synthetics > SLA Report. Choose from reports aggregated by day, week, or month by selecting Daily, Weekly, or Monthly as appropriate. You can also view SLA reports for individual monitors: Go to one.newrelic.com > Synthetics > (select a monitor) > SLA. one.newrelic.com > Synthetics > SLA Report: Use SLA reports to understand your monitors' performance over time. Understand SLA report metrics Use SLA reports to view aggregated performance metrics for a single monitor, or for all your monitors from the account-wide SLA Reports page. SLA reports include the following metrics: Duration: The average duration across all monitor results. Uptime: The percentage of all monitor results that ended successfully. For example, Monitor A might check 50 times per day, and Monitor B might check 150 times per day. If Monitor A has 29 successes out of 50 and Monitor B has 148 successes out of 150, the Uptime would be 88.5: (29+148)/(50+150)=88.5 For individual SLA reports, the uptime score only includes the selected monitor. Apdex: The average Apdex across all monitors. Monitors have a default Apdex T of 7 seconds, but you can customize Apdex T for individual monitors by editing their settings. Apdex F, which defines a frustrating result, is always four times Apdex T. For more information about Apdex, see Apdex: Measuring user satisfaction. For individual SLA reports, the Apdex score only includes the selected monitor. % Satisfied: The percentage of monitor results which complete in a \"satisfying\" time. A satisfying time is defined as a monitor result that completes in Apdex T or less. % Toleration: The percentage of monitor results which complete in a \"tolerable\" time. A tolerable time is greater than Apdex T, but less than Apdex F (four times Apdex T). % Frustrated: The percentage of monitor results which complete in a \"frustrating\" time. A frustrating time is greater than Apdex F (four times Apdex T). The account-wide SLA report includes all monitor types (ping, simple browser, scripted browser, and API test). Use page functions SLA reports support the following features: If you want to... Do this... View the report in Excel or an external program Select Download this report as .csv to download a copy of your SLA data. Open the file in Excel, Google Drive, or another spreadsheet editor to analyze your data. Change your Apdex targets The default Apdex T for all monitors is 7 seconds. You can customize your Apdex T target for individual monitors by editing your monitor. Change the time frame Choose from daily, weekly, or monthly aggregation by selecting the appropriate tab. Make the report public Change the Public SLA setting to ON to allow non-authenticated users to view the report. Select Share Report to get the public URL to share. Generate SLA values The values in the SLA report are generated from Insights queries against the available synthetic monitoring data. You can easily recreate these values and modify the queries to meet your needs. This query returns the average duration, the apdex, and the uptime. Substitute your values for the variables highlighted and described below. SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod Copy Variable Value t: Supply the Apdex T that you would like to calculate your apdex against. The duration attribute in the SyntheticCheck event is stored in milliseconds, so an Apdex T value of 7 seconds should be included as 7000. timeperiod This is the period that you would like to calculate on. For a daily report, facet on dateOf(timestamp), for a weekly report facet on weekOf(timestamp) and for a monthly report facet on monthOf(timestamp). NRQL queries default to querying against the last hour of data. In order to widen the scope of your data you will need to include a SINCE clause at the end of your query. Example #1: Daily report for the last week To generate a daily report for the last week you would add SINCE 1 week ago: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET dateOf(timestamp) SINCE 1 week ago Copy Example #2: Report for a particular monitor To scope the results to a particular monitor you can edit the below query to include a specific monitor name: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName = 'mymonitorname' Copy Example #3: Report for multiple monitors To scope the results to a collection of monitors: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName IN ('mymonitor1', 'mymonitor2', 'mymonitor3') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.906,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View <em>synthetic</em> <em>monitoring</em> SLA reports To view your account-wide SLA report: Go to one.newrelic.com &gt; <em>Synthetics</em>"
      },
      "id": "603ec399196a67e073a83d96"
    },
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-12-25T17:34:22Z",
      "updated_at": "2021-11-07T09:25:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. Avoid extra noise and get notified after three failures Read our blog post on the three strikes rule.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.8695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures <em>page</em> To access your <em>monitor</em>&#x27;s failures: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Failures. Hover the mouse over a failure to get"
      },
      "id": "603e9efd64441faf344e8865"
    },
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-25T17:06:36Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.13727,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results <em>page</em> To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results <em>page</em> to locate interesting runs of your <em>monitor</em> for troubleshooting"
      },
      "id": "603eb5da64441f07ae4e8850"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/pages/synthetic-monitors-index": [
    {
      "sections": [
        "Synthetic monitoring: Aggregate monitor metrics",
        "View synthetic monitoring SLA reports",
        "Understand SLA report metrics",
        "Use page functions",
        "Generate SLA values"
      ],
      "title": "Synthetic monitoring: Aggregate monitor metrics",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "bbead36a5b36d126243f0beb2d60e9ccf23763f5",
      "image": "https://docs.newrelic.com/static/d0dc46884c112568daf4e491098e1951/c1b63/sla-report.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-aggregate-monitor-metrics/",
      "published_at": "2021-12-25T17:22:13Z",
      "updated_at": "2021-11-15T07:04:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View synthetic monitoring SLA reports To view your account-wide SLA report: Go to one.newrelic.com > Synthetics > SLA Report. Choose from reports aggregated by day, week, or month by selecting Daily, Weekly, or Monthly as appropriate. You can also view SLA reports for individual monitors: Go to one.newrelic.com > Synthetics > (select a monitor) > SLA. one.newrelic.com > Synthetics > SLA Report: Use SLA reports to understand your monitors' performance over time. Understand SLA report metrics Use SLA reports to view aggregated performance metrics for a single monitor, or for all your monitors from the account-wide SLA Reports page. SLA reports include the following metrics: Duration: The average duration across all monitor results. Uptime: The percentage of all monitor results that ended successfully. For example, Monitor A might check 50 times per day, and Monitor B might check 150 times per day. If Monitor A has 29 successes out of 50 and Monitor B has 148 successes out of 150, the Uptime would be 88.5: (29+148)/(50+150)=88.5 For individual SLA reports, the uptime score only includes the selected monitor. Apdex: The average Apdex across all monitors. Monitors have a default Apdex T of 7 seconds, but you can customize Apdex T for individual monitors by editing their settings. Apdex F, which defines a frustrating result, is always four times Apdex T. For more information about Apdex, see Apdex: Measuring user satisfaction. For individual SLA reports, the Apdex score only includes the selected monitor. % Satisfied: The percentage of monitor results which complete in a \"satisfying\" time. A satisfying time is defined as a monitor result that completes in Apdex T or less. % Toleration: The percentage of monitor results which complete in a \"tolerable\" time. A tolerable time is greater than Apdex T, but less than Apdex F (four times Apdex T). % Frustrated: The percentage of monitor results which complete in a \"frustrating\" time. A frustrating time is greater than Apdex F (four times Apdex T). The account-wide SLA report includes all monitor types (ping, simple browser, scripted browser, and API test). Use page functions SLA reports support the following features: If you want to... Do this... View the report in Excel or an external program Select Download this report as .csv to download a copy of your SLA data. Open the file in Excel, Google Drive, or another spreadsheet editor to analyze your data. Change your Apdex targets The default Apdex T for all monitors is 7 seconds. You can customize your Apdex T target for individual monitors by editing your monitor. Change the time frame Choose from daily, weekly, or monthly aggregation by selecting the appropriate tab. Make the report public Change the Public SLA setting to ON to allow non-authenticated users to view the report. Select Share Report to get the public URL to share. Generate SLA values The values in the SLA report are generated from Insights queries against the available synthetic monitoring data. You can easily recreate these values and modify the queries to meet your needs. This query returns the average duration, the apdex, and the uptime. Substitute your values for the variables highlighted and described below. SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod Copy Variable Value t: Supply the Apdex T that you would like to calculate your apdex against. The duration attribute in the SyntheticCheck event is stored in milliseconds, so an Apdex T value of 7 seconds should be included as 7000. timeperiod This is the period that you would like to calculate on. For a daily report, facet on dateOf(timestamp), for a weekly report facet on weekOf(timestamp) and for a monthly report facet on monthOf(timestamp). NRQL queries default to querying against the last hour of data. In order to widen the scope of your data you will need to include a SINCE clause at the end of your query. Example #1: Daily report for the last week To generate a daily report for the last week you would add SINCE 1 week ago: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET dateOf(timestamp) SINCE 1 week ago Copy Example #2: Report for a particular monitor To scope the results to a particular monitor you can edit the below query to include a specific monitor name: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName = 'mymonitorname' Copy Example #3: Report for multiple monitors To scope the results to a collection of monitors: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName IN ('mymonitor1', 'mymonitor2', 'mymonitor3') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.906,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View <em>synthetic</em> <em>monitoring</em> SLA reports To view your account-wide SLA report: Go to one.newrelic.com &gt; <em>Synthetics</em>"
      },
      "id": "603ec399196a67e073a83d96"
    },
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-12-25T17:34:22Z",
      "updated_at": "2021-11-07T09:25:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. Avoid extra noise and get notified after three failures Read our blog post on the three strikes rule.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.8695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures <em>page</em> To access your <em>monitor</em>&#x27;s failures: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Failures. Hover the mouse over a failure to get"
      },
      "id": "603e9efd64441faf344e8865"
    },
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-25T17:06:36Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.13727,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results <em>page</em> To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results <em>page</em> to locate interesting runs of your <em>monitor</em> for troubleshooting"
      },
      "id": "603eb5da64441f07ae4e8850"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration": [
    {
      "sections": [
        "Monitor private locations",
        "Prerequisites",
        "Private Minion dashboard JSON",
        "Tip",
        "Are my private minions online?",
        "Does my private location need more minions?",
        "Can I check the status of a specific minion directly?"
      ],
      "title": "Monitor private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "d38b5c957ec41b25199f4d093eb2f6083a5ff351",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/monitor-private-locations/",
      "published_at": "2021-12-25T18:33:22Z",
      "updated_at": "2021-12-15T12:32:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using synthetic monitoring's private locations with New Relic's alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic dashboards and NRQL alerts: Are my private minions online? Does my private location need more minions? Can I check the status of a specific minion directly? Prerequisites Before following the instructions in this guide, ensure you have: A synthetic private location At least one private minion installed at that location Checks scheduled to run at that location An alert policy for the private location, with a configured notification channel to notify your team when a violation occurs The following Private Minion dashboard example JSON can be imported to your account using: the Import a dashboard button the Dashboard API Private Minion dashboard JSON { \"name\": \"Synthetics Private Minions\", \"description\": \"Details on events from SyntheticPrivateLocationStatus, SyntheticsPrivateMinion, SyntheticCheck, SyntheticRequest, NrAuditEvent, plus a page for Performance Analysis.\", \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"SyntheticPrivateLocationStatus\", \"description\": \"Details on the private location queue.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 8, \"width\": 3 }, \"title\": \"pending checks by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(checksPending) FROM SyntheticsPrivateLocationStatus FACET name\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 4, \"width\": 9 }, \"title\": \"private location queue\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES max SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 5, \"height\": 4, \"width\": 9 }, \"title\": \"rate of queue growth\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(checksPending,1 minute),0) as 'queue growth rate' FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 9, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'PRIVATE_LOCATION' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticsPrivateMinion\", \"description\": \"Details on the minion instances.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 3 }, \"title\": \"private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(timestamp),uniqueCount(minionId) - 1 as 'restarts' from SyntheticsPrivateMinion since 2 days ago FACET minionLocation\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 3, \"width\": 7 }, \"title\": \"minion details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionId),latest(timestamp) as 'last seen',latest(minionStartTimestamp) as 'started',uniqueCount(minionId) - 1 as 'restarts',latest(minionIpv4),latest(minionJobsQueued),latest(minionJobsFinished),100*latest(minionJobsFailed)/latest(minionJobsQueued) as 'job failure rate',latest(minionJobsRunning),latest(minionJobsTimedout),latest(minionJobsSkipped),latest(minionJobsInternalEngineError),latest(minionWorkers),latest(minionProcessors),latest(minionPhysicalMemoryUsedBytes/(1024*1024*1024)) as 'used memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024)) as 'total memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024))/latest(minionWorkers) as 'memory (GiB) per heavy worker' FROM SyntheticsPrivateMinion FACET minionBuildNumber,minionLocation,minionOsVersion,minionContainerSystemVersion,minionHostname LIMIT 100 SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"minion instances over time\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' from SyntheticsPrivateMinion since 2 days ago TIMESERIES MAX \" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"CPU utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionProcessorsUsagePercentage) AS 'CPU load %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"memory utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryUsedPercentage) AS 'used memory %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"free memory (GiB)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryFreeBytes / (1024*1024*1024)) AS 'free (GiB)' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(minionJobsFinished,1 minute),0) FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"skipped jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsSkipped) as 'skipped jobs' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 2 weeks ago TIMESERIES MAX\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"count of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsInternalEngineError) as 'IEE',average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.stacked-bar\" }, \"layout\": { \"column\": 9, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"rate of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*average(minionJobsInternalEngineError)/average(minionJobsFailed) as 'IEE',100*(average(minionJobsFailed)-average(minionJobsInternalEngineError))/average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES AUTO SINCE 2 weeks ago\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticCheck\", \"description\": \"Details on job results.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 non-ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type != 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type = 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type = 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 6, \"width\": 6 }, \"title\": \"monitor details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(id) as 'results',uniqueCount(location)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET monitorName,monitorId,type LIMIT MAX\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 7, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 errors by monitor type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE error IS NOT NULL AND location NOT LIKE 'AWS%' FACET error,type TIMESERIES AUTO SINCE 2 weeks ago LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 10, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping duration with monitor count\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)',uniqueCount(monitorId) as 'monitor count' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job results\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET type TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type = 'SIMPLE' as 'ping',WHERE type != 'SIMPLE' as 'non-ping') TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 11, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type, result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type != 'SIMPLE' as 'non-ping',WHERE type = 'SIMPLE' as 'ping'),result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticRequest\", \"description\": \"Details on responses.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 6, \"width\": 5 }, \"title\": \"jobs per minion\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(jobId) as 'jobs' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' FACET location,minion,minionId\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 6, \"row\": 1, \"height\": 6, \"width\": 4 }, \"title\": \"top 5 error response codes\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(responseCode) as 'responses' FROM SyntheticRequest WHERE responseCode NOT IN (200,201,202,203,204,300,301,302,303,304) AND responseCode IS NOT NULL AND location NOT LIKE 'AWS%' FACET responseCode,responseStatus TIMESERIES AUTO LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 10, \"row\": 1, \"height\": 6, \"width\": 3 }, \"title\": \"job rate\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(jobId), 1 minute) as 'job rate' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'MONITOR' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"Performance Analysis\", \"description\": \"Determine if there are enough heavy worker threads.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"minions (hosts) by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"count of heavy worker threads and cpu cores\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionWorkers),latest(minionProcessors) FROM SyntheticsPrivateMinion FACET minionHostname,minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.markdown\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"\", \"rawConfiguration\": { \"text\": \"See [this Google sheet](https://docs.google.com/spreadsheets/d/1k2Aw11r6-S8pIpXQUINQZ0T5qlxS8iSwSo9t9GKDvzc/edit?usp=sharing) to assist in calculating how many workers will be needed based on the values on this page. This will help you to assess the required size of each host (scaling up) and how many hosts you need (scaling out).\\n\\nFor more info: \\nhttps://discuss.newrelic.com/t/relic-solution-scaling-and-rightsizing-for-the-cpm/123999\" }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'non-ping monitors' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping avg job duration and timeout\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average((nr.internalQueueDuration+nr.executionDuration)/1e3) FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location,cases(WHERE error NOT LIKE '%timeout%' as 'job duration (s)', WHERE error LIKE '%timeout%' as 'job timeout (s)') SINCE 2 days ago TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"job timeout rate by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*latest(minionJobsTimedout)/latest(minionJobsReceived) as 'job timeout rate' FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES AUTO SINCE 2 days ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Steps to import: Copy the Dashboard JSON and paste into a text editor. Replace \"accountId\": 1, with your New Relic account ID for each occurrence in the JSON code. Copy the Dashboard JSON from your text editor and import using one of the methods described above. Edit any charts that you'd like to use facet filtering with. Tip If your private locations exist in a parent account and Synthetics monitors in a sub account, insert the parent account ID for NRQL queries that use SyntheticPrivateLocationStatus and SyntheticsPrivateMinion, and the sub account ID for queries that use SyntheticCheck and SyntheticRequest. Are my private minions online? To answer this question, you can rely on attributes from the SyntheticsPrivateMinionevent. Private minions send this event to New Relic every 30 seconds. A simple way to check if your minions are online is to compare the unique count of minion IDs with the number of minions you expect to be online. To understand how many minions are reporting, run this example NRQL query: SELECT uniqueCount(minionId) FROM SyntheticsPrivateMinion WHERE minionLocation = '1-acme_okc_dc-309' Copy Using this query, you can create an alert condition to notify your team when fewer minions are reporting than expected. This condition is configured with a static threshold of 2 units, which means you will receive an alert if any of your minions are offline. You can verify that the alert policy works as expected by manually stopping one of your minions. Then, when the alert violation occurs, you will be notified by any notification channels that have been set up. Once the minion is restarted and it comes back online, the alert will recover. There are more robust ways to check whether minions are functioning correctly, but this query and condition simply and successfully handle the case where a machine fails, is accidentally decommissioned, or the minion process crashes. It also ensures that the minion can communicate with New Relic. Does my private location need more minions? To answer this question, you can use the checksPending attribute of the SyntheticsPrivateLocationStatus event. The checksPending attribute reflects the number of monitor checks that are scheduled (or \"queued\") but have yet to be accepted by a minion in the designated location. For a location with scheduled checks and no minions, this graph would grow linearly up and to the right. This metric is more complicated to monitor than uniqueCount(minionId) because a high value does not necessarily mean the location is in a bad state. As long as the metric is not growing linearly up and to the right (and checks are being run on schedule), the location is in a good state. This use case is perfect for baseline NRQL alert conditions, which allow you to monitor the deviation of a metric rather than its static value. For example: SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus WHERE name = '1-acme_tokyo_dc-512' Copy To test this alert condition, schedule one-minute, browser-based monitors to run from your location. Browser-based jobs consume more resources than ping jobs, which is why they are a better fit for load simulation. New Relic will quickly notify you of a growing number of pending checks. After doubling the number of minions to handle the load, the alert recovers. For example, using the Synthetics private location dashboard example, notice the growth and decline of pending checks over the course of the incident and recovery. By using the NRQL condition, New Relic will notify you if and when the location needs more minion capacity. Can I check the status of a specific minion directly? You can also check how a minion is operating by contacting it directly. You can use a set of HTTP endpoints exposed by the minion to determine what the application is doing. In order to access these endpoints, bind ports 8080 and 8180 to ports on the host. For example, for Docker, use docker run -p 80:8080 -p 81:8180 ...): :8080/status/check: Details about internal health-checks the minion performs; HTTP 200 means \"healthy.\" :8080/status: Details about a minion's status; the same data is then published to Insights as a SyntheticsPrivateMinion event. :8180/: JVM application admin endpoints; an advanced view of a minion's internal state. This approach is not as automated or flexible as the checksPending example. However, if you have total network connectivity failure, this manual approach can help troubleshoot the situation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.12042,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> <em>private</em> <em>locations</em>",
        "sections": "<em>Monitor</em> <em>private</em> <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "When using <em>synthetic</em> <em>monitoring</em>&#x27;s <em>private</em> <em>locations</em> with New Relic&#x27;s alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding <em>private</em> location health by using New Relic"
      },
      "id": "604525f164441f7fd7378ef9"
    },
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-12-25T19:12:51Z",
      "updated_at": "2021-11-26T09:10:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher. macOS: 10.11 or higher. Windows: Windows 10 64-bit or higher. You must also configure Docker to run Linux containers in order for CPMs to work on Windows systems. Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution The Docker CPM is not designed for use with container orchestrators like AWS ECS, Docker Swarm, Apache Mesos, Azure Container Instances, etc. Running the Docker CPM in a container orchestrator will result in unexpected issues because it is itself a container orchestrator. If you're using container orchestration, see our Kubernetes CPM requirements. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Unless hosting the images in a local image repository, connections to either quay.io or docker.io will need to be allowed through your firewall in order for Docker to pull the synthetics-minion and synthetics-minion-runner images. The \"runner\" image is pulled automatically on startup of the synthetics-minion container. See Docker environment configuration and Kubernetes environment configuration for details on how to set a local repository and the runner registry endpoint. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.56561,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-25T17:37:54Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 197.32082,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and <em>private</em> <em>locations</em>. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials <em>Private</em> <em>locations</em> (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-maintenance-monitoring": [
    {
      "sections": [
        "Monitor private locations",
        "Prerequisites",
        "Private Minion dashboard JSON",
        "Tip",
        "Are my private minions online?",
        "Does my private location need more minions?",
        "Can I check the status of a specific minion directly?"
      ],
      "title": "Monitor private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "d38b5c957ec41b25199f4d093eb2f6083a5ff351",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/monitor-private-locations/",
      "published_at": "2021-12-25T18:33:22Z",
      "updated_at": "2021-12-15T12:32:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using synthetic monitoring's private locations with New Relic's alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic dashboards and NRQL alerts: Are my private minions online? Does my private location need more minions? Can I check the status of a specific minion directly? Prerequisites Before following the instructions in this guide, ensure you have: A synthetic private location At least one private minion installed at that location Checks scheduled to run at that location An alert policy for the private location, with a configured notification channel to notify your team when a violation occurs The following Private Minion dashboard example JSON can be imported to your account using: the Import a dashboard button the Dashboard API Private Minion dashboard JSON { \"name\": \"Synthetics Private Minions\", \"description\": \"Details on events from SyntheticPrivateLocationStatus, SyntheticsPrivateMinion, SyntheticCheck, SyntheticRequest, NrAuditEvent, plus a page for Performance Analysis.\", \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"SyntheticPrivateLocationStatus\", \"description\": \"Details on the private location queue.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 8, \"width\": 3 }, \"title\": \"pending checks by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(checksPending) FROM SyntheticsPrivateLocationStatus FACET name\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 4, \"width\": 9 }, \"title\": \"private location queue\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES max SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 5, \"height\": 4, \"width\": 9 }, \"title\": \"rate of queue growth\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(checksPending,1 minute),0) as 'queue growth rate' FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 9, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'PRIVATE_LOCATION' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticsPrivateMinion\", \"description\": \"Details on the minion instances.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 3 }, \"title\": \"private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(timestamp),uniqueCount(minionId) - 1 as 'restarts' from SyntheticsPrivateMinion since 2 days ago FACET minionLocation\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 3, \"width\": 7 }, \"title\": \"minion details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionId),latest(timestamp) as 'last seen',latest(minionStartTimestamp) as 'started',uniqueCount(minionId) - 1 as 'restarts',latest(minionIpv4),latest(minionJobsQueued),latest(minionJobsFinished),100*latest(minionJobsFailed)/latest(minionJobsQueued) as 'job failure rate',latest(minionJobsRunning),latest(minionJobsTimedout),latest(minionJobsSkipped),latest(minionJobsInternalEngineError),latest(minionWorkers),latest(minionProcessors),latest(minionPhysicalMemoryUsedBytes/(1024*1024*1024)) as 'used memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024)) as 'total memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024))/latest(minionWorkers) as 'memory (GiB) per heavy worker' FROM SyntheticsPrivateMinion FACET minionBuildNumber,minionLocation,minionOsVersion,minionContainerSystemVersion,minionHostname LIMIT 100 SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"minion instances over time\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' from SyntheticsPrivateMinion since 2 days ago TIMESERIES MAX \" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"CPU utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionProcessorsUsagePercentage) AS 'CPU load %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"memory utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryUsedPercentage) AS 'used memory %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"free memory (GiB)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryFreeBytes / (1024*1024*1024)) AS 'free (GiB)' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(minionJobsFinished,1 minute),0) FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"skipped jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsSkipped) as 'skipped jobs' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 2 weeks ago TIMESERIES MAX\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"count of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsInternalEngineError) as 'IEE',average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.stacked-bar\" }, \"layout\": { \"column\": 9, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"rate of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*average(minionJobsInternalEngineError)/average(minionJobsFailed) as 'IEE',100*(average(minionJobsFailed)-average(minionJobsInternalEngineError))/average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES AUTO SINCE 2 weeks ago\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticCheck\", \"description\": \"Details on job results.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 non-ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type != 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type = 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type = 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 6, \"width\": 6 }, \"title\": \"monitor details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(id) as 'results',uniqueCount(location)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET monitorName,monitorId,type LIMIT MAX\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 7, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 errors by monitor type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE error IS NOT NULL AND location NOT LIKE 'AWS%' FACET error,type TIMESERIES AUTO SINCE 2 weeks ago LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 10, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping duration with monitor count\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)',uniqueCount(monitorId) as 'monitor count' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job results\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET type TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type = 'SIMPLE' as 'ping',WHERE type != 'SIMPLE' as 'non-ping') TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 11, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type, result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type != 'SIMPLE' as 'non-ping',WHERE type = 'SIMPLE' as 'ping'),result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticRequest\", \"description\": \"Details on responses.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 6, \"width\": 5 }, \"title\": \"jobs per minion\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(jobId) as 'jobs' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' FACET location,minion,minionId\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 6, \"row\": 1, \"height\": 6, \"width\": 4 }, \"title\": \"top 5 error response codes\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(responseCode) as 'responses' FROM SyntheticRequest WHERE responseCode NOT IN (200,201,202,203,204,300,301,302,303,304) AND responseCode IS NOT NULL AND location NOT LIKE 'AWS%' FACET responseCode,responseStatus TIMESERIES AUTO LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 10, \"row\": 1, \"height\": 6, \"width\": 3 }, \"title\": \"job rate\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(jobId), 1 minute) as 'job rate' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'MONITOR' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"Performance Analysis\", \"description\": \"Determine if there are enough heavy worker threads.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"minions (hosts) by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"count of heavy worker threads and cpu cores\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionWorkers),latest(minionProcessors) FROM SyntheticsPrivateMinion FACET minionHostname,minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.markdown\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"\", \"rawConfiguration\": { \"text\": \"See [this Google sheet](https://docs.google.com/spreadsheets/d/1k2Aw11r6-S8pIpXQUINQZ0T5qlxS8iSwSo9t9GKDvzc/edit?usp=sharing) to assist in calculating how many workers will be needed based on the values on this page. This will help you to assess the required size of each host (scaling up) and how many hosts you need (scaling out).\\n\\nFor more info: \\nhttps://discuss.newrelic.com/t/relic-solution-scaling-and-rightsizing-for-the-cpm/123999\" }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'non-ping monitors' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping avg job duration and timeout\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average((nr.internalQueueDuration+nr.executionDuration)/1e3) FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location,cases(WHERE error NOT LIKE '%timeout%' as 'job duration (s)', WHERE error LIKE '%timeout%' as 'job timeout (s)') SINCE 2 days ago TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"job timeout rate by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*latest(minionJobsTimedout)/latest(minionJobsReceived) as 'job timeout rate' FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES AUTO SINCE 2 days ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Steps to import: Copy the Dashboard JSON and paste into a text editor. Replace \"accountId\": 1, with your New Relic account ID for each occurrence in the JSON code. Copy the Dashboard JSON from your text editor and import using one of the methods described above. Edit any charts that you'd like to use facet filtering with. Tip If your private locations exist in a parent account and Synthetics monitors in a sub account, insert the parent account ID for NRQL queries that use SyntheticPrivateLocationStatus and SyntheticsPrivateMinion, and the sub account ID for queries that use SyntheticCheck and SyntheticRequest. Are my private minions online? To answer this question, you can rely on attributes from the SyntheticsPrivateMinionevent. Private minions send this event to New Relic every 30 seconds. A simple way to check if your minions are online is to compare the unique count of minion IDs with the number of minions you expect to be online. To understand how many minions are reporting, run this example NRQL query: SELECT uniqueCount(minionId) FROM SyntheticsPrivateMinion WHERE minionLocation = '1-acme_okc_dc-309' Copy Using this query, you can create an alert condition to notify your team when fewer minions are reporting than expected. This condition is configured with a static threshold of 2 units, which means you will receive an alert if any of your minions are offline. You can verify that the alert policy works as expected by manually stopping one of your minions. Then, when the alert violation occurs, you will be notified by any notification channels that have been set up. Once the minion is restarted and it comes back online, the alert will recover. There are more robust ways to check whether minions are functioning correctly, but this query and condition simply and successfully handle the case where a machine fails, is accidentally decommissioned, or the minion process crashes. It also ensures that the minion can communicate with New Relic. Does my private location need more minions? To answer this question, you can use the checksPending attribute of the SyntheticsPrivateLocationStatus event. The checksPending attribute reflects the number of monitor checks that are scheduled (or \"queued\") but have yet to be accepted by a minion in the designated location. For a location with scheduled checks and no minions, this graph would grow linearly up and to the right. This metric is more complicated to monitor than uniqueCount(minionId) because a high value does not necessarily mean the location is in a bad state. As long as the metric is not growing linearly up and to the right (and checks are being run on schedule), the location is in a good state. This use case is perfect for baseline NRQL alert conditions, which allow you to monitor the deviation of a metric rather than its static value. For example: SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus WHERE name = '1-acme_tokyo_dc-512' Copy To test this alert condition, schedule one-minute, browser-based monitors to run from your location. Browser-based jobs consume more resources than ping jobs, which is why they are a better fit for load simulation. New Relic will quickly notify you of a growing number of pending checks. After doubling the number of minions to handle the load, the alert recovers. For example, using the Synthetics private location dashboard example, notice the growth and decline of pending checks over the course of the incident and recovery. By using the NRQL condition, New Relic will notify you if and when the location needs more minion capacity. Can I check the status of a specific minion directly? You can also check how a minion is operating by contacting it directly. You can use a set of HTTP endpoints exposed by the minion to determine what the application is doing. In order to access these endpoints, bind ports 8080 and 8180 to ports on the host. For example, for Docker, use docker run -p 80:8080 -p 81:8180 ...): :8080/status/check: Details about internal health-checks the minion performs; HTTP 200 means \"healthy.\" :8080/status: Details about a minion's status; the same data is then published to Insights as a SyntheticsPrivateMinion event. :8180/: JVM application admin endpoints; an advanced view of a minion's internal state. This approach is not as automated or flexible as the checksPending example. However, if you have total network connectivity failure, this manual approach can help troubleshoot the situation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.12042,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> <em>private</em> <em>locations</em>",
        "sections": "<em>Monitor</em> <em>private</em> <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "When using <em>synthetic</em> <em>monitoring</em>&#x27;s <em>private</em> <em>locations</em> with New Relic&#x27;s alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding <em>private</em> location health by using New Relic"
      },
      "id": "604525f164441f7fd7378ef9"
    },
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-12-25T19:12:51Z",
      "updated_at": "2021-11-26T09:10:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher. macOS: 10.11 or higher. Windows: Windows 10 64-bit or higher. You must also configure Docker to run Linux containers in order for CPMs to work on Windows systems. Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution The Docker CPM is not designed for use with container orchestrators like AWS ECS, Docker Swarm, Apache Mesos, Azure Container Instances, etc. Running the Docker CPM in a container orchestrator will result in unexpected issues because it is itself a container orchestrator. If you're using container orchestration, see our Kubernetes CPM requirements. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Unless hosting the images in a local image repository, connections to either quay.io or docker.io will need to be allowed through your firewall in order for Docker to pull the synthetics-minion and synthetics-minion-runner images. The \"runner\" image is pulled automatically on startup of the synthetics-minion container. See Docker environment configuration and Kubernetes environment configuration for details on how to set a local repository and the runner registry endpoint. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.56561,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "Containerized private minion (CPM) configuration",
        "Guidelines for mounting volumes",
        "Custom npm modules",
        "Custom module directory",
        "Node version-specific overrides",
        "Docker",
        "Kubernetes",
        "Change package.json for custom modules",
        "Caution",
        "Permanent data storage",
        "User-defined environment variables for scripted monitors",
        "Mounting JSON file",
        "Passing as an environment variable",
        "Tip",
        "Accessing user-defined environment variables from scripts",
        "Environment variables",
        "Docker environment configuration",
        "Kubernetes environment configuration"
      ],
      "title": "Containerized private minion (CPM) configuration",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "5c65dd79f361d23da2154f6a4227515a40dae944",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration/",
      "published_at": "2021-12-25T18:28:55Z",
      "updated_at": "2021-11-15T07:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to configure your containerized private minion (CPM). You can do the following to customize your CPMs: Set up custom modules for scripted browsers in New Relic. Preserve launch data with permanent data storage. Use environment variables in your configuration. You may not modify any CPM files and New Relic is not liable for any modifications you make. Guidelines for mounting volumes All directories and files must be assigned group ownership as 3729 with read/write permissions. This ensures that the Runner, which uses uid: 1000 and gid: 3729, has access to all the mounted volumes. However, the Minion is able to run as root (uid: 0) or with any uid between the range of [2000, 4000], inclusive. For more information, see running as non-root in Kubernetes or Docker. Docker Directories are mounted onto a container as volumes by specifying a -v argument within docker run For example, docker run ... -v /path/to/src:/path/to/dest:rw Kubernetes It is possible to add a directory onto a persistent volume (PV) by using kubectl cp. However, alternative approaches are supported as long as the file permissions are set appropriately. For example, kubectl cp /path/to/src <POD_NAME>:/path/to/dest will add a directory onto each PV in the specified pod Each PV must have a separate copy of the directories. For example, a cluster with n Minion replicas must have n PVs, each with their own copy of directories The directories and files must be added prior to the Minion boot up, otherwise the Minion must be restarted to detect the updates Custom npm modules Custom npm modules are exclusive to the CPM. They allow you to provide an arbitrary set of npm modules, and make them available for scripted monitors in Synthetics. To set up the modules: Create a directory which contains a package.json, following the npm official guidelines, in the root of the directory. Anything contained in the dependencies field will be installed by the CPM at start, and made available when running monitors on that private minion. Optionally, you can override the root level package.json with a Node version-specific directory. This allows a script to be updated per monitor runtime if a Node version of a runtime is no longer compatible with your dependencies. See an example of this below. Custom module directory In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file Copy The package.json defines dependencies as both a local module (for example, counter) and an npm hosted modules (for example, async version ^2.6.1): { \"name\": \"custom-modules\", \"version\": \"1.0.0\", ⇦ optional \"description\": \"example custom modules directory\", ⇦ optional \"dependencies\": { \"async\": \"^2.6.1\", ⇦ npm hosted module \"counter\": \"file:./counter\" ⇦ Local module } } Copy Node version-specific overrides You can declare a package.json per Node version that will override the root level package.json. This allows a monitor script to be updated per monitor runtime in the event that the Node version of a runtime is no longer compatible with your dependencies. As shown in the first example, local modules can still be defined within a version specific directory. If a package.json is not defined for a specific Node version, then the root level package.json will be used to install dependencies. In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── 6.11.2 ⇦ optional Node specific directory │ └── package.json └── 10.15.0 ⇦ optional Node specific directory │ └── package.json ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file ​ Copy Once you create the custom modules directory and the package.json you can apply it to your CPM for Docker and Kubernetes. Docker For Docker, launch CPM mounting the directory at /var/lib/newrelic/synthetics/modules. For example: docker run ... -v /example-custom-modules-dir:/var/lib/newrelic/synthetics/modules:rw ... Copy Kubernetes Complete the following: Launch the CPM, setting a value for the persistence.customModules configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where your custom modules files exist. For example: helm install ... --set persistence.customModules=<custom-modules-subpath> ... Copy Make sure that your custom modules directory is available on the Minion Pod. You can use kubectl cp as one method to copy the directory from your host to the Minion. For example: kubectl cp /example-custom-modules-dir <namespace>/<pod_name>:/var/lib/newrelic/synthetics/modules Copy Look at the CPM logs for \"... Initialization of Custom Modules ...\" to see if the modules were installed properly, or if there were any errors. The npm installation logs will be shown. Now you can add \"require('async');\" into the script of monitors you send to this private location. Change package.json for custom modules Along with npm modules, you can also use Node.js modules. To change the custom modules used by your CPM, modify package.json and reboot the CPM. It will detect the change in configuration during the reboot, and then clean up and re-install. Caution Local modules: While your package.json can include any local module, these modules must reside inside the tree under your custom module directory. If stored outside the tree, the initialization process will fail and you will see an error message in the docker logs after launching CPM. Permanent data storage CPM is a stateless application and does not preserve information from prior requests or sessions by default. However, you can preserve data between launches by enabling permanent data storage. For example, you can permanently set how the minion identifies itself (for example, Minion_ID), and use it to associate the data visible in Synthetics and Insights events with the exact minion that produced it. To set permanent data storage on Docker: Create a directory. Launch the CPM, mounting the directory at /var/lib/newrelic/synthetics. Example: docker run ... -v /example-permanent-dir:/var/lib/newrelic/synthetics:rw ... Copy To set permanent data storage on Kubernetes: Launch the CPM, setting a value for the persistence.permanentData configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where you want the data to be saved. Example: helm install ... --set persistence.permanentData=<permanent-data-subpath> ... Copy User-defined environment variables for scripted monitors Containerized private minions let you configure environment variables for use in scripted monitors. These variables are hosted locally on the CPM and can be accessed via $env.USER_DEFINED_VARIABLES. There are two ways to set user-defined variables: by mounting a JSON file or by supplying an environment variable to the CPM on launch. If both are provided, the CPM will use values provided from the environment only. Mounting JSON file The JSON file must have read permissions and contain a JSON formatted map. Example user-defined variable file: { \"KEY\" : \"VALUE\", \"User_Name\": \"MINION\", \"My_Password\": \"PASSW0RD 1 2 3\", \"my_URL\": \"https://newrelic.com/\", \"ETC\" : \"ETC\" } Copy The file must be available or mounted to the path in your container: /var/lib/newrelic/synthetics/variables/user_defined_variables.json Docker example: docker run ... -v /example-user-defined-variables.json:/var/lib/newrelic/synthetics/variables/user_defined_variables.json:rw ... Copy Kubernetes example: When mounting a JSON file to your Minion Pod in Kubernetes, you can either copy the file directly to the Minion Pod or to a Pod that has access to the same Persistent Volume and Persistent Volume Claim that the Minion will use. After successfully loading the file, you may need to restart your Minion Pod for the change to take effect. kubectl cp path/to/user_defined_variables.json <namespace>/<pod_name>:/var/lib/newrelic/synthetics/variables/user_defined_variables.json Copy Passing as an environment variable Use the -e flag to set up an environment variable named MINION_USER_DEFINED_VARIABLES and give it a value of a JSON formatted map string. docker run ... -e MINION_USER_DEFINED_ENV_VARIABLES='{\"KEY\":\"VALUE\",\"NAME\":\"MINION\",\"ETC\":\"ETC\"}' ... Copy Tip The CPM on Kubernetes does not currently support loading user-defined environment variables via environment variable. You will have to configure your Kubernetes CPM by mounting a JSON file. Accessing user-defined environment variables from scripts To reference a configured user-defined environment variable, use the reserved $env.USER_DEFINED_VARIABLES followed by the name of a given variable with dot notation. For example, $env.USER_DEFINED_VARIABLES.MY_VARIABLE Caution User-defined environment variables are not sanitized from logs. For sensitive information, consider using the secure credentials feature. Environment variables Environmental variables allow you to fine-tune the CPM configuration to meet your specific environmental and functional needs. Docker environment configuration The variables are provided at startup using the -e, --env argument. The following table shows all the environment variables that CPM supports. MINION_PRIVATE_LOCATION_KEY is required, and all other variables are optional. Name Description MINION_PRIVATE_LOCATION_KEY REQUIRED. UUID of the Private Location, as found on the Private Location Web page. DOCKER_API_VERSION Format: \"vX.Y\" API version to be used with the given Docker service. Default: v1.35. DOCKER_HOST Points the minion to a given DOCKER_HOST. If absent, the default value is /var/run/docker.sock. MINION_API_ENDPOINT For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. MINION_DOCKER_RUNNER_REGISTRY_ENDPOINT The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic). MINION_API_PROXY Format: \"host:port\". MINION_API_PROXY_AUTH Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. MINION_API_PROXY_SELF_SIGNED_CERT Acceptable values: true, 1, or yes (any case). MINION_CHECK_TIMEOUT The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. MINION_DOCKER_API_VERSION Synonym of DOCKER_API_VERSION. MINION_DOCKER_HOST Synonym of DOCKER_HOST. MINION_RUNNER_APPARMOR (CPM version > 3.0.2) OR MINION_DOCKER_RUNNER_APPARMOR (CPM version <= 3.0.2) The AppArmor profile name, if it has been applied to Docker containers running monitor scripts (for example, Docker Runner). The AppArmor profile name must exist and be set up on the machine to work. MINION_JVM_MB Default: \"2560\" (2.5GB). MINION_JVM_OPTS Passes command line options to the internal JVM. See Oracle's Java documentation for more information. Default: -server. MINION_LOG_LEVEL When contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. MINION_NETWORK_HEALTHCHECK_DISABLED (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. MINION_USER_DEFINED_ENV_VARIABLES Format: Example. A locally hosted set of user defined key value pairs. MINION_HEAVY_WORKERS The number of workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. MINION_LIGHTWEIGHT_WORKERS The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 1250. For more information on monitor types, see Types of Synthetics monitors. MINION_VSE_PASSPHRASE If set, enables verified script execution and uses this value as a passphrase. Kubernetes environment configuration The variables are provided at startup using the --set argument. The following list shows all the environment variables that CPM supports. synthetics.privateLocationKey is required, and all other variables are optional. Name Description synthetics.privateLocationKey REQUIRED if synthetics.privateLocationKeySecretName is not set. UUID/Private location key of the private location, as found on the private location web page. synthetics.privateLocationKeySecretName REQUIRED if synthetics.privateLocationKey is not set. Name of the Kubernetes secret that contains the key privateLocationKey, which contains the authentication key associated with your Synthetics private location. replicaCount Number of replicas to maintain with your StatefulSet installation Default: 1. imagePullSecrets The name of the secret object used to pull an image from a specified container registry. fullnameOverride Name override used for your StatefulSet installation, replacing the default. appVersionOverride Release version of CPM to use instead of the version specified in chart.yml. synthetics.minionLogLevel If contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. synthetics.heavyWorkers The number of concurrent workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use the value 2. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. synthetics.lightweightWorkers The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * synthetics.heavyWorkers, where synthetics.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on monitor types, see Types of synthetic monitors. synthetics.minionApiEndpoint For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. synthetics.minionDockerRunnerRegistryEndpoint The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic) synthetics.minionVsePassphrase If set, it enables verified script execution, and uses this value as a passphrase. synthetics.minionVsePassphraseSecretName If set, enables verified script execution and uses this value to retrieve the passphrase from a Kubernetes secret with a key called minionVsePassphrase. synthetics.minionApiProxy Format: \"host:port\". synthetics.minionApiProxySelfSignedCert Acceptable values: true, 1, or yes (any case). synthetics.minionApiProxyAuth Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. synthetics.minionCheckTimeout The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. synthetics.minionUserDefinedEnvVariable Format: Example. A locally hosted set of user-defined key value pairs. synthetics.minionJVMOpts Passes command line options to the internal JVM. Default: -server -XX:-UsePerfData synthetics.minionNetworkHealthCheckDisabled (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. image.repository The container to pull. Default: quay.io/newrelic/synthetics-minion image.pullPolicy The pull policy. Default: IfNotPresent persistence.claimName The name of the PVC to use. If undefined or not set, Statefulset will dynamically create a PVC for each replica. persistence.storageClass Overrides StorageClass for VolumeClaimTemplates, relevant only if claimName is undefined or empty. For more details see persistent volumes. persistence.accessMode Access mode to be defined for the PVC, relevant only if claimName is undefined or empty. Default: ReadWriteOnce. persistence.annotations Annotations to add to the PVC, relevant only if claimName is undefined or empty. persistence.size Size to be defined for the PVC, relevant only if claimName is undefined or empty. Default: 10Gi. persistence.permanentData Path on the volume to the permanent data storage directory. For more details, see permanent data storage. persistence.customModules Path on the volume to the custom modules directory. For more details, see custom modules. persistence.userDefinedVariables Path on the volume to the user-defined-variable.json file. For more details, see user defined variables. serviceAccount.create If true, a service account is created and assigned to the deployment. Default: false. serviceAccount.name The service account to assign to the deployment. If serviceAccount.create is true, then this name is used when creating the service account. serviceAccount.annotations The annotations to add to the service account if serviceAccount.create is set to true. removeJobsLog Default Kubernetes doesn't include a jobs/log resource. Set this to true to remove it from the role if needed. Default: false. headlessService.serviceName The name of the headless service to associate to the StatefulSet. If not set a name is generated using the fullname template. appArmorProfileName The AppArmor profile name that will be applied to the Minion and Runner pods. If set, then the AppArmor profile must exist on the Kubernetes node(s) for this to work. podSecurityContextRunAsUser A UID that can be set to either 0 (root) or between [2000, 4000], inclusive. If set, runs the CPM as the given UID. Default: 2379.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.78049,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Containerized <em>private</em> minion (CPM) configuration",
        "sections": "Containerized <em>private</em> minion (CPM) configuration",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " * <em>synthetics</em>.heavyWorkers, where <em>synthetics</em>.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on <em>monitor</em> types, see Types of <em>synthetic</em> monitors. <em>synthetics</em>.minionApiEndpoint For US-based accounts, the endpoint"
      },
      "id": "603ea540196a67e50da83d95"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms": [
    {
      "sections": [
        "Monitor private locations",
        "Prerequisites",
        "Private Minion dashboard JSON",
        "Tip",
        "Are my private minions online?",
        "Does my private location need more minions?",
        "Can I check the status of a specific minion directly?"
      ],
      "title": "Monitor private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "d38b5c957ec41b25199f4d093eb2f6083a5ff351",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/monitor-private-locations/",
      "published_at": "2021-12-25T18:33:22Z",
      "updated_at": "2021-12-15T12:32:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using synthetic monitoring's private locations with New Relic's alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic dashboards and NRQL alerts: Are my private minions online? Does my private location need more minions? Can I check the status of a specific minion directly? Prerequisites Before following the instructions in this guide, ensure you have: A synthetic private location At least one private minion installed at that location Checks scheduled to run at that location An alert policy for the private location, with a configured notification channel to notify your team when a violation occurs The following Private Minion dashboard example JSON can be imported to your account using: the Import a dashboard button the Dashboard API Private Minion dashboard JSON { \"name\": \"Synthetics Private Minions\", \"description\": \"Details on events from SyntheticPrivateLocationStatus, SyntheticsPrivateMinion, SyntheticCheck, SyntheticRequest, NrAuditEvent, plus a page for Performance Analysis.\", \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"SyntheticPrivateLocationStatus\", \"description\": \"Details on the private location queue.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 8, \"width\": 3 }, \"title\": \"pending checks by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(checksPending) FROM SyntheticsPrivateLocationStatus FACET name\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 4, \"width\": 9 }, \"title\": \"private location queue\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES max SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 5, \"height\": 4, \"width\": 9 }, \"title\": \"rate of queue growth\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(checksPending,1 minute),0) as 'queue growth rate' FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 9, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'PRIVATE_LOCATION' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticsPrivateMinion\", \"description\": \"Details on the minion instances.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 3 }, \"title\": \"private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(timestamp),uniqueCount(minionId) - 1 as 'restarts' from SyntheticsPrivateMinion since 2 days ago FACET minionLocation\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 3, \"width\": 7 }, \"title\": \"minion details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionId),latest(timestamp) as 'last seen',latest(minionStartTimestamp) as 'started',uniqueCount(minionId) - 1 as 'restarts',latest(minionIpv4),latest(minionJobsQueued),latest(minionJobsFinished),100*latest(minionJobsFailed)/latest(minionJobsQueued) as 'job failure rate',latest(minionJobsRunning),latest(minionJobsTimedout),latest(minionJobsSkipped),latest(minionJobsInternalEngineError),latest(minionWorkers),latest(minionProcessors),latest(minionPhysicalMemoryUsedBytes/(1024*1024*1024)) as 'used memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024)) as 'total memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024))/latest(minionWorkers) as 'memory (GiB) per heavy worker' FROM SyntheticsPrivateMinion FACET minionBuildNumber,minionLocation,minionOsVersion,minionContainerSystemVersion,minionHostname LIMIT 100 SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"minion instances over time\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' from SyntheticsPrivateMinion since 2 days ago TIMESERIES MAX \" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"CPU utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionProcessorsUsagePercentage) AS 'CPU load %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"memory utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryUsedPercentage) AS 'used memory %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"free memory (GiB)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryFreeBytes / (1024*1024*1024)) AS 'free (GiB)' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(minionJobsFinished,1 minute),0) FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"skipped jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsSkipped) as 'skipped jobs' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 2 weeks ago TIMESERIES MAX\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"count of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsInternalEngineError) as 'IEE',average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.stacked-bar\" }, \"layout\": { \"column\": 9, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"rate of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*average(minionJobsInternalEngineError)/average(minionJobsFailed) as 'IEE',100*(average(minionJobsFailed)-average(minionJobsInternalEngineError))/average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES AUTO SINCE 2 weeks ago\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticCheck\", \"description\": \"Details on job results.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 non-ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type != 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type = 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type = 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 6, \"width\": 6 }, \"title\": \"monitor details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(id) as 'results',uniqueCount(location)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET monitorName,monitorId,type LIMIT MAX\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 7, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 errors by monitor type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE error IS NOT NULL AND location NOT LIKE 'AWS%' FACET error,type TIMESERIES AUTO SINCE 2 weeks ago LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 10, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping duration with monitor count\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)',uniqueCount(monitorId) as 'monitor count' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job results\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET type TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type = 'SIMPLE' as 'ping',WHERE type != 'SIMPLE' as 'non-ping') TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 11, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type, result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type != 'SIMPLE' as 'non-ping',WHERE type = 'SIMPLE' as 'ping'),result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticRequest\", \"description\": \"Details on responses.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 6, \"width\": 5 }, \"title\": \"jobs per minion\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(jobId) as 'jobs' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' FACET location,minion,minionId\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 6, \"row\": 1, \"height\": 6, \"width\": 4 }, \"title\": \"top 5 error response codes\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(responseCode) as 'responses' FROM SyntheticRequest WHERE responseCode NOT IN (200,201,202,203,204,300,301,302,303,304) AND responseCode IS NOT NULL AND location NOT LIKE 'AWS%' FACET responseCode,responseStatus TIMESERIES AUTO LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 10, \"row\": 1, \"height\": 6, \"width\": 3 }, \"title\": \"job rate\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(jobId), 1 minute) as 'job rate' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'MONITOR' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"Performance Analysis\", \"description\": \"Determine if there are enough heavy worker threads.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"minions (hosts) by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"count of heavy worker threads and cpu cores\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionWorkers),latest(minionProcessors) FROM SyntheticsPrivateMinion FACET minionHostname,minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.markdown\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"\", \"rawConfiguration\": { \"text\": \"See [this Google sheet](https://docs.google.com/spreadsheets/d/1k2Aw11r6-S8pIpXQUINQZ0T5qlxS8iSwSo9t9GKDvzc/edit?usp=sharing) to assist in calculating how many workers will be needed based on the values on this page. This will help you to assess the required size of each host (scaling up) and how many hosts you need (scaling out).\\n\\nFor more info: \\nhttps://discuss.newrelic.com/t/relic-solution-scaling-and-rightsizing-for-the-cpm/123999\" }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'non-ping monitors' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping avg job duration and timeout\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average((nr.internalQueueDuration+nr.executionDuration)/1e3) FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location,cases(WHERE error NOT LIKE '%timeout%' as 'job duration (s)', WHERE error LIKE '%timeout%' as 'job timeout (s)') SINCE 2 days ago TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"job timeout rate by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*latest(minionJobsTimedout)/latest(minionJobsReceived) as 'job timeout rate' FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES AUTO SINCE 2 days ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Steps to import: Copy the Dashboard JSON and paste into a text editor. Replace \"accountId\": 1, with your New Relic account ID for each occurrence in the JSON code. Copy the Dashboard JSON from your text editor and import using one of the methods described above. Edit any charts that you'd like to use facet filtering with. Tip If your private locations exist in a parent account and Synthetics monitors in a sub account, insert the parent account ID for NRQL queries that use SyntheticPrivateLocationStatus and SyntheticsPrivateMinion, and the sub account ID for queries that use SyntheticCheck and SyntheticRequest. Are my private minions online? To answer this question, you can rely on attributes from the SyntheticsPrivateMinionevent. Private minions send this event to New Relic every 30 seconds. A simple way to check if your minions are online is to compare the unique count of minion IDs with the number of minions you expect to be online. To understand how many minions are reporting, run this example NRQL query: SELECT uniqueCount(minionId) FROM SyntheticsPrivateMinion WHERE minionLocation = '1-acme_okc_dc-309' Copy Using this query, you can create an alert condition to notify your team when fewer minions are reporting than expected. This condition is configured with a static threshold of 2 units, which means you will receive an alert if any of your minions are offline. You can verify that the alert policy works as expected by manually stopping one of your minions. Then, when the alert violation occurs, you will be notified by any notification channels that have been set up. Once the minion is restarted and it comes back online, the alert will recover. There are more robust ways to check whether minions are functioning correctly, but this query and condition simply and successfully handle the case where a machine fails, is accidentally decommissioned, or the minion process crashes. It also ensures that the minion can communicate with New Relic. Does my private location need more minions? To answer this question, you can use the checksPending attribute of the SyntheticsPrivateLocationStatus event. The checksPending attribute reflects the number of monitor checks that are scheduled (or \"queued\") but have yet to be accepted by a minion in the designated location. For a location with scheduled checks and no minions, this graph would grow linearly up and to the right. This metric is more complicated to monitor than uniqueCount(minionId) because a high value does not necessarily mean the location is in a bad state. As long as the metric is not growing linearly up and to the right (and checks are being run on schedule), the location is in a good state. This use case is perfect for baseline NRQL alert conditions, which allow you to monitor the deviation of a metric rather than its static value. For example: SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus WHERE name = '1-acme_tokyo_dc-512' Copy To test this alert condition, schedule one-minute, browser-based monitors to run from your location. Browser-based jobs consume more resources than ping jobs, which is why they are a better fit for load simulation. New Relic will quickly notify you of a growing number of pending checks. After doubling the number of minions to handle the load, the alert recovers. For example, using the Synthetics private location dashboard example, notice the growth and decline of pending checks over the course of the incident and recovery. By using the NRQL condition, New Relic will notify you if and when the location needs more minion capacity. Can I check the status of a specific minion directly? You can also check how a minion is operating by contacting it directly. You can use a set of HTTP endpoints exposed by the minion to determine what the application is doing. In order to access these endpoints, bind ports 8080 and 8180 to ports on the host. For example, for Docker, use docker run -p 80:8080 -p 81:8180 ...): :8080/status/check: Details about internal health-checks the minion performs; HTTP 200 means \"healthy.\" :8080/status: Details about a minion's status; the same data is then published to Insights as a SyntheticsPrivateMinion event. :8180/: JVM application admin endpoints; an advanced view of a minion's internal state. This approach is not as automated or flexible as the checksPending example. However, if you have total network connectivity failure, this manual approach can help troubleshoot the situation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.12036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> <em>private</em> <em>locations</em>",
        "sections": "<em>Monitor</em> <em>private</em> <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "When using <em>synthetic</em> <em>monitoring</em>&#x27;s <em>private</em> <em>locations</em> with New Relic&#x27;s alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding <em>private</em> location health by using New Relic"
      },
      "id": "604525f164441f7fd7378ef9"
    },
    {
      "sections": [
        "Containerized private minion (CPM) configuration",
        "Guidelines for mounting volumes",
        "Custom npm modules",
        "Custom module directory",
        "Node version-specific overrides",
        "Docker",
        "Kubernetes",
        "Change package.json for custom modules",
        "Caution",
        "Permanent data storage",
        "User-defined environment variables for scripted monitors",
        "Mounting JSON file",
        "Passing as an environment variable",
        "Tip",
        "Accessing user-defined environment variables from scripts",
        "Environment variables",
        "Docker environment configuration",
        "Kubernetes environment configuration"
      ],
      "title": "Containerized private minion (CPM) configuration",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "5c65dd79f361d23da2154f6a4227515a40dae944",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration/",
      "published_at": "2021-12-25T18:28:55Z",
      "updated_at": "2021-11-15T07:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to configure your containerized private minion (CPM). You can do the following to customize your CPMs: Set up custom modules for scripted browsers in New Relic. Preserve launch data with permanent data storage. Use environment variables in your configuration. You may not modify any CPM files and New Relic is not liable for any modifications you make. Guidelines for mounting volumes All directories and files must be assigned group ownership as 3729 with read/write permissions. This ensures that the Runner, which uses uid: 1000 and gid: 3729, has access to all the mounted volumes. However, the Minion is able to run as root (uid: 0) or with any uid between the range of [2000, 4000], inclusive. For more information, see running as non-root in Kubernetes or Docker. Docker Directories are mounted onto a container as volumes by specifying a -v argument within docker run For example, docker run ... -v /path/to/src:/path/to/dest:rw Kubernetes It is possible to add a directory onto a persistent volume (PV) by using kubectl cp. However, alternative approaches are supported as long as the file permissions are set appropriately. For example, kubectl cp /path/to/src <POD_NAME>:/path/to/dest will add a directory onto each PV in the specified pod Each PV must have a separate copy of the directories. For example, a cluster with n Minion replicas must have n PVs, each with their own copy of directories The directories and files must be added prior to the Minion boot up, otherwise the Minion must be restarted to detect the updates Custom npm modules Custom npm modules are exclusive to the CPM. They allow you to provide an arbitrary set of npm modules, and make them available for scripted monitors in Synthetics. To set up the modules: Create a directory which contains a package.json, following the npm official guidelines, in the root of the directory. Anything contained in the dependencies field will be installed by the CPM at start, and made available when running monitors on that private minion. Optionally, you can override the root level package.json with a Node version-specific directory. This allows a script to be updated per monitor runtime if a Node version of a runtime is no longer compatible with your dependencies. See an example of this below. Custom module directory In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file Copy The package.json defines dependencies as both a local module (for example, counter) and an npm hosted modules (for example, async version ^2.6.1): { \"name\": \"custom-modules\", \"version\": \"1.0.0\", ⇦ optional \"description\": \"example custom modules directory\", ⇦ optional \"dependencies\": { \"async\": \"^2.6.1\", ⇦ npm hosted module \"counter\": \"file:./counter\" ⇦ Local module } } Copy Node version-specific overrides You can declare a package.json per Node version that will override the root level package.json. This allows a monitor script to be updated per monitor runtime in the event that the Node version of a runtime is no longer compatible with your dependencies. As shown in the first example, local modules can still be defined within a version specific directory. If a package.json is not defined for a specific Node version, then the root level package.json will be used to install dependencies. In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── 6.11.2 ⇦ optional Node specific directory │ └── package.json └── 10.15.0 ⇦ optional Node specific directory │ └── package.json ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file ​ Copy Once you create the custom modules directory and the package.json you can apply it to your CPM for Docker and Kubernetes. Docker For Docker, launch CPM mounting the directory at /var/lib/newrelic/synthetics/modules. For example: docker run ... -v /example-custom-modules-dir:/var/lib/newrelic/synthetics/modules:rw ... Copy Kubernetes Complete the following: Launch the CPM, setting a value for the persistence.customModules configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where your custom modules files exist. For example: helm install ... --set persistence.customModules=<custom-modules-subpath> ... Copy Make sure that your custom modules directory is available on the Minion Pod. You can use kubectl cp as one method to copy the directory from your host to the Minion. For example: kubectl cp /example-custom-modules-dir <namespace>/<pod_name>:/var/lib/newrelic/synthetics/modules Copy Look at the CPM logs for \"... Initialization of Custom Modules ...\" to see if the modules were installed properly, or if there were any errors. The npm installation logs will be shown. Now you can add \"require('async');\" into the script of monitors you send to this private location. Change package.json for custom modules Along with npm modules, you can also use Node.js modules. To change the custom modules used by your CPM, modify package.json and reboot the CPM. It will detect the change in configuration during the reboot, and then clean up and re-install. Caution Local modules: While your package.json can include any local module, these modules must reside inside the tree under your custom module directory. If stored outside the tree, the initialization process will fail and you will see an error message in the docker logs after launching CPM. Permanent data storage CPM is a stateless application and does not preserve information from prior requests or sessions by default. However, you can preserve data between launches by enabling permanent data storage. For example, you can permanently set how the minion identifies itself (for example, Minion_ID), and use it to associate the data visible in Synthetics and Insights events with the exact minion that produced it. To set permanent data storage on Docker: Create a directory. Launch the CPM, mounting the directory at /var/lib/newrelic/synthetics. Example: docker run ... -v /example-permanent-dir:/var/lib/newrelic/synthetics:rw ... Copy To set permanent data storage on Kubernetes: Launch the CPM, setting a value for the persistence.permanentData configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where you want the data to be saved. Example: helm install ... --set persistence.permanentData=<permanent-data-subpath> ... Copy User-defined environment variables for scripted monitors Containerized private minions let you configure environment variables for use in scripted monitors. These variables are hosted locally on the CPM and can be accessed via $env.USER_DEFINED_VARIABLES. There are two ways to set user-defined variables: by mounting a JSON file or by supplying an environment variable to the CPM on launch. If both are provided, the CPM will use values provided from the environment only. Mounting JSON file The JSON file must have read permissions and contain a JSON formatted map. Example user-defined variable file: { \"KEY\" : \"VALUE\", \"User_Name\": \"MINION\", \"My_Password\": \"PASSW0RD 1 2 3\", \"my_URL\": \"https://newrelic.com/\", \"ETC\" : \"ETC\" } Copy The file must be available or mounted to the path in your container: /var/lib/newrelic/synthetics/variables/user_defined_variables.json Docker example: docker run ... -v /example-user-defined-variables.json:/var/lib/newrelic/synthetics/variables/user_defined_variables.json:rw ... Copy Kubernetes example: When mounting a JSON file to your Minion Pod in Kubernetes, you can either copy the file directly to the Minion Pod or to a Pod that has access to the same Persistent Volume and Persistent Volume Claim that the Minion will use. After successfully loading the file, you may need to restart your Minion Pod for the change to take effect. kubectl cp path/to/user_defined_variables.json <namespace>/<pod_name>:/var/lib/newrelic/synthetics/variables/user_defined_variables.json Copy Passing as an environment variable Use the -e flag to set up an environment variable named MINION_USER_DEFINED_VARIABLES and give it a value of a JSON formatted map string. docker run ... -e MINION_USER_DEFINED_ENV_VARIABLES='{\"KEY\":\"VALUE\",\"NAME\":\"MINION\",\"ETC\":\"ETC\"}' ... Copy Tip The CPM on Kubernetes does not currently support loading user-defined environment variables via environment variable. You will have to configure your Kubernetes CPM by mounting a JSON file. Accessing user-defined environment variables from scripts To reference a configured user-defined environment variable, use the reserved $env.USER_DEFINED_VARIABLES followed by the name of a given variable with dot notation. For example, $env.USER_DEFINED_VARIABLES.MY_VARIABLE Caution User-defined environment variables are not sanitized from logs. For sensitive information, consider using the secure credentials feature. Environment variables Environmental variables allow you to fine-tune the CPM configuration to meet your specific environmental and functional needs. Docker environment configuration The variables are provided at startup using the -e, --env argument. The following table shows all the environment variables that CPM supports. MINION_PRIVATE_LOCATION_KEY is required, and all other variables are optional. Name Description MINION_PRIVATE_LOCATION_KEY REQUIRED. UUID of the Private Location, as found on the Private Location Web page. DOCKER_API_VERSION Format: \"vX.Y\" API version to be used with the given Docker service. Default: v1.35. DOCKER_HOST Points the minion to a given DOCKER_HOST. If absent, the default value is /var/run/docker.sock. MINION_API_ENDPOINT For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. MINION_DOCKER_RUNNER_REGISTRY_ENDPOINT The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic). MINION_API_PROXY Format: \"host:port\". MINION_API_PROXY_AUTH Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. MINION_API_PROXY_SELF_SIGNED_CERT Acceptable values: true, 1, or yes (any case). MINION_CHECK_TIMEOUT The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. MINION_DOCKER_API_VERSION Synonym of DOCKER_API_VERSION. MINION_DOCKER_HOST Synonym of DOCKER_HOST. MINION_RUNNER_APPARMOR (CPM version > 3.0.2) OR MINION_DOCKER_RUNNER_APPARMOR (CPM version <= 3.0.2) The AppArmor profile name, if it has been applied to Docker containers running monitor scripts (for example, Docker Runner). The AppArmor profile name must exist and be set up on the machine to work. MINION_JVM_MB Default: \"2560\" (2.5GB). MINION_JVM_OPTS Passes command line options to the internal JVM. See Oracle's Java documentation for more information. Default: -server. MINION_LOG_LEVEL When contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. MINION_NETWORK_HEALTHCHECK_DISABLED (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. MINION_USER_DEFINED_ENV_VARIABLES Format: Example. A locally hosted set of user defined key value pairs. MINION_HEAVY_WORKERS The number of workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. MINION_LIGHTWEIGHT_WORKERS The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 1250. For more information on monitor types, see Types of Synthetics monitors. MINION_VSE_PASSPHRASE If set, enables verified script execution and uses this value as a passphrase. Kubernetes environment configuration The variables are provided at startup using the --set argument. The following list shows all the environment variables that CPM supports. synthetics.privateLocationKey is required, and all other variables are optional. Name Description synthetics.privateLocationKey REQUIRED if synthetics.privateLocationKeySecretName is not set. UUID/Private location key of the private location, as found on the private location web page. synthetics.privateLocationKeySecretName REQUIRED if synthetics.privateLocationKey is not set. Name of the Kubernetes secret that contains the key privateLocationKey, which contains the authentication key associated with your Synthetics private location. replicaCount Number of replicas to maintain with your StatefulSet installation Default: 1. imagePullSecrets The name of the secret object used to pull an image from a specified container registry. fullnameOverride Name override used for your StatefulSet installation, replacing the default. appVersionOverride Release version of CPM to use instead of the version specified in chart.yml. synthetics.minionLogLevel If contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. synthetics.heavyWorkers The number of concurrent workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use the value 2. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. synthetics.lightweightWorkers The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * synthetics.heavyWorkers, where synthetics.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on monitor types, see Types of synthetic monitors. synthetics.minionApiEndpoint For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. synthetics.minionDockerRunnerRegistryEndpoint The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic) synthetics.minionVsePassphrase If set, it enables verified script execution, and uses this value as a passphrase. synthetics.minionVsePassphraseSecretName If set, enables verified script execution and uses this value to retrieve the passphrase from a Kubernetes secret with a key called minionVsePassphrase. synthetics.minionApiProxy Format: \"host:port\". synthetics.minionApiProxySelfSignedCert Acceptable values: true, 1, or yes (any case). synthetics.minionApiProxyAuth Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. synthetics.minionCheckTimeout The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. synthetics.minionUserDefinedEnvVariable Format: Example. A locally hosted set of user-defined key value pairs. synthetics.minionJVMOpts Passes command line options to the internal JVM. Default: -server -XX:-UsePerfData synthetics.minionNetworkHealthCheckDisabled (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. image.repository The container to pull. Default: quay.io/newrelic/synthetics-minion image.pullPolicy The pull policy. Default: IfNotPresent persistence.claimName The name of the PVC to use. If undefined or not set, Statefulset will dynamically create a PVC for each replica. persistence.storageClass Overrides StorageClass for VolumeClaimTemplates, relevant only if claimName is undefined or empty. For more details see persistent volumes. persistence.accessMode Access mode to be defined for the PVC, relevant only if claimName is undefined or empty. Default: ReadWriteOnce. persistence.annotations Annotations to add to the PVC, relevant only if claimName is undefined or empty. persistence.size Size to be defined for the PVC, relevant only if claimName is undefined or empty. Default: 10Gi. persistence.permanentData Path on the volume to the permanent data storage directory. For more details, see permanent data storage. persistence.customModules Path on the volume to the custom modules directory. For more details, see custom modules. persistence.userDefinedVariables Path on the volume to the user-defined-variable.json file. For more details, see user defined variables. serviceAccount.create If true, a service account is created and assigned to the deployment. Default: false. serviceAccount.name The service account to assign to the deployment. If serviceAccount.create is true, then this name is used when creating the service account. serviceAccount.annotations The annotations to add to the service account if serviceAccount.create is set to true. removeJobsLog Default Kubernetes doesn't include a jobs/log resource. Set this to true to remove it from the role if needed. Default: false. headlessService.serviceName The name of the headless service to associate to the StatefulSet. If not set a name is generated using the fullname template. appArmorProfileName The AppArmor profile name that will be applied to the Minion and Runner pods. If set, then the AppArmor profile must exist on the Kubernetes node(s) for this to work. podSecurityContextRunAsUser A UID that can be set to either 0 (root) or between [2000, 4000], inclusive. If set, runs the CPM as the given UID. Default: 2379.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.78047,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Containerized <em>private</em> minion (CPM) configuration",
        "sections": "Containerized <em>private</em> minion (CPM) configuration",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " * <em>synthetics</em>.heavyWorkers, where <em>synthetics</em>.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on <em>monitor</em> types, see Types of <em>synthetic</em> monitors. <em>synthetics</em>.minionApiEndpoint For US-based accounts, the endpoint"
      },
      "id": "603ea540196a67e50da83d95"
    },
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-25T17:37:54Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 197.3208,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and <em>private</em> <em>locations</em>. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials <em>Private</em> <em>locations</em> (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/monitor-private-locations": [
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-12-25T19:12:51Z",
      "updated_at": "2021-11-26T09:10:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher. macOS: 10.11 or higher. Windows: Windows 10 64-bit or higher. You must also configure Docker to run Linux containers in order for CPMs to work on Windows systems. Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution The Docker CPM is not designed for use with container orchestrators like AWS ECS, Docker Swarm, Apache Mesos, Azure Container Instances, etc. Running the Docker CPM in a container orchestrator will result in unexpected issues because it is itself a container orchestrator. If you're using container orchestration, see our Kubernetes CPM requirements. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Unless hosting the images in a local image repository, connections to either quay.io or docker.io will need to be allowed through your firewall in order for Docker to pull the synthetics-minion and synthetics-minion-runner images. The \"runner\" image is pulled automatically on startup of the synthetics-minion container. See Docker environment configuration and Kubernetes environment configuration for details on how to set a local repository and the runner registry endpoint. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.5656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "Containerized private minion (CPM) configuration",
        "Guidelines for mounting volumes",
        "Custom npm modules",
        "Custom module directory",
        "Node version-specific overrides",
        "Docker",
        "Kubernetes",
        "Change package.json for custom modules",
        "Caution",
        "Permanent data storage",
        "User-defined environment variables for scripted monitors",
        "Mounting JSON file",
        "Passing as an environment variable",
        "Tip",
        "Accessing user-defined environment variables from scripts",
        "Environment variables",
        "Docker environment configuration",
        "Kubernetes environment configuration"
      ],
      "title": "Containerized private minion (CPM) configuration",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "5c65dd79f361d23da2154f6a4227515a40dae944",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration/",
      "published_at": "2021-12-25T18:28:55Z",
      "updated_at": "2021-11-15T07:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to configure your containerized private minion (CPM). You can do the following to customize your CPMs: Set up custom modules for scripted browsers in New Relic. Preserve launch data with permanent data storage. Use environment variables in your configuration. You may not modify any CPM files and New Relic is not liable for any modifications you make. Guidelines for mounting volumes All directories and files must be assigned group ownership as 3729 with read/write permissions. This ensures that the Runner, which uses uid: 1000 and gid: 3729, has access to all the mounted volumes. However, the Minion is able to run as root (uid: 0) or with any uid between the range of [2000, 4000], inclusive. For more information, see running as non-root in Kubernetes or Docker. Docker Directories are mounted onto a container as volumes by specifying a -v argument within docker run For example, docker run ... -v /path/to/src:/path/to/dest:rw Kubernetes It is possible to add a directory onto a persistent volume (PV) by using kubectl cp. However, alternative approaches are supported as long as the file permissions are set appropriately. For example, kubectl cp /path/to/src <POD_NAME>:/path/to/dest will add a directory onto each PV in the specified pod Each PV must have a separate copy of the directories. For example, a cluster with n Minion replicas must have n PVs, each with their own copy of directories The directories and files must be added prior to the Minion boot up, otherwise the Minion must be restarted to detect the updates Custom npm modules Custom npm modules are exclusive to the CPM. They allow you to provide an arbitrary set of npm modules, and make them available for scripted monitors in Synthetics. To set up the modules: Create a directory which contains a package.json, following the npm official guidelines, in the root of the directory. Anything contained in the dependencies field will be installed by the CPM at start, and made available when running monitors on that private minion. Optionally, you can override the root level package.json with a Node version-specific directory. This allows a script to be updated per monitor runtime if a Node version of a runtime is no longer compatible with your dependencies. See an example of this below. Custom module directory In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file Copy The package.json defines dependencies as both a local module (for example, counter) and an npm hosted modules (for example, async version ^2.6.1): { \"name\": \"custom-modules\", \"version\": \"1.0.0\", ⇦ optional \"description\": \"example custom modules directory\", ⇦ optional \"dependencies\": { \"async\": \"^2.6.1\", ⇦ npm hosted module \"counter\": \"file:./counter\" ⇦ Local module } } Copy Node version-specific overrides You can declare a package.json per Node version that will override the root level package.json. This allows a monitor script to be updated per monitor runtime in the event that the Node version of a runtime is no longer compatible with your dependencies. As shown in the first example, local modules can still be defined within a version specific directory. If a package.json is not defined for a specific Node version, then the root level package.json will be used to install dependencies. In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── 6.11.2 ⇦ optional Node specific directory │ └── package.json └── 10.15.0 ⇦ optional Node specific directory │ └── package.json ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file ​ Copy Once you create the custom modules directory and the package.json you can apply it to your CPM for Docker and Kubernetes. Docker For Docker, launch CPM mounting the directory at /var/lib/newrelic/synthetics/modules. For example: docker run ... -v /example-custom-modules-dir:/var/lib/newrelic/synthetics/modules:rw ... Copy Kubernetes Complete the following: Launch the CPM, setting a value for the persistence.customModules configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where your custom modules files exist. For example: helm install ... --set persistence.customModules=<custom-modules-subpath> ... Copy Make sure that your custom modules directory is available on the Minion Pod. You can use kubectl cp as one method to copy the directory from your host to the Minion. For example: kubectl cp /example-custom-modules-dir <namespace>/<pod_name>:/var/lib/newrelic/synthetics/modules Copy Look at the CPM logs for \"... Initialization of Custom Modules ...\" to see if the modules were installed properly, or if there were any errors. The npm installation logs will be shown. Now you can add \"require('async');\" into the script of monitors you send to this private location. Change package.json for custom modules Along with npm modules, you can also use Node.js modules. To change the custom modules used by your CPM, modify package.json and reboot the CPM. It will detect the change in configuration during the reboot, and then clean up and re-install. Caution Local modules: While your package.json can include any local module, these modules must reside inside the tree under your custom module directory. If stored outside the tree, the initialization process will fail and you will see an error message in the docker logs after launching CPM. Permanent data storage CPM is a stateless application and does not preserve information from prior requests or sessions by default. However, you can preserve data between launches by enabling permanent data storage. For example, you can permanently set how the minion identifies itself (for example, Minion_ID), and use it to associate the data visible in Synthetics and Insights events with the exact minion that produced it. To set permanent data storage on Docker: Create a directory. Launch the CPM, mounting the directory at /var/lib/newrelic/synthetics. Example: docker run ... -v /example-permanent-dir:/var/lib/newrelic/synthetics:rw ... Copy To set permanent data storage on Kubernetes: Launch the CPM, setting a value for the persistence.permanentData configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where you want the data to be saved. Example: helm install ... --set persistence.permanentData=<permanent-data-subpath> ... Copy User-defined environment variables for scripted monitors Containerized private minions let you configure environment variables for use in scripted monitors. These variables are hosted locally on the CPM and can be accessed via $env.USER_DEFINED_VARIABLES. There are two ways to set user-defined variables: by mounting a JSON file or by supplying an environment variable to the CPM on launch. If both are provided, the CPM will use values provided from the environment only. Mounting JSON file The JSON file must have read permissions and contain a JSON formatted map. Example user-defined variable file: { \"KEY\" : \"VALUE\", \"User_Name\": \"MINION\", \"My_Password\": \"PASSW0RD 1 2 3\", \"my_URL\": \"https://newrelic.com/\", \"ETC\" : \"ETC\" } Copy The file must be available or mounted to the path in your container: /var/lib/newrelic/synthetics/variables/user_defined_variables.json Docker example: docker run ... -v /example-user-defined-variables.json:/var/lib/newrelic/synthetics/variables/user_defined_variables.json:rw ... Copy Kubernetes example: When mounting a JSON file to your Minion Pod in Kubernetes, you can either copy the file directly to the Minion Pod or to a Pod that has access to the same Persistent Volume and Persistent Volume Claim that the Minion will use. After successfully loading the file, you may need to restart your Minion Pod for the change to take effect. kubectl cp path/to/user_defined_variables.json <namespace>/<pod_name>:/var/lib/newrelic/synthetics/variables/user_defined_variables.json Copy Passing as an environment variable Use the -e flag to set up an environment variable named MINION_USER_DEFINED_VARIABLES and give it a value of a JSON formatted map string. docker run ... -e MINION_USER_DEFINED_ENV_VARIABLES='{\"KEY\":\"VALUE\",\"NAME\":\"MINION\",\"ETC\":\"ETC\"}' ... Copy Tip The CPM on Kubernetes does not currently support loading user-defined environment variables via environment variable. You will have to configure your Kubernetes CPM by mounting a JSON file. Accessing user-defined environment variables from scripts To reference a configured user-defined environment variable, use the reserved $env.USER_DEFINED_VARIABLES followed by the name of a given variable with dot notation. For example, $env.USER_DEFINED_VARIABLES.MY_VARIABLE Caution User-defined environment variables are not sanitized from logs. For sensitive information, consider using the secure credentials feature. Environment variables Environmental variables allow you to fine-tune the CPM configuration to meet your specific environmental and functional needs. Docker environment configuration The variables are provided at startup using the -e, --env argument. The following table shows all the environment variables that CPM supports. MINION_PRIVATE_LOCATION_KEY is required, and all other variables are optional. Name Description MINION_PRIVATE_LOCATION_KEY REQUIRED. UUID of the Private Location, as found on the Private Location Web page. DOCKER_API_VERSION Format: \"vX.Y\" API version to be used with the given Docker service. Default: v1.35. DOCKER_HOST Points the minion to a given DOCKER_HOST. If absent, the default value is /var/run/docker.sock. MINION_API_ENDPOINT For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. MINION_DOCKER_RUNNER_REGISTRY_ENDPOINT The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic). MINION_API_PROXY Format: \"host:port\". MINION_API_PROXY_AUTH Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. MINION_API_PROXY_SELF_SIGNED_CERT Acceptable values: true, 1, or yes (any case). MINION_CHECK_TIMEOUT The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. MINION_DOCKER_API_VERSION Synonym of DOCKER_API_VERSION. MINION_DOCKER_HOST Synonym of DOCKER_HOST. MINION_RUNNER_APPARMOR (CPM version > 3.0.2) OR MINION_DOCKER_RUNNER_APPARMOR (CPM version <= 3.0.2) The AppArmor profile name, if it has been applied to Docker containers running monitor scripts (for example, Docker Runner). The AppArmor profile name must exist and be set up on the machine to work. MINION_JVM_MB Default: \"2560\" (2.5GB). MINION_JVM_OPTS Passes command line options to the internal JVM. See Oracle's Java documentation for more information. Default: -server. MINION_LOG_LEVEL When contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. MINION_NETWORK_HEALTHCHECK_DISABLED (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. MINION_USER_DEFINED_ENV_VARIABLES Format: Example. A locally hosted set of user defined key value pairs. MINION_HEAVY_WORKERS The number of workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. MINION_LIGHTWEIGHT_WORKERS The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 1250. For more information on monitor types, see Types of Synthetics monitors. MINION_VSE_PASSPHRASE If set, enables verified script execution and uses this value as a passphrase. Kubernetes environment configuration The variables are provided at startup using the --set argument. The following list shows all the environment variables that CPM supports. synthetics.privateLocationKey is required, and all other variables are optional. Name Description synthetics.privateLocationKey REQUIRED if synthetics.privateLocationKeySecretName is not set. UUID/Private location key of the private location, as found on the private location web page. synthetics.privateLocationKeySecretName REQUIRED if synthetics.privateLocationKey is not set. Name of the Kubernetes secret that contains the key privateLocationKey, which contains the authentication key associated with your Synthetics private location. replicaCount Number of replicas to maintain with your StatefulSet installation Default: 1. imagePullSecrets The name of the secret object used to pull an image from a specified container registry. fullnameOverride Name override used for your StatefulSet installation, replacing the default. appVersionOverride Release version of CPM to use instead of the version specified in chart.yml. synthetics.minionLogLevel If contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. synthetics.heavyWorkers The number of concurrent workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use the value 2. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. synthetics.lightweightWorkers The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * synthetics.heavyWorkers, where synthetics.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on monitor types, see Types of synthetic monitors. synthetics.minionApiEndpoint For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. synthetics.minionDockerRunnerRegistryEndpoint The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic) synthetics.minionVsePassphrase If set, it enables verified script execution, and uses this value as a passphrase. synthetics.minionVsePassphraseSecretName If set, enables verified script execution and uses this value to retrieve the passphrase from a Kubernetes secret with a key called minionVsePassphrase. synthetics.minionApiProxy Format: \"host:port\". synthetics.minionApiProxySelfSignedCert Acceptable values: true, 1, or yes (any case). synthetics.minionApiProxyAuth Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. synthetics.minionCheckTimeout The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. synthetics.minionUserDefinedEnvVariable Format: Example. A locally hosted set of user-defined key value pairs. synthetics.minionJVMOpts Passes command line options to the internal JVM. Default: -server -XX:-UsePerfData synthetics.minionNetworkHealthCheckDisabled (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. image.repository The container to pull. Default: quay.io/newrelic/synthetics-minion image.pullPolicy The pull policy. Default: IfNotPresent persistence.claimName The name of the PVC to use. If undefined or not set, Statefulset will dynamically create a PVC for each replica. persistence.storageClass Overrides StorageClass for VolumeClaimTemplates, relevant only if claimName is undefined or empty. For more details see persistent volumes. persistence.accessMode Access mode to be defined for the PVC, relevant only if claimName is undefined or empty. Default: ReadWriteOnce. persistence.annotations Annotations to add to the PVC, relevant only if claimName is undefined or empty. persistence.size Size to be defined for the PVC, relevant only if claimName is undefined or empty. Default: 10Gi. persistence.permanentData Path on the volume to the permanent data storage directory. For more details, see permanent data storage. persistence.customModules Path on the volume to the custom modules directory. For more details, see custom modules. persistence.userDefinedVariables Path on the volume to the user-defined-variable.json file. For more details, see user defined variables. serviceAccount.create If true, a service account is created and assigned to the deployment. Default: false. serviceAccount.name The service account to assign to the deployment. If serviceAccount.create is true, then this name is used when creating the service account. serviceAccount.annotations The annotations to add to the service account if serviceAccount.create is set to true. removeJobsLog Default Kubernetes doesn't include a jobs/log resource. Set this to true to remove it from the role if needed. Default: false. headlessService.serviceName The name of the headless service to associate to the StatefulSet. If not set a name is generated using the fullname template. appArmorProfileName The AppArmor profile name that will be applied to the Minion and Runner pods. If set, then the AppArmor profile must exist on the Kubernetes node(s) for this to work. podSecurityContextRunAsUser A UID that can be set to either 0 (root) or between [2000, 4000], inclusive. If set, runs the CPM as the given UID. Default: 2379.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.78047,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Containerized <em>private</em> minion (CPM) configuration",
        "sections": "Containerized <em>private</em> minion (CPM) configuration",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " * <em>synthetics</em>.heavyWorkers, where <em>synthetics</em>.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on <em>monitor</em> types, see Types of <em>synthetic</em> monitors. <em>synthetics</em>.minionApiEndpoint For US-based accounts, the endpoint"
      },
      "id": "603ea540196a67e50da83d95"
    },
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-25T17:37:54Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 197.3208,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and <em>private</em> <em>locations</em>. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials <em>Private</em> <em>locations</em> (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/private-locations-overview-monitor-internal-sites-add-new-locations": [
    {
      "sections": [
        "Monitor private locations",
        "Prerequisites",
        "Private Minion dashboard JSON",
        "Tip",
        "Are my private minions online?",
        "Does my private location need more minions?",
        "Can I check the status of a specific minion directly?"
      ],
      "title": "Monitor private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "d38b5c957ec41b25199f4d093eb2f6083a5ff351",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/monitor-private-locations/",
      "published_at": "2021-12-25T18:33:22Z",
      "updated_at": "2021-12-15T12:32:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using synthetic monitoring's private locations with New Relic's alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic dashboards and NRQL alerts: Are my private minions online? Does my private location need more minions? Can I check the status of a specific minion directly? Prerequisites Before following the instructions in this guide, ensure you have: A synthetic private location At least one private minion installed at that location Checks scheduled to run at that location An alert policy for the private location, with a configured notification channel to notify your team when a violation occurs The following Private Minion dashboard example JSON can be imported to your account using: the Import a dashboard button the Dashboard API Private Minion dashboard JSON { \"name\": \"Synthetics Private Minions\", \"description\": \"Details on events from SyntheticPrivateLocationStatus, SyntheticsPrivateMinion, SyntheticCheck, SyntheticRequest, NrAuditEvent, plus a page for Performance Analysis.\", \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"SyntheticPrivateLocationStatus\", \"description\": \"Details on the private location queue.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 8, \"width\": 3 }, \"title\": \"pending checks by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(checksPending) FROM SyntheticsPrivateLocationStatus FACET name\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 4, \"width\": 9 }, \"title\": \"private location queue\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES max SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 5, \"height\": 4, \"width\": 9 }, \"title\": \"rate of queue growth\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(checksPending,1 minute),0) as 'queue growth rate' FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 9, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'PRIVATE_LOCATION' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticsPrivateMinion\", \"description\": \"Details on the minion instances.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 3 }, \"title\": \"private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(timestamp),uniqueCount(minionId) - 1 as 'restarts' from SyntheticsPrivateMinion since 2 days ago FACET minionLocation\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 3, \"width\": 7 }, \"title\": \"minion details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionId),latest(timestamp) as 'last seen',latest(minionStartTimestamp) as 'started',uniqueCount(minionId) - 1 as 'restarts',latest(minionIpv4),latest(minionJobsQueued),latest(minionJobsFinished),100*latest(minionJobsFailed)/latest(minionJobsQueued) as 'job failure rate',latest(minionJobsRunning),latest(minionJobsTimedout),latest(minionJobsSkipped),latest(minionJobsInternalEngineError),latest(minionWorkers),latest(minionProcessors),latest(minionPhysicalMemoryUsedBytes/(1024*1024*1024)) as 'used memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024)) as 'total memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024))/latest(minionWorkers) as 'memory (GiB) per heavy worker' FROM SyntheticsPrivateMinion FACET minionBuildNumber,minionLocation,minionOsVersion,minionContainerSystemVersion,minionHostname LIMIT 100 SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"minion instances over time\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' from SyntheticsPrivateMinion since 2 days ago TIMESERIES MAX \" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"CPU utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionProcessorsUsagePercentage) AS 'CPU load %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"memory utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryUsedPercentage) AS 'used memory %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"free memory (GiB)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryFreeBytes / (1024*1024*1024)) AS 'free (GiB)' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(minionJobsFinished,1 minute),0) FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"skipped jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsSkipped) as 'skipped jobs' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 2 weeks ago TIMESERIES MAX\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"count of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsInternalEngineError) as 'IEE',average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.stacked-bar\" }, \"layout\": { \"column\": 9, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"rate of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*average(minionJobsInternalEngineError)/average(minionJobsFailed) as 'IEE',100*(average(minionJobsFailed)-average(minionJobsInternalEngineError))/average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES AUTO SINCE 2 weeks ago\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticCheck\", \"description\": \"Details on job results.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 non-ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type != 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type = 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type = 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 6, \"width\": 6 }, \"title\": \"monitor details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(id) as 'results',uniqueCount(location)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET monitorName,monitorId,type LIMIT MAX\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 7, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 errors by monitor type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE error IS NOT NULL AND location NOT LIKE 'AWS%' FACET error,type TIMESERIES AUTO SINCE 2 weeks ago LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 10, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping duration with monitor count\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)',uniqueCount(monitorId) as 'monitor count' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job results\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET type TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type = 'SIMPLE' as 'ping',WHERE type != 'SIMPLE' as 'non-ping') TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 11, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type, result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type != 'SIMPLE' as 'non-ping',WHERE type = 'SIMPLE' as 'ping'),result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticRequest\", \"description\": \"Details on responses.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 6, \"width\": 5 }, \"title\": \"jobs per minion\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(jobId) as 'jobs' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' FACET location,minion,minionId\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 6, \"row\": 1, \"height\": 6, \"width\": 4 }, \"title\": \"top 5 error response codes\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(responseCode) as 'responses' FROM SyntheticRequest WHERE responseCode NOT IN (200,201,202,203,204,300,301,302,303,304) AND responseCode IS NOT NULL AND location NOT LIKE 'AWS%' FACET responseCode,responseStatus TIMESERIES AUTO LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 10, \"row\": 1, \"height\": 6, \"width\": 3 }, \"title\": \"job rate\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(jobId), 1 minute) as 'job rate' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'MONITOR' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"Performance Analysis\", \"description\": \"Determine if there are enough heavy worker threads.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"minions (hosts) by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"count of heavy worker threads and cpu cores\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionWorkers),latest(minionProcessors) FROM SyntheticsPrivateMinion FACET minionHostname,minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.markdown\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"\", \"rawConfiguration\": { \"text\": \"See [this Google sheet](https://docs.google.com/spreadsheets/d/1k2Aw11r6-S8pIpXQUINQZ0T5qlxS8iSwSo9t9GKDvzc/edit?usp=sharing) to assist in calculating how many workers will be needed based on the values on this page. This will help you to assess the required size of each host (scaling up) and how many hosts you need (scaling out).\\n\\nFor more info: \\nhttps://discuss.newrelic.com/t/relic-solution-scaling-and-rightsizing-for-the-cpm/123999\" }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'non-ping monitors' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping avg job duration and timeout\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average((nr.internalQueueDuration+nr.executionDuration)/1e3) FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location,cases(WHERE error NOT LIKE '%timeout%' as 'job duration (s)', WHERE error LIKE '%timeout%' as 'job timeout (s)') SINCE 2 days ago TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"job timeout rate by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*latest(minionJobsTimedout)/latest(minionJobsReceived) as 'job timeout rate' FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES AUTO SINCE 2 days ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Steps to import: Copy the Dashboard JSON and paste into a text editor. Replace \"accountId\": 1, with your New Relic account ID for each occurrence in the JSON code. Copy the Dashboard JSON from your text editor and import using one of the methods described above. Edit any charts that you'd like to use facet filtering with. Tip If your private locations exist in a parent account and Synthetics monitors in a sub account, insert the parent account ID for NRQL queries that use SyntheticPrivateLocationStatus and SyntheticsPrivateMinion, and the sub account ID for queries that use SyntheticCheck and SyntheticRequest. Are my private minions online? To answer this question, you can rely on attributes from the SyntheticsPrivateMinionevent. Private minions send this event to New Relic every 30 seconds. A simple way to check if your minions are online is to compare the unique count of minion IDs with the number of minions you expect to be online. To understand how many minions are reporting, run this example NRQL query: SELECT uniqueCount(minionId) FROM SyntheticsPrivateMinion WHERE minionLocation = '1-acme_okc_dc-309' Copy Using this query, you can create an alert condition to notify your team when fewer minions are reporting than expected. This condition is configured with a static threshold of 2 units, which means you will receive an alert if any of your minions are offline. You can verify that the alert policy works as expected by manually stopping one of your minions. Then, when the alert violation occurs, you will be notified by any notification channels that have been set up. Once the minion is restarted and it comes back online, the alert will recover. There are more robust ways to check whether minions are functioning correctly, but this query and condition simply and successfully handle the case where a machine fails, is accidentally decommissioned, or the minion process crashes. It also ensures that the minion can communicate with New Relic. Does my private location need more minions? To answer this question, you can use the checksPending attribute of the SyntheticsPrivateLocationStatus event. The checksPending attribute reflects the number of monitor checks that are scheduled (or \"queued\") but have yet to be accepted by a minion in the designated location. For a location with scheduled checks and no minions, this graph would grow linearly up and to the right. This metric is more complicated to monitor than uniqueCount(minionId) because a high value does not necessarily mean the location is in a bad state. As long as the metric is not growing linearly up and to the right (and checks are being run on schedule), the location is in a good state. This use case is perfect for baseline NRQL alert conditions, which allow you to monitor the deviation of a metric rather than its static value. For example: SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus WHERE name = '1-acme_tokyo_dc-512' Copy To test this alert condition, schedule one-minute, browser-based monitors to run from your location. Browser-based jobs consume more resources than ping jobs, which is why they are a better fit for load simulation. New Relic will quickly notify you of a growing number of pending checks. After doubling the number of minions to handle the load, the alert recovers. For example, using the Synthetics private location dashboard example, notice the growth and decline of pending checks over the course of the incident and recovery. By using the NRQL condition, New Relic will notify you if and when the location needs more minion capacity. Can I check the status of a specific minion directly? You can also check how a minion is operating by contacting it directly. You can use a set of HTTP endpoints exposed by the minion to determine what the application is doing. In order to access these endpoints, bind ports 8080 and 8180 to ports on the host. For example, for Docker, use docker run -p 80:8080 -p 81:8180 ...): :8080/status/check: Details about internal health-checks the minion performs; HTTP 200 means \"healthy.\" :8080/status: Details about a minion's status; the same data is then published to Insights as a SyntheticsPrivateMinion event. :8180/: JVM application admin endpoints; an advanced view of a minion's internal state. This approach is not as automated or flexible as the checksPending example. However, if you have total network connectivity failure, this manual approach can help troubleshoot the situation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.1203,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> <em>private</em> <em>locations</em>",
        "sections": "<em>Monitor</em> <em>private</em> <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "When using <em>synthetic</em> <em>monitoring</em>&#x27;s <em>private</em> <em>locations</em> with New Relic&#x27;s alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding <em>private</em> location health by using New Relic"
      },
      "id": "604525f164441f7fd7378ef9"
    },
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-12-25T19:12:51Z",
      "updated_at": "2021-11-26T09:10:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher. macOS: 10.11 or higher. Windows: Windows 10 64-bit or higher. You must also configure Docker to run Linux containers in order for CPMs to work on Windows systems. Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution The Docker CPM is not designed for use with container orchestrators like AWS ECS, Docker Swarm, Apache Mesos, Azure Container Instances, etc. Running the Docker CPM in a container orchestrator will result in unexpected issues because it is itself a container orchestrator. If you're using container orchestration, see our Kubernetes CPM requirements. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Unless hosting the images in a local image repository, connections to either quay.io or docker.io will need to be allowed through your firewall in order for Docker to pull the synthetics-minion and synthetics-minion-runner images. The \"runner\" image is pulled automatically on startup of the synthetics-minion container. See Docker environment configuration and Kubernetes environment configuration for details on how to set a local repository and the runner registry endpoint. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.56558,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "Containerized private minion (CPM) configuration",
        "Guidelines for mounting volumes",
        "Custom npm modules",
        "Custom module directory",
        "Node version-specific overrides",
        "Docker",
        "Kubernetes",
        "Change package.json for custom modules",
        "Caution",
        "Permanent data storage",
        "User-defined environment variables for scripted monitors",
        "Mounting JSON file",
        "Passing as an environment variable",
        "Tip",
        "Accessing user-defined environment variables from scripts",
        "Environment variables",
        "Docker environment configuration",
        "Kubernetes environment configuration"
      ],
      "title": "Containerized private minion (CPM) configuration",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "5c65dd79f361d23da2154f6a4227515a40dae944",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration/",
      "published_at": "2021-12-25T18:28:55Z",
      "updated_at": "2021-11-15T07:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to configure your containerized private minion (CPM). You can do the following to customize your CPMs: Set up custom modules for scripted browsers in New Relic. Preserve launch data with permanent data storage. Use environment variables in your configuration. You may not modify any CPM files and New Relic is not liable for any modifications you make. Guidelines for mounting volumes All directories and files must be assigned group ownership as 3729 with read/write permissions. This ensures that the Runner, which uses uid: 1000 and gid: 3729, has access to all the mounted volumes. However, the Minion is able to run as root (uid: 0) or with any uid between the range of [2000, 4000], inclusive. For more information, see running as non-root in Kubernetes or Docker. Docker Directories are mounted onto a container as volumes by specifying a -v argument within docker run For example, docker run ... -v /path/to/src:/path/to/dest:rw Kubernetes It is possible to add a directory onto a persistent volume (PV) by using kubectl cp. However, alternative approaches are supported as long as the file permissions are set appropriately. For example, kubectl cp /path/to/src <POD_NAME>:/path/to/dest will add a directory onto each PV in the specified pod Each PV must have a separate copy of the directories. For example, a cluster with n Minion replicas must have n PVs, each with their own copy of directories The directories and files must be added prior to the Minion boot up, otherwise the Minion must be restarted to detect the updates Custom npm modules Custom npm modules are exclusive to the CPM. They allow you to provide an arbitrary set of npm modules, and make them available for scripted monitors in Synthetics. To set up the modules: Create a directory which contains a package.json, following the npm official guidelines, in the root of the directory. Anything contained in the dependencies field will be installed by the CPM at start, and made available when running monitors on that private minion. Optionally, you can override the root level package.json with a Node version-specific directory. This allows a script to be updated per monitor runtime if a Node version of a runtime is no longer compatible with your dependencies. See an example of this below. Custom module directory In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file Copy The package.json defines dependencies as both a local module (for example, counter) and an npm hosted modules (for example, async version ^2.6.1): { \"name\": \"custom-modules\", \"version\": \"1.0.0\", ⇦ optional \"description\": \"example custom modules directory\", ⇦ optional \"dependencies\": { \"async\": \"^2.6.1\", ⇦ npm hosted module \"counter\": \"file:./counter\" ⇦ Local module } } Copy Node version-specific overrides You can declare a package.json per Node version that will override the root level package.json. This allows a monitor script to be updated per monitor runtime in the event that the Node version of a runtime is no longer compatible with your dependencies. As shown in the first example, local modules can still be defined within a version specific directory. If a package.json is not defined for a specific Node version, then the root level package.json will be used to install dependencies. In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── 6.11.2 ⇦ optional Node specific directory │ └── package.json └── 10.15.0 ⇦ optional Node specific directory │ └── package.json ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file ​ Copy Once you create the custom modules directory and the package.json you can apply it to your CPM for Docker and Kubernetes. Docker For Docker, launch CPM mounting the directory at /var/lib/newrelic/synthetics/modules. For example: docker run ... -v /example-custom-modules-dir:/var/lib/newrelic/synthetics/modules:rw ... Copy Kubernetes Complete the following: Launch the CPM, setting a value for the persistence.customModules configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where your custom modules files exist. For example: helm install ... --set persistence.customModules=<custom-modules-subpath> ... Copy Make sure that your custom modules directory is available on the Minion Pod. You can use kubectl cp as one method to copy the directory from your host to the Minion. For example: kubectl cp /example-custom-modules-dir <namespace>/<pod_name>:/var/lib/newrelic/synthetics/modules Copy Look at the CPM logs for \"... Initialization of Custom Modules ...\" to see if the modules were installed properly, or if there were any errors. The npm installation logs will be shown. Now you can add \"require('async');\" into the script of monitors you send to this private location. Change package.json for custom modules Along with npm modules, you can also use Node.js modules. To change the custom modules used by your CPM, modify package.json and reboot the CPM. It will detect the change in configuration during the reboot, and then clean up and re-install. Caution Local modules: While your package.json can include any local module, these modules must reside inside the tree under your custom module directory. If stored outside the tree, the initialization process will fail and you will see an error message in the docker logs after launching CPM. Permanent data storage CPM is a stateless application and does not preserve information from prior requests or sessions by default. However, you can preserve data between launches by enabling permanent data storage. For example, you can permanently set how the minion identifies itself (for example, Minion_ID), and use it to associate the data visible in Synthetics and Insights events with the exact minion that produced it. To set permanent data storage on Docker: Create a directory. Launch the CPM, mounting the directory at /var/lib/newrelic/synthetics. Example: docker run ... -v /example-permanent-dir:/var/lib/newrelic/synthetics:rw ... Copy To set permanent data storage on Kubernetes: Launch the CPM, setting a value for the persistence.permanentData configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where you want the data to be saved. Example: helm install ... --set persistence.permanentData=<permanent-data-subpath> ... Copy User-defined environment variables for scripted monitors Containerized private minions let you configure environment variables for use in scripted monitors. These variables are hosted locally on the CPM and can be accessed via $env.USER_DEFINED_VARIABLES. There are two ways to set user-defined variables: by mounting a JSON file or by supplying an environment variable to the CPM on launch. If both are provided, the CPM will use values provided from the environment only. Mounting JSON file The JSON file must have read permissions and contain a JSON formatted map. Example user-defined variable file: { \"KEY\" : \"VALUE\", \"User_Name\": \"MINION\", \"My_Password\": \"PASSW0RD 1 2 3\", \"my_URL\": \"https://newrelic.com/\", \"ETC\" : \"ETC\" } Copy The file must be available or mounted to the path in your container: /var/lib/newrelic/synthetics/variables/user_defined_variables.json Docker example: docker run ... -v /example-user-defined-variables.json:/var/lib/newrelic/synthetics/variables/user_defined_variables.json:rw ... Copy Kubernetes example: When mounting a JSON file to your Minion Pod in Kubernetes, you can either copy the file directly to the Minion Pod or to a Pod that has access to the same Persistent Volume and Persistent Volume Claim that the Minion will use. After successfully loading the file, you may need to restart your Minion Pod for the change to take effect. kubectl cp path/to/user_defined_variables.json <namespace>/<pod_name>:/var/lib/newrelic/synthetics/variables/user_defined_variables.json Copy Passing as an environment variable Use the -e flag to set up an environment variable named MINION_USER_DEFINED_VARIABLES and give it a value of a JSON formatted map string. docker run ... -e MINION_USER_DEFINED_ENV_VARIABLES='{\"KEY\":\"VALUE\",\"NAME\":\"MINION\",\"ETC\":\"ETC\"}' ... Copy Tip The CPM on Kubernetes does not currently support loading user-defined environment variables via environment variable. You will have to configure your Kubernetes CPM by mounting a JSON file. Accessing user-defined environment variables from scripts To reference a configured user-defined environment variable, use the reserved $env.USER_DEFINED_VARIABLES followed by the name of a given variable with dot notation. For example, $env.USER_DEFINED_VARIABLES.MY_VARIABLE Caution User-defined environment variables are not sanitized from logs. For sensitive information, consider using the secure credentials feature. Environment variables Environmental variables allow you to fine-tune the CPM configuration to meet your specific environmental and functional needs. Docker environment configuration The variables are provided at startup using the -e, --env argument. The following table shows all the environment variables that CPM supports. MINION_PRIVATE_LOCATION_KEY is required, and all other variables are optional. Name Description MINION_PRIVATE_LOCATION_KEY REQUIRED. UUID of the Private Location, as found on the Private Location Web page. DOCKER_API_VERSION Format: \"vX.Y\" API version to be used with the given Docker service. Default: v1.35. DOCKER_HOST Points the minion to a given DOCKER_HOST. If absent, the default value is /var/run/docker.sock. MINION_API_ENDPOINT For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. MINION_DOCKER_RUNNER_REGISTRY_ENDPOINT The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic). MINION_API_PROXY Format: \"host:port\". MINION_API_PROXY_AUTH Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. MINION_API_PROXY_SELF_SIGNED_CERT Acceptable values: true, 1, or yes (any case). MINION_CHECK_TIMEOUT The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. MINION_DOCKER_API_VERSION Synonym of DOCKER_API_VERSION. MINION_DOCKER_HOST Synonym of DOCKER_HOST. MINION_RUNNER_APPARMOR (CPM version > 3.0.2) OR MINION_DOCKER_RUNNER_APPARMOR (CPM version <= 3.0.2) The AppArmor profile name, if it has been applied to Docker containers running monitor scripts (for example, Docker Runner). The AppArmor profile name must exist and be set up on the machine to work. MINION_JVM_MB Default: \"2560\" (2.5GB). MINION_JVM_OPTS Passes command line options to the internal JVM. See Oracle's Java documentation for more information. Default: -server. MINION_LOG_LEVEL When contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. MINION_NETWORK_HEALTHCHECK_DISABLED (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. MINION_USER_DEFINED_ENV_VARIABLES Format: Example. A locally hosted set of user defined key value pairs. MINION_HEAVY_WORKERS The number of workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. MINION_LIGHTWEIGHT_WORKERS The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 1250. For more information on monitor types, see Types of Synthetics monitors. MINION_VSE_PASSPHRASE If set, enables verified script execution and uses this value as a passphrase. Kubernetes environment configuration The variables are provided at startup using the --set argument. The following list shows all the environment variables that CPM supports. synthetics.privateLocationKey is required, and all other variables are optional. Name Description synthetics.privateLocationKey REQUIRED if synthetics.privateLocationKeySecretName is not set. UUID/Private location key of the private location, as found on the private location web page. synthetics.privateLocationKeySecretName REQUIRED if synthetics.privateLocationKey is not set. Name of the Kubernetes secret that contains the key privateLocationKey, which contains the authentication key associated with your Synthetics private location. replicaCount Number of replicas to maintain with your StatefulSet installation Default: 1. imagePullSecrets The name of the secret object used to pull an image from a specified container registry. fullnameOverride Name override used for your StatefulSet installation, replacing the default. appVersionOverride Release version of CPM to use instead of the version specified in chart.yml. synthetics.minionLogLevel If contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. synthetics.heavyWorkers The number of concurrent workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use the value 2. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. synthetics.lightweightWorkers The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * synthetics.heavyWorkers, where synthetics.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on monitor types, see Types of synthetic monitors. synthetics.minionApiEndpoint For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. synthetics.minionDockerRunnerRegistryEndpoint The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic) synthetics.minionVsePassphrase If set, it enables verified script execution, and uses this value as a passphrase. synthetics.minionVsePassphraseSecretName If set, enables verified script execution and uses this value to retrieve the passphrase from a Kubernetes secret with a key called minionVsePassphrase. synthetics.minionApiProxy Format: \"host:port\". synthetics.minionApiProxySelfSignedCert Acceptable values: true, 1, or yes (any case). synthetics.minionApiProxyAuth Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. synthetics.minionCheckTimeout The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. synthetics.minionUserDefinedEnvVariable Format: Example. A locally hosted set of user-defined key value pairs. synthetics.minionJVMOpts Passes command line options to the internal JVM. Default: -server -XX:-UsePerfData synthetics.minionNetworkHealthCheckDisabled (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. image.repository The container to pull. Default: quay.io/newrelic/synthetics-minion image.pullPolicy The pull policy. Default: IfNotPresent persistence.claimName The name of the PVC to use. If undefined or not set, Statefulset will dynamically create a PVC for each replica. persistence.storageClass Overrides StorageClass for VolumeClaimTemplates, relevant only if claimName is undefined or empty. For more details see persistent volumes. persistence.accessMode Access mode to be defined for the PVC, relevant only if claimName is undefined or empty. Default: ReadWriteOnce. persistence.annotations Annotations to add to the PVC, relevant only if claimName is undefined or empty. persistence.size Size to be defined for the PVC, relevant only if claimName is undefined or empty. Default: 10Gi. persistence.permanentData Path on the volume to the permanent data storage directory. For more details, see permanent data storage. persistence.customModules Path on the volume to the custom modules directory. For more details, see custom modules. persistence.userDefinedVariables Path on the volume to the user-defined-variable.json file. For more details, see user defined variables. serviceAccount.create If true, a service account is created and assigned to the deployment. Default: false. serviceAccount.name The service account to assign to the deployment. If serviceAccount.create is true, then this name is used when creating the service account. serviceAccount.annotations The annotations to add to the service account if serviceAccount.create is set to true. removeJobsLog Default Kubernetes doesn't include a jobs/log resource. Set this to true to remove it from the role if needed. Default: false. headlessService.serviceName The name of the headless service to associate to the StatefulSet. If not set a name is generated using the fullname template. appArmorProfileName The AppArmor profile name that will be applied to the Minion and Runner pods. If set, then the AppArmor profile must exist on the Kubernetes node(s) for this to work. podSecurityContextRunAsUser A UID that can be set to either 0 (root) or between [2000, 4000], inclusive. If set, runs the CPM as the given UID. Default: 2379.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.78046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Containerized <em>private</em> minion (CPM) configuration",
        "sections": "Containerized <em>private</em> minion (CPM) configuration",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " * <em>synthetics</em>.heavyWorkers, where <em>synthetics</em>.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on <em>monitor</em> types, see Types of <em>synthetic</em> monitors. <em>synthetics</em>.minionApiEndpoint For US-based accounts, the endpoint"
      },
      "id": "603ea540196a67e50da83d95"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/troubleshoot-private-locations": [
    {
      "sections": [
        "Monitor private locations",
        "Prerequisites",
        "Private Minion dashboard JSON",
        "Tip",
        "Are my private minions online?",
        "Does my private location need more minions?",
        "Can I check the status of a specific minion directly?"
      ],
      "title": "Monitor private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "d38b5c957ec41b25199f4d093eb2f6083a5ff351",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/monitor-private-locations/",
      "published_at": "2021-12-25T18:33:22Z",
      "updated_at": "2021-12-15T12:32:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using synthetic monitoring's private locations with New Relic's alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic dashboards and NRQL alerts: Are my private minions online? Does my private location need more minions? Can I check the status of a specific minion directly? Prerequisites Before following the instructions in this guide, ensure you have: A synthetic private location At least one private minion installed at that location Checks scheduled to run at that location An alert policy for the private location, with a configured notification channel to notify your team when a violation occurs The following Private Minion dashboard example JSON can be imported to your account using: the Import a dashboard button the Dashboard API Private Minion dashboard JSON { \"name\": \"Synthetics Private Minions\", \"description\": \"Details on events from SyntheticPrivateLocationStatus, SyntheticsPrivateMinion, SyntheticCheck, SyntheticRequest, NrAuditEvent, plus a page for Performance Analysis.\", \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"SyntheticPrivateLocationStatus\", \"description\": \"Details on the private location queue.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 8, \"width\": 3 }, \"title\": \"pending checks by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(checksPending) FROM SyntheticsPrivateLocationStatus FACET name\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 4, \"width\": 9 }, \"title\": \"private location queue\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES max SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 5, \"height\": 4, \"width\": 9 }, \"title\": \"rate of queue growth\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(checksPending,1 minute),0) as 'queue growth rate' FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 9, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'PRIVATE_LOCATION' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticsPrivateMinion\", \"description\": \"Details on the minion instances.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 3 }, \"title\": \"private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(timestamp),uniqueCount(minionId) - 1 as 'restarts' from SyntheticsPrivateMinion since 2 days ago FACET minionLocation\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 3, \"width\": 7 }, \"title\": \"minion details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionId),latest(timestamp) as 'last seen',latest(minionStartTimestamp) as 'started',uniqueCount(minionId) - 1 as 'restarts',latest(minionIpv4),latest(minionJobsQueued),latest(minionJobsFinished),100*latest(minionJobsFailed)/latest(minionJobsQueued) as 'job failure rate',latest(minionJobsRunning),latest(minionJobsTimedout),latest(minionJobsSkipped),latest(minionJobsInternalEngineError),latest(minionWorkers),latest(minionProcessors),latest(minionPhysicalMemoryUsedBytes/(1024*1024*1024)) as 'used memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024)) as 'total memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024))/latest(minionWorkers) as 'memory (GiB) per heavy worker' FROM SyntheticsPrivateMinion FACET minionBuildNumber,minionLocation,minionOsVersion,minionContainerSystemVersion,minionHostname LIMIT 100 SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"minion instances over time\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' from SyntheticsPrivateMinion since 2 days ago TIMESERIES MAX \" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"CPU utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionProcessorsUsagePercentage) AS 'CPU load %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"memory utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryUsedPercentage) AS 'used memory %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"free memory (GiB)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryFreeBytes / (1024*1024*1024)) AS 'free (GiB)' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(minionJobsFinished,1 minute),0) FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"skipped jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsSkipped) as 'skipped jobs' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 2 weeks ago TIMESERIES MAX\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"count of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsInternalEngineError) as 'IEE',average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.stacked-bar\" }, \"layout\": { \"column\": 9, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"rate of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*average(minionJobsInternalEngineError)/average(minionJobsFailed) as 'IEE',100*(average(minionJobsFailed)-average(minionJobsInternalEngineError))/average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES AUTO SINCE 2 weeks ago\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticCheck\", \"description\": \"Details on job results.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 non-ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type != 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type = 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type = 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 6, \"width\": 6 }, \"title\": \"monitor details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(id) as 'results',uniqueCount(location)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET monitorName,monitorId,type LIMIT MAX\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 7, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 errors by monitor type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE error IS NOT NULL AND location NOT LIKE 'AWS%' FACET error,type TIMESERIES AUTO SINCE 2 weeks ago LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 10, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping duration with monitor count\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)',uniqueCount(monitorId) as 'monitor count' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job results\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET type TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type = 'SIMPLE' as 'ping',WHERE type != 'SIMPLE' as 'non-ping') TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 11, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type, result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type != 'SIMPLE' as 'non-ping',WHERE type = 'SIMPLE' as 'ping'),result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticRequest\", \"description\": \"Details on responses.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 6, \"width\": 5 }, \"title\": \"jobs per minion\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(jobId) as 'jobs' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' FACET location,minion,minionId\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 6, \"row\": 1, \"height\": 6, \"width\": 4 }, \"title\": \"top 5 error response codes\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(responseCode) as 'responses' FROM SyntheticRequest WHERE responseCode NOT IN (200,201,202,203,204,300,301,302,303,304) AND responseCode IS NOT NULL AND location NOT LIKE 'AWS%' FACET responseCode,responseStatus TIMESERIES AUTO LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 10, \"row\": 1, \"height\": 6, \"width\": 3 }, \"title\": \"job rate\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(jobId), 1 minute) as 'job rate' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'MONITOR' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"Performance Analysis\", \"description\": \"Determine if there are enough heavy worker threads.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"minions (hosts) by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"count of heavy worker threads and cpu cores\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionWorkers),latest(minionProcessors) FROM SyntheticsPrivateMinion FACET minionHostname,minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.markdown\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"\", \"rawConfiguration\": { \"text\": \"See [this Google sheet](https://docs.google.com/spreadsheets/d/1k2Aw11r6-S8pIpXQUINQZ0T5qlxS8iSwSo9t9GKDvzc/edit?usp=sharing) to assist in calculating how many workers will be needed based on the values on this page. This will help you to assess the required size of each host (scaling up) and how many hosts you need (scaling out).\\n\\nFor more info: \\nhttps://discuss.newrelic.com/t/relic-solution-scaling-and-rightsizing-for-the-cpm/123999\" }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'non-ping monitors' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping avg job duration and timeout\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average((nr.internalQueueDuration+nr.executionDuration)/1e3) FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location,cases(WHERE error NOT LIKE '%timeout%' as 'job duration (s)', WHERE error LIKE '%timeout%' as 'job timeout (s)') SINCE 2 days ago TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"job timeout rate by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*latest(minionJobsTimedout)/latest(minionJobsReceived) as 'job timeout rate' FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES AUTO SINCE 2 days ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Steps to import: Copy the Dashboard JSON and paste into a text editor. Replace \"accountId\": 1, with your New Relic account ID for each occurrence in the JSON code. Copy the Dashboard JSON from your text editor and import using one of the methods described above. Edit any charts that you'd like to use facet filtering with. Tip If your private locations exist in a parent account and Synthetics monitors in a sub account, insert the parent account ID for NRQL queries that use SyntheticPrivateLocationStatus and SyntheticsPrivateMinion, and the sub account ID for queries that use SyntheticCheck and SyntheticRequest. Are my private minions online? To answer this question, you can rely on attributes from the SyntheticsPrivateMinionevent. Private minions send this event to New Relic every 30 seconds. A simple way to check if your minions are online is to compare the unique count of minion IDs with the number of minions you expect to be online. To understand how many minions are reporting, run this example NRQL query: SELECT uniqueCount(minionId) FROM SyntheticsPrivateMinion WHERE minionLocation = '1-acme_okc_dc-309' Copy Using this query, you can create an alert condition to notify your team when fewer minions are reporting than expected. This condition is configured with a static threshold of 2 units, which means you will receive an alert if any of your minions are offline. You can verify that the alert policy works as expected by manually stopping one of your minions. Then, when the alert violation occurs, you will be notified by any notification channels that have been set up. Once the minion is restarted and it comes back online, the alert will recover. There are more robust ways to check whether minions are functioning correctly, but this query and condition simply and successfully handle the case where a machine fails, is accidentally decommissioned, or the minion process crashes. It also ensures that the minion can communicate with New Relic. Does my private location need more minions? To answer this question, you can use the checksPending attribute of the SyntheticsPrivateLocationStatus event. The checksPending attribute reflects the number of monitor checks that are scheduled (or \"queued\") but have yet to be accepted by a minion in the designated location. For a location with scheduled checks and no minions, this graph would grow linearly up and to the right. This metric is more complicated to monitor than uniqueCount(minionId) because a high value does not necessarily mean the location is in a bad state. As long as the metric is not growing linearly up and to the right (and checks are being run on schedule), the location is in a good state. This use case is perfect for baseline NRQL alert conditions, which allow you to monitor the deviation of a metric rather than its static value. For example: SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus WHERE name = '1-acme_tokyo_dc-512' Copy To test this alert condition, schedule one-minute, browser-based monitors to run from your location. Browser-based jobs consume more resources than ping jobs, which is why they are a better fit for load simulation. New Relic will quickly notify you of a growing number of pending checks. After doubling the number of minions to handle the load, the alert recovers. For example, using the Synthetics private location dashboard example, notice the growth and decline of pending checks over the course of the incident and recovery. By using the NRQL condition, New Relic will notify you if and when the location needs more minion capacity. Can I check the status of a specific minion directly? You can also check how a minion is operating by contacting it directly. You can use a set of HTTP endpoints exposed by the minion to determine what the application is doing. In order to access these endpoints, bind ports 8080 and 8180 to ports on the host. For example, for Docker, use docker run -p 80:8080 -p 81:8180 ...): :8080/status/check: Details about internal health-checks the minion performs; HTTP 200 means \"healthy.\" :8080/status: Details about a minion's status; the same data is then published to Insights as a SyntheticsPrivateMinion event. :8180/: JVM application admin endpoints; an advanced view of a minion's internal state. This approach is not as automated or flexible as the checksPending example. However, if you have total network connectivity failure, this manual approach can help troubleshoot the situation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.1203,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> <em>private</em> <em>locations</em>",
        "sections": "<em>Monitor</em> <em>private</em> <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "When using <em>synthetic</em> <em>monitoring</em>&#x27;s <em>private</em> <em>locations</em> with New Relic&#x27;s alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding <em>private</em> location health by using New Relic"
      },
      "id": "604525f164441f7fd7378ef9"
    },
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-12-25T19:12:51Z",
      "updated_at": "2021-11-26T09:10:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher. macOS: 10.11 or higher. Windows: Windows 10 64-bit or higher. You must also configure Docker to run Linux containers in order for CPMs to work on Windows systems. Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution The Docker CPM is not designed for use with container orchestrators like AWS ECS, Docker Swarm, Apache Mesos, Azure Container Instances, etc. Running the Docker CPM in a container orchestrator will result in unexpected issues because it is itself a container orchestrator. If you're using container orchestration, see our Kubernetes CPM requirements. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Unless hosting the images in a local image repository, connections to either quay.io or docker.io will need to be allowed through your firewall in order for Docker to pull the synthetics-minion and synthetics-minion-runner images. The \"runner\" image is pulled automatically on startup of the synthetics-minion container. See Docker environment configuration and Kubernetes environment configuration for details on how to set a local repository and the runner registry endpoint. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.56558,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "Containerized private minion (CPM) configuration",
        "Guidelines for mounting volumes",
        "Custom npm modules",
        "Custom module directory",
        "Node version-specific overrides",
        "Docker",
        "Kubernetes",
        "Change package.json for custom modules",
        "Caution",
        "Permanent data storage",
        "User-defined environment variables for scripted monitors",
        "Mounting JSON file",
        "Passing as an environment variable",
        "Tip",
        "Accessing user-defined environment variables from scripts",
        "Environment variables",
        "Docker environment configuration",
        "Kubernetes environment configuration"
      ],
      "title": "Containerized private minion (CPM) configuration",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "5c65dd79f361d23da2154f6a4227515a40dae944",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration/",
      "published_at": "2021-12-25T18:28:55Z",
      "updated_at": "2021-11-15T07:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to configure your containerized private minion (CPM). You can do the following to customize your CPMs: Set up custom modules for scripted browsers in New Relic. Preserve launch data with permanent data storage. Use environment variables in your configuration. You may not modify any CPM files and New Relic is not liable for any modifications you make. Guidelines for mounting volumes All directories and files must be assigned group ownership as 3729 with read/write permissions. This ensures that the Runner, which uses uid: 1000 and gid: 3729, has access to all the mounted volumes. However, the Minion is able to run as root (uid: 0) or with any uid between the range of [2000, 4000], inclusive. For more information, see running as non-root in Kubernetes or Docker. Docker Directories are mounted onto a container as volumes by specifying a -v argument within docker run For example, docker run ... -v /path/to/src:/path/to/dest:rw Kubernetes It is possible to add a directory onto a persistent volume (PV) by using kubectl cp. However, alternative approaches are supported as long as the file permissions are set appropriately. For example, kubectl cp /path/to/src <POD_NAME>:/path/to/dest will add a directory onto each PV in the specified pod Each PV must have a separate copy of the directories. For example, a cluster with n Minion replicas must have n PVs, each with their own copy of directories The directories and files must be added prior to the Minion boot up, otherwise the Minion must be restarted to detect the updates Custom npm modules Custom npm modules are exclusive to the CPM. They allow you to provide an arbitrary set of npm modules, and make them available for scripted monitors in Synthetics. To set up the modules: Create a directory which contains a package.json, following the npm official guidelines, in the root of the directory. Anything contained in the dependencies field will be installed by the CPM at start, and made available when running monitors on that private minion. Optionally, you can override the root level package.json with a Node version-specific directory. This allows a script to be updated per monitor runtime if a Node version of a runtime is no longer compatible with your dependencies. See an example of this below. Custom module directory In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file Copy The package.json defines dependencies as both a local module (for example, counter) and an npm hosted modules (for example, async version ^2.6.1): { \"name\": \"custom-modules\", \"version\": \"1.0.0\", ⇦ optional \"description\": \"example custom modules directory\", ⇦ optional \"dependencies\": { \"async\": \"^2.6.1\", ⇦ npm hosted module \"counter\": \"file:./counter\" ⇦ Local module } } Copy Node version-specific overrides You can declare a package.json per Node version that will override the root level package.json. This allows a monitor script to be updated per monitor runtime in the event that the Node version of a runtime is no longer compatible with your dependencies. As shown in the first example, local modules can still be defined within a version specific directory. If a package.json is not defined for a specific Node version, then the root level package.json will be used to install dependencies. In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── 6.11.2 ⇦ optional Node specific directory │ └── package.json └── 10.15.0 ⇦ optional Node specific directory │ └── package.json ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file ​ Copy Once you create the custom modules directory and the package.json you can apply it to your CPM for Docker and Kubernetes. Docker For Docker, launch CPM mounting the directory at /var/lib/newrelic/synthetics/modules. For example: docker run ... -v /example-custom-modules-dir:/var/lib/newrelic/synthetics/modules:rw ... Copy Kubernetes Complete the following: Launch the CPM, setting a value for the persistence.customModules configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where your custom modules files exist. For example: helm install ... --set persistence.customModules=<custom-modules-subpath> ... Copy Make sure that your custom modules directory is available on the Minion Pod. You can use kubectl cp as one method to copy the directory from your host to the Minion. For example: kubectl cp /example-custom-modules-dir <namespace>/<pod_name>:/var/lib/newrelic/synthetics/modules Copy Look at the CPM logs for \"... Initialization of Custom Modules ...\" to see if the modules were installed properly, or if there were any errors. The npm installation logs will be shown. Now you can add \"require('async');\" into the script of monitors you send to this private location. Change package.json for custom modules Along with npm modules, you can also use Node.js modules. To change the custom modules used by your CPM, modify package.json and reboot the CPM. It will detect the change in configuration during the reboot, and then clean up and re-install. Caution Local modules: While your package.json can include any local module, these modules must reside inside the tree under your custom module directory. If stored outside the tree, the initialization process will fail and you will see an error message in the docker logs after launching CPM. Permanent data storage CPM is a stateless application and does not preserve information from prior requests or sessions by default. However, you can preserve data between launches by enabling permanent data storage. For example, you can permanently set how the minion identifies itself (for example, Minion_ID), and use it to associate the data visible in Synthetics and Insights events with the exact minion that produced it. To set permanent data storage on Docker: Create a directory. Launch the CPM, mounting the directory at /var/lib/newrelic/synthetics. Example: docker run ... -v /example-permanent-dir:/var/lib/newrelic/synthetics:rw ... Copy To set permanent data storage on Kubernetes: Launch the CPM, setting a value for the persistence.permanentData configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where you want the data to be saved. Example: helm install ... --set persistence.permanentData=<permanent-data-subpath> ... Copy User-defined environment variables for scripted monitors Containerized private minions let you configure environment variables for use in scripted monitors. These variables are hosted locally on the CPM and can be accessed via $env.USER_DEFINED_VARIABLES. There are two ways to set user-defined variables: by mounting a JSON file or by supplying an environment variable to the CPM on launch. If both are provided, the CPM will use values provided from the environment only. Mounting JSON file The JSON file must have read permissions and contain a JSON formatted map. Example user-defined variable file: { \"KEY\" : \"VALUE\", \"User_Name\": \"MINION\", \"My_Password\": \"PASSW0RD 1 2 3\", \"my_URL\": \"https://newrelic.com/\", \"ETC\" : \"ETC\" } Copy The file must be available or mounted to the path in your container: /var/lib/newrelic/synthetics/variables/user_defined_variables.json Docker example: docker run ... -v /example-user-defined-variables.json:/var/lib/newrelic/synthetics/variables/user_defined_variables.json:rw ... Copy Kubernetes example: When mounting a JSON file to your Minion Pod in Kubernetes, you can either copy the file directly to the Minion Pod or to a Pod that has access to the same Persistent Volume and Persistent Volume Claim that the Minion will use. After successfully loading the file, you may need to restart your Minion Pod for the change to take effect. kubectl cp path/to/user_defined_variables.json <namespace>/<pod_name>:/var/lib/newrelic/synthetics/variables/user_defined_variables.json Copy Passing as an environment variable Use the -e flag to set up an environment variable named MINION_USER_DEFINED_VARIABLES and give it a value of a JSON formatted map string. docker run ... -e MINION_USER_DEFINED_ENV_VARIABLES='{\"KEY\":\"VALUE\",\"NAME\":\"MINION\",\"ETC\":\"ETC\"}' ... Copy Tip The CPM on Kubernetes does not currently support loading user-defined environment variables via environment variable. You will have to configure your Kubernetes CPM by mounting a JSON file. Accessing user-defined environment variables from scripts To reference a configured user-defined environment variable, use the reserved $env.USER_DEFINED_VARIABLES followed by the name of a given variable with dot notation. For example, $env.USER_DEFINED_VARIABLES.MY_VARIABLE Caution User-defined environment variables are not sanitized from logs. For sensitive information, consider using the secure credentials feature. Environment variables Environmental variables allow you to fine-tune the CPM configuration to meet your specific environmental and functional needs. Docker environment configuration The variables are provided at startup using the -e, --env argument. The following table shows all the environment variables that CPM supports. MINION_PRIVATE_LOCATION_KEY is required, and all other variables are optional. Name Description MINION_PRIVATE_LOCATION_KEY REQUIRED. UUID of the Private Location, as found on the Private Location Web page. DOCKER_API_VERSION Format: \"vX.Y\" API version to be used with the given Docker service. Default: v1.35. DOCKER_HOST Points the minion to a given DOCKER_HOST. If absent, the default value is /var/run/docker.sock. MINION_API_ENDPOINT For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. MINION_DOCKER_RUNNER_REGISTRY_ENDPOINT The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic). MINION_API_PROXY Format: \"host:port\". MINION_API_PROXY_AUTH Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. MINION_API_PROXY_SELF_SIGNED_CERT Acceptable values: true, 1, or yes (any case). MINION_CHECK_TIMEOUT The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. MINION_DOCKER_API_VERSION Synonym of DOCKER_API_VERSION. MINION_DOCKER_HOST Synonym of DOCKER_HOST. MINION_RUNNER_APPARMOR (CPM version > 3.0.2) OR MINION_DOCKER_RUNNER_APPARMOR (CPM version <= 3.0.2) The AppArmor profile name, if it has been applied to Docker containers running monitor scripts (for example, Docker Runner). The AppArmor profile name must exist and be set up on the machine to work. MINION_JVM_MB Default: \"2560\" (2.5GB). MINION_JVM_OPTS Passes command line options to the internal JVM. See Oracle's Java documentation for more information. Default: -server. MINION_LOG_LEVEL When contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. MINION_NETWORK_HEALTHCHECK_DISABLED (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. MINION_USER_DEFINED_ENV_VARIABLES Format: Example. A locally hosted set of user defined key value pairs. MINION_HEAVY_WORKERS The number of workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. MINION_LIGHTWEIGHT_WORKERS The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 1250. For more information on monitor types, see Types of Synthetics monitors. MINION_VSE_PASSPHRASE If set, enables verified script execution and uses this value as a passphrase. Kubernetes environment configuration The variables are provided at startup using the --set argument. The following list shows all the environment variables that CPM supports. synthetics.privateLocationKey is required, and all other variables are optional. Name Description synthetics.privateLocationKey REQUIRED if synthetics.privateLocationKeySecretName is not set. UUID/Private location key of the private location, as found on the private location web page. synthetics.privateLocationKeySecretName REQUIRED if synthetics.privateLocationKey is not set. Name of the Kubernetes secret that contains the key privateLocationKey, which contains the authentication key associated with your Synthetics private location. replicaCount Number of replicas to maintain with your StatefulSet installation Default: 1. imagePullSecrets The name of the secret object used to pull an image from a specified container registry. fullnameOverride Name override used for your StatefulSet installation, replacing the default. appVersionOverride Release version of CPM to use instead of the version specified in chart.yml. synthetics.minionLogLevel If contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. synthetics.heavyWorkers The number of concurrent workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use the value 2. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. synthetics.lightweightWorkers The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * synthetics.heavyWorkers, where synthetics.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on monitor types, see Types of synthetic monitors. synthetics.minionApiEndpoint For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. synthetics.minionDockerRunnerRegistryEndpoint The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic) synthetics.minionVsePassphrase If set, it enables verified script execution, and uses this value as a passphrase. synthetics.minionVsePassphraseSecretName If set, enables verified script execution and uses this value to retrieve the passphrase from a Kubernetes secret with a key called minionVsePassphrase. synthetics.minionApiProxy Format: \"host:port\". synthetics.minionApiProxySelfSignedCert Acceptable values: true, 1, or yes (any case). synthetics.minionApiProxyAuth Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. synthetics.minionCheckTimeout The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. synthetics.minionUserDefinedEnvVariable Format: Example. A locally hosted set of user-defined key value pairs. synthetics.minionJVMOpts Passes command line options to the internal JVM. Default: -server -XX:-UsePerfData synthetics.minionNetworkHealthCheckDisabled (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. image.repository The container to pull. Default: quay.io/newrelic/synthetics-minion image.pullPolicy The pull policy. Default: IfNotPresent persistence.claimName The name of the PVC to use. If undefined or not set, Statefulset will dynamically create a PVC for each replica. persistence.storageClass Overrides StorageClass for VolumeClaimTemplates, relevant only if claimName is undefined or empty. For more details see persistent volumes. persistence.accessMode Access mode to be defined for the PVC, relevant only if claimName is undefined or empty. Default: ReadWriteOnce. persistence.annotations Annotations to add to the PVC, relevant only if claimName is undefined or empty. persistence.size Size to be defined for the PVC, relevant only if claimName is undefined or empty. Default: 10Gi. persistence.permanentData Path on the volume to the permanent data storage directory. For more details, see permanent data storage. persistence.customModules Path on the volume to the custom modules directory. For more details, see custom modules. persistence.userDefinedVariables Path on the volume to the user-defined-variable.json file. For more details, see user defined variables. serviceAccount.create If true, a service account is created and assigned to the deployment. Default: false. serviceAccount.name The service account to assign to the deployment. If serviceAccount.create is true, then this name is used when creating the service account. serviceAccount.annotations The annotations to add to the service account if serviceAccount.create is set to true. removeJobsLog Default Kubernetes doesn't include a jobs/log resource. Set this to true to remove it from the role if needed. Default: false. headlessService.serviceName The name of the headless service to associate to the StatefulSet. If not set a name is generated using the fullname template. appArmorProfileName The AppArmor profile name that will be applied to the Minion and Runner pods. If set, then the AppArmor profile must exist on the Kubernetes node(s) for this to work. podSecurityContextRunAsUser A UID that can be set to either 0 (root) or between [2000, 4000], inclusive. If set, runs the CPM as the given UID. Default: 2379.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.78046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Containerized <em>private</em> minion (CPM) configuration",
        "sections": "Containerized <em>private</em> minion (CPM) configuration",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " * <em>synthetics</em>.heavyWorkers, where <em>synthetics</em>.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on <em>monitor</em> types, see Types of <em>synthetic</em> monitors. <em>synthetics</em>.minionApiEndpoint For US-based accounts, the endpoint"
      },
      "id": "603ea540196a67e50da83d95"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/verified-script-execution-private-locations": [
    {
      "sections": [
        "Monitor private locations",
        "Prerequisites",
        "Private Minion dashboard JSON",
        "Tip",
        "Are my private minions online?",
        "Does my private location need more minions?",
        "Can I check the status of a specific minion directly?"
      ],
      "title": "Monitor private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "d38b5c957ec41b25199f4d093eb2f6083a5ff351",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/monitor-private-locations/",
      "published_at": "2021-12-25T18:33:22Z",
      "updated_at": "2021-12-15T12:32:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using synthetic monitoring's private locations with New Relic's alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic dashboards and NRQL alerts: Are my private minions online? Does my private location need more minions? Can I check the status of a specific minion directly? Prerequisites Before following the instructions in this guide, ensure you have: A synthetic private location At least one private minion installed at that location Checks scheduled to run at that location An alert policy for the private location, with a configured notification channel to notify your team when a violation occurs The following Private Minion dashboard example JSON can be imported to your account using: the Import a dashboard button the Dashboard API Private Minion dashboard JSON { \"name\": \"Synthetics Private Minions\", \"description\": \"Details on events from SyntheticPrivateLocationStatus, SyntheticsPrivateMinion, SyntheticCheck, SyntheticRequest, NrAuditEvent, plus a page for Performance Analysis.\", \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"SyntheticPrivateLocationStatus\", \"description\": \"Details on the private location queue.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 8, \"width\": 3 }, \"title\": \"pending checks by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(checksPending) FROM SyntheticsPrivateLocationStatus FACET name\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 4, \"width\": 9 }, \"title\": \"private location queue\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES max SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 5, \"height\": 4, \"width\": 9 }, \"title\": \"rate of queue growth\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(checksPending,1 minute),0) as 'queue growth rate' FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 9, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'PRIVATE_LOCATION' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticsPrivateMinion\", \"description\": \"Details on the minion instances.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 3 }, \"title\": \"private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(timestamp),uniqueCount(minionId) - 1 as 'restarts' from SyntheticsPrivateMinion since 2 days ago FACET minionLocation\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 3, \"width\": 7 }, \"title\": \"minion details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionId),latest(timestamp) as 'last seen',latest(minionStartTimestamp) as 'started',uniqueCount(minionId) - 1 as 'restarts',latest(minionIpv4),latest(minionJobsQueued),latest(minionJobsFinished),100*latest(minionJobsFailed)/latest(minionJobsQueued) as 'job failure rate',latest(minionJobsRunning),latest(minionJobsTimedout),latest(minionJobsSkipped),latest(minionJobsInternalEngineError),latest(minionWorkers),latest(minionProcessors),latest(minionPhysicalMemoryUsedBytes/(1024*1024*1024)) as 'used memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024)) as 'total memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024))/latest(minionWorkers) as 'memory (GiB) per heavy worker' FROM SyntheticsPrivateMinion FACET minionBuildNumber,minionLocation,minionOsVersion,minionContainerSystemVersion,minionHostname LIMIT 100 SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"minion instances over time\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' from SyntheticsPrivateMinion since 2 days ago TIMESERIES MAX \" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"CPU utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionProcessorsUsagePercentage) AS 'CPU load %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"memory utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryUsedPercentage) AS 'used memory %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"free memory (GiB)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryFreeBytes / (1024*1024*1024)) AS 'free (GiB)' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(minionJobsFinished,1 minute),0) FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"skipped jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsSkipped) as 'skipped jobs' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 2 weeks ago TIMESERIES MAX\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"count of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsInternalEngineError) as 'IEE',average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.stacked-bar\" }, \"layout\": { \"column\": 9, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"rate of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*average(minionJobsInternalEngineError)/average(minionJobsFailed) as 'IEE',100*(average(minionJobsFailed)-average(minionJobsInternalEngineError))/average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES AUTO SINCE 2 weeks ago\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticCheck\", \"description\": \"Details on job results.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 non-ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type != 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type = 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type = 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 6, \"width\": 6 }, \"title\": \"monitor details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(id) as 'results',uniqueCount(location)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET monitorName,monitorId,type LIMIT MAX\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 7, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 errors by monitor type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE error IS NOT NULL AND location NOT LIKE 'AWS%' FACET error,type TIMESERIES AUTO SINCE 2 weeks ago LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 10, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping duration with monitor count\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)',uniqueCount(monitorId) as 'monitor count' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job results\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET type TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type = 'SIMPLE' as 'ping',WHERE type != 'SIMPLE' as 'non-ping') TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 11, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type, result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type != 'SIMPLE' as 'non-ping',WHERE type = 'SIMPLE' as 'ping'),result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticRequest\", \"description\": \"Details on responses.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 6, \"width\": 5 }, \"title\": \"jobs per minion\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(jobId) as 'jobs' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' FACET location,minion,minionId\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 6, \"row\": 1, \"height\": 6, \"width\": 4 }, \"title\": \"top 5 error response codes\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(responseCode) as 'responses' FROM SyntheticRequest WHERE responseCode NOT IN (200,201,202,203,204,300,301,302,303,304) AND responseCode IS NOT NULL AND location NOT LIKE 'AWS%' FACET responseCode,responseStatus TIMESERIES AUTO LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 10, \"row\": 1, \"height\": 6, \"width\": 3 }, \"title\": \"job rate\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(jobId), 1 minute) as 'job rate' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'MONITOR' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"Performance Analysis\", \"description\": \"Determine if there are enough heavy worker threads.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"minions (hosts) by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"count of heavy worker threads and cpu cores\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionWorkers),latest(minionProcessors) FROM SyntheticsPrivateMinion FACET minionHostname,minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.markdown\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"\", \"rawConfiguration\": { \"text\": \"See [this Google sheet](https://docs.google.com/spreadsheets/d/1k2Aw11r6-S8pIpXQUINQZ0T5qlxS8iSwSo9t9GKDvzc/edit?usp=sharing) to assist in calculating how many workers will be needed based on the values on this page. This will help you to assess the required size of each host (scaling up) and how many hosts you need (scaling out).\\n\\nFor more info: \\nhttps://discuss.newrelic.com/t/relic-solution-scaling-and-rightsizing-for-the-cpm/123999\" }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'non-ping monitors' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping avg job duration and timeout\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average((nr.internalQueueDuration+nr.executionDuration)/1e3) FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location,cases(WHERE error NOT LIKE '%timeout%' as 'job duration (s)', WHERE error LIKE '%timeout%' as 'job timeout (s)') SINCE 2 days ago TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"job timeout rate by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*latest(minionJobsTimedout)/latest(minionJobsReceived) as 'job timeout rate' FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES AUTO SINCE 2 days ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Steps to import: Copy the Dashboard JSON and paste into a text editor. Replace \"accountId\": 1, with your New Relic account ID for each occurrence in the JSON code. Copy the Dashboard JSON from your text editor and import using one of the methods described above. Edit any charts that you'd like to use facet filtering with. Tip If your private locations exist in a parent account and Synthetics monitors in a sub account, insert the parent account ID for NRQL queries that use SyntheticPrivateLocationStatus and SyntheticsPrivateMinion, and the sub account ID for queries that use SyntheticCheck and SyntheticRequest. Are my private minions online? To answer this question, you can rely on attributes from the SyntheticsPrivateMinionevent. Private minions send this event to New Relic every 30 seconds. A simple way to check if your minions are online is to compare the unique count of minion IDs with the number of minions you expect to be online. To understand how many minions are reporting, run this example NRQL query: SELECT uniqueCount(minionId) FROM SyntheticsPrivateMinion WHERE minionLocation = '1-acme_okc_dc-309' Copy Using this query, you can create an alert condition to notify your team when fewer minions are reporting than expected. This condition is configured with a static threshold of 2 units, which means you will receive an alert if any of your minions are offline. You can verify that the alert policy works as expected by manually stopping one of your minions. Then, when the alert violation occurs, you will be notified by any notification channels that have been set up. Once the minion is restarted and it comes back online, the alert will recover. There are more robust ways to check whether minions are functioning correctly, but this query and condition simply and successfully handle the case where a machine fails, is accidentally decommissioned, or the minion process crashes. It also ensures that the minion can communicate with New Relic. Does my private location need more minions? To answer this question, you can use the checksPending attribute of the SyntheticsPrivateLocationStatus event. The checksPending attribute reflects the number of monitor checks that are scheduled (or \"queued\") but have yet to be accepted by a minion in the designated location. For a location with scheduled checks and no minions, this graph would grow linearly up and to the right. This metric is more complicated to monitor than uniqueCount(minionId) because a high value does not necessarily mean the location is in a bad state. As long as the metric is not growing linearly up and to the right (and checks are being run on schedule), the location is in a good state. This use case is perfect for baseline NRQL alert conditions, which allow you to monitor the deviation of a metric rather than its static value. For example: SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus WHERE name = '1-acme_tokyo_dc-512' Copy To test this alert condition, schedule one-minute, browser-based monitors to run from your location. Browser-based jobs consume more resources than ping jobs, which is why they are a better fit for load simulation. New Relic will quickly notify you of a growing number of pending checks. After doubling the number of minions to handle the load, the alert recovers. For example, using the Synthetics private location dashboard example, notice the growth and decline of pending checks over the course of the incident and recovery. By using the NRQL condition, New Relic will notify you if and when the location needs more minion capacity. Can I check the status of a specific minion directly? You can also check how a minion is operating by contacting it directly. You can use a set of HTTP endpoints exposed by the minion to determine what the application is doing. In order to access these endpoints, bind ports 8080 and 8180 to ports on the host. For example, for Docker, use docker run -p 80:8080 -p 81:8180 ...): :8080/status/check: Details about internal health-checks the minion performs; HTTP 200 means \"healthy.\" :8080/status: Details about a minion's status; the same data is then published to Insights as a SyntheticsPrivateMinion event. :8180/: JVM application admin endpoints; an advanced view of a minion's internal state. This approach is not as automated or flexible as the checksPending example. However, if you have total network connectivity failure, this manual approach can help troubleshoot the situation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.12024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> <em>private</em> <em>locations</em>",
        "sections": "<em>Monitor</em> <em>private</em> <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "When using <em>synthetic</em> <em>monitoring</em>&#x27;s <em>private</em> <em>locations</em> with New Relic&#x27;s alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding <em>private</em> location health by using New Relic"
      },
      "id": "604525f164441f7fd7378ef9"
    },
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-12-25T19:12:51Z",
      "updated_at": "2021-11-26T09:10:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher. macOS: 10.11 or higher. Windows: Windows 10 64-bit or higher. You must also configure Docker to run Linux containers in order for CPMs to work on Windows systems. Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution The Docker CPM is not designed for use with container orchestrators like AWS ECS, Docker Swarm, Apache Mesos, Azure Container Instances, etc. Running the Docker CPM in a container orchestrator will result in unexpected issues because it is itself a container orchestrator. If you're using container orchestration, see our Kubernetes CPM requirements. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Unless hosting the images in a local image repository, connections to either quay.io or docker.io will need to be allowed through your firewall in order for Docker to pull the synthetics-minion and synthetics-minion-runner images. The \"runner\" image is pulled automatically on startup of the synthetics-minion container. See Docker environment configuration and Kubernetes environment configuration for details on how to set a local repository and the runner registry endpoint. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.56558,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "Containerized private minion (CPM) configuration",
        "Guidelines for mounting volumes",
        "Custom npm modules",
        "Custom module directory",
        "Node version-specific overrides",
        "Docker",
        "Kubernetes",
        "Change package.json for custom modules",
        "Caution",
        "Permanent data storage",
        "User-defined environment variables for scripted monitors",
        "Mounting JSON file",
        "Passing as an environment variable",
        "Tip",
        "Accessing user-defined environment variables from scripts",
        "Environment variables",
        "Docker environment configuration",
        "Kubernetes environment configuration"
      ],
      "title": "Containerized private minion (CPM) configuration",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "5c65dd79f361d23da2154f6a4227515a40dae944",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration/",
      "published_at": "2021-12-25T18:28:55Z",
      "updated_at": "2021-11-15T07:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to configure your containerized private minion (CPM). You can do the following to customize your CPMs: Set up custom modules for scripted browsers in New Relic. Preserve launch data with permanent data storage. Use environment variables in your configuration. You may not modify any CPM files and New Relic is not liable for any modifications you make. Guidelines for mounting volumes All directories and files must be assigned group ownership as 3729 with read/write permissions. This ensures that the Runner, which uses uid: 1000 and gid: 3729, has access to all the mounted volumes. However, the Minion is able to run as root (uid: 0) or with any uid between the range of [2000, 4000], inclusive. For more information, see running as non-root in Kubernetes or Docker. Docker Directories are mounted onto a container as volumes by specifying a -v argument within docker run For example, docker run ... -v /path/to/src:/path/to/dest:rw Kubernetes It is possible to add a directory onto a persistent volume (PV) by using kubectl cp. However, alternative approaches are supported as long as the file permissions are set appropriately. For example, kubectl cp /path/to/src <POD_NAME>:/path/to/dest will add a directory onto each PV in the specified pod Each PV must have a separate copy of the directories. For example, a cluster with n Minion replicas must have n PVs, each with their own copy of directories The directories and files must be added prior to the Minion boot up, otherwise the Minion must be restarted to detect the updates Custom npm modules Custom npm modules are exclusive to the CPM. They allow you to provide an arbitrary set of npm modules, and make them available for scripted monitors in Synthetics. To set up the modules: Create a directory which contains a package.json, following the npm official guidelines, in the root of the directory. Anything contained in the dependencies field will be installed by the CPM at start, and made available when running monitors on that private minion. Optionally, you can override the root level package.json with a Node version-specific directory. This allows a script to be updated per monitor runtime if a Node version of a runtime is no longer compatible with your dependencies. See an example of this below. Custom module directory In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file Copy The package.json defines dependencies as both a local module (for example, counter) and an npm hosted modules (for example, async version ^2.6.1): { \"name\": \"custom-modules\", \"version\": \"1.0.0\", ⇦ optional \"description\": \"example custom modules directory\", ⇦ optional \"dependencies\": { \"async\": \"^2.6.1\", ⇦ npm hosted module \"counter\": \"file:./counter\" ⇦ Local module } } Copy Node version-specific overrides You can declare a package.json per Node version that will override the root level package.json. This allows a monitor script to be updated per monitor runtime in the event that the Node version of a runtime is no longer compatible with your dependencies. As shown in the first example, local modules can still be defined within a version specific directory. If a package.json is not defined for a specific Node version, then the root level package.json will be used to install dependencies. In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── 6.11.2 ⇦ optional Node specific directory │ └── package.json └── 10.15.0 ⇦ optional Node specific directory │ └── package.json ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file ​ Copy Once you create the custom modules directory and the package.json you can apply it to your CPM for Docker and Kubernetes. Docker For Docker, launch CPM mounting the directory at /var/lib/newrelic/synthetics/modules. For example: docker run ... -v /example-custom-modules-dir:/var/lib/newrelic/synthetics/modules:rw ... Copy Kubernetes Complete the following: Launch the CPM, setting a value for the persistence.customModules configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where your custom modules files exist. For example: helm install ... --set persistence.customModules=<custom-modules-subpath> ... Copy Make sure that your custom modules directory is available on the Minion Pod. You can use kubectl cp as one method to copy the directory from your host to the Minion. For example: kubectl cp /example-custom-modules-dir <namespace>/<pod_name>:/var/lib/newrelic/synthetics/modules Copy Look at the CPM logs for \"... Initialization of Custom Modules ...\" to see if the modules were installed properly, or if there were any errors. The npm installation logs will be shown. Now you can add \"require('async');\" into the script of monitors you send to this private location. Change package.json for custom modules Along with npm modules, you can also use Node.js modules. To change the custom modules used by your CPM, modify package.json and reboot the CPM. It will detect the change in configuration during the reboot, and then clean up and re-install. Caution Local modules: While your package.json can include any local module, these modules must reside inside the tree under your custom module directory. If stored outside the tree, the initialization process will fail and you will see an error message in the docker logs after launching CPM. Permanent data storage CPM is a stateless application and does not preserve information from prior requests or sessions by default. However, you can preserve data between launches by enabling permanent data storage. For example, you can permanently set how the minion identifies itself (for example, Minion_ID), and use it to associate the data visible in Synthetics and Insights events with the exact minion that produced it. To set permanent data storage on Docker: Create a directory. Launch the CPM, mounting the directory at /var/lib/newrelic/synthetics. Example: docker run ... -v /example-permanent-dir:/var/lib/newrelic/synthetics:rw ... Copy To set permanent data storage on Kubernetes: Launch the CPM, setting a value for the persistence.permanentData configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where you want the data to be saved. Example: helm install ... --set persistence.permanentData=<permanent-data-subpath> ... Copy User-defined environment variables for scripted monitors Containerized private minions let you configure environment variables for use in scripted monitors. These variables are hosted locally on the CPM and can be accessed via $env.USER_DEFINED_VARIABLES. There are two ways to set user-defined variables: by mounting a JSON file or by supplying an environment variable to the CPM on launch. If both are provided, the CPM will use values provided from the environment only. Mounting JSON file The JSON file must have read permissions and contain a JSON formatted map. Example user-defined variable file: { \"KEY\" : \"VALUE\", \"User_Name\": \"MINION\", \"My_Password\": \"PASSW0RD 1 2 3\", \"my_URL\": \"https://newrelic.com/\", \"ETC\" : \"ETC\" } Copy The file must be available or mounted to the path in your container: /var/lib/newrelic/synthetics/variables/user_defined_variables.json Docker example: docker run ... -v /example-user-defined-variables.json:/var/lib/newrelic/synthetics/variables/user_defined_variables.json:rw ... Copy Kubernetes example: When mounting a JSON file to your Minion Pod in Kubernetes, you can either copy the file directly to the Minion Pod or to a Pod that has access to the same Persistent Volume and Persistent Volume Claim that the Minion will use. After successfully loading the file, you may need to restart your Minion Pod for the change to take effect. kubectl cp path/to/user_defined_variables.json <namespace>/<pod_name>:/var/lib/newrelic/synthetics/variables/user_defined_variables.json Copy Passing as an environment variable Use the -e flag to set up an environment variable named MINION_USER_DEFINED_VARIABLES and give it a value of a JSON formatted map string. docker run ... -e MINION_USER_DEFINED_ENV_VARIABLES='{\"KEY\":\"VALUE\",\"NAME\":\"MINION\",\"ETC\":\"ETC\"}' ... Copy Tip The CPM on Kubernetes does not currently support loading user-defined environment variables via environment variable. You will have to configure your Kubernetes CPM by mounting a JSON file. Accessing user-defined environment variables from scripts To reference a configured user-defined environment variable, use the reserved $env.USER_DEFINED_VARIABLES followed by the name of a given variable with dot notation. For example, $env.USER_DEFINED_VARIABLES.MY_VARIABLE Caution User-defined environment variables are not sanitized from logs. For sensitive information, consider using the secure credentials feature. Environment variables Environmental variables allow you to fine-tune the CPM configuration to meet your specific environmental and functional needs. Docker environment configuration The variables are provided at startup using the -e, --env argument. The following table shows all the environment variables that CPM supports. MINION_PRIVATE_LOCATION_KEY is required, and all other variables are optional. Name Description MINION_PRIVATE_LOCATION_KEY REQUIRED. UUID of the Private Location, as found on the Private Location Web page. DOCKER_API_VERSION Format: \"vX.Y\" API version to be used with the given Docker service. Default: v1.35. DOCKER_HOST Points the minion to a given DOCKER_HOST. If absent, the default value is /var/run/docker.sock. MINION_API_ENDPOINT For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. MINION_DOCKER_RUNNER_REGISTRY_ENDPOINT The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic). MINION_API_PROXY Format: \"host:port\". MINION_API_PROXY_AUTH Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. MINION_API_PROXY_SELF_SIGNED_CERT Acceptable values: true, 1, or yes (any case). MINION_CHECK_TIMEOUT The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. MINION_DOCKER_API_VERSION Synonym of DOCKER_API_VERSION. MINION_DOCKER_HOST Synonym of DOCKER_HOST. MINION_RUNNER_APPARMOR (CPM version > 3.0.2) OR MINION_DOCKER_RUNNER_APPARMOR (CPM version <= 3.0.2) The AppArmor profile name, if it has been applied to Docker containers running monitor scripts (for example, Docker Runner). The AppArmor profile name must exist and be set up on the machine to work. MINION_JVM_MB Default: \"2560\" (2.5GB). MINION_JVM_OPTS Passes command line options to the internal JVM. See Oracle's Java documentation for more information. Default: -server. MINION_LOG_LEVEL When contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. MINION_NETWORK_HEALTHCHECK_DISABLED (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. MINION_USER_DEFINED_ENV_VARIABLES Format: Example. A locally hosted set of user defined key value pairs. MINION_HEAVY_WORKERS The number of workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. MINION_LIGHTWEIGHT_WORKERS The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 1250. For more information on monitor types, see Types of Synthetics monitors. MINION_VSE_PASSPHRASE If set, enables verified script execution and uses this value as a passphrase. Kubernetes environment configuration The variables are provided at startup using the --set argument. The following list shows all the environment variables that CPM supports. synthetics.privateLocationKey is required, and all other variables are optional. Name Description synthetics.privateLocationKey REQUIRED if synthetics.privateLocationKeySecretName is not set. UUID/Private location key of the private location, as found on the private location web page. synthetics.privateLocationKeySecretName REQUIRED if synthetics.privateLocationKey is not set. Name of the Kubernetes secret that contains the key privateLocationKey, which contains the authentication key associated with your Synthetics private location. replicaCount Number of replicas to maintain with your StatefulSet installation Default: 1. imagePullSecrets The name of the secret object used to pull an image from a specified container registry. fullnameOverride Name override used for your StatefulSet installation, replacing the default. appVersionOverride Release version of CPM to use instead of the version specified in chart.yml. synthetics.minionLogLevel If contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. synthetics.heavyWorkers The number of concurrent workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use the value 2. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. synthetics.lightweightWorkers The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * synthetics.heavyWorkers, where synthetics.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on monitor types, see Types of synthetic monitors. synthetics.minionApiEndpoint For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. synthetics.minionDockerRunnerRegistryEndpoint The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic) synthetics.minionVsePassphrase If set, it enables verified script execution, and uses this value as a passphrase. synthetics.minionVsePassphraseSecretName If set, enables verified script execution and uses this value to retrieve the passphrase from a Kubernetes secret with a key called minionVsePassphrase. synthetics.minionApiProxy Format: \"host:port\". synthetics.minionApiProxySelfSignedCert Acceptable values: true, 1, or yes (any case). synthetics.minionApiProxyAuth Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. synthetics.minionCheckTimeout The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. synthetics.minionUserDefinedEnvVariable Format: Example. A locally hosted set of user-defined key value pairs. synthetics.minionJVMOpts Passes command line options to the internal JVM. Default: -server -XX:-UsePerfData synthetics.minionNetworkHealthCheckDisabled (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. image.repository The container to pull. Default: quay.io/newrelic/synthetics-minion image.pullPolicy The pull policy. Default: IfNotPresent persistence.claimName The name of the PVC to use. If undefined or not set, Statefulset will dynamically create a PVC for each replica. persistence.storageClass Overrides StorageClass for VolumeClaimTemplates, relevant only if claimName is undefined or empty. For more details see persistent volumes. persistence.accessMode Access mode to be defined for the PVC, relevant only if claimName is undefined or empty. Default: ReadWriteOnce. persistence.annotations Annotations to add to the PVC, relevant only if claimName is undefined or empty. persistence.size Size to be defined for the PVC, relevant only if claimName is undefined or empty. Default: 10Gi. persistence.permanentData Path on the volume to the permanent data storage directory. For more details, see permanent data storage. persistence.customModules Path on the volume to the custom modules directory. For more details, see custom modules. persistence.userDefinedVariables Path on the volume to the user-defined-variable.json file. For more details, see user defined variables. serviceAccount.create If true, a service account is created and assigned to the deployment. Default: false. serviceAccount.name The service account to assign to the deployment. If serviceAccount.create is true, then this name is used when creating the service account. serviceAccount.annotations The annotations to add to the service account if serviceAccount.create is set to true. removeJobsLog Default Kubernetes doesn't include a jobs/log resource. Set this to true to remove it from the role if needed. Default: false. headlessService.serviceName The name of the headless service to associate to the StatefulSet. If not set a name is generated using the fullname template. appArmorProfileName The AppArmor profile name that will be applied to the Minion and Runner pods. If set, then the AppArmor profile must exist on the Kubernetes node(s) for this to work. podSecurityContextRunAsUser A UID that can be set to either 0 (root) or between [2000, 4000], inclusive. If set, runs the CPM as the given UID. Default: 2379.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.78046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Containerized <em>private</em> minion (CPM) configuration",
        "sections": "Containerized <em>private</em> minion (CPM) configuration",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " * <em>synthetics</em>.heavyWorkers, where <em>synthetics</em>.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on <em>monitor</em> types, see Types of <em>synthetic</em> monitors. <em>synthetics</em>.minionApiEndpoint For US-based accounts, the endpoint"
      },
      "id": "603ea540196a67e50da83d95"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/add-custom-attributes-synthetic-monitoring-data": [
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-12-25T18:03:33Z",
      "updated_at": "2021-11-15T07:23:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy Here's an example of setting up a proxied network via proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, 'anotherExample.com': {username: 'authUsername', password: 'authPassword'}, } $network.setProxyPAC(\"https://www.example.com/pacScript\", authCredentialsMap) Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples Here's an example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy Here's an example of setting up a proxied network with mixed network zone assets: var proxyRules = {singleProxy: {host:\"http://entproxy.mycompany.com\"}, bypassList:['s3.amazonaws.com','*.localcdn.com'] } $network.setProxyAdvanced(proxyRules) Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.52367,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    },
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-12-25T18:04:06Z",
      "updated_at": "2021-11-07T09:33:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. (Note that Request is deprecated, but these options still apply.) Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. We recommend using SSL to avoid exposing plain text credentials in your headers. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(duration)%20FROM%20Transaction', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.3644,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ". If any assert functions fail, the entire <em>monitor</em> will be considered a failed check. This may trigger alert notifications and affect your metrics. Important <em>Synthetic</em> <em>monitoring</em> does not allow thrown exceptions. Thrown exceptions result in <em>script</em> failure. Use the assert module to validate your results"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-12-25T18:03:33Z",
      "updated_at": "2021-10-31T07:57:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.51804,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/import-nodejs-modules": [
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-12-25T18:03:33Z",
      "updated_at": "2021-11-15T07:23:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy Here's an example of setting up a proxied network via proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, 'anotherExample.com': {username: 'authUsername', password: 'authPassword'}, } $network.setProxyPAC(\"https://www.example.com/pacScript\", authCredentialsMap) Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples Here's an example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy Here's an example of setting up a proxied network with mixed network zone assets: var proxyRules = {singleProxy: {host:\"http://entproxy.mycompany.com\"}, bypassList:['s3.amazonaws.com','*.localcdn.com'] } $network.setProxyAdvanced(proxyRules) Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.52367,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    },
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-12-25T18:04:06Z",
      "updated_at": "2021-11-07T09:33:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. (Note that Request is deprecated, but these options still apply.) Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. We recommend using SSL to avoid exposing plain text credentials in your headers. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(duration)%20FROM%20Transaction', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.36438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ". If any assert functions fail, the entire <em>monitor</em> will be considered a failed check. This may trigger alert notifications and affect your metrics. Important <em>Synthetic</em> <em>monitoring</em> does not allow thrown exceptions. Thrown exceptions result in <em>script</em> failure. Use the assert module to validate your results"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-12-25T18:03:33Z",
      "updated_at": "2021-10-31T07:57:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.51802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/introduction-scripted-browser-monitors": [
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-12-25T18:03:33Z",
      "updated_at": "2021-11-15T07:23:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy Here's an example of setting up a proxied network via proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, 'anotherExample.com': {username: 'authUsername', password: 'authPassword'}, } $network.setProxyPAC(\"https://www.example.com/pacScript\", authCredentialsMap) Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples Here's an example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy Here's an example of setting up a proxied network with mixed network zone assets: var proxyRules = {singleProxy: {host:\"http://entproxy.mycompany.com\"}, bypassList:['s3.amazonaws.com','*.localcdn.com'] } $network.setProxyAdvanced(proxyRules) Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.52367,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    },
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-12-25T18:04:06Z",
      "updated_at": "2021-11-07T09:33:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. (Note that Request is deprecated, but these options still apply.) Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. We recommend using SSL to avoid exposing plain text credentials in your headers. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(duration)%20FROM%20Transaction', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.36438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ". If any assert functions fail, the entire <em>monitor</em> will be considered a failed check. This may trigger alert notifications and affect your metrics. Important <em>Synthetic</em> <em>monitoring</em> does not allow thrown exceptions. Thrown exceptions result in <em>script</em> failure. Use the assert module to validate your results"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-12-25T18:03:33Z",
      "updated_at": "2021-10-31T07:57:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.51802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/scripted-browser-examples": [
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-12-25T18:03:33Z",
      "updated_at": "2021-11-15T07:23:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy Here's an example of setting up a proxied network via proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, 'anotherExample.com': {username: 'authUsername', password: 'authPassword'}, } $network.setProxyPAC(\"https://www.example.com/pacScript\", authCredentialsMap) Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples Here's an example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy Here's an example of setting up a proxied network with mixed network zone assets: var proxyRules = {singleProxy: {host:\"http://entproxy.mycompany.com\"}, bypassList:['s3.amazonaws.com','*.localcdn.com'] } $network.setProxyAdvanced(proxyRules) Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.52367,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    },
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-12-25T18:04:06Z",
      "updated_at": "2021-11-07T09:33:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. (Note that Request is deprecated, but these options still apply.) Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. We recommend using SSL to avoid exposing plain text credentials in your headers. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(duration)%20FROM%20Transaction', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.36438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ". If any assert functions fail, the entire <em>monitor</em> will be considered a failed check. This may trigger alert notifications and affect your metrics. Important <em>Synthetic</em> <em>monitoring</em> does not allow thrown exceptions. Thrown exceptions result in <em>script</em> failure. Use the assert module to validate your results"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-12-25T18:03:33Z",
      "updated_at": "2021-10-31T07:57:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.51802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors": [
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-12-25T18:04:06Z",
      "updated_at": "2021-11-07T09:33:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. (Note that Request is deprecated, but these options still apply.) Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. We recommend using SSL to avoid exposing plain text credentials in your headers. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(duration)%20FROM%20Transaction', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.36438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ". If any assert functions fail, the entire <em>monitor</em> will be considered a failed check. This may trigger alert notifications and affect your metrics. Important <em>Synthetic</em> <em>monitoring</em> does not allow thrown exceptions. Thrown exceptions result in <em>script</em> failure. Use the assert module to validate your results"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-12-25T18:03:33Z",
      "updated_at": "2021-10-31T07:57:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.51802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    },
    {
      "sections": [
        "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
        "Selenium Webdriver APIs",
        "Top-level functions: Build your script",
        "Deny list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "Tip"
      ],
      "title": "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "47ceb711bcb322760a428f1e7c03c4444b777998",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050/",
      "published_at": "2021-12-25T17:37:54Z",
      "updated_at": "2021-10-31T07:57:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes scripted browser functions available for synthetic monitors versions 0.5.x or higher. If you are using older monitor versions, see the monitor version 0.4.0 and lower documentation. For more on monitor versions and runtime differences, see Runtime environments. Selenium Webdriver APIs The synthetic scripted browsers provide access to the Selenium Webdriver APIs 3.6.0 for monitor version 0.6.x and Selenium Webdriver APIs 3.5.0 for monitor version 0.5.x via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic monitoring instance of selenium-webdriver.WebDriver(). It exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Description $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence. Return value: void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. Return value: void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. Return value: void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. Return value: void $browser.deleteHeaders(header: [string]) Deletes all headers in the argument from runtime. Return value: void $browser.addHostnameToBlacklist(hostname: string) Adds a hostname to your deny list. Allows using wildcards. Return value: void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Adds all hostnames in an array of arguments to your deny list. Allows using wildcards. Return value: void $browser.addHostnameToWhitelist(hostname: string) Adds a hostname blocked by default in synthetic monitoring to your allow list. Return value: void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Adds all hostnames in the argument to your allow list. Return value: void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname for this browser instance from your deny list. Return value: void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in the argument from your deny list. Return value: void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname for this browser instance from your allow list. Return value: void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in the argument from your allow list for this browser instance. Return value: void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. Return value: promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. Return value: promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, synthetic monitoring returns an error. Return value: WebElementPromise $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. Return value: promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, synthetic monitoring returns an error. The timeout value is optional. It is applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). Return value: WebElementPromise $browser.get(url: string) Loads a webpage in a synthetic browser. Return value: promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. Return value: promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. Return value: promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. Return value: promise $browser.getHeaders() Returns a map of currently configured headers. Return value: map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM. Do not expect it to be formatted or escaped in the same way as the response sent from the web server. Return value: promise $browser.getSession() A promise for this client's session. Return value: promise $browser.getTitle() Schedules a command to retrieve the current page's title. Return value: promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. Return value: promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. Return value: void $browser.navigate() The navigation interface (history of browser functions) for this instance. Return value: void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. Return value: promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. Return value: promise $browser.switchTo() The target locator interface for this instance. Return value: void $browser.takeScreenshot() Schedules a command to take a screenshot. Return value: promise $browser.wait(fn: $driver.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by your supplied function. Return value: WebElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. Return value: promise Deny list: Wildcard use If you want to add domains to the deny list for your browser instance, the wildcards must match the URL syntax of the URL to be blocked. An overall .com deny list must contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance, such as cookies, timeouts, and window size. Access these options through the $browser.manage() function. Function Description $browser.manage().addCookie(spec: object) Schedules a command to add a cookie. spec is a record object describing a browser cookie. For more information, see the Selenium documentation. Return value: promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. Return value: promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. Return value: promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. Return value: promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. Return value: promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. Return value: promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. Return value: promise $browser.manage().window().getSize() Retrieves the window's current size. Return value: promise $browser.manage().window().maximize() Maximizes the current window. Return value: promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. Return value: promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. Return value: promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement. Call them through $driver.By. Function Description $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. Return value: locator $driver.By.css(cssName: string) Locates an element using a CSS selector. Return value: locator $driver.By.id(id: string) Locates an element by its ID. Return value: locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. Return value: locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. Return value: locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. Return value: locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. Return value: locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. Return value: locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. Return value: locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. For example, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Description click() Clicks on this element. Return value: self reference sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. Return value: WebElement getTagName() Schedules a command to query for the tag/node name of this element. Return value: WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). Return value: promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. Return value: promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. Return value: promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. Return value: promise getLocation() Schedules a command to compute the location of this element, in page space. Return value: promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. Return value: promise isSelected() Schedules a command to query whether this element is selected. Return value: promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. Return value: promise clear() Schedules a command to clear the value of this element. Return value: promise isDisplayed() Schedules a command to test whether this element is currently displayed. Return value: promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation on GitHub. Function Description click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). Return value: actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. Return value: actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a drag and drop maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. Return value: actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. Return value: actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. Return value: actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. Return value: actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). Return value: actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). Return value: actionsequence perform() Executes this action sequence. Return value: promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation on GitHub. Return value: actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, finally() and catch(). For more information, see Sequence actions. Function Description isPending() Whether this promise's value is still being computed. Return value: boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. Return value: promise finally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. Return value: promise catch(callback: fn()) Registers a listener for when this promise is rejected. Return value: promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Description back() Move back by one step in the browser's history. Return value: void forward() Move forward by one step in the browser's history. Return value: void refresh() Refresh the current page. Return value: void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). Return value: void Conditions: Pause and wait for conditions Tip You can learn more about waits in Selenium here. Used with $browser.wait, until pauses your script execution until the condition is matched. For more information, see Selenium's WebDriver until documentation. The following are available functions for $driver.until.Condition: Function Description ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. Return value: condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. Return value: condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. Return value: condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. Return value: condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. Return value: condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. Return value: condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. Return value: condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. Return value: condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. Return value: condition n elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. Return value: condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. Return value: condition n elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. Return value: condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM or a new page has loaded. Return value: condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. Return value: condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. Return value: condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. Return value: condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.51802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "sections": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "This document describes scripted browser functions available for <em>synthetic</em> <em>monitors</em> versions 0.5.x or higher. If you are using older <em>monitor</em> versions, see the <em>monitor</em> version 0.4.0 and lower documentation. For more on <em>monitor</em> versions and runtime differences, see Runtime environments. Selenium"
      },
      "id": "603e7f27e7b9d2b2912a07ab"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower": [
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-12-25T18:03:33Z",
      "updated_at": "2021-11-15T07:23:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy Here's an example of setting up a proxied network via proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, 'anotherExample.com': {username: 'authUsername', password: 'authPassword'}, } $network.setProxyPAC(\"https://www.example.com/pacScript\", authCredentialsMap) Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples Here's an example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy Here's an example of setting up a proxied network with mixed network zone assets: var proxyRules = {singleProxy: {host:\"http://entproxy.mycompany.com\"}, bypassList:['s3.amazonaws.com','*.localcdn.com'] } $network.setProxyAdvanced(proxyRules) Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.52365,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    },
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-12-25T18:04:06Z",
      "updated_at": "2021-11-07T09:33:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. (Note that Request is deprecated, but these options still apply.) Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. We recommend using SSL to avoid exposing plain text credentials in your headers. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(duration)%20FROM%20Transaction', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.36438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ". If any assert functions fail, the entire <em>monitor</em> will be considered a failed check. This may trigger alert notifications and affect your metrics. Important <em>Synthetic</em> <em>monitoring</em> does not allow thrown exceptions. Thrown exceptions result in <em>script</em> failure. Use the assert module to validate your results"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
        "Selenium Webdriver APIs",
        "Top-level functions: Build your script",
        "Deny list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "Tip"
      ],
      "title": "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "47ceb711bcb322760a428f1e7c03c4444b777998",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050/",
      "published_at": "2021-12-25T17:37:54Z",
      "updated_at": "2021-10-31T07:57:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes scripted browser functions available for synthetic monitors versions 0.5.x or higher. If you are using older monitor versions, see the monitor version 0.4.0 and lower documentation. For more on monitor versions and runtime differences, see Runtime environments. Selenium Webdriver APIs The synthetic scripted browsers provide access to the Selenium Webdriver APIs 3.6.0 for monitor version 0.6.x and Selenium Webdriver APIs 3.5.0 for monitor version 0.5.x via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic monitoring instance of selenium-webdriver.WebDriver(). It exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Description $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence. Return value: void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. Return value: void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. Return value: void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. Return value: void $browser.deleteHeaders(header: [string]) Deletes all headers in the argument from runtime. Return value: void $browser.addHostnameToBlacklist(hostname: string) Adds a hostname to your deny list. Allows using wildcards. Return value: void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Adds all hostnames in an array of arguments to your deny list. Allows using wildcards. Return value: void $browser.addHostnameToWhitelist(hostname: string) Adds a hostname blocked by default in synthetic monitoring to your allow list. Return value: void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Adds all hostnames in the argument to your allow list. Return value: void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname for this browser instance from your deny list. Return value: void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in the argument from your deny list. Return value: void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname for this browser instance from your allow list. Return value: void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in the argument from your allow list for this browser instance. Return value: void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. Return value: promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. Return value: promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, synthetic monitoring returns an error. Return value: WebElementPromise $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. Return value: promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, synthetic monitoring returns an error. The timeout value is optional. It is applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). Return value: WebElementPromise $browser.get(url: string) Loads a webpage in a synthetic browser. Return value: promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. Return value: promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. Return value: promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. Return value: promise $browser.getHeaders() Returns a map of currently configured headers. Return value: map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM. Do not expect it to be formatted or escaped in the same way as the response sent from the web server. Return value: promise $browser.getSession() A promise for this client's session. Return value: promise $browser.getTitle() Schedules a command to retrieve the current page's title. Return value: promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. Return value: promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. Return value: void $browser.navigate() The navigation interface (history of browser functions) for this instance. Return value: void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. Return value: promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. Return value: promise $browser.switchTo() The target locator interface for this instance. Return value: void $browser.takeScreenshot() Schedules a command to take a screenshot. Return value: promise $browser.wait(fn: $driver.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by your supplied function. Return value: WebElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. Return value: promise Deny list: Wildcard use If you want to add domains to the deny list for your browser instance, the wildcards must match the URL syntax of the URL to be blocked. An overall .com deny list must contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance, such as cookies, timeouts, and window size. Access these options through the $browser.manage() function. Function Description $browser.manage().addCookie(spec: object) Schedules a command to add a cookie. spec is a record object describing a browser cookie. For more information, see the Selenium documentation. Return value: promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. Return value: promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. Return value: promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. Return value: promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. Return value: promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. Return value: promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. Return value: promise $browser.manage().window().getSize() Retrieves the window's current size. Return value: promise $browser.manage().window().maximize() Maximizes the current window. Return value: promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. Return value: promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. Return value: promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement. Call them through $driver.By. Function Description $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. Return value: locator $driver.By.css(cssName: string) Locates an element using a CSS selector. Return value: locator $driver.By.id(id: string) Locates an element by its ID. Return value: locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. Return value: locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. Return value: locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. Return value: locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. Return value: locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. Return value: locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. Return value: locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. For example, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Description click() Clicks on this element. Return value: self reference sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. Return value: WebElement getTagName() Schedules a command to query for the tag/node name of this element. Return value: WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). Return value: promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. Return value: promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. Return value: promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. Return value: promise getLocation() Schedules a command to compute the location of this element, in page space. Return value: promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. Return value: promise isSelected() Schedules a command to query whether this element is selected. Return value: promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. Return value: promise clear() Schedules a command to clear the value of this element. Return value: promise isDisplayed() Schedules a command to test whether this element is currently displayed. Return value: promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation on GitHub. Function Description click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). Return value: actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. Return value: actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a drag and drop maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. Return value: actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. Return value: actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. Return value: actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. Return value: actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). Return value: actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). Return value: actionsequence perform() Executes this action sequence. Return value: promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation on GitHub. Return value: actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, finally() and catch(). For more information, see Sequence actions. Function Description isPending() Whether this promise's value is still being computed. Return value: boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. Return value: promise finally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. Return value: promise catch(callback: fn()) Registers a listener for when this promise is rejected. Return value: promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Description back() Move back by one step in the browser's history. Return value: void forward() Move forward by one step in the browser's history. Return value: void refresh() Refresh the current page. Return value: void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). Return value: void Conditions: Pause and wait for conditions Tip You can learn more about waits in Selenium here. Used with $browser.wait, until pauses your script execution until the condition is matched. For more information, see Selenium's WebDriver until documentation. The following are available functions for $driver.until.Condition: Function Description ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. Return value: condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. Return value: condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. Return value: condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. Return value: condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. Return value: condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. Return value: condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. Return value: condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. Return value: condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. Return value: condition n elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. Return value: condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. Return value: condition n elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. Return value: condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM or a new page has loaded. Return value: condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. Return value: condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. Return value: condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. Return value: condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.51802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "sections": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "This document describes scripted browser functions available for <em>synthetic</em> <em>monitors</em> versions 0.5.x or higher. If you are using older <em>monitor</em> versions, see the <em>monitor</em> version 0.4.0 and lower documentation. For more on <em>monitor</em> versions and runtime differences, see Runtime environments. Selenium"
      },
      "id": "603e7f27e7b9d2b2912a07ab"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050": [
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-12-25T18:03:33Z",
      "updated_at": "2021-11-15T07:23:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy Here's an example of setting up a proxied network via proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, 'anotherExample.com': {username: 'authUsername', password: 'authPassword'}, } $network.setProxyPAC(\"https://www.example.com/pacScript\", authCredentialsMap) Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples Here's an example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy Here's an example of setting up a proxied network with mixed network zone assets: var proxyRules = {singleProxy: {host:\"http://entproxy.mycompany.com\"}, bypassList:['s3.amazonaws.com','*.localcdn.com'] } $network.setProxyAdvanced(proxyRules) Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.52365,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    },
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-12-25T18:04:06Z",
      "updated_at": "2021-11-07T09:33:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. (Note that Request is deprecated, but these options still apply.) Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. We recommend using SSL to avoid exposing plain text credentials in your headers. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(duration)%20FROM%20Transaction', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.36438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ". If any assert functions fail, the entire <em>monitor</em> will be considered a failed check. This may trigger alert notifications and affect your metrics. Important <em>Synthetic</em> <em>monitoring</em> does not allow thrown exceptions. Thrown exceptions result in <em>script</em> failure. Use the assert module to validate your results"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-12-25T18:03:33Z",
      "updated_at": "2021-10-31T07:57:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.51802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests": [
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-12-25T18:03:33Z",
      "updated_at": "2021-11-15T07:23:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy Here's an example of setting up a proxied network via proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, 'anotherExample.com': {username: 'authUsername', password: 'authPassword'}, } $network.setProxyPAC(\"https://www.example.com/pacScript\", authCredentialsMap) Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples Here's an example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy Here's an example of setting up a proxied network with mixed network zone assets: var proxyRules = {singleProxy: {host:\"http://entproxy.mycompany.com\"}, bypassList:['s3.amazonaws.com','*.localcdn.com'] } $network.setProxyAdvanced(proxyRules) Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.52365,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-12-25T18:03:33Z",
      "updated_at": "2021-10-31T07:57:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.51802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    },
    {
      "sections": [
        "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
        "Selenium Webdriver APIs",
        "Top-level functions: Build your script",
        "Deny list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "Tip"
      ],
      "title": "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "47ceb711bcb322760a428f1e7c03c4444b777998",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050/",
      "published_at": "2021-12-25T17:37:54Z",
      "updated_at": "2021-10-31T07:57:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes scripted browser functions available for synthetic monitors versions 0.5.x or higher. If you are using older monitor versions, see the monitor version 0.4.0 and lower documentation. For more on monitor versions and runtime differences, see Runtime environments. Selenium Webdriver APIs The synthetic scripted browsers provide access to the Selenium Webdriver APIs 3.6.0 for monitor version 0.6.x and Selenium Webdriver APIs 3.5.0 for monitor version 0.5.x via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic monitoring instance of selenium-webdriver.WebDriver(). It exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Description $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence. Return value: void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. Return value: void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. Return value: void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. Return value: void $browser.deleteHeaders(header: [string]) Deletes all headers in the argument from runtime. Return value: void $browser.addHostnameToBlacklist(hostname: string) Adds a hostname to your deny list. Allows using wildcards. Return value: void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Adds all hostnames in an array of arguments to your deny list. Allows using wildcards. Return value: void $browser.addHostnameToWhitelist(hostname: string) Adds a hostname blocked by default in synthetic monitoring to your allow list. Return value: void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Adds all hostnames in the argument to your allow list. Return value: void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname for this browser instance from your deny list. Return value: void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in the argument from your deny list. Return value: void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname for this browser instance from your allow list. Return value: void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in the argument from your allow list for this browser instance. Return value: void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. Return value: promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. Return value: promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, synthetic monitoring returns an error. Return value: WebElementPromise $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. Return value: promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, synthetic monitoring returns an error. The timeout value is optional. It is applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). Return value: WebElementPromise $browser.get(url: string) Loads a webpage in a synthetic browser. Return value: promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. Return value: promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. Return value: promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. Return value: promise $browser.getHeaders() Returns a map of currently configured headers. Return value: map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM. Do not expect it to be formatted or escaped in the same way as the response sent from the web server. Return value: promise $browser.getSession() A promise for this client's session. Return value: promise $browser.getTitle() Schedules a command to retrieve the current page's title. Return value: promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. Return value: promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. Return value: void $browser.navigate() The navigation interface (history of browser functions) for this instance. Return value: void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. Return value: promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. Return value: promise $browser.switchTo() The target locator interface for this instance. Return value: void $browser.takeScreenshot() Schedules a command to take a screenshot. Return value: promise $browser.wait(fn: $driver.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by your supplied function. Return value: WebElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. Return value: promise Deny list: Wildcard use If you want to add domains to the deny list for your browser instance, the wildcards must match the URL syntax of the URL to be blocked. An overall .com deny list must contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance, such as cookies, timeouts, and window size. Access these options through the $browser.manage() function. Function Description $browser.manage().addCookie(spec: object) Schedules a command to add a cookie. spec is a record object describing a browser cookie. For more information, see the Selenium documentation. Return value: promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. Return value: promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. Return value: promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. Return value: promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. Return value: promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. Return value: promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. Return value: promise $browser.manage().window().getSize() Retrieves the window's current size. Return value: promise $browser.manage().window().maximize() Maximizes the current window. Return value: promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. Return value: promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. Return value: promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement. Call them through $driver.By. Function Description $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. Return value: locator $driver.By.css(cssName: string) Locates an element using a CSS selector. Return value: locator $driver.By.id(id: string) Locates an element by its ID. Return value: locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. Return value: locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. Return value: locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. Return value: locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. Return value: locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. Return value: locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. Return value: locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. For example, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Description click() Clicks on this element. Return value: self reference sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. Return value: WebElement getTagName() Schedules a command to query for the tag/node name of this element. Return value: WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). Return value: promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. Return value: promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. Return value: promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. Return value: promise getLocation() Schedules a command to compute the location of this element, in page space. Return value: promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. Return value: promise isSelected() Schedules a command to query whether this element is selected. Return value: promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. Return value: promise clear() Schedules a command to clear the value of this element. Return value: promise isDisplayed() Schedules a command to test whether this element is currently displayed. Return value: promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation on GitHub. Function Description click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). Return value: actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. Return value: actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a drag and drop maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. Return value: actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. Return value: actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. Return value: actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. Return value: actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). Return value: actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). Return value: actionsequence perform() Executes this action sequence. Return value: promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation on GitHub. Return value: actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, finally() and catch(). For more information, see Sequence actions. Function Description isPending() Whether this promise's value is still being computed. Return value: boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. Return value: promise finally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. Return value: promise catch(callback: fn()) Registers a listener for when this promise is rejected. Return value: promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Description back() Move back by one step in the browser's history. Return value: void forward() Move forward by one step in the browser's history. Return value: void refresh() Refresh the current page. Return value: void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). Return value: void Conditions: Pause and wait for conditions Tip You can learn more about waits in Selenium here. Used with $browser.wait, until pauses your script execution until the condition is matched. For more information, see Selenium's WebDriver until documentation. The following are available functions for $driver.until.Condition: Function Description ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. Return value: condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. Return value: condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. Return value: condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. Return value: condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. Return value: condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. Return value: condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. Return value: condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. Return value: condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. Return value: condition n elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. Return value: condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. Return value: condition n elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. Return value: condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM or a new page has loaded. Return value: condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. Return value: condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. Return value: condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. Return value: condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 156.518,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "sections": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "This document describes scripted browser functions available for <em>synthetic</em> <em>monitors</em> versions 0.5.x or higher. If you are using older <em>monitor</em> versions, see the <em>monitor</em> version 0.4.0 and lower documentation. For more on <em>monitor</em> versions and runtime differences, see Runtime environments. Selenium"
      },
      "id": "603e7f27e7b9d2b2912a07ab"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/troubleshooting/monitor-produces-no-traffic": [
    {
      "sections": [
        "Monitor private locations",
        "Prerequisites",
        "Private Minion dashboard JSON",
        "Tip",
        "Are my private minions online?",
        "Does my private location need more minions?",
        "Can I check the status of a specific minion directly?"
      ],
      "title": "Monitor private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "d38b5c957ec41b25199f4d093eb2f6083a5ff351",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/monitor-private-locations/",
      "published_at": "2021-12-25T18:33:22Z",
      "updated_at": "2021-12-15T12:32:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using synthetic monitoring's private locations with New Relic's alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic dashboards and NRQL alerts: Are my private minions online? Does my private location need more minions? Can I check the status of a specific minion directly? Prerequisites Before following the instructions in this guide, ensure you have: A synthetic private location At least one private minion installed at that location Checks scheduled to run at that location An alert policy for the private location, with a configured notification channel to notify your team when a violation occurs The following Private Minion dashboard example JSON can be imported to your account using: the Import a dashboard button the Dashboard API Private Minion dashboard JSON { \"name\": \"Synthetics Private Minions\", \"description\": \"Details on events from SyntheticPrivateLocationStatus, SyntheticsPrivateMinion, SyntheticCheck, SyntheticRequest, NrAuditEvent, plus a page for Performance Analysis.\", \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"SyntheticPrivateLocationStatus\", \"description\": \"Details on the private location queue.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 8, \"width\": 3 }, \"title\": \"pending checks by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(checksPending) FROM SyntheticsPrivateLocationStatus FACET name\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 4, \"width\": 9 }, \"title\": \"private location queue\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES max SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 5, \"height\": 4, \"width\": 9 }, \"title\": \"rate of queue growth\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(checksPending,1 minute),0) as 'queue growth rate' FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 9, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'PRIVATE_LOCATION' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticsPrivateMinion\", \"description\": \"Details on the minion instances.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 3 }, \"title\": \"private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(timestamp),uniqueCount(minionId) - 1 as 'restarts' from SyntheticsPrivateMinion since 2 days ago FACET minionLocation\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 3, \"width\": 7 }, \"title\": \"minion details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionId),latest(timestamp) as 'last seen',latest(minionStartTimestamp) as 'started',uniqueCount(minionId) - 1 as 'restarts',latest(minionIpv4),latest(minionJobsQueued),latest(minionJobsFinished),100*latest(minionJobsFailed)/latest(minionJobsQueued) as 'job failure rate',latest(minionJobsRunning),latest(minionJobsTimedout),latest(minionJobsSkipped),latest(minionJobsInternalEngineError),latest(minionWorkers),latest(minionProcessors),latest(minionPhysicalMemoryUsedBytes/(1024*1024*1024)) as 'used memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024)) as 'total memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024))/latest(minionWorkers) as 'memory (GiB) per heavy worker' FROM SyntheticsPrivateMinion FACET minionBuildNumber,minionLocation,minionOsVersion,minionContainerSystemVersion,minionHostname LIMIT 100 SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"minion instances over time\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' from SyntheticsPrivateMinion since 2 days ago TIMESERIES MAX \" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"CPU utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionProcessorsUsagePercentage) AS 'CPU load %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"memory utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryUsedPercentage) AS 'used memory %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"free memory (GiB)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryFreeBytes / (1024*1024*1024)) AS 'free (GiB)' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(minionJobsFinished,1 minute),0) FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"skipped jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsSkipped) as 'skipped jobs' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 2 weeks ago TIMESERIES MAX\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"count of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsInternalEngineError) as 'IEE',average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.stacked-bar\" }, \"layout\": { \"column\": 9, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"rate of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*average(minionJobsInternalEngineError)/average(minionJobsFailed) as 'IEE',100*(average(minionJobsFailed)-average(minionJobsInternalEngineError))/average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES AUTO SINCE 2 weeks ago\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticCheck\", \"description\": \"Details on job results.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 non-ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type != 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type = 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type = 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 6, \"width\": 6 }, \"title\": \"monitor details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(id) as 'results',uniqueCount(location)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET monitorName,monitorId,type LIMIT MAX\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 7, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 errors by monitor type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE error IS NOT NULL AND location NOT LIKE 'AWS%' FACET error,type TIMESERIES AUTO SINCE 2 weeks ago LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 10, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping duration with monitor count\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)',uniqueCount(monitorId) as 'monitor count' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job results\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET type TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type = 'SIMPLE' as 'ping',WHERE type != 'SIMPLE' as 'non-ping') TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 11, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type, result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type != 'SIMPLE' as 'non-ping',WHERE type = 'SIMPLE' as 'ping'),result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticRequest\", \"description\": \"Details on responses.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 6, \"width\": 5 }, \"title\": \"jobs per minion\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(jobId) as 'jobs' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' FACET location,minion,minionId\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 6, \"row\": 1, \"height\": 6, \"width\": 4 }, \"title\": \"top 5 error response codes\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(responseCode) as 'responses' FROM SyntheticRequest WHERE responseCode NOT IN (200,201,202,203,204,300,301,302,303,304) AND responseCode IS NOT NULL AND location NOT LIKE 'AWS%' FACET responseCode,responseStatus TIMESERIES AUTO LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 10, \"row\": 1, \"height\": 6, \"width\": 3 }, \"title\": \"job rate\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(jobId), 1 minute) as 'job rate' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'MONITOR' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"Performance Analysis\", \"description\": \"Determine if there are enough heavy worker threads.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"minions (hosts) by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"count of heavy worker threads and cpu cores\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionWorkers),latest(minionProcessors) FROM SyntheticsPrivateMinion FACET minionHostname,minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.markdown\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"\", \"rawConfiguration\": { \"text\": \"See [this Google sheet](https://docs.google.com/spreadsheets/d/1k2Aw11r6-S8pIpXQUINQZ0T5qlxS8iSwSo9t9GKDvzc/edit?usp=sharing) to assist in calculating how many workers will be needed based on the values on this page. This will help you to assess the required size of each host (scaling up) and how many hosts you need (scaling out).\\n\\nFor more info: \\nhttps://discuss.newrelic.com/t/relic-solution-scaling-and-rightsizing-for-the-cpm/123999\" }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'non-ping monitors' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping avg job duration and timeout\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average((nr.internalQueueDuration+nr.executionDuration)/1e3) FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location,cases(WHERE error NOT LIKE '%timeout%' as 'job duration (s)', WHERE error LIKE '%timeout%' as 'job timeout (s)') SINCE 2 days ago TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"job timeout rate by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*latest(minionJobsTimedout)/latest(minionJobsReceived) as 'job timeout rate' FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES AUTO SINCE 2 days ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Steps to import: Copy the Dashboard JSON and paste into a text editor. Replace \"accountId\": 1, with your New Relic account ID for each occurrence in the JSON code. Copy the Dashboard JSON from your text editor and import using one of the methods described above. Edit any charts that you'd like to use facet filtering with. Tip If your private locations exist in a parent account and Synthetics monitors in a sub account, insert the parent account ID for NRQL queries that use SyntheticPrivateLocationStatus and SyntheticsPrivateMinion, and the sub account ID for queries that use SyntheticCheck and SyntheticRequest. Are my private minions online? To answer this question, you can rely on attributes from the SyntheticsPrivateMinionevent. Private minions send this event to New Relic every 30 seconds. A simple way to check if your minions are online is to compare the unique count of minion IDs with the number of minions you expect to be online. To understand how many minions are reporting, run this example NRQL query: SELECT uniqueCount(minionId) FROM SyntheticsPrivateMinion WHERE minionLocation = '1-acme_okc_dc-309' Copy Using this query, you can create an alert condition to notify your team when fewer minions are reporting than expected. This condition is configured with a static threshold of 2 units, which means you will receive an alert if any of your minions are offline. You can verify that the alert policy works as expected by manually stopping one of your minions. Then, when the alert violation occurs, you will be notified by any notification channels that have been set up. Once the minion is restarted and it comes back online, the alert will recover. There are more robust ways to check whether minions are functioning correctly, but this query and condition simply and successfully handle the case where a machine fails, is accidentally decommissioned, or the minion process crashes. It also ensures that the minion can communicate with New Relic. Does my private location need more minions? To answer this question, you can use the checksPending attribute of the SyntheticsPrivateLocationStatus event. The checksPending attribute reflects the number of monitor checks that are scheduled (or \"queued\") but have yet to be accepted by a minion in the designated location. For a location with scheduled checks and no minions, this graph would grow linearly up and to the right. This metric is more complicated to monitor than uniqueCount(minionId) because a high value does not necessarily mean the location is in a bad state. As long as the metric is not growing linearly up and to the right (and checks are being run on schedule), the location is in a good state. This use case is perfect for baseline NRQL alert conditions, which allow you to monitor the deviation of a metric rather than its static value. For example: SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus WHERE name = '1-acme_tokyo_dc-512' Copy To test this alert condition, schedule one-minute, browser-based monitors to run from your location. Browser-based jobs consume more resources than ping jobs, which is why they are a better fit for load simulation. New Relic will quickly notify you of a growing number of pending checks. After doubling the number of minions to handle the load, the alert recovers. For example, using the Synthetics private location dashboard example, notice the growth and decline of pending checks over the course of the incident and recovery. By using the NRQL condition, New Relic will notify you if and when the location needs more minion capacity. Can I check the status of a specific minion directly? You can also check how a minion is operating by contacting it directly. You can use a set of HTTP endpoints exposed by the minion to determine what the application is doing. In order to access these endpoints, bind ports 8080 and 8180 to ports on the host. For example, for Docker, use docker run -p 80:8080 -p 81:8180 ...): :8080/status/check: Details about internal health-checks the minion performs; HTTP 200 means \"healthy.\" :8080/status: Details about a minion's status; the same data is then published to Insights as a SyntheticsPrivateMinion event. :8180/: JVM application admin endpoints; an advanced view of a minion's internal state. This approach is not as automated or flexible as the checksPending example. However, if you have total network connectivity failure, this manual approach can help troubleshoot the situation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.08148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> private locations",
        "sections": "<em>Monitor</em> private locations",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "When using <em>synthetic</em> <em>monitoring</em>&#x27;s private locations with New Relic&#x27;s alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic"
      },
      "id": "604525f164441f7fd7378ef9"
    },
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-25T17:06:36Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.12822,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results page To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results page to locate interesting runs of your <em>monitor</em> for <em>troubleshooting</em>"
      },
      "id": "603eb5da64441f07ae4e8850"
    },
    {
      "sections": [
        "Simple, scripted, or scripted API (non-ping) errors",
        "Problem",
        "Solutions",
        "Simple or scripted browser errors",
        "Element A is not clickable at point (X, Y). Other element would receive the click: Element B",
        "Solution",
        "Tip",
        "Cause",
        "Error: element not visible",
        "Error: no such element: Unable to locate element: <LOCATOR>",
        "JobTimeoutError: Job timed-out after 180s",
        "NetworkError: Monitor produced no traffic",
        "ReferenceError: $network is not defined",
        "ScriptTimeoutError",
        "StaleElementReferenceError: element is not attached to the page document",
        "TaskTimedOut: task timed-out waiting for element to be located using: <LOCATOR>",
        "TimeoutError: Page load timed-out (unable to finish all network requests on time)",
        "TypeError: $browser.isElementPresent is not a function",
        "Scripted API monitor errors",
        "SyntaxError: Unexpected token <",
        "SyntaxError: Unexpected token u in JSON at position 0",
        "TypeError: Cannot read property 'statusCode' of undefined"
      ],
      "title": "Simple, scripted, or scripted API (non-ping) errors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Troubleshooting"
      ],
      "external_id": "cc45967d186d8847e1755948d22477ac3dd84e60",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/troubleshooting/simple-scripted-or-scripted-api-non-ping-errors/",
      "published_at": "2021-12-25T17:35:08Z",
      "updated_at": "2021-07-10T02:12:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem Your New Relic's synthetic Simple, Scripted, or Scripted API (non-ping) monitor reported an error, but the application appears to have loaded correctly. For ping and simple monitor errors, see non-scripted monitor errors. Solutions Below are some of the most common non-ping monitor error messages. Simple or scripted browser errors Element A is not clickable at point (X, Y). Other element would receive the click: Element B Problem The synthetic script is attempting to .click() an element (Element A) at point (X,Y), but another element (Element B) is obscuring the target element. Solution Set a custom wait time, allowing time for a specific condition to be met. In this case, until the loading animation is no longer visible: .then(function() { return $browser.wait($driver.until.elementIsNotVisible($browser.findElement($driver.By.id('LOADING'))), 10000); }) Copy Alternatively, you can set a custom sleep delay using $browser.sleep(sleeptime_ms), stalling script execution for a specified amount of time. As this is a fixed amount of wait-time, which does not account for increased network latency or degraded site performance, we recommend using the .wait() function instead. Tip This will not correct .click() issues caused by sticky headers or footers. In these instances, you may need to scroll manually to bring the target into view. Cause This happens if the target element, at the time of the .click() function, is obscured by: A loading overlay, modal, or pop-up An animation that reveals the target element A sticky header or footer Error: element not visible Problem The targeted element is not visible to the Selenium WebDriver. Solution Verify that the targeted element does not have the CSS properties of display: none or visibility: hidden applied. Cause Any element that has a CSS property of display: none or visibility: hidden will not be found by the Selenium WebDriver, as the script will only look for elements that are actually visible to a user. Error: no such element: Unable to locate element: <LOCATOR> Problem The Selenium WebDriver was unable to find this element in the visible DOM. Solution To resolve this problem: Confirm that the element locator being used for the target element is accurate. Avoid using By.XPath where possible as it is rigidly tied to the page’s DOM structure, and can easily become out-of-date when there are updates on the page. If element is in an iframe, use $browser.switchTo().frame(<index or element reference>. Tip See the Selenium documentation for more information on switchTo() and TargetLocator() functions. Cause Common reasons for this error include: The targeted element is unable to be located by functions such as: $browser.findElement(locator: $driver.Locator) or $browser.waitForAndFindElement(locator: $driver.Locator [ , timeout: number This may be due to a timing issue. For example, the WebDriver is attempting to locate the element before the page has been loaded. Element is in an iframe, which is a separate document context. JobTimeoutError: Job timed-out after 180s Problem The scripted monitor run reached the 180 second non-configurable timeout threshold, and the run was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assign the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. NetworkError: Monitor produced no traffic Problem The API test or scripted browser monitor appears to be running but is returning this error. Solution Ensure that $http.get() or $browser.get() are being called appropriately and are generating traffic. For Scripted API monitors, if you are using a request option to spin up an un-instrumented HTTP agent under the hood, specify one of our instrumented HTTP agents using either of the agent request options below: $globalAgents.http $globalAgents.https Example: var options = { uri: 'https://www.newrelic.com', agent: $globalAgents.https, agentOptions: { 'rejectUnauthorized': false }, strictSSL: false }; function callback(err, res, body) { ... }; $http.get(options, callback); Copy Cause This occurs in scripted monitor runs when the HTTP client ($http in scripted api monitors) or Chrome browser ($browser in scripted browser monitors) is not used to generate HTTP traffic. In some cases, certain request options in API monitors may force a new HTTP agent, one that is not instrumented by synthetic monitoring, to be used to collect HTTP traffic. ReferenceError: $network is not defined Problem The $network object used for setting monitor proxies is not available for that monitor’s runtime. Solution If your monitor was created before the 0.4.0 runtime release, create a new monitor to take advantage of the latest runtime. Your monitor’s current runtime version is shown at the top of the monitor's settings. For more information, see Scripted monitor version runtime environments. Cause This error occurs when attempting to use $network on a monitor with a runtime at or below 0.2.2. Proxying monitor traffic was introduced in monitor runtime version 0.4.0, causing this method to be evaluated as undefined on earlier monitor runtimes. ScriptTimeoutError Problem This error indicates that the job has reached the Docker container timeout threshold, and the script was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assigned the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. StaleElementReferenceError: element is not attached to the page document Problem The target page has loaded, but there was a change to an element between the execution of an element locator and an action being executed on the element. Solution Set your scripted browser to wait until the page is settled before performing a findElement() action. This can be accomplished by setting a custom wait time, using the $browser.wait(fn, timeout) function prior to the findElement call, to wait for a condition that indicates a settled page state. This will make it less likely for DOM manipulation to cause a reference to go stale. Alternatively, you can set a custom sleep delay using $browser.sleep(sleeptime_ms), stalling script execution for a specified amount of time. As this is a fixed amount of wait-time, which does not account for increased network latency or degraded site performance, we recommend using the .wait() function instead. Cause This error typically happens when the script attempts to .click() an element after using either the findElement() or waitForAndFindElement() function. If the DOM has changed between when the element locator was generated and the action was executed against the element, this error will occur because the actual element has changed. For example: the findElement() function is used to generate an element reference while the page’s script is actively manipulating the DOM. The DOM is then changed, causing the previously generated reference to become stale. The now out-of-date reference is used in an attempt to perform a .click() action, resulting in this monitor failure. Tip For more information, see the Selenium documentation on Stale Element Reference Exceptions. TaskTimedOut: task timed-out waiting for element to be located using: <LOCATOR> Problem The waitForAndFindElement(<locator>, <timeout>) function failed to locate an element within the provided timeout. Solution Confirm that the element locator being used for the target element is accurate. Avoid using By.XPath() where possible, as it is rigidly tied to the page’s DOM structure and can easily become out-of-date when there are updates on the page. Cause The target element did not exist on the page when the waitForAndFindElement(<locator>, <timeout>) function was called. This may be caused by the target page not being in the expected state. Common reasons for this error include: There is a legitimate issue with the target site. The element locator being used is incorrect. The target site has changed, requiring the revision of the Synthetics script. The previous action in the script did not successfully complete, causing the page to be in an unexpected state when the subsequent waitForAndFindElement() call was initiated. TimeoutError: Page load timed-out (unable to finish all network requests on time) Problem The target page loaded successfully, but returned the error: TimeoutError: Page load timed-out (unable to finish all network requests on time) Solution If the failures began suddenly, investigate any requests that could be blocking or delaying the page load event. If you are unsure which request is causing the error, use the timeline view to identify any long running HTTP requests. If the page is frequently unable to fully load within the current timeout, set a custom page load timeout using the $browser.manage().timeouts().pageLoadTimeout(ms: number) function. Cause The target page loaded successfully, but the page load event was not fired within the page load timeout set in the .pageLoadTimeout() function. There are a number of reasons you could see this error message, including: A blocked resource request on the page held up the page load. A resource request processed slower than normal due to an underlying network issue. A dependent resource on the page blocked the iframe load event. TypeError: $browser.isElementPresent is not a function Problem The function isElementPresent(), used by Synthetics monitors with a runtime >= 0.5.0, has been deprecated in Selenium 3. Solution To continue to use this function after depreciation you will need to create a custom version of this function, such as: return $browser.findElements(ele).then(function(found) { return found.length > 0; }); } Copy Example usage, which would return true: $browser .get(\"https://www.newrelic.com\") .then(function() { return isElementPresent($driver.By.id(\"nav_signup\")); }) .then(function(found) { return console.log(found); }); Copy Cause This can occur when attempting to use a scripted browser monitor script from an older monitor ( < = 0.4.1 runtime) with a newer monitor ( >= 0.5.0) runtime. Scripted API monitor errors JobTimeoutError: Job timed-out after 180s Problem The scripted monitor run reached the 180 second non-configurable timeout threshold, and the run was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assign the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. NetworkError: Monitor produced no traffic Problem The API test or scripted browser monitor appears to be running but is returning this error. Solution Ensure that $http.get() or $browser.get() are being called appropriately and are generating traffic. For Scripted API monitors, if you are using a request option to spin up an un-instrumented HTTP agent under the hood, specify one of our instrumented HTTP agents using either of the agent request options below: $globalAgents.http $globalAgents.https Example: var options = { uri: 'https://www.newrelic.com', agent: $globalAgents.https, agentOptions: { 'rejectUnauthorized': false }, strictSSL: false }; function callback(err, res, body) { ... }; $http.get(options, callback); Copy Cause This occurs in scripted monitor runs when the HTTP client ($http in scripted api monitors) or Chrome browser ($browser in scripted browser monitors) is not used to generate HTTP traffic. In some cases, certain request options in API monitors may force a new HTTP agent, one that is not instrumented by Synthetics, to be used to collect HTTP traffic. ReferenceError: $network is not defined Problem The $network object used for setting monitor proxies is not available for that monitor’s runtime. Solution If your monitor was created before the 0.4.0 runtime release, create a new monitor to take advantage of the latest runtime. Your monitor’s current runtime version is shown at the top of the Monitor Settings page. For more information, see Scripted monitor version runtime environments. Cause This error occurs when attempting to use $network on a monitor with a runtime at or below 0.2.2. Proxying monitor traffic was introduced in monitor runtime version 0.4.0, causing this method to be evaluated as undefined on earlier monitor runtimes. ScriptTimeoutError Problem This error indicates that the job has reached the Docker container timeout threshold, and the script was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assigned the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. SyntaxError: Unexpected token < Problem JSON.parse() was passed a string that begins with the < character and is likely HTML, instead of JSON. Solution Ensure the target endpoint is returning the expected response body. You can do this by logging the response body in the callback, before attempting to parse. Example: $http.get('http://www.newrelic.com', function(error, response, body) { if (error) { throw new Error(error); } console.log(body); // Log HTML response body, don't parse as JSON }); Copy Depending on the target API endpoint, you may need to include specific request headers to ensure that JSON is returned. Cause The script is attempting to use JSON.parse() on a response body after a request is made and is expecting the endpoint to return JSON, but HTML was returned instead. SyntaxError: Unexpected token u in JSON at position 0 Problem JSON.parse() was passed an undefined parameter, but expected a JSON string. Solution Troubleshoot the cause of the request error. Details on what is causing request errors can be found in the error object passed to the request callback function. Example: $http.get('http://www.newrelic.com', function(error, response, body) { if (error) { throw new Error(error); } var bodyJson = JSON.parse(body); console.log(bodyJson); // Log response body }); Copy Cause This can occur in Scripted API monitors when a performing an API request, then attempting to parse the request response within the callback function. The response body is passed to JSON.parse() without checking if the response body is undefined first. An undefined response body is often caused by a request error. If there is no error handling to prevent code that parses the response body, this monitor failure will occur. TypeError: Cannot read property 'statusCode' of undefined Problem The response object (and thus response.statusCode) in an API request callback is undefined. Solution Troubleshoot the cause of the request error. Details on what is causing request errors can be found in the error object passed to the request callback function. Example: $http.get('http://www.newrelic.com', function(error, response, body) { if (error) { throw new Error(error); } console.log(response.statusCode); }); Copy Cause This error occurs when there was an error completing the API request (for example, unable to reach server, unable to resolve DNS). In these instances, the request was not completed so the response object in the callback function arguments is undefined. If there is no error handling to prevent code that checks response status code, this monitor failure will occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.73019,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "NetworkError: <em>Monitor</em> produced no traffic",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " that is not instrumented by <em>synthetic</em> <em>monitoring</em>, to be used to collect HTTP traffic. ReferenceError: $network is not defined Problem The $network object used for setting <em>monitor</em> proxies is not available for that <em>monitor</em>’s runtime. Solution If your <em>monitor</em> was created before the 0.4.0 runtime release"
      },
      "id": "603ea832196a67c147a83de7"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/troubleshooting/non-scripted-monitor-errors": [
    {
      "sections": [
        "Monitor private locations",
        "Prerequisites",
        "Private Minion dashboard JSON",
        "Tip",
        "Are my private minions online?",
        "Does my private location need more minions?",
        "Can I check the status of a specific minion directly?"
      ],
      "title": "Monitor private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "d38b5c957ec41b25199f4d093eb2f6083a5ff351",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/monitor-private-locations/",
      "published_at": "2021-12-25T18:33:22Z",
      "updated_at": "2021-12-15T12:32:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using synthetic monitoring's private locations with New Relic's alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic dashboards and NRQL alerts: Are my private minions online? Does my private location need more minions? Can I check the status of a specific minion directly? Prerequisites Before following the instructions in this guide, ensure you have: A synthetic private location At least one private minion installed at that location Checks scheduled to run at that location An alert policy for the private location, with a configured notification channel to notify your team when a violation occurs The following Private Minion dashboard example JSON can be imported to your account using: the Import a dashboard button the Dashboard API Private Minion dashboard JSON { \"name\": \"Synthetics Private Minions\", \"description\": \"Details on events from SyntheticPrivateLocationStatus, SyntheticsPrivateMinion, SyntheticCheck, SyntheticRequest, NrAuditEvent, plus a page for Performance Analysis.\", \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"SyntheticPrivateLocationStatus\", \"description\": \"Details on the private location queue.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 8, \"width\": 3 }, \"title\": \"pending checks by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(checksPending) FROM SyntheticsPrivateLocationStatus FACET name\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 4, \"width\": 9 }, \"title\": \"private location queue\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES max SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 5, \"height\": 4, \"width\": 9 }, \"title\": \"rate of queue growth\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(checksPending,1 minute),0) as 'queue growth rate' FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 9, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'PRIVATE_LOCATION' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticsPrivateMinion\", \"description\": \"Details on the minion instances.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 3 }, \"title\": \"private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(timestamp),uniqueCount(minionId) - 1 as 'restarts' from SyntheticsPrivateMinion since 2 days ago FACET minionLocation\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 3, \"width\": 7 }, \"title\": \"minion details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionId),latest(timestamp) as 'last seen',latest(minionStartTimestamp) as 'started',uniqueCount(minionId) - 1 as 'restarts',latest(minionIpv4),latest(minionJobsQueued),latest(minionJobsFinished),100*latest(minionJobsFailed)/latest(minionJobsQueued) as 'job failure rate',latest(minionJobsRunning),latest(minionJobsTimedout),latest(minionJobsSkipped),latest(minionJobsInternalEngineError),latest(minionWorkers),latest(minionProcessors),latest(minionPhysicalMemoryUsedBytes/(1024*1024*1024)) as 'used memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024)) as 'total memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024))/latest(minionWorkers) as 'memory (GiB) per heavy worker' FROM SyntheticsPrivateMinion FACET minionBuildNumber,minionLocation,minionOsVersion,minionContainerSystemVersion,minionHostname LIMIT 100 SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"minion instances over time\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' from SyntheticsPrivateMinion since 2 days ago TIMESERIES MAX \" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"CPU utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionProcessorsUsagePercentage) AS 'CPU load %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"memory utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryUsedPercentage) AS 'used memory %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"free memory (GiB)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryFreeBytes / (1024*1024*1024)) AS 'free (GiB)' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(minionJobsFinished,1 minute),0) FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"skipped jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsSkipped) as 'skipped jobs' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 2 weeks ago TIMESERIES MAX\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"count of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsInternalEngineError) as 'IEE',average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.stacked-bar\" }, \"layout\": { \"column\": 9, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"rate of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*average(minionJobsInternalEngineError)/average(minionJobsFailed) as 'IEE',100*(average(minionJobsFailed)-average(minionJobsInternalEngineError))/average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES AUTO SINCE 2 weeks ago\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticCheck\", \"description\": \"Details on job results.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 non-ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type != 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type = 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type = 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 6, \"width\": 6 }, \"title\": \"monitor details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(id) as 'results',uniqueCount(location)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET monitorName,monitorId,type LIMIT MAX\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 7, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 errors by monitor type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE error IS NOT NULL AND location NOT LIKE 'AWS%' FACET error,type TIMESERIES AUTO SINCE 2 weeks ago LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 10, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping duration with monitor count\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)',uniqueCount(monitorId) as 'monitor count' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job results\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET type TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type = 'SIMPLE' as 'ping',WHERE type != 'SIMPLE' as 'non-ping') TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 11, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type, result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type != 'SIMPLE' as 'non-ping',WHERE type = 'SIMPLE' as 'ping'),result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticRequest\", \"description\": \"Details on responses.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 6, \"width\": 5 }, \"title\": \"jobs per minion\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(jobId) as 'jobs' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' FACET location,minion,minionId\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 6, \"row\": 1, \"height\": 6, \"width\": 4 }, \"title\": \"top 5 error response codes\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(responseCode) as 'responses' FROM SyntheticRequest WHERE responseCode NOT IN (200,201,202,203,204,300,301,302,303,304) AND responseCode IS NOT NULL AND location NOT LIKE 'AWS%' FACET responseCode,responseStatus TIMESERIES AUTO LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 10, \"row\": 1, \"height\": 6, \"width\": 3 }, \"title\": \"job rate\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(jobId), 1 minute) as 'job rate' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'MONITOR' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"Performance Analysis\", \"description\": \"Determine if there are enough heavy worker threads.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"minions (hosts) by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"count of heavy worker threads and cpu cores\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionWorkers),latest(minionProcessors) FROM SyntheticsPrivateMinion FACET minionHostname,minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.markdown\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"\", \"rawConfiguration\": { \"text\": \"See [this Google sheet](https://docs.google.com/spreadsheets/d/1k2Aw11r6-S8pIpXQUINQZ0T5qlxS8iSwSo9t9GKDvzc/edit?usp=sharing) to assist in calculating how many workers will be needed based on the values on this page. This will help you to assess the required size of each host (scaling up) and how many hosts you need (scaling out).\\n\\nFor more info: \\nhttps://discuss.newrelic.com/t/relic-solution-scaling-and-rightsizing-for-the-cpm/123999\" }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'non-ping monitors' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping avg job duration and timeout\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average((nr.internalQueueDuration+nr.executionDuration)/1e3) FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location,cases(WHERE error NOT LIKE '%timeout%' as 'job duration (s)', WHERE error LIKE '%timeout%' as 'job timeout (s)') SINCE 2 days ago TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"job timeout rate by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*latest(minionJobsTimedout)/latest(minionJobsReceived) as 'job timeout rate' FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES AUTO SINCE 2 days ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Steps to import: Copy the Dashboard JSON and paste into a text editor. Replace \"accountId\": 1, with your New Relic account ID for each occurrence in the JSON code. Copy the Dashboard JSON from your text editor and import using one of the methods described above. Edit any charts that you'd like to use facet filtering with. Tip If your private locations exist in a parent account and Synthetics monitors in a sub account, insert the parent account ID for NRQL queries that use SyntheticPrivateLocationStatus and SyntheticsPrivateMinion, and the sub account ID for queries that use SyntheticCheck and SyntheticRequest. Are my private minions online? To answer this question, you can rely on attributes from the SyntheticsPrivateMinionevent. Private minions send this event to New Relic every 30 seconds. A simple way to check if your minions are online is to compare the unique count of minion IDs with the number of minions you expect to be online. To understand how many minions are reporting, run this example NRQL query: SELECT uniqueCount(minionId) FROM SyntheticsPrivateMinion WHERE minionLocation = '1-acme_okc_dc-309' Copy Using this query, you can create an alert condition to notify your team when fewer minions are reporting than expected. This condition is configured with a static threshold of 2 units, which means you will receive an alert if any of your minions are offline. You can verify that the alert policy works as expected by manually stopping one of your minions. Then, when the alert violation occurs, you will be notified by any notification channels that have been set up. Once the minion is restarted and it comes back online, the alert will recover. There are more robust ways to check whether minions are functioning correctly, but this query and condition simply and successfully handle the case where a machine fails, is accidentally decommissioned, or the minion process crashes. It also ensures that the minion can communicate with New Relic. Does my private location need more minions? To answer this question, you can use the checksPending attribute of the SyntheticsPrivateLocationStatus event. The checksPending attribute reflects the number of monitor checks that are scheduled (or \"queued\") but have yet to be accepted by a minion in the designated location. For a location with scheduled checks and no minions, this graph would grow linearly up and to the right. This metric is more complicated to monitor than uniqueCount(minionId) because a high value does not necessarily mean the location is in a bad state. As long as the metric is not growing linearly up and to the right (and checks are being run on schedule), the location is in a good state. This use case is perfect for baseline NRQL alert conditions, which allow you to monitor the deviation of a metric rather than its static value. For example: SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus WHERE name = '1-acme_tokyo_dc-512' Copy To test this alert condition, schedule one-minute, browser-based monitors to run from your location. Browser-based jobs consume more resources than ping jobs, which is why they are a better fit for load simulation. New Relic will quickly notify you of a growing number of pending checks. After doubling the number of minions to handle the load, the alert recovers. For example, using the Synthetics private location dashboard example, notice the growth and decline of pending checks over the course of the incident and recovery. By using the NRQL condition, New Relic will notify you if and when the location needs more minion capacity. Can I check the status of a specific minion directly? You can also check how a minion is operating by contacting it directly. You can use a set of HTTP endpoints exposed by the minion to determine what the application is doing. In order to access these endpoints, bind ports 8080 and 8180 to ports on the host. For example, for Docker, use docker run -p 80:8080 -p 81:8180 ...): :8080/status/check: Details about internal health-checks the minion performs; HTTP 200 means \"healthy.\" :8080/status: Details about a minion's status; the same data is then published to Insights as a SyntheticsPrivateMinion event. :8180/: JVM application admin endpoints; an advanced view of a minion's internal state. This approach is not as automated or flexible as the checksPending example. However, if you have total network connectivity failure, this manual approach can help troubleshoot the situation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.08148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> private locations",
        "sections": "<em>Monitor</em> private locations",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "When using <em>synthetic</em> <em>monitoring</em>&#x27;s private locations with New Relic&#x27;s alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic"
      },
      "id": "604525f164441f7fd7378ef9"
    },
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-25T17:06:36Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.12822,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results page To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results page to locate interesting runs of your <em>monitor</em> for <em>troubleshooting</em>"
      },
      "id": "603eb5da64441f07ae4e8850"
    },
    {
      "sections": [
        "Simple, scripted, or scripted API (non-ping) errors",
        "Problem",
        "Solutions",
        "Simple or scripted browser errors",
        "Element A is not clickable at point (X, Y). Other element would receive the click: Element B",
        "Solution",
        "Tip",
        "Cause",
        "Error: element not visible",
        "Error: no such element: Unable to locate element: <LOCATOR>",
        "JobTimeoutError: Job timed-out after 180s",
        "NetworkError: Monitor produced no traffic",
        "ReferenceError: $network is not defined",
        "ScriptTimeoutError",
        "StaleElementReferenceError: element is not attached to the page document",
        "TaskTimedOut: task timed-out waiting for element to be located using: <LOCATOR>",
        "TimeoutError: Page load timed-out (unable to finish all network requests on time)",
        "TypeError: $browser.isElementPresent is not a function",
        "Scripted API monitor errors",
        "SyntaxError: Unexpected token <",
        "SyntaxError: Unexpected token u in JSON at position 0",
        "TypeError: Cannot read property 'statusCode' of undefined"
      ],
      "title": "Simple, scripted, or scripted API (non-ping) errors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Troubleshooting"
      ],
      "external_id": "cc45967d186d8847e1755948d22477ac3dd84e60",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/troubleshooting/simple-scripted-or-scripted-api-non-ping-errors/",
      "published_at": "2021-12-25T17:35:08Z",
      "updated_at": "2021-07-10T02:12:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem Your New Relic's synthetic Simple, Scripted, or Scripted API (non-ping) monitor reported an error, but the application appears to have loaded correctly. For ping and simple monitor errors, see non-scripted monitor errors. Solutions Below are some of the most common non-ping monitor error messages. Simple or scripted browser errors Element A is not clickable at point (X, Y). Other element would receive the click: Element B Problem The synthetic script is attempting to .click() an element (Element A) at point (X,Y), but another element (Element B) is obscuring the target element. Solution Set a custom wait time, allowing time for a specific condition to be met. In this case, until the loading animation is no longer visible: .then(function() { return $browser.wait($driver.until.elementIsNotVisible($browser.findElement($driver.By.id('LOADING'))), 10000); }) Copy Alternatively, you can set a custom sleep delay using $browser.sleep(sleeptime_ms), stalling script execution for a specified amount of time. As this is a fixed amount of wait-time, which does not account for increased network latency or degraded site performance, we recommend using the .wait() function instead. Tip This will not correct .click() issues caused by sticky headers or footers. In these instances, you may need to scroll manually to bring the target into view. Cause This happens if the target element, at the time of the .click() function, is obscured by: A loading overlay, modal, or pop-up An animation that reveals the target element A sticky header or footer Error: element not visible Problem The targeted element is not visible to the Selenium WebDriver. Solution Verify that the targeted element does not have the CSS properties of display: none or visibility: hidden applied. Cause Any element that has a CSS property of display: none or visibility: hidden will not be found by the Selenium WebDriver, as the script will only look for elements that are actually visible to a user. Error: no such element: Unable to locate element: <LOCATOR> Problem The Selenium WebDriver was unable to find this element in the visible DOM. Solution To resolve this problem: Confirm that the element locator being used for the target element is accurate. Avoid using By.XPath where possible as it is rigidly tied to the page’s DOM structure, and can easily become out-of-date when there are updates on the page. If element is in an iframe, use $browser.switchTo().frame(<index or element reference>. Tip See the Selenium documentation for more information on switchTo() and TargetLocator() functions. Cause Common reasons for this error include: The targeted element is unable to be located by functions such as: $browser.findElement(locator: $driver.Locator) or $browser.waitForAndFindElement(locator: $driver.Locator [ , timeout: number This may be due to a timing issue. For example, the WebDriver is attempting to locate the element before the page has been loaded. Element is in an iframe, which is a separate document context. JobTimeoutError: Job timed-out after 180s Problem The scripted monitor run reached the 180 second non-configurable timeout threshold, and the run was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assign the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. NetworkError: Monitor produced no traffic Problem The API test or scripted browser monitor appears to be running but is returning this error. Solution Ensure that $http.get() or $browser.get() are being called appropriately and are generating traffic. For Scripted API monitors, if you are using a request option to spin up an un-instrumented HTTP agent under the hood, specify one of our instrumented HTTP agents using either of the agent request options below: $globalAgents.http $globalAgents.https Example: var options = { uri: 'https://www.newrelic.com', agent: $globalAgents.https, agentOptions: { 'rejectUnauthorized': false }, strictSSL: false }; function callback(err, res, body) { ... }; $http.get(options, callback); Copy Cause This occurs in scripted monitor runs when the HTTP client ($http in scripted api monitors) or Chrome browser ($browser in scripted browser monitors) is not used to generate HTTP traffic. In some cases, certain request options in API monitors may force a new HTTP agent, one that is not instrumented by synthetic monitoring, to be used to collect HTTP traffic. ReferenceError: $network is not defined Problem The $network object used for setting monitor proxies is not available for that monitor’s runtime. Solution If your monitor was created before the 0.4.0 runtime release, create a new monitor to take advantage of the latest runtime. Your monitor’s current runtime version is shown at the top of the monitor's settings. For more information, see Scripted monitor version runtime environments. Cause This error occurs when attempting to use $network on a monitor with a runtime at or below 0.2.2. Proxying monitor traffic was introduced in monitor runtime version 0.4.0, causing this method to be evaluated as undefined on earlier monitor runtimes. ScriptTimeoutError Problem This error indicates that the job has reached the Docker container timeout threshold, and the script was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assigned the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. StaleElementReferenceError: element is not attached to the page document Problem The target page has loaded, but there was a change to an element between the execution of an element locator and an action being executed on the element. Solution Set your scripted browser to wait until the page is settled before performing a findElement() action. This can be accomplished by setting a custom wait time, using the $browser.wait(fn, timeout) function prior to the findElement call, to wait for a condition that indicates a settled page state. This will make it less likely for DOM manipulation to cause a reference to go stale. Alternatively, you can set a custom sleep delay using $browser.sleep(sleeptime_ms), stalling script execution for a specified amount of time. As this is a fixed amount of wait-time, which does not account for increased network latency or degraded site performance, we recommend using the .wait() function instead. Cause This error typically happens when the script attempts to .click() an element after using either the findElement() or waitForAndFindElement() function. If the DOM has changed between when the element locator was generated and the action was executed against the element, this error will occur because the actual element has changed. For example: the findElement() function is used to generate an element reference while the page’s script is actively manipulating the DOM. The DOM is then changed, causing the previously generated reference to become stale. The now out-of-date reference is used in an attempt to perform a .click() action, resulting in this monitor failure. Tip For more information, see the Selenium documentation on Stale Element Reference Exceptions. TaskTimedOut: task timed-out waiting for element to be located using: <LOCATOR> Problem The waitForAndFindElement(<locator>, <timeout>) function failed to locate an element within the provided timeout. Solution Confirm that the element locator being used for the target element is accurate. Avoid using By.XPath() where possible, as it is rigidly tied to the page’s DOM structure and can easily become out-of-date when there are updates on the page. Cause The target element did not exist on the page when the waitForAndFindElement(<locator>, <timeout>) function was called. This may be caused by the target page not being in the expected state. Common reasons for this error include: There is a legitimate issue with the target site. The element locator being used is incorrect. The target site has changed, requiring the revision of the Synthetics script. The previous action in the script did not successfully complete, causing the page to be in an unexpected state when the subsequent waitForAndFindElement() call was initiated. TimeoutError: Page load timed-out (unable to finish all network requests on time) Problem The target page loaded successfully, but returned the error: TimeoutError: Page load timed-out (unable to finish all network requests on time) Solution If the failures began suddenly, investigate any requests that could be blocking or delaying the page load event. If you are unsure which request is causing the error, use the timeline view to identify any long running HTTP requests. If the page is frequently unable to fully load within the current timeout, set a custom page load timeout using the $browser.manage().timeouts().pageLoadTimeout(ms: number) function. Cause The target page loaded successfully, but the page load event was not fired within the page load timeout set in the .pageLoadTimeout() function. There are a number of reasons you could see this error message, including: A blocked resource request on the page held up the page load. A resource request processed slower than normal due to an underlying network issue. A dependent resource on the page blocked the iframe load event. TypeError: $browser.isElementPresent is not a function Problem The function isElementPresent(), used by Synthetics monitors with a runtime >= 0.5.0, has been deprecated in Selenium 3. Solution To continue to use this function after depreciation you will need to create a custom version of this function, such as: return $browser.findElements(ele).then(function(found) { return found.length > 0; }); } Copy Example usage, which would return true: $browser .get(\"https://www.newrelic.com\") .then(function() { return isElementPresent($driver.By.id(\"nav_signup\")); }) .then(function(found) { return console.log(found); }); Copy Cause This can occur when attempting to use a scripted browser monitor script from an older monitor ( < = 0.4.1 runtime) with a newer monitor ( >= 0.5.0) runtime. Scripted API monitor errors JobTimeoutError: Job timed-out after 180s Problem The scripted monitor run reached the 180 second non-configurable timeout threshold, and the run was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assign the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. NetworkError: Monitor produced no traffic Problem The API test or scripted browser monitor appears to be running but is returning this error. Solution Ensure that $http.get() or $browser.get() are being called appropriately and are generating traffic. For Scripted API monitors, if you are using a request option to spin up an un-instrumented HTTP agent under the hood, specify one of our instrumented HTTP agents using either of the agent request options below: $globalAgents.http $globalAgents.https Example: var options = { uri: 'https://www.newrelic.com', agent: $globalAgents.https, agentOptions: { 'rejectUnauthorized': false }, strictSSL: false }; function callback(err, res, body) { ... }; $http.get(options, callback); Copy Cause This occurs in scripted monitor runs when the HTTP client ($http in scripted api monitors) or Chrome browser ($browser in scripted browser monitors) is not used to generate HTTP traffic. In some cases, certain request options in API monitors may force a new HTTP agent, one that is not instrumented by Synthetics, to be used to collect HTTP traffic. ReferenceError: $network is not defined Problem The $network object used for setting monitor proxies is not available for that monitor’s runtime. Solution If your monitor was created before the 0.4.0 runtime release, create a new monitor to take advantage of the latest runtime. Your monitor’s current runtime version is shown at the top of the Monitor Settings page. For more information, see Scripted monitor version runtime environments. Cause This error occurs when attempting to use $network on a monitor with a runtime at or below 0.2.2. Proxying monitor traffic was introduced in monitor runtime version 0.4.0, causing this method to be evaluated as undefined on earlier monitor runtimes. ScriptTimeoutError Problem This error indicates that the job has reached the Docker container timeout threshold, and the script was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assigned the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. SyntaxError: Unexpected token < Problem JSON.parse() was passed a string that begins with the < character and is likely HTML, instead of JSON. Solution Ensure the target endpoint is returning the expected response body. You can do this by logging the response body in the callback, before attempting to parse. Example: $http.get('http://www.newrelic.com', function(error, response, body) { if (error) { throw new Error(error); } console.log(body); // Log HTML response body, don't parse as JSON }); Copy Depending on the target API endpoint, you may need to include specific request headers to ensure that JSON is returned. Cause The script is attempting to use JSON.parse() on a response body after a request is made and is expecting the endpoint to return JSON, but HTML was returned instead. SyntaxError: Unexpected token u in JSON at position 0 Problem JSON.parse() was passed an undefined parameter, but expected a JSON string. Solution Troubleshoot the cause of the request error. Details on what is causing request errors can be found in the error object passed to the request callback function. Example: $http.get('http://www.newrelic.com', function(error, response, body) { if (error) { throw new Error(error); } var bodyJson = JSON.parse(body); console.log(bodyJson); // Log response body }); Copy Cause This can occur in Scripted API monitors when a performing an API request, then attempting to parse the request response within the callback function. The response body is passed to JSON.parse() without checking if the response body is undefined first. An undefined response body is often caused by a request error. If there is no error handling to prevent code that parses the response body, this monitor failure will occur. TypeError: Cannot read property 'statusCode' of undefined Problem The response object (and thus response.statusCode) in an API request callback is undefined. Solution Troubleshoot the cause of the request error. Details on what is causing request errors can be found in the error object passed to the request callback function. Example: $http.get('http://www.newrelic.com', function(error, response, body) { if (error) { throw new Error(error); } console.log(response.statusCode); }); Copy Cause This error occurs when there was an error completing the API request (for example, unable to reach server, unable to resolve DNS). In these instances, the request was not completed so the response object in the callback function arguments is undefined. If there is no error handling to prevent code that checks response status code, this monitor failure will occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.73019,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "NetworkError: <em>Monitor</em> produced no traffic",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " that is not instrumented by <em>synthetic</em> <em>monitoring</em>, to be used to collect HTTP traffic. ReferenceError: $network is not defined Problem The $network object used for setting <em>monitor</em> proxies is not available for that <em>monitor</em>’s runtime. Solution If your <em>monitor</em> was created before the 0.4.0 runtime release"
      },
      "id": "603ea832196a67c147a83de7"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/troubleshooting/private-location-hmac-errors": [
    {
      "sections": [
        "Monitor private locations",
        "Prerequisites",
        "Private Minion dashboard JSON",
        "Tip",
        "Are my private minions online?",
        "Does my private location need more minions?",
        "Can I check the status of a specific minion directly?"
      ],
      "title": "Monitor private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "d38b5c957ec41b25199f4d093eb2f6083a5ff351",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/monitor-private-locations/",
      "published_at": "2021-12-25T18:33:22Z",
      "updated_at": "2021-12-15T12:32:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using synthetic monitoring's private locations with New Relic's alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic dashboards and NRQL alerts: Are my private minions online? Does my private location need more minions? Can I check the status of a specific minion directly? Prerequisites Before following the instructions in this guide, ensure you have: A synthetic private location At least one private minion installed at that location Checks scheduled to run at that location An alert policy for the private location, with a configured notification channel to notify your team when a violation occurs The following Private Minion dashboard example JSON can be imported to your account using: the Import a dashboard button the Dashboard API Private Minion dashboard JSON { \"name\": \"Synthetics Private Minions\", \"description\": \"Details on events from SyntheticPrivateLocationStatus, SyntheticsPrivateMinion, SyntheticCheck, SyntheticRequest, NrAuditEvent, plus a page for Performance Analysis.\", \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"SyntheticPrivateLocationStatus\", \"description\": \"Details on the private location queue.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 8, \"width\": 3 }, \"title\": \"pending checks by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(checksPending) FROM SyntheticsPrivateLocationStatus FACET name\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 4, \"width\": 9 }, \"title\": \"private location queue\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES max SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 5, \"height\": 4, \"width\": 9 }, \"title\": \"rate of queue growth\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(checksPending,1 minute),0) as 'queue growth rate' FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 9, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'PRIVATE_LOCATION' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticsPrivateMinion\", \"description\": \"Details on the minion instances.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 3 }, \"title\": \"private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(timestamp),uniqueCount(minionId) - 1 as 'restarts' from SyntheticsPrivateMinion since 2 days ago FACET minionLocation\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 3, \"width\": 7 }, \"title\": \"minion details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionId),latest(timestamp) as 'last seen',latest(minionStartTimestamp) as 'started',uniqueCount(minionId) - 1 as 'restarts',latest(minionIpv4),latest(minionJobsQueued),latest(minionJobsFinished),100*latest(minionJobsFailed)/latest(minionJobsQueued) as 'job failure rate',latest(minionJobsRunning),latest(minionJobsTimedout),latest(minionJobsSkipped),latest(minionJobsInternalEngineError),latest(minionWorkers),latest(minionProcessors),latest(minionPhysicalMemoryUsedBytes/(1024*1024*1024)) as 'used memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024)) as 'total memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024))/latest(minionWorkers) as 'memory (GiB) per heavy worker' FROM SyntheticsPrivateMinion FACET minionBuildNumber,minionLocation,minionOsVersion,minionContainerSystemVersion,minionHostname LIMIT 100 SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"minion instances over time\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' from SyntheticsPrivateMinion since 2 days ago TIMESERIES MAX \" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"CPU utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionProcessorsUsagePercentage) AS 'CPU load %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"memory utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryUsedPercentage) AS 'used memory %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"free memory (GiB)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryFreeBytes / (1024*1024*1024)) AS 'free (GiB)' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(minionJobsFinished,1 minute),0) FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"skipped jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsSkipped) as 'skipped jobs' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 2 weeks ago TIMESERIES MAX\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"count of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsInternalEngineError) as 'IEE',average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.stacked-bar\" }, \"layout\": { \"column\": 9, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"rate of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*average(minionJobsInternalEngineError)/average(minionJobsFailed) as 'IEE',100*(average(minionJobsFailed)-average(minionJobsInternalEngineError))/average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES AUTO SINCE 2 weeks ago\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticCheck\", \"description\": \"Details on job results.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 non-ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type != 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type = 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type = 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 6, \"width\": 6 }, \"title\": \"monitor details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(id) as 'results',uniqueCount(location)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET monitorName,monitorId,type LIMIT MAX\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 7, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 errors by monitor type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE error IS NOT NULL AND location NOT LIKE 'AWS%' FACET error,type TIMESERIES AUTO SINCE 2 weeks ago LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 10, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping duration with monitor count\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)',uniqueCount(monitorId) as 'monitor count' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job results\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET type TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type = 'SIMPLE' as 'ping',WHERE type != 'SIMPLE' as 'non-ping') TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 11, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type, result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type != 'SIMPLE' as 'non-ping',WHERE type = 'SIMPLE' as 'ping'),result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticRequest\", \"description\": \"Details on responses.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 6, \"width\": 5 }, \"title\": \"jobs per minion\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(jobId) as 'jobs' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' FACET location,minion,minionId\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 6, \"row\": 1, \"height\": 6, \"width\": 4 }, \"title\": \"top 5 error response codes\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(responseCode) as 'responses' FROM SyntheticRequest WHERE responseCode NOT IN (200,201,202,203,204,300,301,302,303,304) AND responseCode IS NOT NULL AND location NOT LIKE 'AWS%' FACET responseCode,responseStatus TIMESERIES AUTO LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 10, \"row\": 1, \"height\": 6, \"width\": 3 }, \"title\": \"job rate\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(jobId), 1 minute) as 'job rate' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'MONITOR' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"Performance Analysis\", \"description\": \"Determine if there are enough heavy worker threads.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"minions (hosts) by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"count of heavy worker threads and cpu cores\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionWorkers),latest(minionProcessors) FROM SyntheticsPrivateMinion FACET minionHostname,minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.markdown\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"\", \"rawConfiguration\": { \"text\": \"See [this Google sheet](https://docs.google.com/spreadsheets/d/1k2Aw11r6-S8pIpXQUINQZ0T5qlxS8iSwSo9t9GKDvzc/edit?usp=sharing) to assist in calculating how many workers will be needed based on the values on this page. This will help you to assess the required size of each host (scaling up) and how many hosts you need (scaling out).\\n\\nFor more info: \\nhttps://discuss.newrelic.com/t/relic-solution-scaling-and-rightsizing-for-the-cpm/123999\" }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'non-ping monitors' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping avg job duration and timeout\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average((nr.internalQueueDuration+nr.executionDuration)/1e3) FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location,cases(WHERE error NOT LIKE '%timeout%' as 'job duration (s)', WHERE error LIKE '%timeout%' as 'job timeout (s)') SINCE 2 days ago TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"job timeout rate by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*latest(minionJobsTimedout)/latest(minionJobsReceived) as 'job timeout rate' FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES AUTO SINCE 2 days ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Steps to import: Copy the Dashboard JSON and paste into a text editor. Replace \"accountId\": 1, with your New Relic account ID for each occurrence in the JSON code. Copy the Dashboard JSON from your text editor and import using one of the methods described above. Edit any charts that you'd like to use facet filtering with. Tip If your private locations exist in a parent account and Synthetics monitors in a sub account, insert the parent account ID for NRQL queries that use SyntheticPrivateLocationStatus and SyntheticsPrivateMinion, and the sub account ID for queries that use SyntheticCheck and SyntheticRequest. Are my private minions online? To answer this question, you can rely on attributes from the SyntheticsPrivateMinionevent. Private minions send this event to New Relic every 30 seconds. A simple way to check if your minions are online is to compare the unique count of minion IDs with the number of minions you expect to be online. To understand how many minions are reporting, run this example NRQL query: SELECT uniqueCount(minionId) FROM SyntheticsPrivateMinion WHERE minionLocation = '1-acme_okc_dc-309' Copy Using this query, you can create an alert condition to notify your team when fewer minions are reporting than expected. This condition is configured with a static threshold of 2 units, which means you will receive an alert if any of your minions are offline. You can verify that the alert policy works as expected by manually stopping one of your minions. Then, when the alert violation occurs, you will be notified by any notification channels that have been set up. Once the minion is restarted and it comes back online, the alert will recover. There are more robust ways to check whether minions are functioning correctly, but this query and condition simply and successfully handle the case where a machine fails, is accidentally decommissioned, or the minion process crashes. It also ensures that the minion can communicate with New Relic. Does my private location need more minions? To answer this question, you can use the checksPending attribute of the SyntheticsPrivateLocationStatus event. The checksPending attribute reflects the number of monitor checks that are scheduled (or \"queued\") but have yet to be accepted by a minion in the designated location. For a location with scheduled checks and no minions, this graph would grow linearly up and to the right. This metric is more complicated to monitor than uniqueCount(minionId) because a high value does not necessarily mean the location is in a bad state. As long as the metric is not growing linearly up and to the right (and checks are being run on schedule), the location is in a good state. This use case is perfect for baseline NRQL alert conditions, which allow you to monitor the deviation of a metric rather than its static value. For example: SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus WHERE name = '1-acme_tokyo_dc-512' Copy To test this alert condition, schedule one-minute, browser-based monitors to run from your location. Browser-based jobs consume more resources than ping jobs, which is why they are a better fit for load simulation. New Relic will quickly notify you of a growing number of pending checks. After doubling the number of minions to handle the load, the alert recovers. For example, using the Synthetics private location dashboard example, notice the growth and decline of pending checks over the course of the incident and recovery. By using the NRQL condition, New Relic will notify you if and when the location needs more minion capacity. Can I check the status of a specific minion directly? You can also check how a minion is operating by contacting it directly. You can use a set of HTTP endpoints exposed by the minion to determine what the application is doing. In order to access these endpoints, bind ports 8080 and 8180 to ports on the host. For example, for Docker, use docker run -p 80:8080 -p 81:8180 ...): :8080/status/check: Details about internal health-checks the minion performs; HTTP 200 means \"healthy.\" :8080/status: Details about a minion's status; the same data is then published to Insights as a SyntheticsPrivateMinion event. :8180/: JVM application admin endpoints; an advanced view of a minion's internal state. This approach is not as automated or flexible as the checksPending example. However, if you have total network connectivity failure, this manual approach can help troubleshoot the situation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.08145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> private locations",
        "sections": "<em>Monitor</em> private locations",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "When using <em>synthetic</em> <em>monitoring</em>&#x27;s private locations with New Relic&#x27;s alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic"
      },
      "id": "604525f164441f7fd7378ef9"
    },
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-25T17:06:36Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.12822,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results page To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results page to locate interesting runs of your <em>monitor</em> for <em>troubleshooting</em>"
      },
      "id": "603eb5da64441f07ae4e8850"
    },
    {
      "sections": [
        "Simple, scripted, or scripted API (non-ping) errors",
        "Problem",
        "Solutions",
        "Simple or scripted browser errors",
        "Element A is not clickable at point (X, Y). Other element would receive the click: Element B",
        "Solution",
        "Tip",
        "Cause",
        "Error: element not visible",
        "Error: no such element: Unable to locate element: <LOCATOR>",
        "JobTimeoutError: Job timed-out after 180s",
        "NetworkError: Monitor produced no traffic",
        "ReferenceError: $network is not defined",
        "ScriptTimeoutError",
        "StaleElementReferenceError: element is not attached to the page document",
        "TaskTimedOut: task timed-out waiting for element to be located using: <LOCATOR>",
        "TimeoutError: Page load timed-out (unable to finish all network requests on time)",
        "TypeError: $browser.isElementPresent is not a function",
        "Scripted API monitor errors",
        "SyntaxError: Unexpected token <",
        "SyntaxError: Unexpected token u in JSON at position 0",
        "TypeError: Cannot read property 'statusCode' of undefined"
      ],
      "title": "Simple, scripted, or scripted API (non-ping) errors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Troubleshooting"
      ],
      "external_id": "cc45967d186d8847e1755948d22477ac3dd84e60",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/troubleshooting/simple-scripted-or-scripted-api-non-ping-errors/",
      "published_at": "2021-12-25T17:35:08Z",
      "updated_at": "2021-07-10T02:12:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem Your New Relic's synthetic Simple, Scripted, or Scripted API (non-ping) monitor reported an error, but the application appears to have loaded correctly. For ping and simple monitor errors, see non-scripted monitor errors. Solutions Below are some of the most common non-ping monitor error messages. Simple or scripted browser errors Element A is not clickable at point (X, Y). Other element would receive the click: Element B Problem The synthetic script is attempting to .click() an element (Element A) at point (X,Y), but another element (Element B) is obscuring the target element. Solution Set a custom wait time, allowing time for a specific condition to be met. In this case, until the loading animation is no longer visible: .then(function() { return $browser.wait($driver.until.elementIsNotVisible($browser.findElement($driver.By.id('LOADING'))), 10000); }) Copy Alternatively, you can set a custom sleep delay using $browser.sleep(sleeptime_ms), stalling script execution for a specified amount of time. As this is a fixed amount of wait-time, which does not account for increased network latency or degraded site performance, we recommend using the .wait() function instead. Tip This will not correct .click() issues caused by sticky headers or footers. In these instances, you may need to scroll manually to bring the target into view. Cause This happens if the target element, at the time of the .click() function, is obscured by: A loading overlay, modal, or pop-up An animation that reveals the target element A sticky header or footer Error: element not visible Problem The targeted element is not visible to the Selenium WebDriver. Solution Verify that the targeted element does not have the CSS properties of display: none or visibility: hidden applied. Cause Any element that has a CSS property of display: none or visibility: hidden will not be found by the Selenium WebDriver, as the script will only look for elements that are actually visible to a user. Error: no such element: Unable to locate element: <LOCATOR> Problem The Selenium WebDriver was unable to find this element in the visible DOM. Solution To resolve this problem: Confirm that the element locator being used for the target element is accurate. Avoid using By.XPath where possible as it is rigidly tied to the page’s DOM structure, and can easily become out-of-date when there are updates on the page. If element is in an iframe, use $browser.switchTo().frame(<index or element reference>. Tip See the Selenium documentation for more information on switchTo() and TargetLocator() functions. Cause Common reasons for this error include: The targeted element is unable to be located by functions such as: $browser.findElement(locator: $driver.Locator) or $browser.waitForAndFindElement(locator: $driver.Locator [ , timeout: number This may be due to a timing issue. For example, the WebDriver is attempting to locate the element before the page has been loaded. Element is in an iframe, which is a separate document context. JobTimeoutError: Job timed-out after 180s Problem The scripted monitor run reached the 180 second non-configurable timeout threshold, and the run was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assign the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. NetworkError: Monitor produced no traffic Problem The API test or scripted browser monitor appears to be running but is returning this error. Solution Ensure that $http.get() or $browser.get() are being called appropriately and are generating traffic. For Scripted API monitors, if you are using a request option to spin up an un-instrumented HTTP agent under the hood, specify one of our instrumented HTTP agents using either of the agent request options below: $globalAgents.http $globalAgents.https Example: var options = { uri: 'https://www.newrelic.com', agent: $globalAgents.https, agentOptions: { 'rejectUnauthorized': false }, strictSSL: false }; function callback(err, res, body) { ... }; $http.get(options, callback); Copy Cause This occurs in scripted monitor runs when the HTTP client ($http in scripted api monitors) or Chrome browser ($browser in scripted browser monitors) is not used to generate HTTP traffic. In some cases, certain request options in API monitors may force a new HTTP agent, one that is not instrumented by synthetic monitoring, to be used to collect HTTP traffic. ReferenceError: $network is not defined Problem The $network object used for setting monitor proxies is not available for that monitor’s runtime. Solution If your monitor was created before the 0.4.0 runtime release, create a new monitor to take advantage of the latest runtime. Your monitor’s current runtime version is shown at the top of the monitor's settings. For more information, see Scripted monitor version runtime environments. Cause This error occurs when attempting to use $network on a monitor with a runtime at or below 0.2.2. Proxying monitor traffic was introduced in monitor runtime version 0.4.0, causing this method to be evaluated as undefined on earlier monitor runtimes. ScriptTimeoutError Problem This error indicates that the job has reached the Docker container timeout threshold, and the script was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assigned the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. StaleElementReferenceError: element is not attached to the page document Problem The target page has loaded, but there was a change to an element between the execution of an element locator and an action being executed on the element. Solution Set your scripted browser to wait until the page is settled before performing a findElement() action. This can be accomplished by setting a custom wait time, using the $browser.wait(fn, timeout) function prior to the findElement call, to wait for a condition that indicates a settled page state. This will make it less likely for DOM manipulation to cause a reference to go stale. Alternatively, you can set a custom sleep delay using $browser.sleep(sleeptime_ms), stalling script execution for a specified amount of time. As this is a fixed amount of wait-time, which does not account for increased network latency or degraded site performance, we recommend using the .wait() function instead. Cause This error typically happens when the script attempts to .click() an element after using either the findElement() or waitForAndFindElement() function. If the DOM has changed between when the element locator was generated and the action was executed against the element, this error will occur because the actual element has changed. For example: the findElement() function is used to generate an element reference while the page’s script is actively manipulating the DOM. The DOM is then changed, causing the previously generated reference to become stale. The now out-of-date reference is used in an attempt to perform a .click() action, resulting in this monitor failure. Tip For more information, see the Selenium documentation on Stale Element Reference Exceptions. TaskTimedOut: task timed-out waiting for element to be located using: <LOCATOR> Problem The waitForAndFindElement(<locator>, <timeout>) function failed to locate an element within the provided timeout. Solution Confirm that the element locator being used for the target element is accurate. Avoid using By.XPath() where possible, as it is rigidly tied to the page’s DOM structure and can easily become out-of-date when there are updates on the page. Cause The target element did not exist on the page when the waitForAndFindElement(<locator>, <timeout>) function was called. This may be caused by the target page not being in the expected state. Common reasons for this error include: There is a legitimate issue with the target site. The element locator being used is incorrect. The target site has changed, requiring the revision of the Synthetics script. The previous action in the script did not successfully complete, causing the page to be in an unexpected state when the subsequent waitForAndFindElement() call was initiated. TimeoutError: Page load timed-out (unable to finish all network requests on time) Problem The target page loaded successfully, but returned the error: TimeoutError: Page load timed-out (unable to finish all network requests on time) Solution If the failures began suddenly, investigate any requests that could be blocking or delaying the page load event. If you are unsure which request is causing the error, use the timeline view to identify any long running HTTP requests. If the page is frequently unable to fully load within the current timeout, set a custom page load timeout using the $browser.manage().timeouts().pageLoadTimeout(ms: number) function. Cause The target page loaded successfully, but the page load event was not fired within the page load timeout set in the .pageLoadTimeout() function. There are a number of reasons you could see this error message, including: A blocked resource request on the page held up the page load. A resource request processed slower than normal due to an underlying network issue. A dependent resource on the page blocked the iframe load event. TypeError: $browser.isElementPresent is not a function Problem The function isElementPresent(), used by Synthetics monitors with a runtime >= 0.5.0, has been deprecated in Selenium 3. Solution To continue to use this function after depreciation you will need to create a custom version of this function, such as: return $browser.findElements(ele).then(function(found) { return found.length > 0; }); } Copy Example usage, which would return true: $browser .get(\"https://www.newrelic.com\") .then(function() { return isElementPresent($driver.By.id(\"nav_signup\")); }) .then(function(found) { return console.log(found); }); Copy Cause This can occur when attempting to use a scripted browser monitor script from an older monitor ( < = 0.4.1 runtime) with a newer monitor ( >= 0.5.0) runtime. Scripted API monitor errors JobTimeoutError: Job timed-out after 180s Problem The scripted monitor run reached the 180 second non-configurable timeout threshold, and the run was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assign the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. NetworkError: Monitor produced no traffic Problem The API test or scripted browser monitor appears to be running but is returning this error. Solution Ensure that $http.get() or $browser.get() are being called appropriately and are generating traffic. For Scripted API monitors, if you are using a request option to spin up an un-instrumented HTTP agent under the hood, specify one of our instrumented HTTP agents using either of the agent request options below: $globalAgents.http $globalAgents.https Example: var options = { uri: 'https://www.newrelic.com', agent: $globalAgents.https, agentOptions: { 'rejectUnauthorized': false }, strictSSL: false }; function callback(err, res, body) { ... }; $http.get(options, callback); Copy Cause This occurs in scripted monitor runs when the HTTP client ($http in scripted api monitors) or Chrome browser ($browser in scripted browser monitors) is not used to generate HTTP traffic. In some cases, certain request options in API monitors may force a new HTTP agent, one that is not instrumented by Synthetics, to be used to collect HTTP traffic. ReferenceError: $network is not defined Problem The $network object used for setting monitor proxies is not available for that monitor’s runtime. Solution If your monitor was created before the 0.4.0 runtime release, create a new monitor to take advantage of the latest runtime. Your monitor’s current runtime version is shown at the top of the Monitor Settings page. For more information, see Scripted monitor version runtime environments. Cause This error occurs when attempting to use $network on a monitor with a runtime at or below 0.2.2. Proxying monitor traffic was introduced in monitor runtime version 0.4.0, causing this method to be evaluated as undefined on earlier monitor runtimes. ScriptTimeoutError Problem This error indicates that the job has reached the Docker container timeout threshold, and the script was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assigned the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. SyntaxError: Unexpected token < Problem JSON.parse() was passed a string that begins with the < character and is likely HTML, instead of JSON. Solution Ensure the target endpoint is returning the expected response body. You can do this by logging the response body in the callback, before attempting to parse. Example: $http.get('http://www.newrelic.com', function(error, response, body) { if (error) { throw new Error(error); } console.log(body); // Log HTML response body, don't parse as JSON }); Copy Depending on the target API endpoint, you may need to include specific request headers to ensure that JSON is returned. Cause The script is attempting to use JSON.parse() on a response body after a request is made and is expecting the endpoint to return JSON, but HTML was returned instead. SyntaxError: Unexpected token u in JSON at position 0 Problem JSON.parse() was passed an undefined parameter, but expected a JSON string. Solution Troubleshoot the cause of the request error. Details on what is causing request errors can be found in the error object passed to the request callback function. Example: $http.get('http://www.newrelic.com', function(error, response, body) { if (error) { throw new Error(error); } var bodyJson = JSON.parse(body); console.log(bodyJson); // Log response body }); Copy Cause This can occur in Scripted API monitors when a performing an API request, then attempting to parse the request response within the callback function. The response body is passed to JSON.parse() without checking if the response body is undefined first. An undefined response body is often caused by a request error. If there is no error handling to prevent code that parses the response body, this monitor failure will occur. TypeError: Cannot read property 'statusCode' of undefined Problem The response object (and thus response.statusCode) in an API request callback is undefined. Solution Troubleshoot the cause of the request error. Details on what is causing request errors can be found in the error object passed to the request callback function. Example: $http.get('http://www.newrelic.com', function(error, response, body) { if (error) { throw new Error(error); } console.log(response.statusCode); }); Copy Cause This error occurs when there was an error completing the API request (for example, unable to reach server, unable to resolve DNS). In these instances, the request was not completed so the response object in the callback function arguments is undefined. If there is no error handling to prevent code that checks response status code, this monitor failure will occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.73019,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "NetworkError: <em>Monitor</em> produced no traffic",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " that is not instrumented by <em>synthetic</em> <em>monitoring</em>, to be used to collect HTTP traffic. ReferenceError: $network is not defined Problem The $network object used for setting <em>monitor</em> proxies is not available for that <em>monitor</em>’s runtime. Solution If your <em>monitor</em> was created before the 0.4.0 runtime release"
      },
      "id": "603ea832196a67c147a83de7"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/troubleshooting/simple-scripted-or-scripted-api-non-ping-errors": [
    {
      "sections": [
        "Monitor private locations",
        "Prerequisites",
        "Private Minion dashboard JSON",
        "Tip",
        "Are my private minions online?",
        "Does my private location need more minions?",
        "Can I check the status of a specific minion directly?"
      ],
      "title": "Monitor private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "d38b5c957ec41b25199f4d093eb2f6083a5ff351",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/monitor-private-locations/",
      "published_at": "2021-12-25T18:33:22Z",
      "updated_at": "2021-12-15T12:32:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using synthetic monitoring's private locations with New Relic's alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic dashboards and NRQL alerts: Are my private minions online? Does my private location need more minions? Can I check the status of a specific minion directly? Prerequisites Before following the instructions in this guide, ensure you have: A synthetic private location At least one private minion installed at that location Checks scheduled to run at that location An alert policy for the private location, with a configured notification channel to notify your team when a violation occurs The following Private Minion dashboard example JSON can be imported to your account using: the Import a dashboard button the Dashboard API Private Minion dashboard JSON { \"name\": \"Synthetics Private Minions\", \"description\": \"Details on events from SyntheticPrivateLocationStatus, SyntheticsPrivateMinion, SyntheticCheck, SyntheticRequest, NrAuditEvent, plus a page for Performance Analysis.\", \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"SyntheticPrivateLocationStatus\", \"description\": \"Details on the private location queue.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 8, \"width\": 3 }, \"title\": \"pending checks by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(checksPending) FROM SyntheticsPrivateLocationStatus FACET name\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 4, \"width\": 9 }, \"title\": \"private location queue\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES max SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 5, \"height\": 4, \"width\": 9 }, \"title\": \"rate of queue growth\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(checksPending,1 minute),0) as 'queue growth rate' FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 9, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'PRIVATE_LOCATION' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticsPrivateMinion\", \"description\": \"Details on the minion instances.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 3 }, \"title\": \"private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(timestamp),uniqueCount(minionId) - 1 as 'restarts' from SyntheticsPrivateMinion since 2 days ago FACET minionLocation\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 3, \"width\": 7 }, \"title\": \"minion details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionId),latest(timestamp) as 'last seen',latest(minionStartTimestamp) as 'started',uniqueCount(minionId) - 1 as 'restarts',latest(minionIpv4),latest(minionJobsQueued),latest(minionJobsFinished),100*latest(minionJobsFailed)/latest(minionJobsQueued) as 'job failure rate',latest(minionJobsRunning),latest(minionJobsTimedout),latest(minionJobsSkipped),latest(minionJobsInternalEngineError),latest(minionWorkers),latest(minionProcessors),latest(minionPhysicalMemoryUsedBytes/(1024*1024*1024)) as 'used memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024)) as 'total memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024))/latest(minionWorkers) as 'memory (GiB) per heavy worker' FROM SyntheticsPrivateMinion FACET minionBuildNumber,minionLocation,minionOsVersion,minionContainerSystemVersion,minionHostname LIMIT 100 SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"minion instances over time\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' from SyntheticsPrivateMinion since 2 days ago TIMESERIES MAX \" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"CPU utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionProcessorsUsagePercentage) AS 'CPU load %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"memory utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryUsedPercentage) AS 'used memory %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"free memory (GiB)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryFreeBytes / (1024*1024*1024)) AS 'free (GiB)' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(minionJobsFinished,1 minute),0) FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"skipped jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsSkipped) as 'skipped jobs' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 2 weeks ago TIMESERIES MAX\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"count of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsInternalEngineError) as 'IEE',average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.stacked-bar\" }, \"layout\": { \"column\": 9, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"rate of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*average(minionJobsInternalEngineError)/average(minionJobsFailed) as 'IEE',100*(average(minionJobsFailed)-average(minionJobsInternalEngineError))/average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES AUTO SINCE 2 weeks ago\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticCheck\", \"description\": \"Details on job results.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 non-ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type != 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type = 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type = 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 6, \"width\": 6 }, \"title\": \"monitor details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(id) as 'results',uniqueCount(location)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET monitorName,monitorId,type LIMIT MAX\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 7, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 errors by monitor type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE error IS NOT NULL AND location NOT LIKE 'AWS%' FACET error,type TIMESERIES AUTO SINCE 2 weeks ago LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 10, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping duration with monitor count\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)',uniqueCount(monitorId) as 'monitor count' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job results\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET type TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type = 'SIMPLE' as 'ping',WHERE type != 'SIMPLE' as 'non-ping') TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 11, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type, result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type != 'SIMPLE' as 'non-ping',WHERE type = 'SIMPLE' as 'ping'),result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticRequest\", \"description\": \"Details on responses.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 6, \"width\": 5 }, \"title\": \"jobs per minion\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(jobId) as 'jobs' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' FACET location,minion,minionId\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 6, \"row\": 1, \"height\": 6, \"width\": 4 }, \"title\": \"top 5 error response codes\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(responseCode) as 'responses' FROM SyntheticRequest WHERE responseCode NOT IN (200,201,202,203,204,300,301,302,303,304) AND responseCode IS NOT NULL AND location NOT LIKE 'AWS%' FACET responseCode,responseStatus TIMESERIES AUTO LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 10, \"row\": 1, \"height\": 6, \"width\": 3 }, \"title\": \"job rate\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(jobId), 1 minute) as 'job rate' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'MONITOR' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"Performance Analysis\", \"description\": \"Determine if there are enough heavy worker threads.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"minions (hosts) by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"count of heavy worker threads and cpu cores\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionWorkers),latest(minionProcessors) FROM SyntheticsPrivateMinion FACET minionHostname,minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.markdown\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"\", \"rawConfiguration\": { \"text\": \"See [this Google sheet](https://docs.google.com/spreadsheets/d/1k2Aw11r6-S8pIpXQUINQZ0T5qlxS8iSwSo9t9GKDvzc/edit?usp=sharing) to assist in calculating how many workers will be needed based on the values on this page. This will help you to assess the required size of each host (scaling up) and how many hosts you need (scaling out).\\n\\nFor more info: \\nhttps://discuss.newrelic.com/t/relic-solution-scaling-and-rightsizing-for-the-cpm/123999\" }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'non-ping monitors' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping avg job duration and timeout\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average((nr.internalQueueDuration+nr.executionDuration)/1e3) FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location,cases(WHERE error NOT LIKE '%timeout%' as 'job duration (s)', WHERE error LIKE '%timeout%' as 'job timeout (s)') SINCE 2 days ago TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"job timeout rate by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*latest(minionJobsTimedout)/latest(minionJobsReceived) as 'job timeout rate' FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES AUTO SINCE 2 days ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Steps to import: Copy the Dashboard JSON and paste into a text editor. Replace \"accountId\": 1, with your New Relic account ID for each occurrence in the JSON code. Copy the Dashboard JSON from your text editor and import using one of the methods described above. Edit any charts that you'd like to use facet filtering with. Tip If your private locations exist in a parent account and Synthetics monitors in a sub account, insert the parent account ID for NRQL queries that use SyntheticPrivateLocationStatus and SyntheticsPrivateMinion, and the sub account ID for queries that use SyntheticCheck and SyntheticRequest. Are my private minions online? To answer this question, you can rely on attributes from the SyntheticsPrivateMinionevent. Private minions send this event to New Relic every 30 seconds. A simple way to check if your minions are online is to compare the unique count of minion IDs with the number of minions you expect to be online. To understand how many minions are reporting, run this example NRQL query: SELECT uniqueCount(minionId) FROM SyntheticsPrivateMinion WHERE minionLocation = '1-acme_okc_dc-309' Copy Using this query, you can create an alert condition to notify your team when fewer minions are reporting than expected. This condition is configured with a static threshold of 2 units, which means you will receive an alert if any of your minions are offline. You can verify that the alert policy works as expected by manually stopping one of your minions. Then, when the alert violation occurs, you will be notified by any notification channels that have been set up. Once the minion is restarted and it comes back online, the alert will recover. There are more robust ways to check whether minions are functioning correctly, but this query and condition simply and successfully handle the case where a machine fails, is accidentally decommissioned, or the minion process crashes. It also ensures that the minion can communicate with New Relic. Does my private location need more minions? To answer this question, you can use the checksPending attribute of the SyntheticsPrivateLocationStatus event. The checksPending attribute reflects the number of monitor checks that are scheduled (or \"queued\") but have yet to be accepted by a minion in the designated location. For a location with scheduled checks and no minions, this graph would grow linearly up and to the right. This metric is more complicated to monitor than uniqueCount(minionId) because a high value does not necessarily mean the location is in a bad state. As long as the metric is not growing linearly up and to the right (and checks are being run on schedule), the location is in a good state. This use case is perfect for baseline NRQL alert conditions, which allow you to monitor the deviation of a metric rather than its static value. For example: SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus WHERE name = '1-acme_tokyo_dc-512' Copy To test this alert condition, schedule one-minute, browser-based monitors to run from your location. Browser-based jobs consume more resources than ping jobs, which is why they are a better fit for load simulation. New Relic will quickly notify you of a growing number of pending checks. After doubling the number of minions to handle the load, the alert recovers. For example, using the Synthetics private location dashboard example, notice the growth and decline of pending checks over the course of the incident and recovery. By using the NRQL condition, New Relic will notify you if and when the location needs more minion capacity. Can I check the status of a specific minion directly? You can also check how a minion is operating by contacting it directly. You can use a set of HTTP endpoints exposed by the minion to determine what the application is doing. In order to access these endpoints, bind ports 8080 and 8180 to ports on the host. For example, for Docker, use docker run -p 80:8080 -p 81:8180 ...): :8080/status/check: Details about internal health-checks the minion performs; HTTP 200 means \"healthy.\" :8080/status: Details about a minion's status; the same data is then published to Insights as a SyntheticsPrivateMinion event. :8180/: JVM application admin endpoints; an advanced view of a minion's internal state. This approach is not as automated or flexible as the checksPending example. However, if you have total network connectivity failure, this manual approach can help troubleshoot the situation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.08145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> private locations",
        "sections": "<em>Monitor</em> private locations",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "When using <em>synthetic</em> <em>monitoring</em>&#x27;s private locations with New Relic&#x27;s alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic"
      },
      "id": "604525f164441f7fd7378ef9"
    },
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-25T17:06:36Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.12822,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results page To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results page to locate interesting runs of your <em>monitor</em> for <em>troubleshooting</em>"
      },
      "id": "603eb5da64441f07ae4e8850"
    },
    {
      "sections": [
        "Non-scripted monitor errors",
        "Problem",
        "Solutions",
        "ERROR: Job timed out after 65 seconds",
        "Solution",
        "Cause",
        "NetworkError: Connect to (HOST) [HOST./IP ADDRESS] failed: connect timed out",
        "NetworkError: Connect to (HOST) [HOST./IP ADDRESS] failed: Connection refused",
        "HTTPError: Server replied with HTTP XXX response code",
        "SSLVerificationError: (ERROR)",
        "ResponseValidationError: Response did not contain the expected string",
        "NetworkError: Read timed out",
        "NetworkError: Socket is closed",
        "NetworkError: No route to host (Host unreachable)",
        "HTTPError: Server sent us too many redirects (20)",
        "NetworkError: DNS resolution failed for host: (HOST)",
        "BlockedRequestError: (URL)"
      ],
      "title": "Non-scripted monitor errors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Troubleshooting"
      ],
      "external_id": "156625f0d6481bdcabd07d6101ffbd3db2d184c3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/troubleshooting/non-scripted-monitor-errors/",
      "published_at": "2021-12-25T16:57:51Z",
      "updated_at": "2021-07-10T02:11:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem Your synthetic ping or simple monitor reported one of these errors. For scripted monitor errors, see non-ping errors. Solutions These are some of the most common non-scripted monitor error messages. ERROR: Job timed out after 65 seconds Problem Your ping timed out after 65 seconds, the non-configurable check duration time limit. Solution The 65 second time limit is non-configurable. Pings exceeding 65 seconds may be a result of latency from the target server. Investigate potential issues along the network path between our servers and yours, as this may indicate an issue experienced by real users of your application. Cause Ping monitors will first perform a HEAD request. If this request fails for any reason, or reaches the 30 second HTTP connect timeout for ping monitors, then a subsequent GET request is performed. This error happens when both the HEAD and GET request exceed 30 seconds, usually due to server latency. NetworkError: Connect to (HOST) [HOST./IP ADDRESS] failed: connect timed out Problem HTTP requests during the check exceeded the non-configurable 30 second TCP connection timeout limit. Solution The 30 second time limit is non-configurable. Investigate potential issues along the network path between our servers and yours, as this may indicate an issue experienced by real users of your application. Cause This failure indicates an issue reaching your site from the location where the synthetic's check was performed. NetworkError: Connect to (HOST) [HOST./IP ADDRESS] failed: Connection refused Problem The target server refused connection from the synthetic ping monitor HTTP client. Solution Add our synthetic monitoring IP addresses to your allow list, to ensure traffic from our synthetic monitors can reach the target server. Cause The target server is likely blocking or rate-limiting synthetic's traffic. HTTPError: Server replied with HTTP XXX response code Problem The synthetic monitor encountered an unsuccessful status code, usually a response code that is not in the 2XX/3XX range. Solution Check your server-side logging to determine why the response code was sent. To assist with identifying synthetic's traffic on your server, all synthetic monitoring traffic includes an X-Abuse-Info HTTP request header and we provide a list of origin IP addresses for all synthetic monitoring traffic. Cause The cause depends on the response code sent. SSLVerificationError: (ERROR) Problem Your monitor returns an SSLVerificationError. Solution Go to one.newrelic.com > Synthetics > (select a monitor) > Settings > General > Advanced options, then disable the Verify SSL check. Cause SSLVerificationError failures are a result of the optional Verify SSL check failing against the target host. SSL verification failed during execution for domain <TARGET_URL> failures indicate that the URL provided is not HTTPS or does not redirect to an HTTPS endpoint. SSLVerificationError: (<ERROR CODE>) <ERROR> errors are retrieved directly from the openssl command and often indicate a legitimate SSL configuration issue on the target site. ResponseValidationError: Response did not contain the expected string Problem The string value included in the synthetic monitor’s optional Response Validation field was not found in the target server’s response. Solution To troubleshoot: Check the failed results timeline to ensure the endpoint where the response validation text is expected, is the last endpoint being requested. Attempt a curl request against the target endpoint to see if the expected response body is returned. Ensure your endpoint doesn't have policies that will return different content depending on header content or request activity. If so, use a scripted browser to spoof a specific header string. If you’re using a simple browser to monitor a page whose content is loaded via JavaScript after the page’s load event is fired, consider using a scripted browser monitor instead. You can program scripted browsers to wait for specific elements to appear on a page before interacting with them. Cause The cause depends on the monitor type: Ping monitors: The string value must be present in the first 1MB (10^6 bytes) of the response body. Simple browsers: The string must be visible on the page when the page’s load event is fired. NetworkError: Read timed out Problem The monitor client was able to establish an HTTP connection to the target site, but then exceeded the 30 second read timeout while waiting for a response. Solution To troubleshoot: Investigate the target server's performance during the time period the issue was observed. Investigate potential issues along the network path between our servers and yours, as this may indicate an issue experienced by real users of your application. Cause This indicates an issue with the target server responding to the synthetic monitor HTTP client, or network latency between your server and ours. NetworkError: Socket is closed Problem The synthetic monitor's HTTP client was able to establish a connection to the target server. The target server then closed the connection without a response. Solution Add our synthetic monitoring IP addresses to your allow list, to ensure traffic from our synthetic monitors can reach the target server. Cause Edge infrastructure sometimes implements measures such as this for an application endpoint to handle traffic that violates behavior policies like rate limiting. NetworkError: No route to host (Host unreachable) Problem The synthetic monitoring client was able to resolve the target host’s IP address, but it was unable to find a route to the target host to establish a connection. Solution If the failure is occurring on a public synthetic monitoring's location, ensure that the DNS records for this host are resolving to a reachable IP address. If the failure is occurring on a synthetic monitoring's private location, ensure the private minion’s network configuration is properly configured and that the target hostname is resolvable and reachable via the private minion virtual command line interface. Cause This occurs when the target hostname resolves to a non-routable IP address per RFC 1918. HTTPError: Server sent us too many redirects (20) Problem The synthetic monitor client was redirected (observing 301 or 302 response codes) 20 times when performing a request to the target endpoint. Solution Ensure that the target endpoint redirects client requests less than 20 times. If this is only occurring within New Relic, recreate the issue outside New Relic to troubleshoot the root cause. Use a similar client to perform requests against the target endpoint: Ping monitors: HTTP client similar to curl. Simple browser and scripted browser monitors: Chrome 60 instance in an Ubuntu 14.04.5 VM. Scripted API monitors: Use the request HTTP client for Node.js. Cause This occurs when the monitored endpoint effectively serves a redirect loop to the synthetic monitor: The initial response redirects to another URL which redirects to another URL, etc. NetworkError: DNS resolution failed for host: (HOST) Problem The target hostname was not able to be resolved by the synthetic monitor’s HTTP client. Solution Private synthetic monitoring's locations: Confirm that the network configuration for the minion is correct. If the target hostname is an internal one, ensure that the minion is using your network’s internal DNS service that is able to resolve the host. The containerized private minion and the runner containers it spawns on host (to run non-ping checks) should inherit DNS configuration from the host /etc/resolv.conf. Docker: Network arguments like –dns or -network used in the Docker run command on the containerized private minion will only be used by the minion container but not the runner containers. If the DNS points to the loopback interface such as 127.0.0.1, define a DNS config at the Docker daemon level, or use a tool like dnsmasq to make sure the runner will forward DNS requests on the Docker bridge interface. Public synthetic monitoring locations: Ensure that the target site’s DNS record can be looked up by public DNS services such as Google public DNS and Amazon-provided DNS. Cause Our public synthetic monitoring locations use Google public DNS and Amazon-provided DNS. If DNS resolution of the target host is failing on our public synthetic monitoring locations, this is likely an issue other users are facing. If you are seeing DNS resolution related monitor failures on a synthetic monitoring private location, this is often caused by the private minion for that location having an invalid network configuration. BlockedRequestError: (URL) Problem The target domain is blocked by synthetic monitoring. Solution To unblock domains, you must use a scripted browser monitor and manually make calls in your script. Cause Synthetic monitoring specifically exclude scripts for popular analytics services such as Google Analytics. This ensures your analytics tools continue to receive accurate data, even with thousands of monitors checking your website each month.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.73015,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Non-scripted <em>monitor</em> errors",
        "sections": "Non-scripted <em>monitor</em> errors",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " ADDRESS] failed: Connection refused Problem The target server refused connection from the <em>synthetic</em> ping <em>monitor</em> HTTP client. Solution Add our <em>synthetic</em> <em>monitoring</em> IP addresses to your allow list, to ensure traffic from our <em>synthetic</em> monitors can reach the target server. Cause The target server"
      },
      "id": "603eb369e7b9d20e922a07d6"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/troubleshooting/troubleshoot-isolated-monitor-failures": [
    {
      "sections": [
        "Monitor private locations",
        "Prerequisites",
        "Private Minion dashboard JSON",
        "Tip",
        "Are my private minions online?",
        "Does my private location need more minions?",
        "Can I check the status of a specific minion directly?"
      ],
      "title": "Monitor private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "d38b5c957ec41b25199f4d093eb2f6083a5ff351",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/monitor-private-locations/",
      "published_at": "2021-12-25T18:33:22Z",
      "updated_at": "2021-12-15T12:32:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using synthetic monitoring's private locations with New Relic's alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic dashboards and NRQL alerts: Are my private minions online? Does my private location need more minions? Can I check the status of a specific minion directly? Prerequisites Before following the instructions in this guide, ensure you have: A synthetic private location At least one private minion installed at that location Checks scheduled to run at that location An alert policy for the private location, with a configured notification channel to notify your team when a violation occurs The following Private Minion dashboard example JSON can be imported to your account using: the Import a dashboard button the Dashboard API Private Minion dashboard JSON { \"name\": \"Synthetics Private Minions\", \"description\": \"Details on events from SyntheticPrivateLocationStatus, SyntheticsPrivateMinion, SyntheticCheck, SyntheticRequest, NrAuditEvent, plus a page for Performance Analysis.\", \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"SyntheticPrivateLocationStatus\", \"description\": \"Details on the private location queue.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 8, \"width\": 3 }, \"title\": \"pending checks by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(checksPending) FROM SyntheticsPrivateLocationStatus FACET name\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 4, \"width\": 9 }, \"title\": \"private location queue\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES max SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 4, \"row\": 5, \"height\": 4, \"width\": 9 }, \"title\": \"rate of queue growth\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(checksPending,1 minute),0) as 'queue growth rate' FROM SyntheticsPrivateLocationStatus FACET name TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 9, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'PRIVATE_LOCATION' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticsPrivateMinion\", \"description\": \"Details on the minion instances.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 3 }, \"title\": \"private locations\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(timestamp),uniqueCount(minionId) - 1 as 'restarts' from SyntheticsPrivateMinion since 2 days ago FACET minionLocation\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 4, \"row\": 1, \"height\": 3, \"width\": 7 }, \"title\": \"minion details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionId),latest(timestamp) as 'last seen',latest(minionStartTimestamp) as 'started',uniqueCount(minionId) - 1 as 'restarts',latest(minionIpv4),latest(minionJobsQueued),latest(minionJobsFinished),100*latest(minionJobsFailed)/latest(minionJobsQueued) as 'job failure rate',latest(minionJobsRunning),latest(minionJobsTimedout),latest(minionJobsSkipped),latest(minionJobsInternalEngineError),latest(minionWorkers),latest(minionProcessors),latest(minionPhysicalMemoryUsedBytes/(1024*1024*1024)) as 'used memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024)) as 'total memory (GiB)',latest(minionPhysicalMemoryTotalBytes/(1024*1024*1024))/latest(minionWorkers) as 'memory (GiB) per heavy worker' FROM SyntheticsPrivateMinion FACET minionBuildNumber,minionLocation,minionOsVersion,minionContainerSystemVersion,minionHostname LIMIT 100 SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"minion instances over time\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' from SyntheticsPrivateMinion since 2 days ago TIMESERIES MAX \" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"CPU utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionProcessorsUsagePercentage) AS 'CPU load %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"memory utilization (%)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryUsedPercentage) AS 'used memory %' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"free memory (GiB)\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT max(minionPhysicalMemoryFreeBytes / (1024*1024*1024)) AS 'free (GiB)' FROM SyntheticsPrivateMinion TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT clamp_min(derivative(minionJobsFinished,1 minute),0) FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 7, \"height\": 3, \"width\": 2 }, \"title\": \"skipped jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsSkipped) as 'skipped jobs' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 2 weeks ago TIMESERIES MAX\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"count of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(minionJobsInternalEngineError) as 'IEE',average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES MAX SINCE 2 weeks ago\" } ], \"yAxisLeft\": { \"zero\": false } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.stacked-bar\" }, \"layout\": { \"column\": 9, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"rate of Internal Engine Errors (IEE) vs failed jobs\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*average(minionJobsInternalEngineError)/average(minionJobsFailed) as 'IEE',100*(average(minionJobsFailed)-average(minionJobsInternalEngineError))/average(minionJobsFailed) as 'failed jobs' FROM SyntheticsPrivateMinion TIMESERIES AUTO SINCE 2 weeks ago\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticCheck\", \"description\": \"Details on job results.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 non-ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type != 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"ping monitor details by location\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'monitors with results',uniqueCount(monitorId)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE type = 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location \" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 7, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 ping errors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(error) as 'count',latest(monitorName),average((nr.internalQueueDuration+nr.executionDuration)/1e3) as 'avg job duration (s)',max(timestamp) as 'last occurrence' FROM SyntheticCheck WHERE type = 'SIMPLE' AND result = 'FAILED' AND location NOT LIKE 'AWS%' FACET error LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 6, \"width\": 6 }, \"title\": \"monitor details\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(id) as 'results',uniqueCount(location)/rate(uniqueCount(id), 1 minute) as 'avg job frequency (m)',average(nr.internalQueueDuration+nr.executionDuration)/1e3 as 'avg duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET monitorName,monitorId,type LIMIT MAX\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 7, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"top 5 errors by monitor type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE error IS NOT NULL AND location NOT LIKE 'AWS%' FACET error,type TIMESERIES AUTO SINCE 2 weeks ago LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 10, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping duration with monitor count\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)',uniqueCount(monitorId) as 'monitor count' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job results\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(*) FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 3, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 7, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET type TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 9, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"job rate by type\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type = 'SIMPLE' as 'ping',WHERE type != 'SIMPLE' as 'non-ping') TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 11, \"row\": 13, \"height\": 3, \"width\": 2 }, \"title\": \"duration by type, result\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average(nr.internalQueueDuration+nr.executionDuration/1e3) as 'avg job duration (s)' FROM SyntheticCheck WHERE location NOT LIKE 'AWS%' FACET cases(WHERE type != 'SIMPLE' as 'non-ping',WHERE type = 'SIMPLE' as 'ping'),result TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] }, { \"name\": \"SyntheticRequest\", \"description\": \"Details on responses.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 6, \"width\": 5 }, \"title\": \"jobs per minion\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(jobId) as 'jobs' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' FACET location,minion,minionId\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.area\" }, \"layout\": { \"column\": 6, \"row\": 1, \"height\": 6, \"width\": 4 }, \"title\": \"top 5 error response codes\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT count(responseCode) as 'responses' FROM SyntheticRequest WHERE responseCode NOT IN (200,201,202,203,204,300,301,302,303,304) AND responseCode IS NOT NULL AND location NOT LIKE 'AWS%' FACET responseCode,responseStatus TIMESERIES AUTO LIMIT 5\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 10, \"row\": 1, \"height\": 6, \"width\": 3 }, \"title\": \"job rate\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(jobId), 1 minute) as 'job rate' FROM SyntheticRequest WHERE location NOT LIKE 'AWS%' TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 4, \"width\": 12 }, \"title\": \"audit events for monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT * from NrAuditEvent WHERE targetType = 'MONITOR' SINCE 2 days ago LIMIT MAX\" } ] }, \"linkedEntityGuids\": null } ] }, { \"name\": \"Performance Analysis\", \"description\": \"Determine if there are enough heavy worker threads.\", \"widgets\": [ { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"minions (hosts) by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(minionId) as 'minions' FROM SyntheticsPrivateMinion FACET minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.table\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 6 }, \"title\": \"count of heavy worker threads and cpu cores\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT latest(minionWorkers),latest(minionProcessors) FROM SyntheticsPrivateMinion FACET minionHostname,minionLocation SINCE 5 minutes ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.markdown\" }, \"layout\": { \"column\": 11, \"row\": 1, \"height\": 3, \"width\": 2 }, \"title\": \"\", \"rawConfiguration\": { \"text\": \"See [this Google sheet](https://docs.google.com/spreadsheets/d/1k2Aw11r6-S8pIpXQUINQZ0T5qlxS8iSwSo9t9GKDvzc/edit?usp=sharing) to assist in calculating how many workers will be needed based on the values on this page. This will help you to assess the required size of each host (scaling up) and how many hosts you need (scaling out).\\n\\nFor more info: \\nhttps://discuss.newrelic.com/t/relic-solution-scaling-and-rightsizing-for-the-cpm/123999\" }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 4, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping monitors\", \"rawConfiguration\": { \"dataFormatters\": [], \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT uniqueCount(monitorId) as 'non-ping monitors' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 4, \"height\": 3, \"width\": 6 }, \"title\": \"non-ping avg job duration and timeout\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT average((nr.internalQueueDuration+nr.executionDuration)/1e3) FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location,cases(WHERE error NOT LIKE '%timeout%' as 'job duration (s)', WHERE error LIKE '%timeout%' as 'job timeout (s)') SINCE 2 days ago TIMESERIES AUTO\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.bar\" }, \"layout\": { \"column\": 1, \"row\": 7, \"height\": 3, \"width\": 4 }, \"title\": \"non-ping jobs per minute\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT rate(uniqueCount(id), 1 minute) as 'job rate' FROM SyntheticCheck WHERE type != 'SIMPLE' AND location NOT LIKE 'AWS%' FACET location SINCE 2 days ago\" } ] }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 7, \"height\": 3, \"width\": 6 }, \"title\": \"job timeout rate by location\", \"rawConfiguration\": { \"facet\": { \"showOtherSeries\": false }, \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": 1, \"query\": \"SELECT 100*latest(minionJobsTimedout)/latest(minionJobsReceived) as 'job timeout rate' FROM SyntheticsPrivateMinion FACET minionLocation TIMESERIES AUTO SINCE 2 days ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } Copy Steps to import: Copy the Dashboard JSON and paste into a text editor. Replace \"accountId\": 1, with your New Relic account ID for each occurrence in the JSON code. Copy the Dashboard JSON from your text editor and import using one of the methods described above. Edit any charts that you'd like to use facet filtering with. Tip If your private locations exist in a parent account and Synthetics monitors in a sub account, insert the parent account ID for NRQL queries that use SyntheticPrivateLocationStatus and SyntheticsPrivateMinion, and the sub account ID for queries that use SyntheticCheck and SyntheticRequest. Are my private minions online? To answer this question, you can rely on attributes from the SyntheticsPrivateMinionevent. Private minions send this event to New Relic every 30 seconds. A simple way to check if your minions are online is to compare the unique count of minion IDs with the number of minions you expect to be online. To understand how many minions are reporting, run this example NRQL query: SELECT uniqueCount(minionId) FROM SyntheticsPrivateMinion WHERE minionLocation = '1-acme_okc_dc-309' Copy Using this query, you can create an alert condition to notify your team when fewer minions are reporting than expected. This condition is configured with a static threshold of 2 units, which means you will receive an alert if any of your minions are offline. You can verify that the alert policy works as expected by manually stopping one of your minions. Then, when the alert violation occurs, you will be notified by any notification channels that have been set up. Once the minion is restarted and it comes back online, the alert will recover. There are more robust ways to check whether minions are functioning correctly, but this query and condition simply and successfully handle the case where a machine fails, is accidentally decommissioned, or the minion process crashes. It also ensures that the minion can communicate with New Relic. Does my private location need more minions? To answer this question, you can use the checksPending attribute of the SyntheticsPrivateLocationStatus event. The checksPending attribute reflects the number of monitor checks that are scheduled (or \"queued\") but have yet to be accepted by a minion in the designated location. For a location with scheduled checks and no minions, this graph would grow linearly up and to the right. This metric is more complicated to monitor than uniqueCount(minionId) because a high value does not necessarily mean the location is in a bad state. As long as the metric is not growing linearly up and to the right (and checks are being run on schedule), the location is in a good state. This use case is perfect for baseline NRQL alert conditions, which allow you to monitor the deviation of a metric rather than its static value. For example: SELECT average(checksPending) FROM SyntheticsPrivateLocationStatus WHERE name = '1-acme_tokyo_dc-512' Copy To test this alert condition, schedule one-minute, browser-based monitors to run from your location. Browser-based jobs consume more resources than ping jobs, which is why they are a better fit for load simulation. New Relic will quickly notify you of a growing number of pending checks. After doubling the number of minions to handle the load, the alert recovers. For example, using the Synthetics private location dashboard example, notice the growth and decline of pending checks over the course of the incident and recovery. By using the NRQL condition, New Relic will notify you if and when the location needs more minion capacity. Can I check the status of a specific minion directly? You can also check how a minion is operating by contacting it directly. You can use a set of HTTP endpoints exposed by the minion to determine what the application is doing. In order to access these endpoints, bind ports 8080 and 8180 to ports on the host. For example, for Docker, use docker run -p 80:8080 -p 81:8180 ...): :8080/status/check: Details about internal health-checks the minion performs; HTTP 200 means \"healthy.\" :8080/status: Details about a minion's status; the same data is then published to Insights as a SyntheticsPrivateMinion event. :8180/: JVM application admin endpoints; an advanced view of a minion's internal state. This approach is not as automated or flexible as the checksPending example. However, if you have total network connectivity failure, this manual approach can help troubleshoot the situation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.08142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> private locations",
        "sections": "<em>Monitor</em> private locations",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "When using <em>synthetic</em> <em>monitoring</em>&#x27;s private locations with New Relic&#x27;s alerts, you can be notified if a location is under-provisioned, mis-configured, or generally misbehaving. This guide will help you answer the following basic questions regarding private location health by using New Relic"
      },
      "id": "604525f164441f7fd7378ef9"
    },
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-25T17:06:36Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.12822,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results page To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results page to locate interesting runs of your <em>monitor</em> for <em>troubleshooting</em>"
      },
      "id": "603eb5da64441f07ae4e8850"
    },
    {
      "sections": [
        "Simple, scripted, or scripted API (non-ping) errors",
        "Problem",
        "Solutions",
        "Simple or scripted browser errors",
        "Element A is not clickable at point (X, Y). Other element would receive the click: Element B",
        "Solution",
        "Tip",
        "Cause",
        "Error: element not visible",
        "Error: no such element: Unable to locate element: <LOCATOR>",
        "JobTimeoutError: Job timed-out after 180s",
        "NetworkError: Monitor produced no traffic",
        "ReferenceError: $network is not defined",
        "ScriptTimeoutError",
        "StaleElementReferenceError: element is not attached to the page document",
        "TaskTimedOut: task timed-out waiting for element to be located using: <LOCATOR>",
        "TimeoutError: Page load timed-out (unable to finish all network requests on time)",
        "TypeError: $browser.isElementPresent is not a function",
        "Scripted API monitor errors",
        "SyntaxError: Unexpected token <",
        "SyntaxError: Unexpected token u in JSON at position 0",
        "TypeError: Cannot read property 'statusCode' of undefined"
      ],
      "title": "Simple, scripted, or scripted API (non-ping) errors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Troubleshooting"
      ],
      "external_id": "cc45967d186d8847e1755948d22477ac3dd84e60",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/troubleshooting/simple-scripted-or-scripted-api-non-ping-errors/",
      "published_at": "2021-12-25T17:35:08Z",
      "updated_at": "2021-07-10T02:12:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem Your New Relic's synthetic Simple, Scripted, or Scripted API (non-ping) monitor reported an error, but the application appears to have loaded correctly. For ping and simple monitor errors, see non-scripted monitor errors. Solutions Below are some of the most common non-ping monitor error messages. Simple or scripted browser errors Element A is not clickable at point (X, Y). Other element would receive the click: Element B Problem The synthetic script is attempting to .click() an element (Element A) at point (X,Y), but another element (Element B) is obscuring the target element. Solution Set a custom wait time, allowing time for a specific condition to be met. In this case, until the loading animation is no longer visible: .then(function() { return $browser.wait($driver.until.elementIsNotVisible($browser.findElement($driver.By.id('LOADING'))), 10000); }) Copy Alternatively, you can set a custom sleep delay using $browser.sleep(sleeptime_ms), stalling script execution for a specified amount of time. As this is a fixed amount of wait-time, which does not account for increased network latency or degraded site performance, we recommend using the .wait() function instead. Tip This will not correct .click() issues caused by sticky headers or footers. In these instances, you may need to scroll manually to bring the target into view. Cause This happens if the target element, at the time of the .click() function, is obscured by: A loading overlay, modal, or pop-up An animation that reveals the target element A sticky header or footer Error: element not visible Problem The targeted element is not visible to the Selenium WebDriver. Solution Verify that the targeted element does not have the CSS properties of display: none or visibility: hidden applied. Cause Any element that has a CSS property of display: none or visibility: hidden will not be found by the Selenium WebDriver, as the script will only look for elements that are actually visible to a user. Error: no such element: Unable to locate element: <LOCATOR> Problem The Selenium WebDriver was unable to find this element in the visible DOM. Solution To resolve this problem: Confirm that the element locator being used for the target element is accurate. Avoid using By.XPath where possible as it is rigidly tied to the page’s DOM structure, and can easily become out-of-date when there are updates on the page. If element is in an iframe, use $browser.switchTo().frame(<index or element reference>. Tip See the Selenium documentation for more information on switchTo() and TargetLocator() functions. Cause Common reasons for this error include: The targeted element is unable to be located by functions such as: $browser.findElement(locator: $driver.Locator) or $browser.waitForAndFindElement(locator: $driver.Locator [ , timeout: number This may be due to a timing issue. For example, the WebDriver is attempting to locate the element before the page has been loaded. Element is in an iframe, which is a separate document context. JobTimeoutError: Job timed-out after 180s Problem The scripted monitor run reached the 180 second non-configurable timeout threshold, and the run was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assign the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. NetworkError: Monitor produced no traffic Problem The API test or scripted browser monitor appears to be running but is returning this error. Solution Ensure that $http.get() or $browser.get() are being called appropriately and are generating traffic. For Scripted API monitors, if you are using a request option to spin up an un-instrumented HTTP agent under the hood, specify one of our instrumented HTTP agents using either of the agent request options below: $globalAgents.http $globalAgents.https Example: var options = { uri: 'https://www.newrelic.com', agent: $globalAgents.https, agentOptions: { 'rejectUnauthorized': false }, strictSSL: false }; function callback(err, res, body) { ... }; $http.get(options, callback); Copy Cause This occurs in scripted monitor runs when the HTTP client ($http in scripted api monitors) or Chrome browser ($browser in scripted browser monitors) is not used to generate HTTP traffic. In some cases, certain request options in API monitors may force a new HTTP agent, one that is not instrumented by synthetic monitoring, to be used to collect HTTP traffic. ReferenceError: $network is not defined Problem The $network object used for setting monitor proxies is not available for that monitor’s runtime. Solution If your monitor was created before the 0.4.0 runtime release, create a new monitor to take advantage of the latest runtime. Your monitor’s current runtime version is shown at the top of the monitor's settings. For more information, see Scripted monitor version runtime environments. Cause This error occurs when attempting to use $network on a monitor with a runtime at or below 0.2.2. Proxying monitor traffic was introduced in monitor runtime version 0.4.0, causing this method to be evaluated as undefined on earlier monitor runtimes. ScriptTimeoutError Problem This error indicates that the job has reached the Docker container timeout threshold, and the script was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assigned the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. StaleElementReferenceError: element is not attached to the page document Problem The target page has loaded, but there was a change to an element between the execution of an element locator and an action being executed on the element. Solution Set your scripted browser to wait until the page is settled before performing a findElement() action. This can be accomplished by setting a custom wait time, using the $browser.wait(fn, timeout) function prior to the findElement call, to wait for a condition that indicates a settled page state. This will make it less likely for DOM manipulation to cause a reference to go stale. Alternatively, you can set a custom sleep delay using $browser.sleep(sleeptime_ms), stalling script execution for a specified amount of time. As this is a fixed amount of wait-time, which does not account for increased network latency or degraded site performance, we recommend using the .wait() function instead. Cause This error typically happens when the script attempts to .click() an element after using either the findElement() or waitForAndFindElement() function. If the DOM has changed between when the element locator was generated and the action was executed against the element, this error will occur because the actual element has changed. For example: the findElement() function is used to generate an element reference while the page’s script is actively manipulating the DOM. The DOM is then changed, causing the previously generated reference to become stale. The now out-of-date reference is used in an attempt to perform a .click() action, resulting in this monitor failure. Tip For more information, see the Selenium documentation on Stale Element Reference Exceptions. TaskTimedOut: task timed-out waiting for element to be located using: <LOCATOR> Problem The waitForAndFindElement(<locator>, <timeout>) function failed to locate an element within the provided timeout. Solution Confirm that the element locator being used for the target element is accurate. Avoid using By.XPath() where possible, as it is rigidly tied to the page’s DOM structure and can easily become out-of-date when there are updates on the page. Cause The target element did not exist on the page when the waitForAndFindElement(<locator>, <timeout>) function was called. This may be caused by the target page not being in the expected state. Common reasons for this error include: There is a legitimate issue with the target site. The element locator being used is incorrect. The target site has changed, requiring the revision of the Synthetics script. The previous action in the script did not successfully complete, causing the page to be in an unexpected state when the subsequent waitForAndFindElement() call was initiated. TimeoutError: Page load timed-out (unable to finish all network requests on time) Problem The target page loaded successfully, but returned the error: TimeoutError: Page load timed-out (unable to finish all network requests on time) Solution If the failures began suddenly, investigate any requests that could be blocking or delaying the page load event. If you are unsure which request is causing the error, use the timeline view to identify any long running HTTP requests. If the page is frequently unable to fully load within the current timeout, set a custom page load timeout using the $browser.manage().timeouts().pageLoadTimeout(ms: number) function. Cause The target page loaded successfully, but the page load event was not fired within the page load timeout set in the .pageLoadTimeout() function. There are a number of reasons you could see this error message, including: A blocked resource request on the page held up the page load. A resource request processed slower than normal due to an underlying network issue. A dependent resource on the page blocked the iframe load event. TypeError: $browser.isElementPresent is not a function Problem The function isElementPresent(), used by Synthetics monitors with a runtime >= 0.5.0, has been deprecated in Selenium 3. Solution To continue to use this function after depreciation you will need to create a custom version of this function, such as: return $browser.findElements(ele).then(function(found) { return found.length > 0; }); } Copy Example usage, which would return true: $browser .get(\"https://www.newrelic.com\") .then(function() { return isElementPresent($driver.By.id(\"nav_signup\")); }) .then(function(found) { return console.log(found); }); Copy Cause This can occur when attempting to use a scripted browser monitor script from an older monitor ( < = 0.4.1 runtime) with a newer monitor ( >= 0.5.0) runtime. Scripted API monitor errors JobTimeoutError: Job timed-out after 180s Problem The scripted monitor run reached the 180 second non-configurable timeout threshold, and the run was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assign the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. NetworkError: Monitor produced no traffic Problem The API test or scripted browser monitor appears to be running but is returning this error. Solution Ensure that $http.get() or $browser.get() are being called appropriately and are generating traffic. For Scripted API monitors, if you are using a request option to spin up an un-instrumented HTTP agent under the hood, specify one of our instrumented HTTP agents using either of the agent request options below: $globalAgents.http $globalAgents.https Example: var options = { uri: 'https://www.newrelic.com', agent: $globalAgents.https, agentOptions: { 'rejectUnauthorized': false }, strictSSL: false }; function callback(err, res, body) { ... }; $http.get(options, callback); Copy Cause This occurs in scripted monitor runs when the HTTP client ($http in scripted api monitors) or Chrome browser ($browser in scripted browser monitors) is not used to generate HTTP traffic. In some cases, certain request options in API monitors may force a new HTTP agent, one that is not instrumented by Synthetics, to be used to collect HTTP traffic. ReferenceError: $network is not defined Problem The $network object used for setting monitor proxies is not available for that monitor’s runtime. Solution If your monitor was created before the 0.4.0 runtime release, create a new monitor to take advantage of the latest runtime. Your monitor’s current runtime version is shown at the top of the Monitor Settings page. For more information, see Scripted monitor version runtime environments. Cause This error occurs when attempting to use $network on a monitor with a runtime at or below 0.2.2. Proxying monitor traffic was introduced in monitor runtime version 0.4.0, causing this method to be evaluated as undefined on earlier monitor runtimes. ScriptTimeoutError Problem This error indicates that the job has reached the Docker container timeout threshold, and the script was terminated. Solution If this is a frequent error, consider breaking up the scripted tasks into a separate scripted monitors. If it appears that a specific task is causing the job to wait an unacceptable amount of time, consider changing the method by which you’re accomplishing that task. For example, changing $browser.findElement(locator: $driver.Locator) to $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) would assigned the task its own configurable timeout. If you have multiple steps where the $browser.waitForAndFindElement(locator, timeout) function is called, ensure that the the sum of the provided timeouts to these steps does not exceed 180 seconds. If you’re finding it difficult to accomplish this, then that is a sign that the monitor should probably be broken up into separate monitor scripts. Cause All synthetic scripted monitors have a non-configurable maximum global 180s timeout for running a script. If a script has not completed after 180 seconds, the job is terminated. If this happens consistently it could be a sign of a script that is taking too long to complete, or that the job is waiting an extended period of time while attempting to perform a scripted task. SyntaxError: Unexpected token < Problem JSON.parse() was passed a string that begins with the < character and is likely HTML, instead of JSON. Solution Ensure the target endpoint is returning the expected response body. You can do this by logging the response body in the callback, before attempting to parse. Example: $http.get('http://www.newrelic.com', function(error, response, body) { if (error) { throw new Error(error); } console.log(body); // Log HTML response body, don't parse as JSON }); Copy Depending on the target API endpoint, you may need to include specific request headers to ensure that JSON is returned. Cause The script is attempting to use JSON.parse() on a response body after a request is made and is expecting the endpoint to return JSON, but HTML was returned instead. SyntaxError: Unexpected token u in JSON at position 0 Problem JSON.parse() was passed an undefined parameter, but expected a JSON string. Solution Troubleshoot the cause of the request error. Details on what is causing request errors can be found in the error object passed to the request callback function. Example: $http.get('http://www.newrelic.com', function(error, response, body) { if (error) { throw new Error(error); } var bodyJson = JSON.parse(body); console.log(bodyJson); // Log response body }); Copy Cause This can occur in Scripted API monitors when a performing an API request, then attempting to parse the request response within the callback function. The response body is passed to JSON.parse() without checking if the response body is undefined first. An undefined response body is often caused by a request error. If there is no error handling to prevent code that parses the response body, this monitor failure will occur. TypeError: Cannot read property 'statusCode' of undefined Problem The response object (and thus response.statusCode) in an API request callback is undefined. Solution Troubleshoot the cause of the request error. Details on what is causing request errors can be found in the error object passed to the request callback function. Example: $http.get('http://www.newrelic.com', function(error, response, body) { if (error) { throw new Error(error); } console.log(response.statusCode); }); Copy Cause This error occurs when there was an error completing the API request (for example, unable to reach server, unable to resolve DNS). In these instances, the request was not completed so the response object in the callback function arguments is undefined. If there is no error handling to prevent code that checks response status code, this monitor failure will occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.73018,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "NetworkError: <em>Monitor</em> produced no traffic",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " that is not instrumented by <em>synthetic</em> <em>monitoring</em>, to be used to collect HTTP traffic. ReferenceError: $network is not defined Problem The $network object used for setting <em>monitor</em> proxies is not available for that <em>monitor</em>’s runtime. Solution If your <em>monitor</em> was created before the 0.4.0 runtime release"
      },
      "id": "603ea832196a67c147a83de7"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors": [
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-25T18:28:53Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-25T18:04:49Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.75371,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    },
    {
      "sections": [
        "Store secure credentials for scripted browsers and API tests",
        "Requirements and limits",
        "Add or update secure credentials",
        "Update the script",
        "Security for secure credentials",
        "Redacted information"
      ],
      "title": "Store secure credentials for scripted browsers and API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ee8bec412a7cb3223e6164d653ca9fc9307e672a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests/",
      "published_at": "2021-12-25T18:04:49Z",
      "updated_at": "2021-10-13T00:42:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use secure credentials with synthetic monitoring to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted monitor users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). You can set secure credentials in New Relic One or with the API. Requirements and limits Before using secure credentials, review these requirements and guidelines: Secure credentials Comments Applicable monitors The secure credentials feature is available only for synthetic scripted browsers and API test monitors. Permissions Account administrators can control which users can create, view, or delete secure credentials by managing users' permissions. Limit You can have a maximum of 1,000 secure credentials. Add or update secure credentials You can add or update secure credentials using the UI or the Synthetics REST API. To add, view, edit, or delete a secure credential for a scripted browser or API test monitor from the UI: Go to one.newrelic.com > Synthetics > Secure credentials. To add a new secure credential, look for the Create secure credential + button. If you have credentials already added, this button is at the top right. Tips for creating the Key: choose a username or other meaningful key name to identify the secure credential. Use alphanumeric or underscore _ characters. Key names must be UPPERCASE. Tips for creating the Value: Use any combination of alphanumeric or special characters. 10000 characters maximum. This field is not accessible via the API. To edit an existing credential, click the ellipsis icon for options. Associate the secure credential with a scripted browser or API test by editing the script. After you add the secure credential to the script, the Secure credentials UI shows how many scripted monitors use that credential. This number is approximate and only updates after a monitor with a secure credential has actually been run. Update the script When using the Synthetics UI editor to create scripted browsers or API test monitors, follow these guidelines: Script Guidelines Format Anywhere in the script where you reference the secure credential, it is accessed via the reserved New Relic $secure JavaScript object with dot notation. For example, $secure.MY_SECURE_CREDENTIAL. Properties on $secure are not accessible through bracket notation. Existing credentials To view or select from a list of available secure credentials: Type $secure. OR Select from the dropdown in the editor UI. Validation To validate the secure credential, follow standard procedures to test the script or write an API test. Any changes to the secure credential's value will automatically take effect across all monitors that use it. You do not need to also update the script. Exception: If you update the script and jobs are already processing, the secure credential change will not take effect until the next time the job begins. Security for secure credentials To ensure the security of your secure credentials, New Relic scrubs the secure value out of all data that goes to results in synthetic monitoring data and alerts. New Relic employees cannot access secure credential values and must be added to the account to be able to view secure credentials. Example A secure credential is named PASSWORD and the value is Pass123!. New Relic replaces Pass123! with _SECURECREDENTIAL_ For example, a script includes: $browser.get(\"https://example.com/\" + $secure.PASSWORD) Copy The script results will show that New Relic Synthetics went to https://example.com/_SECURECREDENTIAL_, even though it actually went to https://example.com/Pass123!. This ensures the value of the secure credential will not appear in the results. Redacted information We currently redact the following from the results of your monitor: The exact values of your secure credentials Any percent-encoded values of your secure credentials",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.15933,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can <em>use</em> secure credentials with <em>synthetic</em> <em>monitoring</em> to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted <em>monitor</em> users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely"
      },
      "id": "60452772196a67195c960f3b"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/alerts-synthetic-monitoring": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-25T17:22:28Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.0944,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-25T18:28:53Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-25T18:04:49Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.75371,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/collect-synthetic-transaction-traces": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-25T17:22:28Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.09439,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-25T18:28:53Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-25T18:04:49Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.75371,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/handle-sites-authentication": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-25T17:22:28Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.09439,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-25T18:28:53Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-25T18:04:49Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.75371,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/manage-monitor-runtimes": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-25T17:22:28Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.09439,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-25T18:28:53Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-25T18:04:49Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.75371,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-25T17:22:28Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.09439,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-25T18:28:53Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Store secure credentials for scripted browsers and API tests",
        "Requirements and limits",
        "Add or update secure credentials",
        "Update the script",
        "Security for secure credentials",
        "Redacted information"
      ],
      "title": "Store secure credentials for scripted browsers and API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ee8bec412a7cb3223e6164d653ca9fc9307e672a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests/",
      "published_at": "2021-12-25T18:04:49Z",
      "updated_at": "2021-10-13T00:42:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use secure credentials with synthetic monitoring to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted monitor users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). You can set secure credentials in New Relic One or with the API. Requirements and limits Before using secure credentials, review these requirements and guidelines: Secure credentials Comments Applicable monitors The secure credentials feature is available only for synthetic scripted browsers and API test monitors. Permissions Account administrators can control which users can create, view, or delete secure credentials by managing users' permissions. Limit You can have a maximum of 1,000 secure credentials. Add or update secure credentials You can add or update secure credentials using the UI or the Synthetics REST API. To add, view, edit, or delete a secure credential for a scripted browser or API test monitor from the UI: Go to one.newrelic.com > Synthetics > Secure credentials. To add a new secure credential, look for the Create secure credential + button. If you have credentials already added, this button is at the top right. Tips for creating the Key: choose a username or other meaningful key name to identify the secure credential. Use alphanumeric or underscore _ characters. Key names must be UPPERCASE. Tips for creating the Value: Use any combination of alphanumeric or special characters. 10000 characters maximum. This field is not accessible via the API. To edit an existing credential, click the ellipsis icon for options. Associate the secure credential with a scripted browser or API test by editing the script. After you add the secure credential to the script, the Secure credentials UI shows how many scripted monitors use that credential. This number is approximate and only updates after a monitor with a secure credential has actually been run. Update the script When using the Synthetics UI editor to create scripted browsers or API test monitors, follow these guidelines: Script Guidelines Format Anywhere in the script where you reference the secure credential, it is accessed via the reserved New Relic $secure JavaScript object with dot notation. For example, $secure.MY_SECURE_CREDENTIAL. Properties on $secure are not accessible through bracket notation. Existing credentials To view or select from a list of available secure credentials: Type $secure. OR Select from the dropdown in the editor UI. Validation To validate the secure credential, follow standard procedures to test the script or write an API test. Any changes to the secure credential's value will automatically take effect across all monitors that use it. You do not need to also update the script. Exception: If you update the script and jobs are already processing, the secure credential change will not take effect until the next time the job begins. Security for secure credentials To ensure the security of your secure credentials, New Relic scrubs the secure value out of all data that goes to results in synthetic monitoring data and alerts. New Relic employees cannot access secure credential values and must be added to the account to be able to view secure credentials. Example A secure credential is named PASSWORD and the value is Pass123!. New Relic replaces Pass123! with _SECURECREDENTIAL_ For example, a script includes: $browser.get(\"https://example.com/\" + $secure.PASSWORD) Copy The script results will show that New Relic Synthetics went to https://example.com/_SECURECREDENTIAL_, even though it actually went to https://example.com/Pass123!. This ensures the value of the secure credential will not appear in the results. Redacted information We currently redact the following from the results of your monitor: The exact values of your secure credentials Any percent-encoded values of your secure credentials",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.15933,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can <em>use</em> secure credentials with <em>synthetic</em> <em>monitoring</em> to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted <em>monitor</em> users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely"
      },
      "id": "60452772196a67195c960f3b"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/recheck-failed-monitors": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-25T17:22:28Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.09438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-25T18:28:53Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-25T18:04:49Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.75371,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-25T17:22:28Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.09438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-25T18:28:53Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-25T18:04:49Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.75371,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    }
  ]
}