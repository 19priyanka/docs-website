{
  "/docs/service-level-management/consume-slm": [
    {
      "sections": [
        "Service Levels Management: Questions and next steps",
        "BETA FEATURE",
        "What permissions do I need to use New Relic's Service Levels?",
        "How do I get support from New Relic during the public beta?",
        "Why don’t I see any data right after I create an SLI?",
        "Can I configure an SLI on any entity type?",
        "Can I get alerts on SLI data?",
        "How does New Relic calculate the remaining error budget?"
      ],
      "title": "Service Levels Management: Questions and next steps",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started",
        "Service Level Management"
      ],
      "external_id": "262058f4dc430fbaee0382261f79de147e348f53",
      "image": "",
      "url": "https://docs.newrelic.com/docs/service-level-management/faqs-slm/",
      "published_at": "2021-12-10T10:53:28Z",
      "updated_at": "2021-12-04T09:53:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic's Service Levels? To use New Relic's Service Levels and see SLO results, you need a full platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify events to metric rules. If you get the following errors, check your user permissions: The UI has disabled the option to save an SLI/SLO. The API returns the error message “Cannot query field \\\"eventExportRegisterRule\\\" on type \\\"RootMutationType\\\".”. How do I get support from New Relic during the public beta? Service Levels Management is in public beta, and no official support is offered yet through the Support portal. If you have general questions and feedback, please post them on the Explorers Hub. New Relic’s community and the product team will be glad to help you there. If you have suggestions about documentation, please suggest an improvement or send your contribution using the Create issue or Edit page buttons on the top right corner in the docs UI. Why don’t I see any data right after I create an SLI? New Relic starts generating new SLI metrics from the moment that you create an SLI. This is why we need a few minutes before we can start showing the first meaningful SLI attainment results. The benefit of the new data is that it has 13 month retention by default, and it’s more efficient to query for long periods of time. Can I configure an SLI on any entity type? Yes, you can configure an SLI on any entity type, such as an APM service, a browser application, or a Lambda function. SLI queries support NRDB events. Support for dimensional metrics on SLI queries is on our roadmap. Can I get alerts on SLI data? Alerts on New Relic's Service Levels are on our roadmap. How does New Relic calculate the remaining error budget? The remaining error budget indicates what percentage of requests could still have a bad response over the SLO period without compromising the objective. Therefore, the total amount of tolerated bad responses will vary with the throughput of requests. Time-based error budgets are on our roadmap.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 474.5638,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Service</em> <em>Levels</em> <em>Management</em>: Questions and next steps",
        "sections": "<em>Service</em> <em>Levels</em> <em>Management</em>: Questions and next steps",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic&#x27;s <em>Service</em> Levels? To use New Relic&#x27;s <em>Service</em> Levels and see <em>SLO</em> results, you need a <em>full</em> platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify"
      },
      "id": "61ab3a9d28ccbc492ac23ee2"
    },
    {
      "sections": [
        "Configure Service Levels via the NerdGraph API",
        "BETA FEATURE",
        "Important",
        "Create an SLI with an SLO",
        "Retrieve the configuration of an SLI for an APM service",
        "Update the SLOs of an SLI"
      ],
      "title": "Configure Service Levels via the NerdGraph API",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Service Level Management",
        "SLI/SLO",
        "Configure",
        "Consume",
        "NerdGraph"
      ],
      "external_id": "bbc11b33aca5f3cd12d3c6217d44ad9d5f7b5daa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-slm/",
      "published_at": "2021-12-10T10:54:10Z",
      "updated_at": "2021-12-04T09:46:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. With New Relic you can implement Service Levels for your applications, consume the results easily from the UI during your planning sessions and incident response, and progressively iterate on the configuration to adjust your objectives to the desired user experience. Besides the UI, you can also use our NerdGraph API Explorer to create and edit of SLIs and their SLOs. Alternatively, you can automate this configuration using the Terraform Service Level resource. Important In order to create Service Levels, the API key needs a role with permissions to modify and delete metric rules. Create an SLI with an SLO Please refer to Create and edit SLIs and SLOs to learn the basic concepts in the SLI and SLO configuration, such as the entity that an SLI is associated with. Also, you can refer to that documentation to find examples of the most common indicators for APM services and browser applications. The following is an example NerdGraph call that creates an SLI using the serviceLevelCreate mutation query: mutation { serviceLevelCreate( entityGuid: \"entityGuid\", indicator: { name: \"Latency below 0.25 seconds\", description: \"The proportion of valid requests that were served faster than 0.25s, which is considered to correspond to a good experience.\", events: { validEvents: { from: \"Transaction\", where: \"entityGuid = 'entityGuid'\" }, goodEvents: { from: \"Transaction\", where: \"entityGuid = 'entityGuid' and duration < 0.25\" }, accountId: accountId}, objectives: { target: 99.5, timeWindow: { rolling: { count: 7, unit: DAY }}}}) { id description } } Copy It contains these fields: entityGuid: The GUID of the entity (for example, APM service, browser application, etc.) that you want to relate this SLI to. On the UI, you can find this GUID on the entity page, under See metadata and manage tags. description: Use detailed descriptions, including the selected threshold that determines good events. For example, for an availability SLI, include something like “The proportion of valid requests that were served without errors.” Or, for a latency SLI, include a description such as “The proportion of valid requests that were served faster than 0.25s, which is considered to correspond to a good experience”. accountId: The ID of the account where the APM service or browser application belongs to, which contains the NRDB data for the SLI/SLO calculations. badEvents.from, badEvents.where The NRQL query that defines bad events, SELECT count(*) FROM badEvents.from WHERE badEvents.where, requires these FROM and WHERE clauses. If you defined an SLI from valid and bad events, leave the goodEvents object empty. goodEvents.from, goodEvents.where The NRQL query that defines good events, SELECT count(*) FROM goodEvents.from WHERE goodEvents.where, requires these FROM and WHERE clauses. If you defined an SLI from valid and good events, leave the badEvents object empty. validEvents.from, validEvents.where These are the FROM and WHERE clauses for the NRQL query that defines valid events, which will result in SELECT count(*) FROM validEvents.from WHERE validEvents.where. name: A short category name for your SLI to help understand what the Service Level is about. We suggest including any specific parameters and filters involved in the SLI definition. Examples: Availability Latency below 4 seconds CLS for desktops below 0.1 objectives: An array of objectives (SLOs) for the SLI. target: The target for your SLO, up to 100.00. The field supports up to 5 decimals. If your users are happy with the current experience, set the SLO percentage to match the current baseline. For instance, the percentile used to determine the SLI's good events. timeWindow.rolling.count: The length of the period taken into consideration to calculate the SLO. The supported values are 1, 7, 14, 28, and 30. timeWindow.rolling.unit: DAYis the supported value. Retrieve the configuration of an SLI for an APM service Use this query to retrieve the configuration of an SLI, including its id. { actor { entity(guid: \"entityGuid\") { guid name serviceLevel { indicators { createdAt createdBy { email } description entityGuid id name objectives { target timeWindow { rolling { count unit } } } } } } } } Copy Update the SLOs of an SLI Use the serviceLevelUpdate mutation to define one or more SLOs for each one of the SLIs. To obtain the SLI's id, use the query above. mutation { serviceLevelUpdate( id: \"indicators.id\", indicator: { objectives: { target: 99.00, timeWindow: { rolling: { count: 7, unit: DAY }}}}) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 456.4144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure <em>Service</em> <em>Levels</em> via the NerdGraph API",
        "sections": "Configure <em>Service</em> <em>Levels</em> via the NerdGraph API",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": " indicators for APM services and browser applications. The following is an example NerdGraph call that creates an <em>SLI</em> using the <em>serviceLevel</em>Create mutation query: mutation { <em>serviceLevel</em>Create( entityGuid: &quot;entityGuid&quot;, indicator: { name: &quot;Latency below 0.25 seconds&quot;, description: &quot;The proportion"
      },
      "id": "61ab38e028ccbcf9dbc25413"
    },
    {
      "sections": [
        "Get started with New Relic's Service Levels Management",
        "BETA FEATURE",
        "What are SLIs and SLOs?",
        "Service Levels and APM SLA reports",
        "What's next?"
      ],
      "title": "Get started with New Relic's Service Levels Management",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started",
        "Service Level Management"
      ],
      "external_id": "c3da65667ad9557562bd537c738309d80d3f31ee",
      "image": "https://docs.newrelic.com/static/a0a3554edde9777dc70c4ee8281fddd6/01e7c/slm1_1.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/intro-slm/",
      "published_at": "2021-12-12T01:44:07Z",
      "updated_at": "2021-12-02T01:44:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. With New Relic you can define and consume service level indicators and service level objectives for your applications. What are SLIs and SLOs? Service Levels are used to measure the performance of a service from the end user (or client application) point of view. For instance, a Service Level can represent whether a video loaded quickly enough, or whether a directions service returned at least one possible route between two points. Service level indicators (SLIs) are accurate quantitative measures of the user experience as described by a service level. They represent a proportion of successful outputs, and therefore they’re expressed as a percentage (%). For example, an SLI can measure the proportion of requests that were faster than some threshold, or the proportion of records coming into a pipeline that resulted in the correct value coming out. And while users understand that a video might take a few additional seconds to load, or that an application might return an error from time to time, this shouldn’t happen often if you don’t want to lose their trust. Therefore, once you’ve defined SLIs for the performance aspects that are most relevant for the end users of your services, you need to set SLOs to track that the service is meeting their expectations. Service level objectives (SLOs) are defined as a target value that an SLI must meet over a period of time. For example, videos must start playing in less than 2 seconds 99% of the time over a week period. Please refer to the Service Level management use case implementation guide to learn more about identifying service boundaries and deploying the instrumentation that your service levels will be based on. Service Levels and APM SLA reports New Relic has provided automatic SLA Reports for APM Services for a long time. The Apdex-based reports, which you can get on your email inbox on Mondays, are automatically generated for services that produce web transactions, and are useful to see trends over time. On top of the SLAs, our new SLM level capability is better aligned with modern service level best practices, such as those promoted by the Google SRE Handbook, and provides new, improved functionality: SLIs can be defined on any NRDB event that is reported to New Relic, not just APM transactions. Therefore you can also base SLIs on your own custom events. You can decide which service boundaries and which metrics are relevant for your service levels, and you can set your own objectives. You can view SLO results across your accounts, and within your workloads. What's next? Ready to get started? If you don't already have one, sign up for a free New Relic account. You can find Service Levels in several places in New Relic One: At the top nav bar, under the More menu (which you can customize). At the previews of those entities that have an SLI defined. In APM services, at the reports section. Within a workload, at the Service Levels tab. Carry on and read our docs on how to create and consume SLIs and SLOs. You can also check out how to manage SLMs with our API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 396.47656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with New Relic&#x27;s <em>Service</em> <em>Levels</em> <em>Management</em>",
        "sections": "Get started with New Relic&#x27;s <em>Service</em> <em>Levels</em> <em>Management</em>",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": "BETA FEATURE This feature is currently in beta. With New Relic you can define and <em>consume</em> <em>service</em> <em>level</em> indicators and <em>service</em> <em>level</em> objectives for your applications. What are SLIs and SLOs? <em>Service</em> Levels are used to measure the performance of a <em>service</em> from the end user (or client application"
      },
      "id": "61a824fe28ccbcc5e3c22dc5"
    }
  ],
  "/docs/service-level-management/create-slm": [
    {
      "sections": [
        "Service Levels Management: Questions and next steps",
        "BETA FEATURE",
        "What permissions do I need to use New Relic's Service Levels?",
        "How do I get support from New Relic during the public beta?",
        "Why don’t I see any data right after I create an SLI?",
        "Can I configure an SLI on any entity type?",
        "Can I get alerts on SLI data?",
        "How does New Relic calculate the remaining error budget?"
      ],
      "title": "Service Levels Management: Questions and next steps",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started",
        "Service Level Management"
      ],
      "external_id": "262058f4dc430fbaee0382261f79de147e348f53",
      "image": "",
      "url": "https://docs.newrelic.com/docs/service-level-management/faqs-slm/",
      "published_at": "2021-12-10T10:53:28Z",
      "updated_at": "2021-12-04T09:53:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic's Service Levels? To use New Relic's Service Levels and see SLO results, you need a full platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify events to metric rules. If you get the following errors, check your user permissions: The UI has disabled the option to save an SLI/SLO. The API returns the error message “Cannot query field \\\"eventExportRegisterRule\\\" on type \\\"RootMutationType\\\".”. How do I get support from New Relic during the public beta? Service Levels Management is in public beta, and no official support is offered yet through the Support portal. If you have general questions and feedback, please post them on the Explorers Hub. New Relic’s community and the product team will be glad to help you there. If you have suggestions about documentation, please suggest an improvement or send your contribution using the Create issue or Edit page buttons on the top right corner in the docs UI. Why don’t I see any data right after I create an SLI? New Relic starts generating new SLI metrics from the moment that you create an SLI. This is why we need a few minutes before we can start showing the first meaningful SLI attainment results. The benefit of the new data is that it has 13 month retention by default, and it’s more efficient to query for long periods of time. Can I configure an SLI on any entity type? Yes, you can configure an SLI on any entity type, such as an APM service, a browser application, or a Lambda function. SLI queries support NRDB events. Support for dimensional metrics on SLI queries is on our roadmap. Can I get alerts on SLI data? Alerts on New Relic's Service Levels are on our roadmap. How does New Relic calculate the remaining error budget? The remaining error budget indicates what percentage of requests could still have a bad response over the SLO period without compromising the objective. Therefore, the total amount of tolerated bad responses will vary with the throughput of requests. Time-based error budgets are on our roadmap.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 512.45355,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Service</em> <em>Levels</em> <em>Management</em>: Questions and next steps",
        "sections": "<em>Service</em> <em>Levels</em> <em>Management</em>: Questions and next steps",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic&#x27;s <em>Service</em> Levels? To use New Relic&#x27;s <em>Service</em> Levels and see <em>SLO</em> results, you need a <em>full</em> platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify"
      },
      "id": "61ab3a9d28ccbc492ac23ee2"
    },
    {
      "sections": [
        "Configure Service Levels via the NerdGraph API",
        "BETA FEATURE",
        "Important",
        "Create an SLI with an SLO",
        "Retrieve the configuration of an SLI for an APM service",
        "Update the SLOs of an SLI"
      ],
      "title": "Configure Service Levels via the NerdGraph API",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Service Level Management",
        "SLI/SLO",
        "Configure",
        "Consume",
        "NerdGraph"
      ],
      "external_id": "bbc11b33aca5f3cd12d3c6217d44ad9d5f7b5daa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-slm/",
      "published_at": "2021-12-10T10:54:10Z",
      "updated_at": "2021-12-04T09:46:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. With New Relic you can implement Service Levels for your applications, consume the results easily from the UI during your planning sessions and incident response, and progressively iterate on the configuration to adjust your objectives to the desired user experience. Besides the UI, you can also use our NerdGraph API Explorer to create and edit of SLIs and their SLOs. Alternatively, you can automate this configuration using the Terraform Service Level resource. Important In order to create Service Levels, the API key needs a role with permissions to modify and delete metric rules. Create an SLI with an SLO Please refer to Create and edit SLIs and SLOs to learn the basic concepts in the SLI and SLO configuration, such as the entity that an SLI is associated with. Also, you can refer to that documentation to find examples of the most common indicators for APM services and browser applications. The following is an example NerdGraph call that creates an SLI using the serviceLevelCreate mutation query: mutation { serviceLevelCreate( entityGuid: \"entityGuid\", indicator: { name: \"Latency below 0.25 seconds\", description: \"The proportion of valid requests that were served faster than 0.25s, which is considered to correspond to a good experience.\", events: { validEvents: { from: \"Transaction\", where: \"entityGuid = 'entityGuid'\" }, goodEvents: { from: \"Transaction\", where: \"entityGuid = 'entityGuid' and duration < 0.25\" }, accountId: accountId}, objectives: { target: 99.5, timeWindow: { rolling: { count: 7, unit: DAY }}}}) { id description } } Copy It contains these fields: entityGuid: The GUID of the entity (for example, APM service, browser application, etc.) that you want to relate this SLI to. On the UI, you can find this GUID on the entity page, under See metadata and manage tags. description: Use detailed descriptions, including the selected threshold that determines good events. For example, for an availability SLI, include something like “The proportion of valid requests that were served without errors.” Or, for a latency SLI, include a description such as “The proportion of valid requests that were served faster than 0.25s, which is considered to correspond to a good experience”. accountId: The ID of the account where the APM service or browser application belongs to, which contains the NRDB data for the SLI/SLO calculations. badEvents.from, badEvents.where The NRQL query that defines bad events, SELECT count(*) FROM badEvents.from WHERE badEvents.where, requires these FROM and WHERE clauses. If you defined an SLI from valid and bad events, leave the goodEvents object empty. goodEvents.from, goodEvents.where The NRQL query that defines good events, SELECT count(*) FROM goodEvents.from WHERE goodEvents.where, requires these FROM and WHERE clauses. If you defined an SLI from valid and good events, leave the badEvents object empty. validEvents.from, validEvents.where These are the FROM and WHERE clauses for the NRQL query that defines valid events, which will result in SELECT count(*) FROM validEvents.from WHERE validEvents.where. name: A short category name for your SLI to help understand what the Service Level is about. We suggest including any specific parameters and filters involved in the SLI definition. Examples: Availability Latency below 4 seconds CLS for desktops below 0.1 objectives: An array of objectives (SLOs) for the SLI. target: The target for your SLO, up to 100.00. The field supports up to 5 decimals. If your users are happy with the current experience, set the SLO percentage to match the current baseline. For instance, the percentile used to determine the SLI's good events. timeWindow.rolling.count: The length of the period taken into consideration to calculate the SLO. The supported values are 1, 7, 14, 28, and 30. timeWindow.rolling.unit: DAYis the supported value. Retrieve the configuration of an SLI for an APM service Use this query to retrieve the configuration of an SLI, including its id. { actor { entity(guid: \"entityGuid\") { guid name serviceLevel { indicators { createdAt createdBy { email } description entityGuid id name objectives { target timeWindow { rolling { count unit } } } } } } } } Copy Update the SLOs of an SLI Use the serviceLevelUpdate mutation to define one or more SLOs for each one of the SLIs. To obtain the SLI's id, use the query above. mutation { serviceLevelUpdate( id: \"indicators.id\", indicator: { objectives: { target: 99.00, timeWindow: { rolling: { count: 7, unit: DAY }}}}) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 456.41425,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Configure</em> <em>Service</em> <em>Levels</em> via the NerdGraph API",
        "sections": "<em>Configure</em> <em>Service</em> <em>Levels</em> via the NerdGraph API",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": " indicators for APM services and browser applications. The following is an example NerdGraph call that creates an <em>SLI</em> using the <em>serviceLevel</em>Create mutation query: mutation { <em>serviceLevel</em>Create( entityGuid: &quot;entityGuid&quot;, indicator: { name: &quot;Latency below 0.25 seconds&quot;, description: &quot;The proportion"
      },
      "id": "61ab38e028ccbcf9dbc25413"
    },
    {
      "sections": [
        "Consume Service Levels",
        "BETA FEATURE",
        "Check your SLOs state",
        "Understand Service Levels details",
        "Good and bad responses",
        "SLI attainment over time (%)",
        "Compliance over the period",
        "Remaining error budget (Requests)",
        "SLI attainment over time and SLO target (%)",
        "Analyze bad responses"
      ],
      "title": "Consume Service Levels",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Service Level Management",
        "SLI/SLO",
        "Consume"
      ],
      "external_id": "2b1e77937fb81e4b43d6f81d660e53f1cbbb5f80",
      "image": "https://docs.newrelic.com/static/5ecaa57f52ed11c79de67ea6200443c8/c1b63/sli_card.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/consume-slm/",
      "published_at": "2021-12-09T22:06:47Z",
      "updated_at": "2021-12-04T09:53:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. After you create your set of SLIs and SLOs, New Relic will start generating SLI data. The first results will take a few minutes to appear in the New Relic One UI. Find Service Levels: At the top nav bar, under Service Levels in the More menu (which you can customize). Here you can filter the SLIs by entity tags. At the previews of those entities that have an SLI defined. You can find them all around the UI. For instance, click on an entity from the Explorer's Navigator view. In APM services, at the reports section. In any workload that contains the SLI entity, such as an APM service or browser application. If you want to group SLIs under a certain workload, make sure to add the APM service or browser app to an existing workload, or create a new one. Click on any SLI to open the SLI card, which contains: The entity the SLI refers to, and the SLI name. Each row represents an SLO with: Target and time window. Compliance in the SLO period. Remaining requests error budget. Check your SLOs state Request-based SLOs are determined from SLIs defined as the ratio of the number of good responses to the total number of requests. This means a request-based SLO is met when that ratio meets or exceeds the goal for the SLO compliance period. If the SLO row has a green background, you’re doing good for the period. You may have not served successfully 100% of the requests, but you still have some remaining error budget to consume. If the SLO row has a yellow background, your error budget is closer to being totally consumed, and you should be more cautious for the rest of the period. If the SLO row has a red background, you’ve not reached the target SLO in this period, and you’ve consumed all of your error budget. Be careful if you need to deploy, and plan some work to improve your SLIs. You can click on the SLO to see more data about the entity, such as the golden metrics, the latest deployments, anomalies, and ongoing issues. This data can help you understand when and why you missed the SLO targets. You can define more than one SLO for the same SLI to check how fast you’re consuming the error budget. For instance, if you have an error budget of 0,1% requests for a whole week, you may not want to consume most of it in a single day, or the SLO will be at risk for the rest of the week. Understand Service Levels details We provide SLI details for two main purposes: For SLO analysis: See in which time ranges the SLO targets were missed. For SLI/SLO configuration and fine tuning: Learn how New Relic calculated SLO values. The SLI card contains the following charts: Good and bad responses These are the key concepts to analyze Service Levels: A valid request is any request that you want to count as meaningful for your SLIs. A good response is any response that you consider to provide a good experience (for example, the service responded in less than 2 seconds, providing a good navigation experience for the end user). A bad response is any response that you consider to provide a bad experience (like the service responded with a server error, interrupting the user's flow). This chart shows the total number of valid requests that your service received, broken down by good or bad. This chart shows the actual throughput of your service, which you can use to see if there’s any correlation between the increase of throughput and bad responses. SLI attainment over time (%) It's the proportion of what you consider good responses over time. The line should stay close to 100%, meaning that most requests were served successfully. Compliance over the period It's the ratio of good events (responses) to total events (requests), measured over the SLO compliance period. The closer to 100%, the closer your service is to meet the SLO target over the period. When this percentage goes below the SLO target, the chart will turn red: You need to put more effort in reliability. Remaining error budget (Requests) The error budget is an alternative way to read the SLO. It indicates what percentage of requests could still have a bad response over the SLO period, without compromising the objective. As the total amount of tolerated bad responses will vary with the request throughput, New Relic shows the percentage of remaining error budget: As long as the remaining error budget is above 25%, you'll see green, and your SLO is good. When the error budget goes below 25%, it will turn yellow. This means you’re close to burning the whole budget for the period. You may want to be more careful with new deployments and changes, and plan for some reliability work. Once the error budget is completely spent, it will show in red. SLI attainment over time and SLO target (%) The last chart shows two time series: the (SLI attainment over time) [#sli-over-time] , and the SLO target. When the SLI value is below the SLO target,your service is missing the SLO. Use this chart to learn in which time ranges your service missed the SLO target. Analyze bad responses When an SLO is not compliant, you need to analyze the original data to better understand what the impact is for your customer, with a special focus on what went wrong. At the Service Levels page, click the ... menu in any SLI and select Analyze. You'll access the query that represents the original NRDB events used to determine the bad responses which calculate the SLI attainment. You can then use the query builder to facet and filter down the unsuccessful responses by user account, client id, requesting source, etc. to better understand the cause and impact of missing your SLIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 387.62384,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Consume <em>Service</em> <em>Levels</em>",
        "sections": "Consume <em>Service</em> <em>Levels</em>",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": " for the same <em>SLI</em> to check how fast you’re consuming the error budget. For instance, if you have an error budget of 0,1% requests for a whole week, you may not want to consume most of it in a single day, or the <em>SLO</em> will be at risk for the rest of the week. Understand <em>Service</em> Levels details We provide"
      },
      "id": "61ab3a9d28ccbc4b5fc23f44"
    }
  ],
  "/docs/service-level-management/faqs-slm": [
    {
      "sections": [
        "Get started with New Relic's Service Levels Management",
        "BETA FEATURE",
        "What are SLIs and SLOs?",
        "Service Levels and APM SLA reports",
        "What's next?"
      ],
      "title": "Get started with New Relic's Service Levels Management",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started",
        "Service Level Management"
      ],
      "external_id": "c3da65667ad9557562bd537c738309d80d3f31ee",
      "image": "https://docs.newrelic.com/static/a0a3554edde9777dc70c4ee8281fddd6/01e7c/slm1_1.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/intro-slm/",
      "published_at": "2021-12-12T01:44:07Z",
      "updated_at": "2021-12-02T01:44:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. With New Relic you can define and consume service level indicators and service level objectives for your applications. What are SLIs and SLOs? Service Levels are used to measure the performance of a service from the end user (or client application) point of view. For instance, a Service Level can represent whether a video loaded quickly enough, or whether a directions service returned at least one possible route between two points. Service level indicators (SLIs) are accurate quantitative measures of the user experience as described by a service level. They represent a proportion of successful outputs, and therefore they’re expressed as a percentage (%). For example, an SLI can measure the proportion of requests that were faster than some threshold, or the proportion of records coming into a pipeline that resulted in the correct value coming out. And while users understand that a video might take a few additional seconds to load, or that an application might return an error from time to time, this shouldn’t happen often if you don’t want to lose their trust. Therefore, once you’ve defined SLIs for the performance aspects that are most relevant for the end users of your services, you need to set SLOs to track that the service is meeting their expectations. Service level objectives (SLOs) are defined as a target value that an SLI must meet over a period of time. For example, videos must start playing in less than 2 seconds 99% of the time over a week period. Please refer to the Service Level management use case implementation guide to learn more about identifying service boundaries and deploying the instrumentation that your service levels will be based on. Service Levels and APM SLA reports New Relic has provided automatic SLA Reports for APM Services for a long time. The Apdex-based reports, which you can get on your email inbox on Mondays, are automatically generated for services that produce web transactions, and are useful to see trends over time. On top of the SLAs, our new SLM level capability is better aligned with modern service level best practices, such as those promoted by the Google SRE Handbook, and provides new, improved functionality: SLIs can be defined on any NRDB event that is reported to New Relic, not just APM transactions. Therefore you can also base SLIs on your own custom events. You can decide which service boundaries and which metrics are relevant for your service levels, and you can set your own objectives. You can view SLO results across your accounts, and within your workloads. What's next? Ready to get started? If you don't already have one, sign up for a free New Relic account. You can find Service Levels in several places in New Relic One: At the top nav bar, under the More menu (which you can customize). At the previews of those entities that have an SLI defined. In APM services, at the reports section. Within a workload, at the Service Levels tab. Carry on and read our docs on how to create and consume SLIs and SLOs. You can also check out how to manage SLMs with our API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 379.04718,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with New Relic&#x27;s <em>Service</em> <em>Levels</em> <em>Management</em>",
        "sections": "<em>Get</em> <em>started</em> with New Relic&#x27;s <em>Service</em> <em>Levels</em> <em>Management</em>",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": " that are most relevant for the end users of your services, you need to set SLOs to track that the <em>service</em> is meeting their expectations. <em>Service</em> <em>level</em> objectives (SLOs) are defined as a target value that an SLI must meet over a period of time. For example, videos must <em>start</em> playing in less than 2 seconds 99"
      },
      "id": "61a824fe28ccbcc5e3c22dc5"
    },
    {
      "sections": [
        "Consume Service Levels",
        "BETA FEATURE",
        "Check your SLOs state",
        "Understand Service Levels details",
        "Good and bad responses",
        "SLI attainment over time (%)",
        "Compliance over the period",
        "Remaining error budget (Requests)",
        "SLI attainment over time and SLO target (%)",
        "Analyze bad responses"
      ],
      "title": "Consume Service Levels",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Service Level Management",
        "SLI/SLO",
        "Consume"
      ],
      "external_id": "2b1e77937fb81e4b43d6f81d660e53f1cbbb5f80",
      "image": "https://docs.newrelic.com/static/5ecaa57f52ed11c79de67ea6200443c8/c1b63/sli_card.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/consume-slm/",
      "published_at": "2021-12-09T22:06:47Z",
      "updated_at": "2021-12-04T09:53:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. After you create your set of SLIs and SLOs, New Relic will start generating SLI data. The first results will take a few minutes to appear in the New Relic One UI. Find Service Levels: At the top nav bar, under Service Levels in the More menu (which you can customize). Here you can filter the SLIs by entity tags. At the previews of those entities that have an SLI defined. You can find them all around the UI. For instance, click on an entity from the Explorer's Navigator view. In APM services, at the reports section. In any workload that contains the SLI entity, such as an APM service or browser application. If you want to group SLIs under a certain workload, make sure to add the APM service or browser app to an existing workload, or create a new one. Click on any SLI to open the SLI card, which contains: The entity the SLI refers to, and the SLI name. Each row represents an SLO with: Target and time window. Compliance in the SLO period. Remaining requests error budget. Check your SLOs state Request-based SLOs are determined from SLIs defined as the ratio of the number of good responses to the total number of requests. This means a request-based SLO is met when that ratio meets or exceeds the goal for the SLO compliance period. If the SLO row has a green background, you’re doing good for the period. You may have not served successfully 100% of the requests, but you still have some remaining error budget to consume. If the SLO row has a yellow background, your error budget is closer to being totally consumed, and you should be more cautious for the rest of the period. If the SLO row has a red background, you’ve not reached the target SLO in this period, and you’ve consumed all of your error budget. Be careful if you need to deploy, and plan some work to improve your SLIs. You can click on the SLO to see more data about the entity, such as the golden metrics, the latest deployments, anomalies, and ongoing issues. This data can help you understand when and why you missed the SLO targets. You can define more than one SLO for the same SLI to check how fast you’re consuming the error budget. For instance, if you have an error budget of 0,1% requests for a whole week, you may not want to consume most of it in a single day, or the SLO will be at risk for the rest of the week. Understand Service Levels details We provide SLI details for two main purposes: For SLO analysis: See in which time ranges the SLO targets were missed. For SLI/SLO configuration and fine tuning: Learn how New Relic calculated SLO values. The SLI card contains the following charts: Good and bad responses These are the key concepts to analyze Service Levels: A valid request is any request that you want to count as meaningful for your SLIs. A good response is any response that you consider to provide a good experience (for example, the service responded in less than 2 seconds, providing a good navigation experience for the end user). A bad response is any response that you consider to provide a bad experience (like the service responded with a server error, interrupting the user's flow). This chart shows the total number of valid requests that your service received, broken down by good or bad. This chart shows the actual throughput of your service, which you can use to see if there’s any correlation between the increase of throughput and bad responses. SLI attainment over time (%) It's the proportion of what you consider good responses over time. The line should stay close to 100%, meaning that most requests were served successfully. Compliance over the period It's the ratio of good events (responses) to total events (requests), measured over the SLO compliance period. The closer to 100%, the closer your service is to meet the SLO target over the period. When this percentage goes below the SLO target, the chart will turn red: You need to put more effort in reliability. Remaining error budget (Requests) The error budget is an alternative way to read the SLO. It indicates what percentage of requests could still have a bad response over the SLO period, without compromising the objective. As the total amount of tolerated bad responses will vary with the request throughput, New Relic shows the percentage of remaining error budget: As long as the remaining error budget is above 25%, you'll see green, and your SLO is good. When the error budget goes below 25%, it will turn yellow. This means you’re close to burning the whole budget for the period. You may want to be more careful with new deployments and changes, and plan for some reliability work. Once the error budget is completely spent, it will show in red. SLI attainment over time and SLO target (%) The last chart shows two time series: the (SLI attainment over time) [#sli-over-time] , and the SLO target. When the SLI value is below the SLO target,your service is missing the SLO. Use this chart to learn in which time ranges your service missed the SLO target. Analyze bad responses When an SLO is not compliant, you need to analyze the original data to better understand what the impact is for your customer, with a special focus on what went wrong. At the Service Levels page, click the ... menu in any SLI and select Analyze. You'll access the query that represents the original NRDB events used to determine the bad responses which calculate the SLI attainment. You can then use the query builder to facet and filter down the unsuccessful responses by user account, client id, requesting source, etc. to better understand the cause and impact of missing your SLIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 294.19217,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Consume <em>Service</em> <em>Levels</em>",
        "sections": "Consume <em>Service</em> <em>Levels</em>",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": "BETA FEATURE This feature is currently in beta. After you create your set of SLIs and SLOs, New Relic will <em>start</em> generating SLI data. The first results will take a few minutes to appear in the New Relic One UI. Find <em>Service</em> Levels: At the top nav bar, under <em>Service</em> Levels in the More menu (which"
      },
      "id": "61ab3a9d28ccbc4b5fc23f44"
    },
    {
      "sections": [
        "Create and edit SLIs and SLOs",
        "BETA FEATURE",
        "Important",
        "Key concepts to create SLIs and SLOs",
        "The SLI entity",
        "SLI queries",
        "Suggested SLIs",
        "SLIs for APM services",
        "Service availability",
        "Service latency",
        "SLIs for browser applications",
        "Browser app largest contentful paint",
        "Browser app first input delay",
        "Browser app cumulative layout shift",
        "Create and edit Service Levels",
        "Select the SLI data source",
        "Configure the queries",
        "Set the SLO time window and target",
        "Define your SLI",
        "Edit SLIs"
      ],
      "title": "Create and edit SLIs and SLOs",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Service Level Management",
        "SLI/SLO",
        "Configure"
      ],
      "external_id": "ac0e19e3d890a02dde12bd639c55d4bd02a61778",
      "image": "https://docs.newrelic.com/static/fffe62dc00eff1b932b5c76be5730e5a/c1b63/slm_edit_menu.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/create-slm/",
      "published_at": "2021-12-10T06:27:38Z",
      "updated_at": "2021-12-04T09:52:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. You can create SLIs and SLOs manually through the New Relic UI. Alternatively, you can automate the process with our NerdGraph API and the Terraform Service Level resource. Important In order to create Service Levels you need a role with permissions to modify and delete metric rules. Key concepts to create SLIs and SLOs Keep in mind these concepts when defining SLIs and SLOs. The SLI entity In the New Relic ecosystem, SLIs and SLOs are linked to entities, which are all the elements in your stack that report data to us, or that generate data that we have access to. The entity that an SLI is related to determines where the SLI/SLO results show. And the entity's tags help filter down SLI results on the Service Levels view. You can define SLIs on any NRDB event that is reported to New Relic, and therefore you can also base SLIs on custom events. Most custom events are not related to a single New Relic entity, but provide higher level business and user experience insights. In this case, you can still relate the SLI to a specific entity or to a workload. SLI queries SLIs are defined as the percentage of good responses out of the total number of valid requests. Most often you’ll set up your SLIs by defining the valid and good pieces: A valid request is any request that you want to count as meaningful for your SLIs (for example, all transactions related to an endpoint that weren’t initiated by a health check). A good response is any response that you consider to provide a good output for the end-user or client service (for example, the service responded in less than 2 seconds, providing a good navigation experience for the end user). Alternatively, you can define what you consider to be the bad responses instead: A bad response is any response that you consider to provide a bad output (for example, the service responded with a server error, causing the client to fail its flow). New Relic will automatically derive the count of good responses as valid - bad. Request-based SLOs are based on an SLI defined as the ratio of the number of good requests to the total number of requests. A request-based SLO is met when that ratio meets or exceeds the goal for the compliance period. Suggested SLIs In this section you’ll find some SLIs that are typically used to measure the performance of services and browser applications. SLIs for APM services These SLIs are the most common for request-driven services: Service availability Service availability is the ratio of the number of successful responses to the number of all requests. This effectively is an error rate, but you can filter it down, for example removing expected errors. Valid events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Bad events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' AND error IS TRUE Copy Where {entityGuid} is the service's GUID. Service latency A latency SLI measures the proportion of valid requests that were served faster than the threshold established as a good experience. In order to determine that duration threshold, check how the service has been performing in the past weeks, and use that result as a realistic and achievable baseline. Afterwards, you can iterate on the SLI threshold, and align it with a more ambitious performance. To select an appropriate value for the duration condition, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find this duration threshold using the query builder, and use it to determine what you consider to be good events for your SLI: select percentile(duration, 95) from Transaction where entityGuid = '{entityGuid}' since 7 days ago limit max Valid events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Good events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' and duration < {duration} Copy Where {entityGuid} is the service's GUID. Where {duration} is the response time that you consider provides a good experience for your client service or end-user, in seconds. SLIs for browser applications The following SLIs are based on Google’s Browser Core Web Vitals. Browser app largest contentful paint It’s the proportion of valid page views where the largest content element visible in the viewport was rendered faster than the threshold considered to correspond to a good experience. Valid events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Good events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' and largestContentfulPaint<'{largestContentfulPaint}' Copy Where {entityGuid} is the browser app GUID. Where {largestContentfulPaint} is the amount of time (in milliseconds) to render the largest content element visible in the viewport that you consider provides a good experience for your end user. A frequent standard is 4000 ms. To determine a realistic number to use for {largestContentfulPaint} in your environment, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find it by using the query builder: SELECT percentile (largestContentfulPaint,95) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max Browser app first input delay It’s the proportion of page views where the time between a user's first interacion with the page and the time when the browser responds to that interaction is less than a certain threshold. Valid events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Good events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' and firstInputDelay<{firstInputDelay} Copy Where {entityGuid} is the browser app GUID. Where {firstInputDelay} is the amount of time (in milliseconds) the browser should respond in to provide a good experience for your end user. A frequent standard is 300 ms. To determine a realistic number to use for {firstInputDelay} in your environment, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find it by using the query builder: SELECT percentile(firstInputDelay,95) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max facet deviceType Browser app cumulative layout shift It’s the proportion of page views with a good cumulative layout shift (CLS). CLS is described as the total sum of all individual layout shift scores for every unexpected layout shift that occurs during the entire lifespan of the page. A layout shift occurs any time a visible element changes its position from one rendered frame to the next. Valid events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. If you’d like to create separate SLIs to track CLS in desktop and mobile devices separately, add one of these clauses at the end of the field: and deviceType = 'Mobile' and deviceType = 'Desktop' Good events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' and cumulativeLayoutShift < {cumulativeLayoutShift} Copy Where {entityGuid} is the browser app GUID. Where {cumulativeLayoutShift} is a pre-set value. To provide a good user experience, your site should strive to have a CLS score of 0.1 or less. A CLS score of 0.25 or more is considered a poor user experience. If you’ve decided to create separate SLIs to track CLS in desktop and mobile devices separately when you defined the valid events query, add this clause at the end of the field: and deviceType = 'Mobile' and deviceType = 'Desktop' To determine a realistic number to select for {cumulativeLayoutShift} in your environment, one typical practice is to select the 75th percentile of page loads for the last 7 or 15 days, segmented across mobile and desktop devices. Find it by using the query builder: SELECT percentile(cumulativeLayoutShift,75) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max facet deviceType Create and edit Service Levels To create SLIs and SLOs, go to the Service Levels tab at any workload in New Relic One and follow these steps: Select the SLI data source In order to define your new SLI, choose one of these two options: Entity data: Base the SLI on standard data coming from New Relic One agents. This is the most common option. If this is your choice, select the entity (for example, APM service) you want to use. Custom data: Alternatively, you can base the SLI on your custom NRDB events. Use this option when you can't relate the service level data to a specific entity, or when you want to relate the service level directly to a workload. Configure the queries The account where the data is gathered from matches the account of the entity that the SLI refers to. The rest of the fields correspond to the NRDB event that goes into the FROM clause, as well as the WHERE clauses that determine what is a valid and a good/bad event. Please see the section above to know what goes into each field. On the left you’ll see the final queries; and at the bottom you’ll get a preview of the count of valid and good/bad events in the last month. Important SLI queries support NRDB events, but not dimensional metrics yet. Set the SLO time window and target In this step you’ll get a preview of the SLI value. You can add one or more SLOs for this SLI. Just select the length of the time window and the percentage target. The chart on the left will help you anticipate whether the target you’re setting is feasible or if it's often missed. Rolling time-window SLOs are supported. With a rolling time-window, the SLO compliance takes into account the last N days. Every minute, the oldest data drops out of the current calculation and new data replaces it. Define your SLI Select a short name for your SLI that helps you recognize what it’s measuring. Optionally, you may add a description. Edit SLIs After you’ve created an SLI, access the UI and click on the ... menu to edit it:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 294.18832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create and edit <em>Service</em> <em>Levels</em>",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": "BETA FEATURE This feature is currently in beta. You can create SLIs and SLOs manually through the New Relic UI. Alternatively, you can automate the process with our NerdGraph API and the Terraform <em>Service</em> <em>Level</em> resource. Important In order to create <em>Service</em> Levels you need a role with permissions"
      },
      "id": "61ab3a71196a67792ad10bd6"
    }
  ],
  "/docs/service-level-management/intro-slm": [
    {
      "sections": [
        "Service Levels Management: Questions and next steps",
        "BETA FEATURE",
        "What permissions do I need to use New Relic's Service Levels?",
        "How do I get support from New Relic during the public beta?",
        "Why don’t I see any data right after I create an SLI?",
        "Can I configure an SLI on any entity type?",
        "Can I get alerts on SLI data?",
        "How does New Relic calculate the remaining error budget?"
      ],
      "title": "Service Levels Management: Questions and next steps",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started",
        "Service Level Management"
      ],
      "external_id": "262058f4dc430fbaee0382261f79de147e348f53",
      "image": "",
      "url": "https://docs.newrelic.com/docs/service-level-management/faqs-slm/",
      "published_at": "2021-12-10T10:53:28Z",
      "updated_at": "2021-12-04T09:53:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic's Service Levels? To use New Relic's Service Levels and see SLO results, you need a full platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify events to metric rules. If you get the following errors, check your user permissions: The UI has disabled the option to save an SLI/SLO. The API returns the error message “Cannot query field \\\"eventExportRegisterRule\\\" on type \\\"RootMutationType\\\".”. How do I get support from New Relic during the public beta? Service Levels Management is in public beta, and no official support is offered yet through the Support portal. If you have general questions and feedback, please post them on the Explorers Hub. New Relic’s community and the product team will be glad to help you there. If you have suggestions about documentation, please suggest an improvement or send your contribution using the Create issue or Edit page buttons on the top right corner in the docs UI. Why don’t I see any data right after I create an SLI? New Relic starts generating new SLI metrics from the moment that you create an SLI. This is why we need a few minutes before we can start showing the first meaningful SLI attainment results. The benefit of the new data is that it has 13 month retention by default, and it’s more efficient to query for long periods of time. Can I configure an SLI on any entity type? Yes, you can configure an SLI on any entity type, such as an APM service, a browser application, or a Lambda function. SLI queries support NRDB events. Support for dimensional metrics on SLI queries is on our roadmap. Can I get alerts on SLI data? Alerts on New Relic's Service Levels are on our roadmap. How does New Relic calculate the remaining error budget? The remaining error budget indicates what percentage of requests could still have a bad response over the SLO period without compromising the objective. Therefore, the total amount of tolerated bad responses will vary with the throughput of requests. Time-based error budgets are on our roadmap.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 399.96817,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Service</em> <em>Levels</em> <em>Management</em>: Questions and next steps",
        "sections": "<em>Service</em> <em>Levels</em> <em>Management</em>: Questions and next steps",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic&#x27;s <em>Service</em> Levels? To use New Relic&#x27;s <em>Service</em> Levels and see SLO results, you need a <em>full</em> platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify"
      },
      "id": "61ab3a9d28ccbc492ac23ee2"
    },
    {
      "sections": [
        "Consume Service Levels",
        "BETA FEATURE",
        "Check your SLOs state",
        "Understand Service Levels details",
        "Good and bad responses",
        "SLI attainment over time (%)",
        "Compliance over the period",
        "Remaining error budget (Requests)",
        "SLI attainment over time and SLO target (%)",
        "Analyze bad responses"
      ],
      "title": "Consume Service Levels",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Service Level Management",
        "SLI/SLO",
        "Consume"
      ],
      "external_id": "2b1e77937fb81e4b43d6f81d660e53f1cbbb5f80",
      "image": "https://docs.newrelic.com/static/5ecaa57f52ed11c79de67ea6200443c8/c1b63/sli_card.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/consume-slm/",
      "published_at": "2021-12-09T22:06:47Z",
      "updated_at": "2021-12-04T09:53:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. After you create your set of SLIs and SLOs, New Relic will start generating SLI data. The first results will take a few minutes to appear in the New Relic One UI. Find Service Levels: At the top nav bar, under Service Levels in the More menu (which you can customize). Here you can filter the SLIs by entity tags. At the previews of those entities that have an SLI defined. You can find them all around the UI. For instance, click on an entity from the Explorer's Navigator view. In APM services, at the reports section. In any workload that contains the SLI entity, such as an APM service or browser application. If you want to group SLIs under a certain workload, make sure to add the APM service or browser app to an existing workload, or create a new one. Click on any SLI to open the SLI card, which contains: The entity the SLI refers to, and the SLI name. Each row represents an SLO with: Target and time window. Compliance in the SLO period. Remaining requests error budget. Check your SLOs state Request-based SLOs are determined from SLIs defined as the ratio of the number of good responses to the total number of requests. This means a request-based SLO is met when that ratio meets or exceeds the goal for the SLO compliance period. If the SLO row has a green background, you’re doing good for the period. You may have not served successfully 100% of the requests, but you still have some remaining error budget to consume. If the SLO row has a yellow background, your error budget is closer to being totally consumed, and you should be more cautious for the rest of the period. If the SLO row has a red background, you’ve not reached the target SLO in this period, and you’ve consumed all of your error budget. Be careful if you need to deploy, and plan some work to improve your SLIs. You can click on the SLO to see more data about the entity, such as the golden metrics, the latest deployments, anomalies, and ongoing issues. This data can help you understand when and why you missed the SLO targets. You can define more than one SLO for the same SLI to check how fast you’re consuming the error budget. For instance, if you have an error budget of 0,1% requests for a whole week, you may not want to consume most of it in a single day, or the SLO will be at risk for the rest of the week. Understand Service Levels details We provide SLI details for two main purposes: For SLO analysis: See in which time ranges the SLO targets were missed. For SLI/SLO configuration and fine tuning: Learn how New Relic calculated SLO values. The SLI card contains the following charts: Good and bad responses These are the key concepts to analyze Service Levels: A valid request is any request that you want to count as meaningful for your SLIs. A good response is any response that you consider to provide a good experience (for example, the service responded in less than 2 seconds, providing a good navigation experience for the end user). A bad response is any response that you consider to provide a bad experience (like the service responded with a server error, interrupting the user's flow). This chart shows the total number of valid requests that your service received, broken down by good or bad. This chart shows the actual throughput of your service, which you can use to see if there’s any correlation between the increase of throughput and bad responses. SLI attainment over time (%) It's the proportion of what you consider good responses over time. The line should stay close to 100%, meaning that most requests were served successfully. Compliance over the period It's the ratio of good events (responses) to total events (requests), measured over the SLO compliance period. The closer to 100%, the closer your service is to meet the SLO target over the period. When this percentage goes below the SLO target, the chart will turn red: You need to put more effort in reliability. Remaining error budget (Requests) The error budget is an alternative way to read the SLO. It indicates what percentage of requests could still have a bad response over the SLO period, without compromising the objective. As the total amount of tolerated bad responses will vary with the request throughput, New Relic shows the percentage of remaining error budget: As long as the remaining error budget is above 25%, you'll see green, and your SLO is good. When the error budget goes below 25%, it will turn yellow. This means you’re close to burning the whole budget for the period. You may want to be more careful with new deployments and changes, and plan for some reliability work. Once the error budget is completely spent, it will show in red. SLI attainment over time and SLO target (%) The last chart shows two time series: the (SLI attainment over time) [#sli-over-time] , and the SLO target. When the SLI value is below the SLO target,your service is missing the SLO. Use this chart to learn in which time ranges your service missed the SLO target. Analyze bad responses When an SLO is not compliant, you need to analyze the original data to better understand what the impact is for your customer, with a special focus on what went wrong. At the Service Levels page, click the ... menu in any SLI and select Analyze. You'll access the query that represents the original NRDB events used to determine the bad responses which calculate the SLI attainment. You can then use the query builder to facet and filter down the unsuccessful responses by user account, client id, requesting source, etc. to better understand the cause and impact of missing your SLIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 294.19208,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Consume <em>Service</em> <em>Levels</em>",
        "sections": "Consume <em>Service</em> <em>Levels</em>",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": "BETA FEATURE This feature is currently in beta. After you create your set of SLIs and SLOs, New Relic will <em>start</em> generating SLI data. The first results will take a few minutes to appear in the New Relic One UI. Find <em>Service</em> Levels: At the top nav bar, under <em>Service</em> Levels in the More menu (which"
      },
      "id": "61ab3a9d28ccbc4b5fc23f44"
    },
    {
      "sections": [
        "Create and edit SLIs and SLOs",
        "BETA FEATURE",
        "Important",
        "Key concepts to create SLIs and SLOs",
        "The SLI entity",
        "SLI queries",
        "Suggested SLIs",
        "SLIs for APM services",
        "Service availability",
        "Service latency",
        "SLIs for browser applications",
        "Browser app largest contentful paint",
        "Browser app first input delay",
        "Browser app cumulative layout shift",
        "Create and edit Service Levels",
        "Select the SLI data source",
        "Configure the queries",
        "Set the SLO time window and target",
        "Define your SLI",
        "Edit SLIs"
      ],
      "title": "Create and edit SLIs and SLOs",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Service Level Management",
        "SLI/SLO",
        "Configure"
      ],
      "external_id": "ac0e19e3d890a02dde12bd639c55d4bd02a61778",
      "image": "https://docs.newrelic.com/static/fffe62dc00eff1b932b5c76be5730e5a/c1b63/slm_edit_menu.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/create-slm/",
      "published_at": "2021-12-10T06:27:38Z",
      "updated_at": "2021-12-04T09:52:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. You can create SLIs and SLOs manually through the New Relic UI. Alternatively, you can automate the process with our NerdGraph API and the Terraform Service Level resource. Important In order to create Service Levels you need a role with permissions to modify and delete metric rules. Key concepts to create SLIs and SLOs Keep in mind these concepts when defining SLIs and SLOs. The SLI entity In the New Relic ecosystem, SLIs and SLOs are linked to entities, which are all the elements in your stack that report data to us, or that generate data that we have access to. The entity that an SLI is related to determines where the SLI/SLO results show. And the entity's tags help filter down SLI results on the Service Levels view. You can define SLIs on any NRDB event that is reported to New Relic, and therefore you can also base SLIs on custom events. Most custom events are not related to a single New Relic entity, but provide higher level business and user experience insights. In this case, you can still relate the SLI to a specific entity or to a workload. SLI queries SLIs are defined as the percentage of good responses out of the total number of valid requests. Most often you’ll set up your SLIs by defining the valid and good pieces: A valid request is any request that you want to count as meaningful for your SLIs (for example, all transactions related to an endpoint that weren’t initiated by a health check). A good response is any response that you consider to provide a good output for the end-user or client service (for example, the service responded in less than 2 seconds, providing a good navigation experience for the end user). Alternatively, you can define what you consider to be the bad responses instead: A bad response is any response that you consider to provide a bad output (for example, the service responded with a server error, causing the client to fail its flow). New Relic will automatically derive the count of good responses as valid - bad. Request-based SLOs are based on an SLI defined as the ratio of the number of good requests to the total number of requests. A request-based SLO is met when that ratio meets or exceeds the goal for the compliance period. Suggested SLIs In this section you’ll find some SLIs that are typically used to measure the performance of services and browser applications. SLIs for APM services These SLIs are the most common for request-driven services: Service availability Service availability is the ratio of the number of successful responses to the number of all requests. This effectively is an error rate, but you can filter it down, for example removing expected errors. Valid events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Bad events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' AND error IS TRUE Copy Where {entityGuid} is the service's GUID. Service latency A latency SLI measures the proportion of valid requests that were served faster than the threshold established as a good experience. In order to determine that duration threshold, check how the service has been performing in the past weeks, and use that result as a realistic and achievable baseline. Afterwards, you can iterate on the SLI threshold, and align it with a more ambitious performance. To select an appropriate value for the duration condition, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find this duration threshold using the query builder, and use it to determine what you consider to be good events for your SLI: select percentile(duration, 95) from Transaction where entityGuid = '{entityGuid}' since 7 days ago limit max Valid events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Good events fields FROM: Transaction WHERE: entityGuid = '{entityGuid}' and duration < {duration} Copy Where {entityGuid} is the service's GUID. Where {duration} is the response time that you consider provides a good experience for your client service or end-user, in seconds. SLIs for browser applications The following SLIs are based on Google’s Browser Core Web Vitals. Browser app largest contentful paint It’s the proportion of valid page views where the largest content element visible in the viewport was rendered faster than the threshold considered to correspond to a good experience. Valid events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Good events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' and largestContentfulPaint<'{largestContentfulPaint}' Copy Where {entityGuid} is the browser app GUID. Where {largestContentfulPaint} is the amount of time (in milliseconds) to render the largest content element visible in the viewport that you consider provides a good experience for your end user. A frequent standard is 4000 ms. To determine a realistic number to use for {largestContentfulPaint} in your environment, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find it by using the query builder: SELECT percentile (largestContentfulPaint,95) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max Browser app first input delay It’s the proportion of page views where the time between a user's first interacion with the page and the time when the browser responds to that interaction is less than a certain threshold. Valid events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. Good events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' and firstInputDelay<{firstInputDelay} Copy Where {entityGuid} is the browser app GUID. Where {firstInputDelay} is the amount of time (in milliseconds) the browser should respond in to provide a good experience for your end user. A frequent standard is 300 ms. To determine a realistic number to use for {firstInputDelay} in your environment, one typical practice is to select the 95 percentile duration of the responses for the last 7 or 15 days. Find it by using the query builder: SELECT percentile(firstInputDelay,95) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max facet deviceType Browser app cumulative layout shift It’s the proportion of page views with a good cumulative layout shift (CLS). CLS is described as the total sum of all individual layout shift scores for every unexpected layout shift that occurs during the entire lifespan of the page. A layout shift occurs any time a visible element changes its position from one rendered frame to the next. Valid events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' Copy Where {entityGuid} is the service's GUID. If you’d like to create separate SLIs to track CLS in desktop and mobile devices separately, add one of these clauses at the end of the field: and deviceType = 'Mobile' and deviceType = 'Desktop' Good events fields FROM: PageViewTiming WHERE: entityGuid = '{entityGuid}' and cumulativeLayoutShift < {cumulativeLayoutShift} Copy Where {entityGuid} is the browser app GUID. Where {cumulativeLayoutShift} is a pre-set value. To provide a good user experience, your site should strive to have a CLS score of 0.1 or less. A CLS score of 0.25 or more is considered a poor user experience. If you’ve decided to create separate SLIs to track CLS in desktop and mobile devices separately when you defined the valid events query, add this clause at the end of the field: and deviceType = 'Mobile' and deviceType = 'Desktop' To determine a realistic number to select for {cumulativeLayoutShift} in your environment, one typical practice is to select the 75th percentile of page loads for the last 7 or 15 days, segmented across mobile and desktop devices. Find it by using the query builder: SELECT percentile(cumulativeLayoutShift,75) FROM PageViewTiming WHERE entityGuid = '{entityGuid}' since 7 days ago limit max facet deviceType Create and edit Service Levels To create SLIs and SLOs, go to the Service Levels tab at any workload in New Relic One and follow these steps: Select the SLI data source In order to define your new SLI, choose one of these two options: Entity data: Base the SLI on standard data coming from New Relic One agents. This is the most common option. If this is your choice, select the entity (for example, APM service) you want to use. Custom data: Alternatively, you can base the SLI on your custom NRDB events. Use this option when you can't relate the service level data to a specific entity, or when you want to relate the service level directly to a workload. Configure the queries The account where the data is gathered from matches the account of the entity that the SLI refers to. The rest of the fields correspond to the NRDB event that goes into the FROM clause, as well as the WHERE clauses that determine what is a valid and a good/bad event. Please see the section above to know what goes into each field. On the left you’ll see the final queries; and at the bottom you’ll get a preview of the count of valid and good/bad events in the last month. Important SLI queries support NRDB events, but not dimensional metrics yet. Set the SLO time window and target In this step you’ll get a preview of the SLI value. You can add one or more SLOs for this SLI. Just select the length of the time window and the percentage target. The chart on the left will help you anticipate whether the target you’re setting is feasible or if it's often missed. Rolling time-window SLOs are supported. With a rolling time-window, the SLO compliance takes into account the last N days. Every minute, the oldest data drops out of the current calculation and new data replaces it. Define your SLI Select a short name for your SLI that helps you recognize what it’s measuring. Optionally, you may add a description. Edit SLIs After you’ve created an SLI, access the UI and click on the ... menu to edit it:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 294.18823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create and edit <em>Service</em> <em>Levels</em>",
        "tags": "<em>Service</em> <em>Level</em> <em>Management</em>",
        "body": "BETA FEATURE This feature is currently in beta. You can create SLIs and SLOs manually through the New Relic UI. Alternatively, you can automate the process with our NerdGraph API and the Terraform <em>Service</em> <em>Level</em> resource. Important In order to create <em>Service</em> Levels you need a role with permissions"
      },
      "id": "61ab3a71196a67792ad10bd6"
    }
  ],
  "/docs/style-guide/capitalization/capitalization": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-09T22:55:57Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 437.29974,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-09T22:13:57Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.3996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-09T22:16:38Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.38608,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/formatting/buttons": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-09T22:55:57Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 437.2995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-09T22:13:57Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.39948,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-09T22:16:38Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.38605,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/formatting/callouts": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-09T22:55:57Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 437.2995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-09T22:16:38Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.38605,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    },
    {
      "sections": [
        "Lists",
        "Tip",
        "In-line lists"
      ],
      "title": "Lists",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "c8dd72524718c4e6e1d36d0f23b9af6ab4203e2a",
      "image": "https://docs.newrelic.com/static/425a3955215de94222a432e13be5dc84/8c557/tables-example.png",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/lists/",
      "published_at": "2021-12-09T22:16:38Z",
      "updated_at": "2021-11-24T09:17:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Lists are a powerful way to organize information, but they don't always make for a pleasant reading experience. Keep these points in mind when you're writing a list: Always capitalize the first letter of the first word in each list item. Use ordered (numbered) lists for step-by-step procedures, where the order matters. Use unordered (bulleted) lists to make it easier for users to skim related information. Use OR on a separate line when there is more than one option for a numbered step or a bullet point. Use tables when your ordered or unordered list would benefit from some extra detail. Tip For punctuation guidelines, follow the Microsoft Writing Style Guide, which includes considerations for localization. Here's an example of an ordered list as a table. Because each step is a row, the table helps to structure the levels of detail. In-line lists As an alternative to using bullet point lists, you can do an in-line list, like this: C SDK | Go | Java. You might want to use an in-line list when: You're linking to further documentation. Customers will likely be selecting a single option. The list item can be displayed with a short word or phrase (like Java, or Infrastructure). You think a bullet point list takes up a lot of vertical space. This may happen in circumstances where a procedure must include several lists. Here's one example of this. There are only two or three potential options they'll be choosing from and a bullet point list seems unnecessary. Here's an example.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.3839,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " For punctuation guidelines, follow the Microsoft Writing <em>Style</em> <em>Guide</em>, which includes considerations for localization. Here&#x27;s an example of an ordered list as a table. Because each step is a row, the table helps to structure the levels of detail. In-line lists As an alternative to using bullet point"
      },
      "id": "60421e4e28ccbc71a9eba7a2"
    }
  ],
  "/docs/style-guide/formatting/code-examples": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-09T22:55:57Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 437.29926,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-09T22:13:57Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.39938,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-09T22:16:38Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/formatting/code-formatting-guidelines-var-mark": [
    {
      "sections": [
        "Code references",
        "For inline code or data (<code>)",
        "For multi-line code blocks (<pre>)",
        "Highlight user input with <var>",
        "Highlight important sections with <mark>",
        "Add syntax highlighting",
        "Link to other docs",
        "Formatting terminal commands"
      ],
      "title": "Code references",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "9b4c6e235a285475be7ba8afd23936ce3d4cf923",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/code-examples/",
      "published_at": "2021-12-09T22:14:37Z",
      "updated_at": "2021-11-24T09:04:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We use a variety of formatting to highlight code or other technical language. You can use the <code>, <pre>, and <var> tags to indicate \"raw\" technical content such as excerpts from a config file, an API method name, or a file path. The following table provides some examples of our use of code format. For this... Example Command line utility names To install the utility, use apt. File paths and file names The agent looks for newrelic.config in the %ALLUSERSPROFILE%\\New Relic\\.NET Agent directory. Insights event names and attributes To analyze APM errors, use the TransactionError event. Method names To initialize the APM agent, use startAgent(). Non-clickable URLs In your web browser, navigate to the minion Overview page at http://MINION_IP_ADDRESS. The <var> formatting automatically applies color coding and italics in this situation. These sections break down when to use specific types of code formatting. For inline code or data (<code>) To surround small blocks of code or data (single words or lines), mark as code: Source: Use <code> tags. Markdown: Surround the text with backtick ` characters. For multi-line code blocks (<pre>) To surround longer blocks of data that run multiple lines, mark as preformatted text: Source: Use <pre> tags. Markdown: Do not use Markdown-style indented code formatting, as this can cause unexpected formatting problems. Highlight user input with <var> Use the <var> tag to highlight areas of a code block where a user is expected to supply their own value. For more context on when to use <var> tags, see < var> formatting guidelines. Follow these guidelines when you use <var> tags: Address the reader directly Use all caps and underscores _ to separate words (also known as SCREAMING_SNAKE_CASE). Don't use other punctuation (such as wrapping the text in angle brackets). Exception: REST API examples use a ${VARNAME} syntax inspired by Bash conventions. Standard examples: echo \"license_key: YOUR_LICENSE_KEY\" | sudo tee -a /etc/newrelic-infra.yml Copy msiexec.exe /qn /i PATH\\TO\\newrelic-infra.msi Copy https://rpm.newrelic.com/accounts/ACCOUNT_ID/applications/APP_ID Copy REST API v2 example: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=average_call_time&values[]=call_count&from=2014-03-01T20:59:00+00:00&to=2014-03-01T21:59:00+00:00&summarize=true' Copy Highlight important sections with <mark> Use the <mark> tag to highlight areas of a code block that are particularly important. Most commonly, <mark> is used to highlight New Relic API methods in sample code that contains a lot of \"other logic.\" When you use <mark>, you should usually follow the code block with a list of bullets that explain what each API call is doing and link to method syntax. For more context on when to use <mark> tags, see < mark> formatting guidelines. Examples: Example of using the <mark> tag private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal(DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()) ; // fire and forget DB_POOL.submit(() -> { segment.end() ; insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For method syntax, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in APM with datastore data. For more information, see reportAsExternal API. For method syntax, see the Javadoc. segment.end(): Stops timing this segment. For method syntax, see the Javadoc. Add syntax highlighting To add syntax highlighting to a code block, add class=\"highlight\" to the <pre> tag. The syntax highlighter tries to auto-detect the language. If it's not working as expected, ensure the language is supported and specify the language by adding the a lang-LANG-NAME class (for example: lang-html). View a full list of supported languages for syntax highlighting. Element colors and themes are fully customizable. Link to other docs You can add <a href> tags inside a <pre> blocks, just as you would any other content. However, make sure to use them judiciously since they can be easy to miss. A good example is the Infrastructure config file template, where each config element links to the relevant section of the main config doc. Formatting terminal commands If you have sentences that mention single-word system commands, surround these words in code tags (Markdown uses backticks ` for this) so translators don't confuse these words with words in general usage. Here are some words that translators or readers could confuse: curl: Sends http requests via a terminal session–not to be confused with the curls you do with weights at the gym. cat: Lists the first ten lines of a file–not a feline pet who ignores you. date: Displays the day, year, and time–not an outing that couples take. tail: Displays the last ten lines of a file–not the appendage on various mammals. which: Show the location of a program executable–not the pronoun. The moral of the story: If you think a reader or translator might confuse a command with a general English word, just enclose it in backticks (`).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.08087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Code</em> references",
        "sections": "<em>Formatting</em> terminal commands",
        "body": " lines, <em>mark</em> as preformatted text: Source: Use &lt;pre&gt; tags. Markdown: Do not use Markdown-style indented <em>code</em> <em>formatting</em>, as this can cause unexpected <em>formatting</em> problems. Highlight user input with &lt;<em>var</em>&gt; Use the &lt;<em>var</em>&gt; tag to highlight areas of a <em>code</em> block where a user is expected to supply their own"
      },
      "id": "619e001be7b9d23c04fe7524"
    },
    {
      "sections": [
        "Format overview"
      ],
      "title": "Format overview",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "19cdfd626e9695a9576778f2151a883cfe9b9f80",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/format-overview/",
      "published_at": "2021-12-09T22:36:13Z",
      "updated_at": "2021-11-24T09:02:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Generally, follow the Microsoft Style Guide for formating common text elements. You can find code formatting info in the code examples page of this guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.53109,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Format</em> overview",
        "sections": "<em>Format</em> overview",
        "body": "Generally, follow the Microsoft Style Guide for formating common text elements. You can find <em>code</em> <em>formatting</em> info in the <em>code</em> examples page of this guide."
      },
      "id": "619dffb5196a6712afa098a4"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-10T00:27:40Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.69864,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Requirements <em>and</em> recommendations",
        "body": " a new web transaction To tell the agent to <em>mark</em> a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction&#x27;s URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { <em>var</em> uri = new Uri"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/style-guide/formatting/format-overview": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-09T22:55:57Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 437.29926,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-09T22:13:57Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.39938,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-09T22:16:38Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/formatting/hyperlinks": [
    {
      "sections": [
        "apiStyleGuidelines (Example agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Return values",
        "Examples",
        "URL guidelines",
        "Title guidelines",
        "Short title guidelines",
        "Syntax guidelines",
        "Important"
      ],
      "title": "apiStyleGuidelines (Example agent API)",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "API writing guidelines"
      ],
      "external_id": "fb967e77ea9a94d7a35329c0c87062ff93ab2ff8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/apistyleguidelines-example-agent-api/",
      "published_at": "2021-12-10T13:34:04Z",
      "updated_at": "2021-11-26T09:14:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.apiStyleGuidelines(data type $parameter_name[, integer $optional_param]) newrelic.apiStyleGuidelines(data type $parameter_name, array $different_param, string $third_param) Copy Briefly describe the call. Ideally, one line or less on the \"View all methods\" page. Requirements Agent version 1.2.3.4 or higher. Additional requirements on their own line (do not use bullets). Do not use any callouts. If there are no special requirements, write: Compatible with all agent versions. Description Describe the behavior of the call with as much detail as possible. Do not describe what individual parameters do except in broad strokes; details of parameters and call variants belong under the Parameters heading. Similarly, do not describe return values. When cross-referencing another API call, format its name with code blocks, and include parentheses () like this: anotherCoolMethod(). Tip You can include callouts, but use discretion. These pages are already visually busy. Parameters If there are no parameters, leave this section blank. If there is only one call variant, do not include a syntax block in this section. Parameter Description newrelic.apiStyleGuidelines(data type $parameter_name[, integer $optional_param]) Copy $parameter_name data type Required. Brief description of parameter. $optional_param integer Optional. Brief description of parameter. newrelic.apiStyleGuidelines(data type $parameter_name, array $different_param) Copy $parameter_name data type Required. Brief description of parameter. $different_param array Required. Brief description of parameter. $third_param string Required. Brief description of parameter. Return values What does this call return, and in what circumstances? Are there any things we expect customers to do with that return value? If the call does not return anything, leave this section blank. Examples This section documents rules for oddballs that aren't self-documenting. The rest of the examples are embedded within the page itself. In general, this page is intended for style reference. For examples of how to write good API method pages, check out our existing API docs, such as the PHP API. URL guidelines For the doc's URL: Manually edit the URL slug to remove the agent name. Where the API call does not already include separators (as in newrelic_awesome_call), separate the bits with hyphens -. For example: https://docs.newrelic.com/docs/new-relic-only/advanced-style-guide/writing-guidelines/api-style-guidelines Copy Title guidelines For the doc's title: Include the method name and the agent name in parentheses. Do not include newrelic. prefixes unless they are integral to the call name (as in the PHP agent). Do not include parentheses () in the call itself. For example: apiStyleGuidelines (Example agent API) Copy Short title guidelines For the doc's short title: Include only the method name. Do not include newrelic. prefixes unless they are integral to the call name (as in the PHP agent). Do not include parentheses (). Adjust if necessary to fit on a single line in the category's sidebar. For example: apiStyleGuidelines Copy Syntax guidelines Important The Python and iOS agents use their own guidelines. For those guidelines, see the existing methods in those languages. Document each variant of a call on its own line. Do not use any formatting except italicizing the data type. Wrap optional parameters (including the comma separator) in square brackets []. Indicate the variable portion by prefacing it with a dollar sign $. If the call must be prefixed with newrelic. or similar, include that in the syntax. Optional: Include the return value, if that seems important for your particular agent. If you do, follow language conventions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 95.40076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "URL <em>guidelines</em>",
        "tags": "API writing <em>guidelines</em>",
        "body": "Syntax newrelic.apiStyle<em>Guidelines</em>(data type $parameter_name[, integer $optional_param]) newrelic.apiStyle<em>Guidelines</em>(data type $parameter_name, array $different_param, string $third_param) Copy Briefly describe the call. Ideally, one line or less on the &quot;View all methods&quot; page. Requirements Agent"
      },
      "id": "61ab484ee7b9d293670e847e"
    },
    {
      "sections": [
        "API tutorial template",
        "Introduction (this heading will not be visible)",
        "Optional: Provide an overview for complex processes",
        "Provide a procedure to accomplish the task",
        "Tip",
        "Step 1. Do something...",
        "If needed: Step 2. Do something else...",
        "If needed: Step 3. Do something else...",
        "Last step. Verify that the task was completed...",
        "Optional: Do something else with the API",
        "Optional: Large example code block",
        "Code block example",
        "Optional: Troubleshooting"
      ],
      "title": "API tutorial template  ",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "API writing guidelines"
      ],
      "external_id": "b69605a3a5585b2ee7f89c250bbdd5345c5d9311",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/api-tutorial-template/",
      "published_at": "2021-12-10T13:33:23Z",
      "updated_at": "2021-11-26T09:14:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is a template for an API tutorial document: Please skim the entire template first to understand the expected structure for this type of doc. Then, clone this doc using the Clone content link in the Page tools box. Delete all content up to Introduction (this heading won't be visible). For the doc title (the field at top of page): Doc should be named in a practical, use-case-focused way. Example: Add custom attributes to transactions Introduction (this heading will not be visible) Provide a brief explanation of what this document will teach customers, and why it is valuable for customers to know how to do that. Focus on the value the API provides to the customers and mention specific, common use cases. Any relevant notes about support/compatability should go here, too. Here's an example from the Java API asynchronous tutorial doc: New Relic for Java includes an API to instrument asynchronous activity. For supported frameworks, the Java agent usually instruments async work automatically. However, the async API can be useful for adding more detail to your data. This document provides examples of using tokens and segments to instrument your app. Optional: Provide an overview for complex processes This is an optional section for complicated tutorials that involve either using several methods in one procedure or that have different alternate steps you can take to achieve similar results. This section can link to lower-down sections to allow users to skip around as needed. For simple tutorials, this section isn't necessary. For an example, see this section of the Java async tutorial. Provide a procedure to accomplish the task Tell the user how to accomplish the task, and link to the methods necessary to accomplish that task. As much as possible, we're looking to describe tasks in \"procedures\" (procedure is tech writer jargon for a series of numbered steps). This may be tough to do for fairly open-ended/variable tasks, but it will usually be possible to chunk the content at a fairly high-level to make it into a procedure. Along the way, explain what the importance of the procedure step is, and how one might verify that the step was done correctly. For code samples, avoid using large chunks of code. Instead, use smaller pieces of code and give context for how they are being used. (If you think a large app code example would be helpful, place that later in the doc in the Example section.) Tip For an example of an open-ended task segmented into procedural chunks, see the Asynchronous doc section Connecting async threads. For another example, see this TomCat GAE Flex procedure. Base your procedure on the simple structure below. Tech writers will edit your content to match our style and formatting requirements: Step 1. Do something... Methods and example code to implement the first step. For each step, if applicable, indicate the significance of that step (why it's important) and how the user might verify that the step was done correctly (for example, something showing up in UI, or running a verification test of some sort). If needed: Step 2. Do something else... Methods and example code to implement step 2. If needed: Step 3. Do something else... Methods and example code to implement step 3. Last step. Verify that the task was completed... Explain how a user would know they'd completed the task correctly. In particular, how would the user find the new change or data in the New Relic UI. What New Relic products and pages would the change be noticed on? If new data shows up in Insights, what event types can it be found under? Optional: Do something else with the API Same as above. Make as many headings and separate procedures as needed. Optional: Large example code block If you think a large app code example would be useful, place here. Within any code block, explain all New Relic functions/methods, not just the main methods. Instead of in-line comments, consider using highlighted sections underneath the code block to give additional context. Here's an example: Code block example The following code example shows a segment starting in the storeItem method to measure how long the Lambda statement is waiting in the thread pool. To stop timing the segment, you must call either .end() or .ignore(). If you don't want to report the segment as part of its parent transaction, call .ignore(). Otherwise, to report the segment as part of its parent transaction, call .end(). private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal (DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()); // fire and forget DB_POOL.submit(() -> { segment.end(); insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For more on this method, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in APM with datastore data. For more information, see reportAsExternal API. segment.end(): Stops timing this segment. For more on this method, see the Javadoc. Optional: Troubleshooting Optional area for any common errors or troubleshooting tips.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 95.4006,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "API writing <em>guidelines</em>",
        "body": "This document is a template for an API tutorial document: Please skim the entire template first to understand the expected structure for this type of doc. Then, clone this doc using the Clone content <em>link</em> in the Page tools box. Delete all content up to Introduction (this heading won&#x27;t be visible"
      },
      "id": "61b35723196a675e16a5b0a4"
    },
    {
      "sections": [
        "New Relic Metrics Adapter",
        "BETA FEATURE",
        "Requirements",
        "Installation",
        "Tip",
        "Configuration",
        "How it works",
        "Caution",
        "Troubleshooting",
        "Get verbose logs",
        "Get raw metrics",
        "Metrics not working"
      ],
      "title": "New Relic Metrics Adapter",
      "type": "docs",
      "tags": [
        "Integrations",
        "Kubernetes integration",
        "Link apps and services"
      ],
      "external_id": "e2a825763b10ccf4bd1bd8423e2209f66dfb61bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/kubernetes-pixie/kubernetes-integration/newrelic-hpa-metrics-adapter/newrelic-metrics-adapter/",
      "published_at": "2021-12-09T15:21:02Z",
      "updated_at": "2021-11-13T08:47:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is still in development, but we encourage you to try it out! You can use metrics from your New Relic account to autoscale applications and services in your Kubernetes cluster by deploying the New Relic Metrics Adapter. This adapter fetches the metric values from New Relic and makes them available for the Horizontal Pod Autoscalers. The newrelic-k8s-metrics-adapter implements the external.metrics.k8s.io API to support the use of external metrics based New Relic NRQL queries results. Once deployed, the value for each configured metric is fetched using the NerdGraph API based on the configured NRQL query. The metrics adapter exposes the metrics over a secured endpoint with TLS. New Relic metrics adapter in a cluster. Requirements Kubernetes 1.16 or higher. The New Relic Kubernetes integration. New Relic's user API key. No other External Metrics Adapter installed in the cluster. Installation To install the New Relic Metrics Adapter, we provide the newrelic-k8s-metrics-adapter Helm chart, which is also included in the nri-bundle chart used to deploy all New Relic Kubernetes components. If not already installed, install our Kubernetes integration. Upgrade the installation to include the New Relic Metrics Adapter with the following command: helm upgrade --install newrelic newrelic/nri-bundle \\ --namespace newrelic --create-namespace --reuse-values \\ --set metrics-adapter.enabled=true \\ --set newrelic-k8s-metrics-adapter.personalAPIKey=YOUR_NEW_RELIC_PERSONAL_API_KEY \\ --set newrelic-k8s-metrics-adapter.config.accountID=YOUR_NEW_RELIC_ACCOUNT_ID \\ --set newrelic-k8s-metrics-adapter.config.externalMetrics.external_metric_name.query=NRQL query Copy Please notice and adjust the following flags: metrics-adapter.enabled: Must be set to true so the metrics adapter chart is installed. newrelic-k8s-metrics-adapter.personalAPIKey: Must be set to valid New Relic Personal API key. newrelic-k8s-metrics-adapter.accountID: Must be set to valid New Relic account where metrics are going to be fetched from. newrelic-k8s-metrics-adapter.config.externalMetrics.<var>external_metric_name</var>.<var>query</var>: Adds a new external metric where: <var>external_metric_name</var>: The metric name. <var>query</var>: The base NRQL query that is used to get the value for the metric. Tip Alternatively, you can use a values.yaml file that can be passed to the helm command with the --values flag. Values files can contain all parameters needed to configure the metrics explained in the configuration section. Configuration You can configure multiple metrics in the metrics adapter and change some parameters to modify the behaviour of the metrics cache and filtering. To see the full list and descriptions of all parameters that can be modified, refer to the chart README.md and values.yaml files. How it works The following example is a Helm values file that enable the metrics adapter on the nri-bundle chart installation, and configures the nginx_average_requests metric: metrics-adapter: enabled: true newrelic-k8s-metrics-adapter: personalAPIKey: <Personal API Key> config: accountID: <Account ID> externalMetrics: nginx_average_requests: query: \"FROM Metric SELECT average(nginx.server.net.requestsPerSecond) SINCE 2 MINUTES AGO\" Copy Caution The default time span for metrics is 1h. Therefore, you should define queries with the SINCE clause to adjust the time span according to your environment and needs. There is an HPA consuming the external metric as follows: kind: HorizontalPodAutoscaler apiVersion: autoscaling/v2beta2 metadata: name: nginx-scaler spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: nginx minReplicas: 1 maxReplicas: 10 metrics: - type: External external: metric: name: nginx_average_requests selector: matchLabels: k8s.namespaceName: nginx target: type: Value value: 10000 Copy Based on the HPA definition, the controller manager fetches the metrics from the external metrics API which are served by the New Relic metrics adapter. The New Relic metrics adapter receives the query including the nginx_average_requests metric name and all the selectors, and searches for a matching metric name in the internal memory based on the configured metrics. Then, it adds the selectors to the query to form a final query that is executed using NerdGraph to fetch the value from New Relic. The above example will generate a query like the following: FROM Metric SELECT average(nginx.server.net.requestsPerSecond) WHERE clusterName=<clusterName> AND `k8s.namespaceName`='nginx' SINCE 2 MINUTES AGO Copy Notice that a clusterName filter has been automatically added to the query to exclude metrics from other clusters in the same account. You can remove it by using the removeClusterFilter configuration parameter. Also the value is cached for a period of time defined by the cacheTTLSeconds configuration parameter, whose default is 30 seconds. Troubleshooting Get verbose logs Most common errors are displayed in the standard (non-verbose) logs. If you're doing a more in-depth investigation on your own or with New Relic Support, you can enable verbose mode. To get verbose logging details for an integration using Helm: Enable verbose logging: bash Copy $ helm upgrade -n <namespace> --reuse-values newrelic-bundle --set newrelic-k8s-metrics-adapter.verboseLog=true newrelic/nri-bundle Leave on verbose mode for a few minutes, or until enough activity has occurred. When you have the information you need, disable verbose logging: bash Copy $ helm upgrade --reuse-values newrelic-bundle --set newrelic-k8s-metrics-adapter.verboseLog=false newrelic/nri-bundle Caution Verbose mode increases significantly the amount of information sent to log files. Enable this mode temporarily, only for troubleshooting purposes, and reset the log level when finished. Get raw metrics Sometimes it's useful to get the list of available metrics and also to get the current value of an specific metric. To get the list of metrics available, run: bash Copy $ kubectl get --raw \"/apis/external.metrics.k8s.io/v1beta1/\" To get the value for a specific metric with a selector, run: bash Copy $ kubectl get --raw \"/apis/external.metrics.k8s.io/v1beta1/namespaces/*/<metric_name>?labelSelector=<selector_key>=<selector_value>\" Tip You must replace <metric_name>, <selector_key> and <selector_value> with your values. Metrics not working There are some usual errors that could cause a metric fail to retrieve the value. These errors are showed in the status of the metrics when you describe the HPA or are printed when you get the raw metrics directly. executing query: NRQL Syntax Error: Error at line...: The query that is being run has syntax errors. The same error message gives you the executed query and position of the error. You can try this query inside the New Relic query builder and correct the configuration from the adapter. extracting return value: expected first value to be of type \"float64\", got %!q(<nil>): The query doesn't return any value. The same error message gives you the executed query so you can try this query inside the New Relic query builder and correct the configuration from the adapter or the match selectors in the HPA.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.84302,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Link</em> apps and services"
      },
      "id": "6175209d28ccbcf310c6bb2f"
    }
  ],
  "/docs/style-guide/formatting/titles": [
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "835ddacc0acae04e05c8c2ddc694799819a7d696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-11-26T05:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 248.03497,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Rename or <em>redirect</em> a document",
        "sections": "Rename or <em>redirect</em> a document",
        "body": "This document describes how to change the title of a document and how to create, edit, and delete <em>redirects</em>. Procedures are the same for both standard docs (&quot;basic pages&quot;) and release notes. Caution Changing <em>titles</em> or updating <em>redirects</em> can create issues with finding content. If you need to change"
      },
      "id": "61b35af428ccbca9318c6b13"
    },
    {
      "sections": [
        "Update the home page",
        "Update a link's URL",
        "Add a new tile to the home page",
        "Add a new section to the home page",
        "Edit the home page left nav"
      ],
      "title": "Update the home page",
      "type": "docs",
      "tags": [
        "home page",
        "landing pages"
      ],
      "external_id": "1d084fae5223f5b34cec91fcae0bcb35560c7b29",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/edit-homepage/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-12-04T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can't just hit the edit button docs.newrelic.com to make edits to the home page. The page that opens is index.js, the file that manages the parts of the home page, but not the content. It's rare that you'll need to make changes to this file. Most home page changes will be to add a new tile or section to the page, or update links. These types of changes are handled in two files: src/data/homepage.yml - contains home page section titles, section descriptions, and the URLs for tiles. src/i18n/translations/en/translation.json - contains tile info, including the title and short description of tiles. Update a link's URL Change or add new links using homepage.yml. In homepage.yml, search for the link you want to change. Edit the URL, save, commit, and PR the change. Add a new tile to the home page You'll make changes to both homepage.yml and translations.json On the translations.json doc, find the spot where you want to add the new tile (which section, and in what order you want it to appear), and add a new entry with this format: \"t#\": { \"title\": \"tile name\", \"description\": \"Short description.\" }, Copy Make sure you update the number on the tile. If you want to insert it in the middle of a group, update all the subsequent tile numbers as well. Save the file. Open homepage.yml, find the spot where the new tile will be, and add a new line with the relative link for the new tile. For example, - /docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster Save and check that your new tile builds properly on a local build. Commit, push, PR when you're ready. Add a new section to the home page On the translations.json page, add a new section modeled in the spot where you want the new section to appear. Include at least one title. For example, here's the TDP entry, with one tile: \"errors-inbox\": { \"title\": \"Errors Inbox\", \"description\": \"A single place to proactively detect, triage, and take action on all the errors before they impact customers.\", \"t1\": { \"title\": \"Introduction to Errors Inbox\", \"description\": \"How to manage all your monitoring in one place.\" }, Copy When you're done creating the info, save the file. In the homepage.yml page, find the corresponding location for the new section, and add the short name you provided in the translation.json file, title, description, and tile URLs. For example, here's the corresponding TDP section on homepage.yml. errors-inbox: title: Errors Inbox description: A single place to proactively detect, triage, and take action on all the errors before they impact customers. tiles: - /docs/errors-inbox/errors-inbox Copy Save, build locally, commit, PR. Edit the home page left nav The left nav of the home page is controlled by src/nav/root.yml. This is a basic yml file, similar to our taxonomy files. Each link on the left nav needs a title and a path: - title: Welcome to New Relic path: /docs/using-new-relic - title: New Relic One path: /docs/new-relic-one/use-new-relic-one - title: Guides and best practices path: /docs/new-relic-solutions - title: section-break - title: Alerts and Applied Intelligence path: /docs/alerts-applied-intelligence Copy You can add a new link by following the pattern above or delete a link by removing the corresponding title and path. Section breaks are added by including a - title: section-break line. The left nav reflects the exact order of root.yml, so it's easy to organize it as needed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.03047,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " or section to the page, or update links. These types of changes are handled in two files: src&#x2F;data&#x2F;homepage.yml - contains home page section <em>titles</em>, section descriptions, and the URLs for tiles. src&#x2F;i18n&#x2F;translations&#x2F;en&#x2F;translation.json - contains tile info, including the title and <em>short</em> description"
      },
      "id": "61ab480264441f9ef0927fb8"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/levels-headings/",
      "sections": [
        "Levels of headings",
        "Use parallel construction",
        "Keep it short, avoid -ing words",
        "Do not use h1 headings",
        "Use level two headings to identify chunks of information",
        "Important",
        "Avoid using level three headings"
      ],
      "published_at": "2021-12-09T22:15:57Z",
      "title": "Levels of headings",
      "updated_at": "2021-11-24T09:15:43Z",
      "type": "docs",
      "external_id": "18f0cf0f9cd08f4c6118d17119aa9a52b1620136",
      "document_type": "page",
      "popularity": 1,
      "body": "Taking some time to consider your headings and document titles is time well spent. Titles and headings are not only important for search results, but they can make your docs easier to skim. For all headings, subheadings, and titles use sentence case. This means you should capitalize the first word of the title and proper nouns only. You should also capitalize the first word after a colon. Avoid dashes and ellipses in headlines and titles. Avoid using punctuation, with the exception of question marks. Use parallel construction Use parallel construction when naming headers. For example, use all nouns (\"Organization,\" \"Tone\"), all verbs (\"Create,\" \"Delete\"), etc. Keep it short, avoid -ing words For all headers, keep the title as short as possible. In particular, avoid headers that are more than a line long. As with all our writing, you should feel free to address the reader directly: Install the agent, for example, rather than Agent installation. You should also avoid -ing words, which add to character count without contributing clarity. Do not use h1 headings After you publish your doc, the docs site will automatically use what you added to the Title field as the doc's level one heading (h1). To ensure that your doc is properly indexed for search, do not manually create additional h1 headings. If your doc's title is long and you would like a shorter title to appear in the sidebar menu, create a GitHub issue and we'll help you with that change. Use level two headings to identify chunks of information Organize chunks of information into sections with level two headings (##). For example: ## Create a new user [#create-new-user] Copy Important If you don't specify an ID manually, the site will use your header text as that header's ID (also known as anchor link). Create a manual ID to preserve links to that header if you change the header text. If you have too many level sections, consider splitting the document into multiple pages. Avoid using level three headings Avoid using ### headings unless it makes sense for the content or if the content is lengthy. Collapsers, tables, and other structural elements are often a better choice. Be particularly careful about level three headings that make a level two section longer than a single screen height. Here are two examples of good scenarios for using level three headings: Example #1: Events-to-metrics API doc Example #2: Infrastructure integration doc",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.52359,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Keep it <em>short</em>, avoid -ing words",
        "body": "Taking some time to consider your headings and document <em>titles</em> is time well spent. <em>Titles</em> and headings are not only important for search results, but they can make your docs easier to skim. For all headings, subheadings, and <em>titles</em> use sentence case. This means you should capitalize the first word"
      },
      "id": "604221d3196a677e3aa83db4"
    }
  ],
  "/docs/style-guide/formatting/ui-paths": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-09T22:55:57Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 437.29877,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-09T22:13:57Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.39917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-09T22:16:38Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.38593,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/images/embed-images": [
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-10T13:24:39Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.92657,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use content types <em>and</em> text formats",
        "sections": "Use content types <em>and</em> text formats",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " release notes. What&#x27;s New posts This format includes specific fields for product announcements. What&#x27;s New posts are created by PMM for larger announcements. They&#x27;re available in the docs site, but they&#x27;re also visible in the New Relic One UI. For more information, see What&#x27;s New <em>style</em> guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs <em>guide</em>."
      },
      "id": "61b35517196a677196a59e07"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "835ddacc0acae04e05c8c2ddc694799819a7d696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-11-26T05:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.9228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. <em>Procedures</em> are the same for both standard docs (&quot;basic pages&quot;) and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change"
      },
      "id": "61b35af428ccbca9318c6b13"
    },
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "9ec2ccd8a8509ab1b54273206e84f9571164c4f9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-11-26T05:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.91934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Procedures</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original <em>tech</em> <em>writer</em> or docs site contributor"
      },
      "id": "61b35af4e7b9d2769c5a38f9"
    }
  ],
  "/docs/style-guide/images/embed-videos": [
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-10T13:24:39Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.92654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use content types <em>and</em> text formats",
        "sections": "Use content types <em>and</em> text formats",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " release notes. What&#x27;s New posts This format includes specific fields for product announcements. What&#x27;s New posts are created by PMM for larger announcements. They&#x27;re available in the docs site, but they&#x27;re also visible in the New Relic One UI. For more information, see What&#x27;s New <em>style</em> guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs <em>guide</em>."
      },
      "id": "61b35517196a677196a59e07"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "835ddacc0acae04e05c8c2ddc694799819a7d696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-11-26T05:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.92276,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. <em>Procedures</em> are the same for both standard docs (&quot;basic pages&quot;) and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change"
      },
      "id": "61b35af428ccbca9318c6b13"
    },
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "9ec2ccd8a8509ab1b54273206e84f9571164c4f9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-11-26T05:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.91928,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Procedures</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original <em>tech</em> <em>writer</em> or docs site contributor"
      },
      "id": "61b35af4e7b9d2769c5a38f9"
    }
  ],
  "/docs/style-guide/images/screenshots-images": [
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "9ec2ccd8a8509ab1b54273206e84f9571164c4f9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-11-26T05:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 897.58044,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Processes <em>and</em> procedures",
        "body": " sentences, or long paragraphs. Useful <em>images</em> For <em>screenshots</em> and <em>images</em>, check that: Full size <em>images</em> always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped <em>images</em> clearly show their relevance, with or without captions. In addition, make sure"
      },
      "id": "61b35af4e7b9d2769c5a38f9"
    },
    {
      "sections": [
        "Capitalization",
        "Use sentence case in headings",
        "Important",
        "Products and features",
        "UI elements and UI page paths"
      ],
      "title": "Capitalization",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "5d5fb84286568c2a7842bae1247613d33a347593",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/capitalization/capitalization/",
      "published_at": "2021-12-09T22:13:56Z",
      "updated_at": "2021-11-24T08:52:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In general, we only capitalize things when we need to. Over use of capitalization is distracting and limits accessibility for our readers with vision impairment. Read on for some guidelines on how to decide what to capitalize in a document's title, headings, products, features, and other elements of the page. Use sentence case in headings Use sentence case for headings. This includes category headings and document titles. With sentence case, capitalize only the first letter of: The first word Proper nouns Acronyms and abbreviations We have some exceptions: If the heading is a code term, such as a variable or function, then capitalize it exactly as it's used in the code; for example: noticeError. If the heading includes a colon, follow the Microsoft Style Guide for titles and headings, and capitalize the first word that appears after the colon; for example: APM Error profiles: Troubleshoot trends. Important Use sentence case for graphical illustrations such as diagrams and figures. Explore our Screenshots and images document for more information on our image guidelines. Products and features Item Example We use title case for products. Infinite Tracing We don't capitalize features (including features that used to be products). Use transaction traces to... not Use Transaction Traces to... Our infrastructure monitoring... not Our Infrastructure monitoring... UI elements and UI page paths Item Example We use sentence case and bold for UI elements, even if the UI element is in a different case in the UI. \"From the Transactions page, select Transaction traces and...\" We use sentence case and bold for each element in a path that references UI pages. Go to one.newrelic.com > APM > Transactions > Transaction traces > (select a trace) > Another thing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 746.7525,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Products <em>and</em> features",
        "body": ": Troubleshoot trends. Important Use sentence case for graphical illustrations such as diagrams and figures. Explore our <em>Screenshots</em> and <em>images</em> document for more information on our image guidelines. Products and features Item Example We use title case for products. Infinite Tracing We don&#x27;t capitalize features"
      },
      "id": "60421e50196a67d785a83d97"
    },
    {
      "sections": [
        "Update your Nerdpack's catalog information",
        "Update your CLI",
        "Check your permissions",
        "Publish your Nerdpack",
        "Update your Nerdpack's catalog metadata",
        "Update your Nerdpack's icons",
        "Resolve issues with submitting catalog information",
        "Resize your images",
        "Check the length of your strings"
      ],
      "title": "Update your Nerdpack's catalog information",
      "type": "developer",
      "tags": [
        "nerdpack",
        "catalog"
      ],
      "external_id": "dfee75ddee87a216eb9454abcaeabcc1ee0a8c7d",
      "image": "https://developer.newrelic.com/static/e79ab0693c4758e13b4d9d0e586bd3e8/0086b/published-app.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/catalog/",
      "published_at": "2021-12-09T13:38:13Z",
      "updated_at": "2021-11-20T01:49:50Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn to describe your Nerdpack in the Instant Observability catalog",
      "body": "Add screenshots, descriptions, and other metadata to your Nerdpack, and upload it all to Instant Observability. Update your CLI Before you run any commands, ensure that you have the latest version of the CLI: bash Copy $ nr1 update Check your permissions To publish your Nerdpack and update its catalog information, you need: Access to the account that published it The necessary permissions for managing Nerdpacks Publish your Nerdpack You need to publish Nerdpacks that you create before you can update their catalog information. Update your Nerdpack's catalog metadata After you've published your Nerdpack to the Instant Observability catalog, update the Nerdpack's metadata to let users know all about your Nerdlets or visualizations. Step 1 of 9 Go to New Relic: Step 2 of 9 Navigate to Instant Observability: Step 3 of 9 Find your published Nerdpack using the Apps filter or search bar: Notice that there is no information on the Instant Observability or details page other than the Nerdpack's name and the brief description found in nr1.json: There are no screenshots, icons, details, or what's new features. For these, you need to provide catalog information to your Nerdpack. Step 4 of 9 From the root of your Nerdpack, create catalog directories to house your Nerdpack's screenshots and metadata: bash Copy $ nr1 create --type catalog ✔ created: launchers/launcher/catalog ✔ created: nerdlets/home/catalog ✔ catalog created successfully! catalog is available at \"./catalog\" Inside your root catalog directory, you'll find specific files and directories for portraying information about your Nerdpack to your users: bash Copy $ ls catalog README.md additionalInfo.md config.json documentation.md screenshots File Description README.md A markdown file that instructs you how to use the information and metadata in catalog config.json A JSON file that contains the following fields: tagline: A brief headline for the application. This cannot exceed 30 characters. repository: The URL for the Nerdpack's remote repository. This cannot exceed 1000 characters. details: The purpose of the Nerdpack and how to use it. This cannot exceed 1000 characters. Use newlines for formatting, and don't include any markdown or HTML. categoryTerms: A list of terms that matches the Nerdpack to a category in the Instant Observability catalog. You can look up a mapping of category terms with NerdGraph: US Query EU Query keywords: A list of relevant words to improve the search discoverability of the Nerdpack. This cannot exceed 50 words, and each word cannot exceed 64 characters. support: An object that contains: issues: A URL for the repository's issues list. For example, the Issues tab if using GitHub. email: A valid email address for the team supporting the application community: A URL for a support thread, forum, or website for troubleshooting and usage support whatsNew: A bulleted list of changes in the current release version. This cannot exceed 500 characters. Use newlines for formatting, and don't include markdown or HTML. Check out our Pageview Map application's config.json to see a real-life implementation. documentation.md A markdown file that tells users how to use the Nerdpack's Nerdlets or visualizations. This shows in the detail view's Documentation tab. additionalInfo.md An optional markdown file for any additional information about using your application screenshots A directory that contains screenshots showcasing your Nerdpack, such as select images of Nerdlets or visualizations. This can contain no more than 6 images. All screenshots must meet the following criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide This command also generates a catalog directory for each launcher, Nerdlet, and visualization in your Nerdpack. Inside you'll find a directory that allows you to add screenshots for each Nerdpack item. bash Copy $ ls launchers/launcher/catalog screenshots $ ls nerdlets/home/catalog screenshots Step 5 of 9 Update your Nerdpack's documentation.md file: documentation.md config.json 1 Enter your first and last name into the fields provided. When you're done, press **Submit** to see a personalized \"Hello!\" message. catalog/documentation.md Copy 1 { 2 \"tagline\": \"\", 3 \"details\": \"\", 4 \"categoryTerms\": [], 5 \"keywords\": [], 6 \"repository\": \"\", 7 \"whatsNew\": \"\", 8 \"support\": { 9 \"email\": { 10 \"address\": \"\" 11 }, 12 \"issues\": { 13 \"url\": \"\" 14 }, 15 \"community\": { 16 \"url\": \"\" 17 } 18 } 19 } catalog/config.json Copy Step 6 of 9 Update your config.json file: documentation.md config.json 1 Enter your first and last name into the fields provided. When you're done, press **Submit** to see a personalized \"Hello!\" message. catalog/documentation.md Copy 1 { 2 \"tagline\": \"Say hi!\", 3 \"details\": \"DemoApp says Hello to a user.\", 4 \"categoryTerms\": [], 5 \"keywords\": [\"hello world\"], 6 \"repository\": \"https://github.com/newrelic/developer-website\", 7 \"whatsNew\": \"feat: Initial commit\" 8 } catalog/config.json Copy Step 7 of 9 Include screenshots in your root screenshots directory or any Nerdpack item screenshots directory. Step 8 of 9 Submit the information to the Instant Observability catalog: bash Copy $ nr1 catalog:submit Uploading screenshots from demo-app... ✔ Screenshots uploaded from: demo-app Uploading screenshots from demo-app/launchers/launcher... ✔ Screenshots uploaded from: demo-app/launchers/launcher Uploading screenshots from demo-app/nerdlets/home... ✔ Screenshots uploaded from: demo-app/nerdlets/home ✔ Updated metadata for DemoApp 1.0.0 Step 9 of 9 Go to Instant Observability to see your changes: Click your Nerdpack to see the new details: Click What's inside to see any screenshots you uploaded for individual items in your Nerdpack: Update your Nerdpack's icons Within a Nerdpack, you can set two types of icons: One for your entire Nerdpack, which represents your Nerdpack in the catalog One for each of your launchers, which represents your Nerdlets Replace these icons and publish your Nerdpack to see the changes. Step 1 of 7 Update the icon.png in the root of your Nerdpack. This icon is used in the catalog and the Nerdpack's detail page. Step 2 of 7 If you're building a Nerdpack with one or more launchers, update the icon.png in each of your launcher's subfolders. Step 3 of 7 Update your package.json version: { \"private\": true, \"name\": \"demo-app\", \"version\": \"1.0.1\", \"scripts\": { \"start\": \"nr1 nerdpack:serve\", \"test\": \"exit 0\" }, \"nr1\": { \"uuid\": \"f2dbc999-e9a3-49b9-933d-5a704c6750bd\" }, \"dependencies\": { \"prop-types\": \"^15.6.2\", \"react\": \"^16.6.3\", \"react-dom\": \"^16.6.3\" }, \"browserslist\": [\"last 2 versions\", \"not ie < 11\", \"not dead\"] } package.json Copy This allows you to publish a new version of your Nerdpack. Step 4 of 7 Publish your Nerdpack: bash Copy $ nr1 nerdpack:publish Step 5 of 7 Update your whatsNew string in catalog/config.json: documentation.md config.json 1 Enter your first and last name into the fields provided. When you're done, press **Submit** to see a personalized \"Hello!\" message. catalog/documentation.md Copy 1 { 2 \"tagline\": \"Say hi!\", 3 \"details\": \"DemoApp says Hello to a user.\", 4 \"categoryTerms\": [], 5 \"keywords\": [\"hello world\"], 6 \"repository\": \"https://github.com/newrelic/developer-website\", 7 \"whatsNew\": \"feat: Add new icons\" 8 } catalog/config.json Copy This will tell users what you added in the latest version of your Nerdpack. Step 6 of 7 Submit this new metadata to the catalog: bash Copy $ nr1 catalog:submit Uploading screenshots from demo-app... ✔ Screenshots uploaded from: demo-app Uploading screenshots from demo-app/launchers/launcher... ✔ Screenshots uploaded from: demo-app/launchers/launcher Uploading screenshots from demo-app/nerdlets/home... ✔ Screenshots uploaded from: demo-app/nerdlets/home ✔ Updated metadata for DemoApp 1.0.1 Step 7 of 7 Go to the catalog and subscribe to your Nerdpack to see your new icon: Resolve issues with submitting catalog information Sometimes, when you work with catalog metadata, you may run into issues. Consider some common solutions for resolving these issues. Publish your Nerdpack Remember that you can only submit catalog metadata for Nerdpacks that have already been published. If you try to submit information for a Nerdpack that hasn't been published, the CLI will try to help: bash Copy $ nr1 catalog:submit Uploading screenshots... › Error: 1 error while updating DemoApp 1.0.0 › › Invalid Version: Nerdpack version 1.0.0 not found. Have you run `nr1 nerdpack:publish` yet? › Code: UNKNOWN Resize your images Screenshots for the catalog must meet the criteria specified previously in this guide. If they don't, the CLI will try to help: bash Copy $ nr1 catalog:submit Uploading screenshots... › Error: 2 errors while updating DemoApp 1.0.1 › › catalog/screenshots/screenshot.png › Invalid Screenshot: screenshot.png has a size ratio of 4:2. Update size ratio to 3:2. › › catalog/screenshots/screenshot.png › Invalid Screenshot: screenshot.png has a width of 3054px. Update size to be between 1600px and 2400px. › Code: UNKNOWN Check the length of your strings Most of the content in config.json has string-length requirements. Make sure you review those requirements and adhere to them when you update your config.json file. Otherwise, you'll see errors when you try to submit your configuration to the catalog: bash Copy $ nr1 catalog:submit Uploading screenshots... ✔ Screenshots uploaded › Error: 2 errors while updating DemoApp 1.0.1 › › catalog/config.json › Invalid Metadata: `details` has a character length of 2204. Must be no longer than 1000 characters › › catalog/config.json › Invalid Metadata: `tagline` has a character length of 266. Must be no longer than 30 characters › Code: UNKNOWN",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 300.48816,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Resize your <em>images</em>",
        "body": " An optional markdown file for any additional information about using your application <em>screenshots</em> A directory that contains <em>screenshots</em> showcasing your Nerdpack, such as select <em>images</em> of Nerdlets or visualizations. This can contain no more than 6 <em>images</em>. All <em>screenshots</em> must meet the following criteria"
      },
      "id": "609c868664441f2bf22f3706"
    }
  ],
  "/docs/style-guide/structure/collapsers": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-09T22:55:57Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 437.29828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-09T22:13:57Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.39896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-09T22:16:38Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.38583,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/structure/levels-headings": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-strategies/organize-doc/",
      "sections": [
        "Organize your page",
        "Organize your page to make it easier to read",
        "Use action-oriented titles",
        "Start the document with an introductory paragraph",
        "Keep documents short",
        "Use the New Relic voice",
        "Change doc titles and anchors",
        "Create and edit categories",
        "Start writing and editing docs"
      ],
      "published_at": "2021-12-09T22:55:14Z",
      "title": "Organize your page",
      "updated_at": "2021-11-24T07:56:48Z",
      "type": "docs",
      "external_id": "a3e3c993c0bf65626e805676496bcae8ea8d2c64",
      "document_type": "page",
      "popularity": 1,
      "body": "These are some organization basics. Organize your page to make it easier to read Consider these organization guidelines when thinking about the order of information in a doc. By following these guidelines, you'll make it easier for readers to skim and find what they need. How to organize information Comments Separate what and why from how. Define any necessary prerequisites, policies, or background information (the what and the why) before you step through the how (step-by-step procedures). Examples: Explain what the feature is and why it matters before telling readers how to use it. Describe any limitations with user permissions or subscription levels that would prevent them from using the feature. If the feature is available for any user or subscription level, don't bother to say so. Provide a roadmap for what users will be able to accomplish, so they know before starting a procedure that they have everything they need. Front-load directions with context. Make sure readers know where they need to be, before telling them what to do. In general, use (select an app) to describe what users select from the product index. Examples: Go to one.newrelic.com > Explorer > (select an app or service). Select (account dropdown) > User preferences. On the command line, type gitk. Also, structure steps by front-loading context from the user's point of view. For example, instead of \"Go to x to do y,\" structure the step as \"To do y, go to x.\" Separate requirements from options. Example: Type the Email you use to sign in and to receive information from New Relic. Optional: Type additional user emails, separated by commas. Follow the \"five to nine\" guideline. Depending on the topic, organize the information so there is a maximum of five to nine chunks of information. For example, readers may start to get lost or overwhelmed after about five h2 sections or seven steps into a procedure. If you have more than nine h2 sections or steps, you might need to create an additional doc or procedure. Other organization tools to consider: Levels of headings Lists Collapsers Callouts Tables Code examples For more help section Use action-oriented titles Wherever possible, give your document or h2 heading a task- or action-oriented title. Focus on what users are trying to accomplish or the problem they're trying to solve. Use present-tense verbs, rather than \"-ing\" verbs. Quality Title example Bad The query history Okay View query history Good Query history: Create and edit NRQL queries Start the document with an introductory paragraph Unless the document is less than a single screen in length, begin with a brief paragraph that introduces the topic or summarizes the important points. Not sure where to start? Try writing all the content for your document first, and then add the introduction to the top to summarize your key points. Or use the introduction to expand on the text in your metaDescription in the metadata. Keep documents short The amount of content needed can help you decide whether you need one or more documents for the topic. If all of the document's contents apply directly to the title, then everything belongs in the same document. If several related sections could be logically split into individual documents, and the overall length of your document is more than about two screenfuls, split those sections into other documents. Be sure to include links to the related contents. If a large document needs to be broken into multiple smaller documents, consider whether they might be best grouped together in their own sub-category. Use the New Relic voice We strive for a voice that's approachable, expert, and visionary. Check out our voice guidelines for how to write content with these qualities. And keep in mind these essential writing tips that apply to any type of documentation. Guidelines Comments Be clear and direct. Remember to: Use present tense. Use active voice; avoid passive voice. Tell users what to do, not what they \"should\" do. If absolutely necessary, tell users what not to do in situations where unexpected results may occur. Whenever possible, provide an alternative suggestion when telling users what not to do. Example: Using active voice with an alternative suggestion for what not to do Do not use your config file to change this setting, because this could affect other processes. Instead, go to one.newrelic.com > APM > (select an app or service) > Settings > Application. Write to aid localization and translation. Do not use euphemisms, idioms, jargon, or slang. Use the same terms and wording consistently. If you need to include an abbreviation or acronym, spell it out the first time it appears in the document. Always take a moment to ask yourself whether people will really understand the terms you are using in the way you're using them. Change doc titles and anchors Because changes to doc titles, anchors, and redirects can break links to other docs, please create an issue to request these types of changes and we'll help you out with that. Create and edit categories Because changes to categories can affect large groups of docs at once, please create an issue to request these types of changes and we'll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see Create and edit content. To learn how to create and publish release notes, see Create release notes. To make it even easier to start a new doc, use templates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 759.4695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " any limitations with user permissions or subscription <em>levels</em> that would prevent them from using the feature. If the feature is available for any user or subscription <em>level</em>, don&#x27;t bother to say so. Provide a roadmap for what users will be able to accomplish, so they know before starting a procedure"
      },
      "id": "619df04028ccbc2730b9a00a"
    },
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "9ec2ccd8a8509ab1b54273206e84f9571164c4f9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-11-26T05:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.5925,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Headings</em> (H2s)",
        "body": " that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they&#x27;ve found the right doc. It provides a short, readable overview of the doc&#x27;s contents. <em>Headings</em> (H2s) Check that: Heading names are concise, yet provide information that helps readers"
      },
      "id": "61b35af4e7b9d2769c5a38f9"
    },
    {
      "sections": [
        "Capitalization",
        "Use sentence case in headings",
        "Important",
        "Products and features",
        "UI elements and UI page paths"
      ],
      "title": "Capitalization",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "5d5fb84286568c2a7842bae1247613d33a347593",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/capitalization/capitalization/",
      "published_at": "2021-12-09T22:13:56Z",
      "updated_at": "2021-11-24T08:52:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In general, we only capitalize things when we need to. Over use of capitalization is distracting and limits accessibility for our readers with vision impairment. Read on for some guidelines on how to decide what to capitalize in a document's title, headings, products, features, and other elements of the page. Use sentence case in headings Use sentence case for headings. This includes category headings and document titles. With sentence case, capitalize only the first letter of: The first word Proper nouns Acronyms and abbreviations We have some exceptions: If the heading is a code term, such as a variable or function, then capitalize it exactly as it's used in the code; for example: noticeError. If the heading includes a colon, follow the Microsoft Style Guide for titles and headings, and capitalize the first word that appears after the colon; for example: APM Error profiles: Troubleshoot trends. Important Use sentence case for graphical illustrations such as diagrams and figures. Explore our Screenshots and images document for more information on our image guidelines. Products and features Item Example We use title case for products. Infinite Tracing We don't capitalize features (including features that used to be products). Use transaction traces to... not Use Transaction Traces to... Our infrastructure monitoring... not Our Infrastructure monitoring... UI elements and UI page paths Item Example We use sentence case and bold for UI elements, even if the UI element is in a different case in the UI. \"From the Transactions page, select Transaction traces and...\" We use sentence case and bold for each element in a path that references UI pages. Go to one.newrelic.com > APM > Transactions > Transaction traces > (select a trace) > Another thing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.202354,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use sentence case in <em>headings</em>",
        "body": "In general, we only capitalize things when we need to. Over use of capitalization is distracting and limits accessibility for our readers with vision impairment. Read on for some guidelines on how to decide what to capitalize in a document&#x27;s title, <em>headings</em>, products, features, and other elements"
      },
      "id": "60421e50196a67d785a83d97"
    }
  ],
  "/docs/style-guide/structure/lists": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-09T22:55:57Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 437.29828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-09T22:13:57Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.39896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-09T22:16:38Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.38583,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/structure/tables": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-09T22:55:57Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 437.298,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "version number <em>references</em>",
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", or the New Relic One docs. Node.js Always <em>refer</em> to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this <em>style</em> <em>guide</em>). Don&#x27;t use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-09T22:13:57Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.39886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Lists",
        "Tip",
        "In-line lists"
      ],
      "title": "Lists",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "c8dd72524718c4e6e1d36d0f23b9af6ab4203e2a",
      "image": "https://docs.newrelic.com/static/425a3955215de94222a432e13be5dc84/8c557/tables-example.png",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/lists/",
      "published_at": "2021-12-09T22:16:38Z",
      "updated_at": "2021-11-24T09:17:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Lists are a powerful way to organize information, but they don't always make for a pleasant reading experience. Keep these points in mind when you're writing a list: Always capitalize the first letter of the first word in each list item. Use ordered (numbered) lists for step-by-step procedures, where the order matters. Use unordered (bulleted) lists to make it easier for users to skim related information. Use OR on a separate line when there is more than one option for a numbered step or a bullet point. Use tables when your ordered or unordered list would benefit from some extra detail. Tip For punctuation guidelines, follow the Microsoft Writing Style Guide, which includes considerations for localization. Here's an example of an ordered list as a table. Because each step is a row, the table helps to structure the levels of detail. In-line lists As an alternative to using bullet point lists, you can do an in-line list, like this: C SDK | Go | Java. You might want to use an in-line list when: You're linking to further documentation. Customers will likely be selecting a single option. The list item can be displayed with a short word or phrase (like Java, or Infrastructure). You think a bullet point list takes up a lot of vertical space. This may happen in circumstances where a procedure must include several lists. Here's one example of this. There are only two or three potential options they'll be choosing from and a bullet point list seems unnecessary. Here's an example.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.38367,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " For punctuation guidelines, follow the Microsoft Writing <em>Style</em> <em>Guide</em>, which includes considerations for localization. Here&#x27;s an example of an ordered list as a table. Because each step is a row, the table helps to structure the levels of detail. In-line lists As an alternative to using bullet point"
      },
      "id": "60421e4e28ccbc71a9eba7a2"
    }
  ],
  "/docs/style-guide/word-choice/pricing-language-guidelines": [
    {
      "sections": [
        "Query and alert on billing/usage data",
        "Available data types",
        "Query examples",
        "Data usage queries",
        "Daily data usage",
        "Daily usage by source",
        "Metrics ingest by source",
        "Month-to-date data usage",
        "Month-to-date estimated data cost",
        "User count queries",
        "Month-to-date full platform users",
        "Projected monthly full platform user count",
        "Count full platform users and basic users",
        "Set usage alerts",
        "Caution",
        "Ingested gigabytes exceed a fixed value",
        "Usage exceeds fixed threshold for GBs",
        "Usage exceeds fixed threshold for users",
        "Usage exceeds fixed threshold for estimated cost",
        "Available attributes"
      ],
      "title": "Query and alert on billing/usage data",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "New Relic One pricing and billing"
      ],
      "external_id": "e22ae9e26686d11726a82ad4036ff58520b4a439",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-pricing-billing/usage-queries-alerts/",
      "published_at": "2021-12-09T22:39:53Z",
      "updated_at": "2021-12-04T21:08:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For accounts on our New Relic One pricing model, we provide a View your usage UI for understanding billing-related usage and a Manage your data UI for managing billing-related data. Additionally, you can: Query your usage data to get more detail than is available in the UI. Set up NRQL alert conditions to get notifications about changes in your usage. Note that account hierarchy may affect queried data. See Account structure. Available data types Usage data is attached to these events: NrConsumption records usage every hour, and is the equivalent of \"real-time\" usage. Use this event to observe usage trends over time. NrMTDConsumption generates aggregate values from the NrConsumption event. Use this event to see usage or estimated cost for a billing period. NrUsage records usage every hour and is used to see usage reported per product. To see changes made to your account (for example, user management changes), you can query NrAuditEvent. Query examples The View your usage UI displays your data usage and billable user count. If you need more detail than that UI provides, you can use these NRQL queries. For definitions of some of the attributes used in these queries, see Attributes. Data usage queries Here are some data usage query examples: Daily data usage This query totals your billable ingested data, and displays a daily value for the past three months: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' SINCE 3 months ago TIMESERIES 1 day Copy Daily usage by source This query totals your billable ingested data, and displays a daily value for the past three months faceted by the source: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' SINCE 3 months ago FACET usageMetric TIMESERIES 1 day Copy Metrics ingest by source This query breaks down Metric data by the top ten metric names. You could also facet by appName or host to adjust the analysis. FROM Metric SELECT bytecountestimate()/10e8 as 'GB Estimate' SINCE '2021-04-01' UNTIL '2021-04-08' FACET metricName LIMIT 10 TIMESERIES 1 day Copy Month-to-date data usage This query shows the current full platform user count. In other words, it shows how much you'd be billed for your data for that month if you were billed right now. FROM NrMTDConsumption SELECT latest(GigabytesIngested) WHERE productLine = 'DataPlatform' SINCE this month Copy Month-to-date estimated data cost This query shows the estimated cost of your ingested data: FROM NrMTDConsumption SELECT latest(estimatedCost) WHERE productLine = 'DataPlatform' SINCE this month Copy User count queries Here are some user-related query examples. For details on how users are counted, see User count calculations. Month-to-date full platform users This query shows the billable full platform users for the month. In other words, it shows how much you'd be billed for your users for that month if you were billed right now. FROM NrMTDConsumption SELECT latest(usersBillable) SINCE this month Copy This query shows how many full platform users were counted by hour. This is useful for seeing how the full platform user count changed over time. from NrConsumption SELECT max(FullUsers) SINCE 10 days ago TIMESERIES 1 hour Copy Projected monthly full platform user count This query shows a projected count of monthly users. This query would not be good for using in a dashboard; it requires values based on a) the days remaining in the month, b) the start of the month. Here's an example querying the projected end-of-month count with 10 days left in that month: FROM NrMTDConsumption SELECT predictLinear(FullUsers, 10 days) SINCE '2020-09-01' Copy Count full platform users and basic users The usage UI shows the count of full platform users and basic users. The query used is: FROM NrUsage SELECT max(usage) SINCE 10 days ago WHERE productLine='FullStackObservability' WHERE metric in ('FullUsers', 'BasicUsers') FACET metric Copy To see the count of full and basic users over time: FROM NrUsage SELECT max(usage) SINCE 10 days ago WHERE productLine='FullStackObservability' WHERE metric in ('FullUsers', 'BasicUsers') FACET metric TIMESERIES 1 hour Copy Set usage alerts To help manage your billable data, you can set alerts to notify you of unexpected increases in usage. Learn how to create alerts with NRQL queries here. Caution When creating alert conditions, you should use the Event Timer method, which works very well with infrequent data. Here are some NRQL alert condition examples. For attribute definitions, see Attributes. Ingested gigabytes exceed a fixed value This query will create an alert when your hourly usage exceeds a fixed value: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' Copy If you have multiple child accounts, you may want to set threshold alerts for a specific subaccount: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' AND consumingAccountId = YOUR_CHILD-ACCOUNT_ID Copy Usage exceeds fixed threshold for GBs This query will create an alert when your usage exceeds fixed monthly threshold for GBs: FROM NrMTDConsumption SELECT latest(GigabytesIngested) WHERE productLine = 'DataPlatform' Copy Usage exceeds fixed threshold for users This query will create an alert when your usage exceeds fixed monthly threshold for billable users: FROM NrMTDConsumption SELECT latest(usersBillable) Copy Usage exceeds fixed threshold for estimated cost This query will create an alert when your usage exceeds fixed threshold for estimated cost: FROM NrMTDConsumption SELECT latest(estimatedCost) WHERE productLine = 'DataPlatform' Copy Available attributes Below are some of the important attributes attached to usage events. Attribute Description productLine The category of usage. There are three options: DataPlatform, FullStackObservability, and ProactiveDetection. (Starting November 1, 2021, IncidentIntelligence is no longer a billing factor). For more details about these categories, see New Relic platform. metric Consolidates multiple categories of usage into a single metric. Helpful when faceting by productLine. consumingAccountId ID of the New Relic account that is directly responsible for the stored events, as determined from the license key used. estimatedCost Calculates a cost estimate based on usage and metric cost. This is an estimate of costs to date, not your monthly invoice. For more attributes, see the data dictionary.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.32782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Query and alert on <em>billing</em>&#x2F;usage data",
        "sections": "Query and alert on <em>billing</em>&#x2F;usage data",
        "tags": "New Relic One <em>pricing</em> and <em>billing</em>",
        "body": "For accounts on our New Relic One <em>pricing</em> model, we provide a View your usage UI for understanding <em>billing</em>-<em>related</em> usage and a Manage your data UI for managing <em>billing</em>-<em>related</em> data. Additionally, you can: Query your usage data to get more detail than is available in the UI. Set up NRQL alert"
      },
      "id": "6175f12b64441f53a35fc21c"
    },
    {
      "sections": [
        "New Relic One pricing and billing",
        "Important",
        "How the New Relic One pricing model works",
        "Billing and usage in the UI",
        "Billing calculation details",
        "Data usage calculation",
        "Full platform user count billing details",
        "Data retention",
        "Billing periods",
        "Usage plan details",
        "Query and alert on usage data",
        "Free tier",
        "Non-profit use of New Relic",
        "Cancel or downgrade"
      ],
      "title": "New Relic One pricing and billing ",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "New Relic One pricing and billing"
      ],
      "external_id": "03d43f14ae24579c81b601571242aef540833c8c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-pricing-billing/new-relic-one-pricing-billing/",
      "published_at": "2021-12-09T22:57:29Z",
      "updated_at": "2021-11-24T14:22:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "An explanation of how New Relic One pricing works, and how to view and manage billing. Important This document explains the New Relic One pricing model. If you’re on our original pricing model, see Original pricing. Not sure which you're on? See Overview of pricing. How the New Relic One pricing model works Starting July 30, 2020, all of our new customers are on a pricing model that we call New Relic One pricing. Customers on our original pricing model are able to transition to this pricing. For New Relic One pricing, billing is based on these factors: The amount of data ingested. 100 GBs per month is free. $0.25 per GB ingested above that. The number of provisioned full platform users, who have access to our more curated UI experiences. Basic users are free. The cost of each full platform user depends on your edition: Standard, Pro, or Enterprise. Standard edition includes one full platform user for free, and a max of five. Pro and Enterprise give access to more account and user management features, more support, longer data retention, and other features. For a summary of what's included for free, see Free edition. For an overview of pricing, see our Pricing page. Keep reading for details about New Relic One pricing and billing. Billing and usage in the UI For how to view and manage billing and usage in the UI, see Pricing and billing UI. If you need more detail than the usage UI shows, you can also run queries of your usage data and set up alerts. Billing calculation details For accounts on New Relic One pricing, some high-level billing information is displayed in the UI. Here are some more details about how billing works: Data usage calculation One pricing factor is your ingested data. In this context, “ingested” refers to the data actually saved to your account after we apply various data trimming and data transformation rules. In other words, it’s not the size of the raw data sent to New Relic, but the size of the data that actually ends up stored. To view and manage your usage, go to the usage UI. Other calculation details: In the context of our pricing model, a GB is defined as 1 billion bytes. Monthly data ingested is rounded down to the nearest integer. For example, if your account uses 100.9 GBs during a month, that’s counted as 100 GBs. For more on how data is ingested, see Manage data ingest. For how to query usage, see Query and alert on usage. Full platform user count billing details For accounts with New Relic One pricing, the monthly count of provisioned full platform users is one billing factor. To give an example: if you're on the Pro pricing edition and your organization has 100 full platform users during the month of January, you'd be billed for 100 full platform users for that month. A full platform user counts as a billable user the moment they're added to a New Relic organization (provisioned), whether or not that user has logged into or used New Relic yet. A user's user type is meant to be long-term setting determined by a user's expected New Relic duties and responsibilities. Because user type is a billing factor, we have restrictions around how often a full platform user can be downgraded to a basic user: a full platform user can downgrade to a basic user a maximum of two times in a rolling 12-month period. If a full platform user has been changed to a basic user two times in that 12-month period, that user won't be able to return to being a basic user until the start of the next 12-month period. To learn reasons for assigning one user type or another, see Tips on assigning user type. Here are more user-related billing details and caveats: You can see your full platform user count in the UI. We de-duplicate users based on email address. If there are multiple users in an organization that have the same email address, those user records count as a single user for billing purposes. The count of full platform users is prorated based on the start of a New Relic subscription, or based on when a user is created as a full platform user or converted to a full platform user. A New Relic user can have a maximum of either three concurrent active sessions, or three unique IP addresses in use at any given time. For organizations on our original user model that have a parent/child account structure, the count of billable users in the UI may differ from the users you can see. For more on this, see User count discrepancy. The Standard edition of the New Relic One pricing model includes one free full platform user. For organizations on our original user model, because the organization-related settings aren't as robust as on our newer model, a user may be set as a basic user in one account and as a full platform user in another account. In such cases, the full platform user status takes precedence and that user is considered a full platform user. For how to query usage data, see Query and alert on usage. For more on user capabilities, see Users and roles. Data retention See Data retention. Billing periods For pay-as-you-go customers, billing occurs at the end of the month (UTC), and you can see this tracked in the UI. When you input your credit card and start to be charged, your end-of-month bill will take into account all activity (billable data usage and users) that occurred since the beginning of that month. For example: if you input your credit card in the middle of the month, and so far at that point your account has 200 GBs of usage for that month, that 200 GBs counts towards your end-of-month bill. For how to query user-related usage, see Query and alert on usage. Usage plan details There are two New Relic One pricing usage plans: Pay-as-you-go: This plan bills at the end of each month. There are no commitments and you can cancel at any time. For details, see Usage plans. Annual pool of funds: This plan applies to some customers who have subscribed for a year or more. For details, see Usage plans. For some frequently asked questions, see Pricing FAQs. Query and alert on usage data To create detailed queries of your usage, and get notifications when you are close to hitting certain usage levels, see Query usage data. Free tier If your organization is on New Relic One pricing and on the Standard pricing edition, you can use New Relic free, forever, if you stay under the free allowed limits. Here's a summary of what Standard edition gets access to for free: A single account (Pro and Enterprise editions can have multiple accounts per organization). Up to 100 GBs of ingested data per month. One full platform user, and unlimited basic users. To upgrade to Pro or Enterprise, or to learn more about pricing, see New Relic pricing. Non-profit use of New Relic If you’re a non-profit and want to use New Relic at special pricing, see our Non-profit eligibility docs. Cancel or downgrade See Downgrade account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.03669,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic One <em>pricing</em> and <em>billing</em> ",
        "sections": "New Relic One <em>pricing</em> and <em>billing</em>",
        "tags": "New Relic One <em>pricing</em> and <em>billing</em>",
        "body": " at that point your account has 200 GBs of usage for that month, that 200 GBs counts towards your end-of-month <em>bill</em>. For how to query user-<em>related</em> usage, see Query and alert on usage. Usage plan details There are two New Relic One <em>pricing</em> usage plans: Pay-as-you-go: This plan bills at the end"
      },
      "id": "6043f69a64441f7b26378eda"
    },
    {
      "sections": [
        "Overview of changes to pricing and user model",
        "Overview of how pricing model and user model relate",
        "Pricing plans explained",
        "Determine pricing model",
        "Convert to new pricing",
        "User models explained",
        "Requirements for new user model",
        "Determine which user model you're on",
        "Feature impacts of user model",
        "Transition to new models"
      ],
      "title": "Overview of changes to pricing and user model",
      "type": "docs",
      "tags": [
        "Accounts",
        "Original accounts and billing",
        "Original product-based pricing"
      ],
      "external_id": "b19d61b5a0c65ca352e2ce0e260e2b53391b94fc",
      "image": "https://docs.newrelic.com/static/1461470cc1ef0be91120c84d76a7ccdd/c1b63/new-relic-one-pricing-plan-billing-ui.png",
      "url": "https://docs.newrelic.com/docs/accounts/original-accounts-billing/original-product-based-pricing/overview-changes-pricing-user-model/",
      "published_at": "2021-12-09T22:08:55Z",
      "updated_at": "2021-11-24T14:34:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In 2020, New Relic released both a newer pricing model and a newer user model. Keep reading to learn about: How the pricing model and the user model relate to each other Pricing plans explained User models explained How to switch to the new models Overview of how pricing model and user model relate In 2020, we released both a new, improved pricing model and a new, improved user model. These models represent the future. All new sign-ups are on these new models and eventually all organizations will be on these models. But currently, our customers from before July 2020 may have one of several combinations of these as they either switch to the new pricing or migrate their users to the new user model. This table shows how pricing and user model relate to each other: Pricing plan factors User model factors Original pricing If your organization was created before July 30 2020, you remain on our original pricing model until you transition to New Relic One pricing. For original pricing accounts, you have users on the original user model unless you've migrated your users to the new model. Note that if you've added users via automated user management, they're on the new model. This means it's possible to have some users on both models. New Relic One pricing An organization is on the New Relic One pricing model: If it was created on or after July 30 2020, or If it's an older organization but has switched to New Relic One pricing. If your organization was created on or after July 30 2020, your users are on the New Relic One user model. If you have an older organization, you have users on the original user model unless you've migrated your users to the new model. Pricing plans explained New Relic organizations are on one of two pricing models: New Relic One pricing: Our new pricing model is simpler. It bills on a) which edition you're on (Standard, Pro, or Enterprise), b) the GBs of data ingested, and c) how many billable full platform users you have. All organizations created on or after July 30 2020 are on this pricing model, as are older organizations that have switched to this pricing. There are two versions of this pricing model. Our original product-based pricing model: this is based on subscriptions to specific products (for example, APM, Browser, Mobile, Infrastructure). Some organizations have the option to transition to the newer pricing model: in that case, their users remain on our original user model. Determine pricing model To determine which pricing model you’re on: go to one.newrelic.com, select the account dropdown, and select Manage your plan. If you see billing information about data ingested and the number of billable users, you’re on the new pricing model. If you're on New Relic One pricing, you'll see a billing UI like this. Convert to new pricing Some organizations are able to switch to new pricing. Learn more about switching your pricing model. User models explained In this context, the term \"user model\" refers to the structure of a New Relic user record and how it interacts with the broader New Relic organization that it's in. Our two user models are: New Relic One user model: this newer, improved user model has these major differences from the original user model: All your accounts and users are contained under a top-level organization. This gives an organization stronger control over managing users and what they can access. One impact of this is that users who work with multiple New Relic organizations may have an email address associated with multiple logins. Users on this model have a different system for managing permissions and account access. Using access grants, you assign users access to specific roles on specific accounts. Original user model: some aspects of this older model that are different from our newer model: There wasn't as much organization-level control over users. For example, a New Relic user had the ability to access multiple accounts they'd been granted access to using a single login. Users on the original user model have a different user management system. To learn more about benefits of the new model, see our blog post about user model changes and an explanation of the new account structure. For impacts and limitations, see Feature impacts. Requirements for new user model Here's a synopsis of the factors governing what organizations use the new model: All New Relic organizations that signed up after July 30 2020 have users on this model, and also have the new pricing model. Some older New Relic organizations have had their users migrated to the new model by New Relic or by using the user migration procedure. Note that switching to the new pricing model is independent from migrating users. Partner accounts (resellers, managed service providers), and organizations using the partnership account structure, cannot yet migrate their users to the new model. Determine which user model you're on To determine what user model you're on, from the account dropdown select User preferences. If you see the UI below, you're on the New Relic One user model. If you see a different UI with more content displayed, you're on the original user model (see original user docs). To determine if you can manage users on the New Relic One user model, see Manage users. The user model is independent of your pricing model. For how user model relates to pricing, see the Pricing and user model table. Feature impacts of user model The new user model offers many benefits. Here are some feature impacts of being on the New Relic One user model that may be not obvious to users accustomed to our previous user model: More separation of organizations/accounts: If you have an email address associated with multiple New Relic accounts, this may mean you need to log out and log back in. Learn more about account access. Adding accounts: Pro and Enterprise edition can have more than one account in their organization. Currently users in these organizations cannot, on their own, add accounts. They must get help from their New Relic account representative. To learn about adding users to accounts, see Manage users. Alerts-related impacts: Policy actions: For alert policies and conditions, some UI locations display the user that made the last modification. For users on the new model, it will display their user ID and not their user name. For example, a policy might read Last modified Sep 7, '20 4:26 pm by user 1234567 instead of by John Doe. If you have user management permissions, you can determine what user this is by going to the User management UI. Notifications: Users on the new model won’t show up as an option when choosing users to receive alert notifications. The result of this is that these users will not get New Relic mobile app push notifications. As a workaround, you can instead use their email address as the notification channel. You can't use the REST API to generate a list of users (only original model users). Instead you'd use the user management UI. Changing account name: These users cannot change the name of their organization after it has been created. Transition to new models Some New Relic organizations on the old models are able to transition to the new models. To learn more about this, see Transition to new models.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.46036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Overview of changes to <em>pricing</em> and user model",
        "sections": "Overview of how <em>pricing</em> model and user model <em>relate</em>",
        "tags": "Original accounts and <em>billing</em>",
        "body": ", their users remain on our original user model. Determine <em>pricing</em> model To determine which <em>pricing</em> model you’re on: go to one.newrelic.com, select the account dropdown, and select Manage your plan. If you see <em>billing</em> information about data ingested and the number of billable users, you’re on the new"
      },
      "id": "603e97fa28ccbcb7c2eba754"
    }
  ],
  "/docs/style-guide/word-choice/usage-dictionary": [
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-09T22:13:57Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.39874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-09T22:16:38Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.38574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a <em>basic</em> table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    },
    {
      "sections": [
        "Lists",
        "Tip",
        "In-line lists"
      ],
      "title": "Lists",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "c8dd72524718c4e6e1d36d0f23b9af6ab4203e2a",
      "image": "https://docs.newrelic.com/static/425a3955215de94222a432e13be5dc84/8c557/tables-example.png",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/lists/",
      "published_at": "2021-12-09T22:16:38Z",
      "updated_at": "2021-11-24T09:17:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Lists are a powerful way to organize information, but they don't always make for a pleasant reading experience. Keep these points in mind when you're writing a list: Always capitalize the first letter of the first word in each list item. Use ordered (numbered) lists for step-by-step procedures, where the order matters. Use unordered (bulleted) lists to make it easier for users to skim related information. Use OR on a separate line when there is more than one option for a numbered step or a bullet point. Use tables when your ordered or unordered list would benefit from some extra detail. Tip For punctuation guidelines, follow the Microsoft Writing Style Guide, which includes considerations for localization. Here's an example of an ordered list as a table. Because each step is a row, the table helps to structure the levels of detail. In-line lists As an alternative to using bullet point lists, you can do an in-line list, like this: C SDK | Go | Java. You might want to use an in-line list when: You're linking to further documentation. Customers will likely be selecting a single option. The list item can be displayed with a short word or phrase (like Java, or Infrastructure). You think a bullet point list takes up a lot of vertical space. This may happen in circumstances where a procedure must include several lists. Here's one example of this. There are only two or three potential options they'll be choosing from and a bullet point list seems unnecessary. Here's an example.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.38364,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": " For punctuation guidelines, follow the Microsoft Writing <em>Style</em> <em>Guide</em>, which includes considerations for localization. Here&#x27;s an example of an ordered list as a table. Because each step is a row, the table helps to structure the levels of detail. In-line lists As an alternative to using bullet point"
      },
      "id": "60421e4e28ccbc71a9eba7a2"
    }
  ],
  "/docs/style-guide/word-choice/user-related-language-guidelines": [
    {
      "image": "https://docs.newrelic.com/static/565d4ebddf52a4592c594032696516b9/c1b63/New-Relic-capabilities-UI-screenshot.png",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-user-management/new-relic-one-user-model-understand-user-structure/",
      "sections": [
        "Users, roles, permissions (New Relic One user model)",
        "Important",
        "Overview",
        "User type: basic users and full platform users",
        "Compare full vs basic capabilities",
        "Tips on choosing user type",
        "Understand user-related billing",
        "Have questions about why you can't access something?",
        "Default groups: Admin and User",
        "How do user type, roles, and groups relate to each other?",
        "Roles and capabilities",
        "Standard (default) roles",
        "Capabilities",
        "Manage users",
        "2020 user model changes"
      ],
      "published_at": "2021-12-10T06:52:26Z",
      "title": "Users, roles, permissions (New Relic One user model)",
      "updated_at": "2021-11-24T02:17:27Z",
      "type": "docs",
      "external_id": "169383c2678ce973404db07195b2dee6eda9163d",
      "document_type": "page",
      "popularity": 1,
      "body": "Your New Relic users can be on one of two user models: this doc explains the New Relic One user model. Important If your New Relic organization was created before July 30 2020 and you haven't gone through a user migration process, your users are likely on our original user model. For more on this, see User model changes. Overview This doc will explain the structure of the New Relic One user model, including: User type (basic user versus full platform user) Default user groups, including Admin and User Roles and capabilities For how to add and manage users in the UI, see User management. User type: basic users and full platform users Important This section is for users on our New Relic One user model. In November, 2021, we changed the user type \"full user\" to \"full platform user.\" A user's user type determines if they have access to our basic features (basic user) or can access all of our curated observability UI features (full platform user). The user type is something meant to be set long-term based on that user's expected New Relic responsibilities. Below are details on the two user types. Note that full platform users are billable only if you're on New Relic One pricing. Basic user. Details: These users are free and have access to a wide range of features, including setting up and configuring any New Relic data-reporting tool, running queries of your data, using our logs UI, making custom charts and dashboards, and setting up alerts. Unlike full platform users, they do not have access to our more curated observability UI experiences or some Applied Intelligence features (for a detailed comparison, see Capabilities). Basic users will see prompts to become a full platform user when they attempt to access unavailable features. For details, see Upgrade. Full platform user, also known as full user. Details: Full platform users have access to everything (depending on any role restrictions), including all our observability UI experiences, such as APM, infrastructure monitoring, browser monitoring, mobile monitoring, synthetic monitors, access to New Relic One apps, and more. For details, see Capabilities. Standard edition includes one free full platform user and up to five total full platform users. A full platform user can downgrade to a basic user twice in a 12-month period. To view and edit the user type of your users, use the User management UI. Learn more about basic user versus full platform user differences: Compare full vs basic capabilities Below is a table comparing what basic users and full platform users can do. A simple way to think about it is that full platform users have theoretical access (dependent on any chosen role restrictions) to all of our curated UI experiences, while basic users are restricted to fairly basic capabilities. Features Full platform user Basic user Observability UI experiences Application monitoring (APM) UI Infrastructure monitoring UI Digital Experience Monitoring UI, which includes: Browser monitoring UI Mobile monitoring UI Synthetic monitoring UI Synthetics checks Serverless monitoring UI Logs in context Distributed tracing UI Infinite Tracing (Pro and Enterprise edition) Assorted UI experiences, including: Kubernetes cluster explorer UI Errors Inbox Key transaction UI Workloads UI CodeStream integration (temporary preview access) Access to New Relic One apps Can build apps but can't access other apps New Relic One platform capabilities Full platform user Basic user Data ingest from any source (agents, integrations, APIs) Query data Create custom charts and dashboards Alerts and notifications APIs, including NerdGraph (basic user permissions) Query and chart log data Build New Relic One apps (but cannot access other apps) Manage New Relic data Manage other New Relic users Applied Intelligence Full platform user Basic user Acknowledge and resolve issues Root cause analysis Incident/anomaly analysis Correlation assistant Issue maps Machine learning classification Note that the pricing edition (Standard, Pro, or Enterprise) will also affect what features you have access to. For organizations with New Relic One pricing, learn more about how full platform users impact billing. Tips on choosing user type A user's user type (basic user vs full platform user) is meant to be a long-term assignment, based on the New Relic responsibilities that user is expected to perform. A full platform user can be downgraded to a basic user only twice in one year. Below are tips for why you'd choose full platform user versus basic user. Reasons to make someone a full platform user: They play a key role in the development, testing, deployment, and maintenance phases of the application development lifecycle. They break/fix code regularly; they are responsible for triaging workflows, troubleshooting, or managing users and roles for their team. They have DevOps practices like version control systems, and they implement CI/CD. They need to use New Relic's curated dashboards and experiences (not just the ability to create their own custom queries and charts); in other words, they need full access to our platform. They need to be able to manage users and/or billing. Reasons to make someone a basic user: They play a key role in the planning phase of the application development lifecycle. They use and configure New Relic agents, APIs, and integrations to send us data, and access, configure, and use alerts on such data (not necessarily responsible for triaging workflows, troubleshooting, or managing users and roles for their team). They want to see high-level analytics and business metrics for future planning (such as C-Suite executives). They do not need to use our curated experiences and dashboards, but would benefit from the ability to create their own custom queries and charts of data; in other words, they don't need full access to the platform. They don't manage users. For accounts on New Relic One pricing, learn more about user-related billing calculations. Understand user-related billing If you're on the New Relic One pricing model, full platform users are billable, and there are restrictions around how often a full platform user can downgrade to a basic user. For details, see User count billing details. For how to query and alert on usage data, see Query usage data. Have questions about why you can't access something? See Factors affecting access. Default groups: Admin and User For users on our New Relic One user model, a \"group\" is what allows the grouping together and managing of multiple users at the same time. Your New Relic users are assigned to a group, and that group is granted access to specific roles on specific accounts. We have two default groups: User: This group allows a user to use and configure monitoring/analysis features but not perform account-related tasks like managing billing or users. It has access to the All product admin role, which gives access to our observability platform tools but not to the organization and user management capabilities governed by the Organization manager and Authentication manager roles. Admin: has full access and capabilities, including the organization-level admin abilities. This is the equivalent of having the All product admin, the Billing user, the Organization manager and the Authentication domain manager roles. These groups are added inside your default authentication domain, which includes the default settings of users a) being managed via New Relic and b) logging in via standard email and password. If you add other authentication domains (for SAML SSO and/or SCIM provisioning of users), you'd have new custom groups in those new domains to govern those users. Note that groups, whether default or custom, are not what limit a user's capabilities: it is the role that is assigned to that group (with any basic user restrictions on top of that). If your organization is Pro or Enterprise edition and you want to understand how users are granted access to specific roles and accounts, see Access grants. To change the group a user is in, use the User management UI. How do user type, roles, and groups relate to each other? For users on the New Relic One user model, here's a table explaining how user type (basic vs full platform), roles, and groups relate to each other: Full platform user Basic user Group Full platform users can be assigned to default groups (User and Admin) or custom groups. When basic users are added to a group, that group's role-related restrictions apply. A basic user's capabilities can be restricted in that way, but a basic user can never be granted more capabilities than they start with. For Standard edition, basic users can't be assigned to groups. For Pro and Enterprise edition, they can. Role For an explanation of the roles our default groups have, see Default groups. Custom groups can have either our default standard roles, or custom roles. A basic user's abilities aren't directly defined by a specific role. A basic user can best be described as having the All product admin role but without access to our more curated UI experiences (learn more about user type). When basic users are added to a group, that group's role-related restrictions apply, but a basic user can never be granted more capabilities than they start with. Roles and capabilities For users on the New Relic One user model, a \"role\" can be defined as \"a set of capabilities.\" A capability is defined as the ability to do a specific New Relic task, like 'Delete alert conditions' (learn more about capabilities). Roles are assigned to user groups. Our default groups Admin and User already have our standard roles (defined below) assigned. Organizations on Pro or Enterprise edition can also create custom roles. Standard (default) roles Roles are sets of capabilities. We have several \"standard roles,\" which are roles that satisfy some commonly needed use cases. To view roles and their associated capabilities, use the Organization and access UI. Important Note that some of our standard roles have hidden, non-exposed capabilities that are not available for selection when creating a custom role. The only standard roles that can be replicated with a custom role are Standard user and Read only; all others have some hidden capabilities. Our standard roles include: Standard roles Scope Description All product admin Account Provides admin-level access to observability platform features but not organization-level and user management features. In other words, this role includes all New Relic capabilities with the exception of managing users (Authentication domain manager role), managing organization/account-structure settings (Organization manager role), and managing billing (Billing user role). Note: the Standard user role is essentially the All product admin role minus observability feature configuration capabilities. Standard user Account Provides access to observability platform features, but lacks permissions for configuring those features (for example, ability to configure synthetic monitor secure credentials) and lacks organization-level and user management permissions. Note: the Standard user role is essentially the All product admin role without that role's ability to configure platform features. Billing user Account Provides ability to manage subscriptions and billing setup, and read-only access to the rest of the platform. For organizations with multiple accounts, billing is aggregated in the primary (first-created) account, which is why assigning this role to that primary account grants billing permissions for the entire organization. Organization manager Organization Provides the ability to manage organization settings, including organization structure, name, and preferences. Due to our recent switch to the New Relic One user model, this role currently has few abilities but more will be added over time. For how to grant this role, see Add user management capability. Organization read only Organization Provides the ability to view organization-level settings. For how to grant this role, see Add user management capability. Authentication domain manager Organization Provides ability to add and manage users, and configure authentication domains for users on the New Relic One user model. For how to grant this role, see Add user management capability. Authentication domain read only Organization Provides the ability to view users in your organization and view the configuration of authentication domains. For how to grant this role, see Add user management capability. Read only Account Provides read-only access to the New Relic platform (except for synthetic monitor secure credentials). Manage v1 users Account For New Relic organizations that existed before July 30 2020 and have users on our original user model, this role lets you manage those \"v1\" users. For more about how you'd assign roles to groups and create custom roles, see the user management tutorial. Capabilities A role, whether one of our standard roles or a custom role, is defined as a set of capabilities. To view roles and their associated capabilities, use the Organization and access UI. Important Some of our standard roles have hidden capabilities that aren't available for selection when creating a custom role. For details, see Standard roles. A view of the capabilities associated with the All product admin role. When creating a custom role, you select a custom set of capabilities. Note that the capabilities we expose may change over time: this screenshot was taken in April of 2021. For how to set up roles with custom capabilities, see the user management tutorial. Manage users To learn how to add users, assign them to groups, and create custom groups and roles, see Manage users. 2020 user model changes If you'd like to understand how our user model changed in 2020 and what the impacts of that change were, see User model changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.573784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Users</em>, <em>roles</em>, permissions (New Relic One <em>user</em> model)",
        "sections": "How do <em>user</em> type, <em>roles</em>, and groups <em>relate</em> to each other?",
        "body": ", and that group is granted access to specific <em>roles</em> on specific accounts. We have two default groups: <em>User</em>: This group allows a <em>user</em> to use and configure monitoring&#x2F;analysis features but not perform account-<em>related</em> tasks like managing billing or <em>users</em>. It has access to the All product admin <em>role</em>, which"
      },
      "id": "603e88e328ccbcfcbaeba7a8"
    },
    {
      "sections": [
        "Integrations",
        "Early access",
        "Integration details",
        "Atlassian Jira",
        "Permissions",
        "Set up a Jira destination",
        "Important",
        "Two-way sync",
        "Configure the message template",
        "Send a test notification",
        "ServiceNow (Incident-Management)",
        "Roles",
        "Set up a destination",
        "Slack",
        "Prerequisites",
        "Set up a Slack destination",
        "Configure the Slack message settings",
        "Webhook",
        "Set up a webhook destination",
        "Configure the webhook event template",
        "Customize the webhook payload",
        "Email",
        "Configure the email settings"
      ],
      "title": "Integrations",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident Intelligence",
        "Destinations"
      ],
      "external_id": "7220c630fc187bb61784ff2cc2213e588b269b00",
      "image": "https://docs.newrelic.com/static/d4e9baecc3a76dd1a5945f8ec0aeca66/c1b63/webhook-notification-template.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/",
      "published_at": "2021-12-10T06:26:14Z",
      "updated_at": "2021-12-10T06:26:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Early access The features described here are early access. You won't be able to use these features if you're not part of the early access program. For more information on related features, see our docs on Alerts notification channels, Incident Intelligence destinations, and Proactive Detection notifications. Alerts and Applied Intelligence notification integrations are specific services and platforms you can use to send notifications from New Relic. Integration details Read more about each of our specific notification integrations. Atlassian Jira Integrate New Relic with Atlassian Jira(Cloud) and automatically create and update Jira issues. Permissions The required permissions from the Jira API-Token are create, edit, and close tickets. To enable the two-way sync toggle, the provided Jira API-Key should have an Admin role. Set up a Jira destination Create Jira issues, then enable Jira and New Relic to share updates and stay synced. To create a Jira destination, enter the following information: Destination name: Custom name to identify the destination Jira account endpoint: the URL of the destination User-name: this will be the email address of the user making the connection API token: generated from your Atlassian account Important New Relic currently supports Atlassian-Jira Classic (company-managed) projects. Before saving the destination, we recommend you test the connection via the test connection button. Jira destination configuration. We recommand to test the connection before saving. Two-way sync You can enable a two-way integration with Jira to keep the issues' state synced with the corresponding state in New Relic. To enable two-way sync, turn on the ‘two-way integration’ toggle. When turned on, a Jira Webhook would be created in your Jira account at a later stage, for the selected project (see ‘customize a message template’). The webhook would contain access details to Newrelic (URL and Newrelic-API-KEY) Configure the message template To configure a template for a Jira issue, you first need to choose a destination. You will be able to create a new destination at this stage. Upon successful connection to the destination, you will need to choose a project, and then select the Jira issue type you would like to be used. Once the issue-type is selected, the configured project's fields are fetched from your account and automatically mapped to your Jira instance. To help you get started, we automatically present the required and recommended fields and values. Required fields must be set with a value. You can add or remove optional fields(use the X mark on their right side) Jira message template. Send a test notification You can see how the JIRA issue will appear by clicking a test notification with default field values. If successful, a JIRA issue will be created and a link will appear. ServiceNow (Incident-Management) Integrate New Relic with ServiceNow Incident-Management and automatically create and update incidents. Roles As part of the integrations, we fetch fields from the your serviceNow incident table and optional values. For this, the provided ServiceNow user details required read permissions for the tables: sys_dictionary, sys_choice, sys_user and task. A read/write permission to incident To be able to fetch users for the caller column, we required read permissions for the sys_users table. The above permissions can be achieved with the roles personalize_choices, personalize_dictionary, rest_service, itil. Read/Write permissions to the api_key_credentials table is required to enable two-way integration. This can be covered with the roles credentials_admin and discovery_admin. Set up a destination To create a ServiceNow destination, enter the following information: Destination Name: custom name to identify the destination Domain: the URL of the destination User-name: the name of the user Password: the user name’s password Before saving the destination, we recommend testing the connection by clicking the test connection button. Two-way sync You can configure a two-way integration with ServiceNow Incidents Management to keep the incidents' state synced with the corresponding state in New Relic. Here are some required steps to remember when configuring the two-way integration: Turn on the two-way integration toggle. Open and download this XML file, which includes the business rule triggering events back to New Relic One. In the ServiceNow sidebar menu, go to System Definition > Business Rules. Click the menu icon in one of the column headers, select Import XML and upload the XML file you downloaded. Once the Destination is saved, a New-Relic API-Key will be kept in the api_key_credentials. The key would sent in a header as part of the callback REST call to New-Relic Configure the message template Upon a successful connection, ServiceNow incident table columns are fetched from your account and automatically mapped to your ServiceNow instance. To help you get started, we automatically present the required and recommended fields and values. Required fields must be set with a value. You can add or remove optional fields(use the X mark on their right side) Select, edit or remove fields for the ServiceNow-Incident template. Send a test notification You can see how the ServiceNow incident will appear by clicking a test notification with default field values. If successful, an incident will be created and a link will appear. Slack Send notifications-messages to your Slack channels. Prerequisites Your Slack workspace needs to have the New Relic application installed. The application must be approved by a workspace admin before it can be individually installed by users Set up a Slack destination Click on the `one-click Slack authentication' will lead you to the Slack landing page to continue the OAuth2 authentication process. On the Slack landing page, if you're not signed into the required workspace, you're redirected to Slack to sign in. Add your workspace name or select the relevant workspace and click Continue. When signed in to the selected workspace, you are requested to allow New Relic to perform the specified actions. Clicking `Allow' will redirect you back to the Destination page. Configure the Slack message settings Select a Destination(Workspace) and select a Slack-channel where the messages will be sent. You can create a new destination if there is no pre-defined destination for the required workspace. Note that, for privacy reasons, users need to be authenticated to select private channels (one-time process) Send a test notification You can send a test notification with a pre-defined example payload to the channel. This creates a message in the selected Slack-channel. Webhook Use the webhook notifier to send the notification messages to any endpoint you like. Set up a webhook destination To create a webhook destination, you need the following: Destination Name: A unique destination name URL: the endpoint of the target application, authentication and custom headers if needed. Authorization mechanism (Optional):. Can be basic authentication or a bearer token Configure the webhook event template Pick a webhook destination from the list and configure the HTTP-POST request. The request configuration requires you to: Set a name for the template. Select a pre-configured destination from the destinations list or create a new one. Add custom headers (optional). Configure the request’s payload. Customize the webhook payload You can use the default payload or customize it to contain the required data. Pick Variables from the variables menu and apply handlebars syntax to enrich your webhook. Note that the request’s content-type is JSON by default. Hence, the payload needs to keep the JSON form. See Usage examples The ‘preview’ section on the right hand-side shows an expected payload after the template is rendered. If the eventual payload would not form a valid Json, an error will be shown and it won’t be possible to save the template. If the webhook payload conforms a valid Json, you can send a test notification to your defined webhook destination We recommend sending a test notification to make sure that everything's connected correctly. Email Send email notifications to users. Configure the email settings Add one or more recipients. Users with New Relic accounts can be found via autocomplete when searching for their name or email address. To add a user without a New Relic account or email distribution list, add the full email address. Every recipient will be translated into a 'destination'. You can follow the email notifications per destination in the notifications-log Send a test notification You can send a test notification to make sure the email notifications reach the inbox.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.58484,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Roles</em>",
        "body": " of the integrations, we fetch fields from the your serviceNow incident table and optional values. For this, the provided ServiceNow <em>user</em> details required read permissions for the tables: sys_dictionary, sys_choice, sys_<em>user</em> and task. A read&#x2F;write permission to incident To be able to fetch <em>users</em>"
      },
      "id": "618ff71628ccbc60710321e4"
    },
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-09T22:55:57Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.041336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>users</em>",
        "body": " See <em>User</em>-<em>related</em> <em>language</em>. For pricing tier&#x2F;edition <em>language</em>, see Pricing <em>language</em>. pricing See Pricing <em>language</em>. real <em>user</em> monitoring (RUM) Don&#x27;t use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers"
      },
      "id": "619e1c0a64441fb97e9858d2"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/agent-api-guide-template": [
    {
      "sections": [
        "Basic doc template",
        "Section example",
        "Code example",
        "List example",
        "Table example"
      ],
      "title": "Basic doc template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "13ab0e9d759903149944453fc4392998b6fab974",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/basic-doc-template/",
      "published_at": "2021-12-10T13:34:04Z",
      "updated_at": "2021-11-26T09:12:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the formatting tips in this template to organize the docs you create on the docs site. Then replace the template information with your own text, lists, and tables as needed. Before you create sections, start your doc with a brief introduction, usually no more than a paragraph, that helps readers understand what your doc will cover. Your introduction (and the structure of your doc) should help readers understand within ten seconds whether they are in the right place. Section example Begin each section with a meaningful H2 title. The docs site uses these to generate the contents, which appears automatically in the left navigation. If you want to include a screenshot with the section, provide a permalink for the Docs team to create the image for you. Due to security requirements, the Docs team manages all images on the docs site. Code example def article_url(category, article, options={}) url_for(options.reverse_merge( :controller => 'articles';, :action => 'show', :category => category, :article => article )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add require('newrelic'); as the first line of your app's main module. Use the command npm install newrelic --save for each application you want to monitor. For unordered lists, use bullets (ul in HTML or * in Markdown). For example: Black White For complex lists, consider using collapsers. Table example Tables help organize detailed lists so the information is easier to skim. Tables are easier to manage in HTML. For exammple: <table> <thead> <tr> <th width={200}> **Item** </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Some thing </td> <td> More detailed information about it </td> </tr> <tr> <td> Another thing </td> <td> More detailed information about another thing </td> </tr> </tbody> </table> Copy Tables created in Markdown use three or more hyphens --- to create each column’s header, and pipes | to separate each column. For example: | Item | Requirements ------------ | ------------ | Some thing | More detailed information about it | Another thing | More detailed information about another thing Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 300.02518,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Basic doc <em>template</em>",
        "sections": "Basic doc <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " <em>article</em>_url(category, <em>article</em>, options={}) url_for(options.reverse_merge( :controller =&gt; &#x27;articles&#x27;;, :action =&gt; &#x27;show&#x27;, :category =&gt; category, :<em>article</em> =&gt; <em>article</em> )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add"
      },
      "id": "61b3574c64441f1cc6aec5a4"
    },
    {
      "sections": [
        "GraphQL API tutorial template",
        "Example query #1 with GraphQL",
        "Example query #2 with GraphQL",
        "Example query #3 with GraphQL"
      ],
      "title": "GraphQL API tutorial template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "827639827da156b6a36096c0f6a3911052706a91",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/graphql-api-tutorial-template/",
      "published_at": "2021-12-10T13:29:35Z",
      "updated_at": "2021-11-26T09:09:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL API tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what problem or use case the users want to solve, or why the API can help them query to get this data Three to five query examples that show interesting data they can get from GraphQL Sample intro paragraph: You can use the New Relic GraphQL API to [ add key use cases here]. To construct these queries and see responses, you can use the New Relic GraphQL Explorer. This document explains some of the available functions to query [ data to be queried]. Example query #1 with GraphQL Add a description here for your example query. Tell users why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #2 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #3 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 300.01706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "GraphQL API tutorial <em>template</em>",
        "sections": "GraphQL API tutorial <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61ab330c64441fd067927126"
    },
    {
      "sections": [
        "Add to data dictionary",
        "Data dictionary structure",
        "Add a new data type",
        "Add attributes",
        "Attribute style guidelines",
        "Using units of measurement"
      ],
      "title": "Add to data dictionary",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "05c35d88b970eee521e2af4e255666e31b915468",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/data-dictionary-style-guidelines/",
      "published_at": "2021-12-10T13:29:03Z",
      "updated_at": "2021-11-26T07:01:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We use the data dictionary to provide information about data types (for example, Transaction, Metric, Log) and attached attributes. This is exposed in the New Relic query experience, on hovering over the data types and attributes. And we also expose the dictionary to the public. This doc contains info on how to add data to the dictionary. Note that currently we don't have infrastructure integration data in the dictionary. We also have very few attributes for the Metric data type, just a few basic default ones, despite there being many potential attributes attached to that data type depending on what the data source is. Data dictionary structure The data in the data dictionary is structured like this: Data types: sometimes called \"events\" for historical reasons, these are the NRDB data objects, like Transaction, Metric, Log, Span, etc. Attributes: these are key:value pairs attached to data types. One attribute can have multiple data types listed for it. For example, appName is on multiple data types. Data source: The New Relic product from which the data originates. With the current implementation, a data type must have a single data source assigned. This isn't ideal, as theoretically a data type can come from multiple sources. Add a new data type To add a new data type: Make a new folder in this directory, alongside the other directories: src/data-dictionary/events Copy Duplicate a data type file (for example, this Metric data type), place it in the new folder, and fill it out with the new info. For how to add attributes on a new data type, keep reading. Add attributes To add attributes: Check if there's an existing attribute that has the same name and same general definition as the one you're trying to add. If it exists, edit that file to include the new data type (under events:). If an existing attribute is fairly close in definition but not exact, try to edit the definition so it works for all associated data types. If there is no existing attribute, create a new one. The easiest way is to copy an existing attribute file, edit all relevant fields to be accurate, and place it in the folder of the data type it's attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see Style. If the attribute has one of the units of measurement we use (like units: percentage (%)), add that to the front matter. For info on units, see Units. Attribute style guidelines When adding or editing attributes, some things to keep in mind: Aim for concise descriptions. Notes on this: Feel free to use sentence fragments. Feel free to edit definitions submitted from internal teams as sometimes their definitions will be overly long or have unneeded links. Some attributes are only present in some situations (for example, when a specific APM agent is used, or when a specific config option is true). We should avoid documenting most of these, with the idea that most customers will only care about the data because it's being reported for them, and won't care about the things that factor into the reasons why it wouldn't be reported. If it's thought that the addition would help customers who already have the data reporting understand the data better, you can include it. Write so it reads well as plain text. Details on this: Note that the docs site data dictionary has our usual docs styles available, but the query UI definitions have no styling available. This means that you should write definitions so that they are understandable without any styling, as plain text. You can often avoid any need for styling (for example, data types like Transaction are easy to understand as plain text, as are most phrasings that use attribute names or values. When plain text makes something too ambiguous and you need some styling, use back ticks to indicate attributes or values (for example, a definition like: Reported when ` category ` is ` http ` ). Using this also sets us up for success if we implement styling in the UI definitions in the future. We should avoid links because those aren't visible in the query UI; the query UI only displays plain text. However, every attribute entry in the query UI does display a 'See attribute in docs' link that links to the complete and normally formatted docs site entry. This means that we can use links provided that they will display in an easy to understand way in the query UI. For example, here's an example of an attribute that would read clearly in plain text despite not having a link. We should avoid using a link format like \"For more information, see Create an alert condition\", because it wouldn't read well in plain text, and would choose something like \"For more information, see our alert condition docs.\" Using units of measurement Attribute entries have an optional unit of measurement field in the front matter. For example, here the front matter for an attribute with a percent unit of measurement: --- name: cpuPercent type: attribute units: percentage (%) events: - ProcessSample --- Copy What unit of measurement to select for an attribute is sometimes obvious, like if the attribute value is measured in milliseconds (units: milliseconds (ms)) or seconds (units: seconds (s)) or a percentage (units: percentage (%)). We also have several units of measurement that are not obvious, like count, enum, rate, and ID. (Technically, these aren't actually \"units of measurement\" and are more just conceptual data types but we're doing it this way as a workaround so you can ignore the fact that units of measurement isn't actually accurate.) The main reason we want to specify this information is that this will control what kinds of queries or charts can be created or auto-suggested by New Relic. For example, the New Relic UI wouldn't want to auto-suggest a chart graphing the average of ID values because that wouldn't make any sense. So attributes with accurate units, such as data types, will help product provide more practical help/suggestions to customers in future. Here are some tips for the non-obvious unit types: count: This is a count of something, though not a count of time-based units. For a number to be a count, it must (a) only be capable of increasing during a given time/sampling period, and (b) have a theoretically uncapped range. This wouldn't be used for a count of time units; if it was a count of seconds, for example, you would just use 'seconds' as the unit of measurement. A couple of examples of a count: databaseCallCount threadConcurrency enum: enum is short for enumerated list. In other words, it is a specific range of numbers that represent other non-numeric elements. For example, an attribute that had HTTP error codes (404, 505, etc.) as possible values would be an enum. A range of numbers that represent color codes would be another example of an enum. (Theoretically, an enum can represent lists without numeric values but we have no need to categorize strings so we only care about numeric-value lists.) Example: httpResponsecode. rate: Use this for any rate (for example, count per second). These are typically for averaged rates over small units of time, like second or millisecond. We previously have used the unit of time for these attributes (for example, using seconds as the unit of measurement for a count per second rate), but now we want to use rate for these. This is necessary because the types of displays used for rates would be different than the types of displays used for a simpler duration/count measurement. Example: MySQL integration attribute db.innodb.dataReadBytesPerSecond, which has the definition \"Rate at which data is read from InnoDB tables in bytes per second.\" id: Use ID for any identification number attribute. Example: appId.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.66617,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Attribute <em>style</em> <em>guidelines</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " to be accurate, and place it in the folder of the data type it&#x27;s attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see <em>Style</em>. If the attribute has one of the units of measurement we use (like units: percentage"
      },
      "id": "61ab4782e7b9d278d80e6e03"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/agent-release-notes-template-123": [
    {
      "sections": [
        "Security guide",
        "Tip",
        "Security Program",
        "Security Domains",
        "Security Certifications",
        "Data Control, Facilities, and Encryption",
        "Law Enforcement Request Report"
      ],
      "title": "Security guide",
      "type": "docs",
      "tags": [
        "Licenses",
        "License information",
        "Referenced policies"
      ],
      "external_id": "356f0d11ffcb62208a743a0a7c127f5f6da9c940",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/referenced-policies/security-guide/",
      "published_at": "2021-12-09T15:28:15Z",
      "updated_at": "2021-12-09T15:28:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Last updated September 17, 2021. This is supplement to our security policy and serves as a guide to New Relic’s description of its Services, functionalities, and features. Tip We may update the URLs in this document without notice. Security Program New Relic follows \"privacy by design\" principles as described here: https://docs.newrelic.com/docs/security/security-privacy/data-privacy/data-privacy-new-relic/. Security Domains New Relic’s policies and procedures cover industry-recognized security domains such as Endpoint Protection; Portable Media Security; Mobile Device Security; Wireless Security; Configuration Management; Vulnerability Management; Network Protection; Transmission Protection; Password Management; Access Control, Audit Logging & Monitoring; Education, Training, and Awareness; Third Party Assurance; Incident Management; Business Continuity and Disaster Recover; Risk Management; Data Protection & Privacy; and Service Management Systems. Security Certifications New Relic audits its Services against industry standards as described at https://docs.newrelic.com/docs/security/security-privacy/compliance/regulatory-audits-new-relic-services/. Data Control, Facilities, and Encryption New Relic's customers can send data to New Relic's APIs by (1) using New Relic's software, (2) using vendor-neutral software that is managed and maintained by a third-party such as via OpenTelemetry instrumentation provided by opentelemetry.io, or (3) from third-party systems that customer's manage and/or control. New Relic's customers can use New Relic's Services such as NerdGraph to filter out and drop data. See https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/drop-data-using-nerdgraph/. New Relic's customers can adjust their data retention periods as appropriate for their needs. See https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/manage-data-retention/#adjust-retention. New Relic Logs obfuscates numbers that match known patterns, such as bank card and social security numbers as described here: https://docs.newrelic.com/docs/logs/log-management/get-started/new-relics-log-management-security-privacy/. New Relic honors requests to delete personal data in accordance with applicable privacy laws. Please see https://docs.newrelic.com/docs/security/security-privacy/data-privacy/data-privacy-new-relic/. Customers may use New Relic's APIs to query data, such as NerdGraph described here, and New Relic Services to export the data to other cloud providers. Customers can configure its log forwarder [https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/enable-log-monitoring-new-relic/forward-your-logs-using-infrastructure-agent/] before sending infrastructure logs to New Relic. For New Relic Customers in New Relic US, FedRAMP and HIPAA-enabled environments, Customer Data is replicated to the off-site backup system via Amazon Simple Storage Service (S3). Category of Customer Description FedRAMP HIPAA-enabled US Gen Pop EU Gen Pop Data is stored in Amazon Web Services (“AWS”). Limited Data is stored in IBM Data for New Relic Incident Intelligence is stored in Google Cloud New Relic regularly tests, assess, and evaluates its measures to ensure the security of processing using industry-recognized standards and uses independent third-party auditors as provided below: Annual SOC 2 Type 2 Annual FedRAMP assessment by an independent third-party pursuant to NIST 800-53 rev 4 Moderate authorization. Annual HITRUST-validated assessment by an independent third-party *Pursuing CY2021 Q4 ISO 27001 TISAX The Services that operate on Amazon Web Services (“AWS”) are protected by the security and environmental controls of AWS. Detailed information about AWS security is available at https://aws.amazon.com/security/ and http://aws.amazon.com/security/sharing-the-security-responsibility/. Data encryption at rest utilizes FIPS 140-2 compliant encryption methodology. For AWS SOC Reports, please see https://aws.amazon.com/compliance/soc-faqs/. The Services that operate on Google Cloud Platform (\"GCP\") are protected by the security and environmental controls of GCP. Detailed information about GCP security is available at https://cloud.google.com/docs/tutorials#security. For GCP reports, please see https://cloud.google.com/security/compliance/. IBM Deft Zayo QTS Law Enforcement Request Report New Relic has not to date received any request for customer data from a law enforcement or other government agency (including under any national security process), and has not made any corresponding disclosures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2.027779,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "id": "6147558128ccbc973a56a863",
      "highlight": {}
    },
    {
      "sections": [
        "Automatic application naming",
        "Important",
        "Caution",
        "Application name sources",
        "Request attribute",
        "Tip",
        "Servlet init parameter",
        "Filter init parameter",
        "Context parameter",
        "Display name",
        "Context path"
      ],
      "title": "Automatic application naming",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "b8d38d3fe920d7d399bd1eb05d53ba438c01790d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/configuration/automatic-application-naming/",
      "published_at": "2021-12-09T21:44:01Z",
      "updated_at": "2021-12-05T04:44:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic's Java agent reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming, see Name your Java application). By changing enable_auto_app_naming in newrelic.yml to true, applications will be named for their context, filter, servlet, or request attribute. This setting allows you to run several web applications in a single JVM while reporting transactions, errors, and metrics to other appropriate applications in the New Relic user interface. Background tasks will still use the default application name from the newrelic.yml. Important These configuration changes require a JVM restart to take effect. This configuration does NOT work with Infinite Tracing enabled. Caution Enabling auto app naming will increase the amount of data ingested by the agent. There are various methods to alert on and monitor data ingest. Application name sources When you set enable_auto_app_naming to true, New Relic uses the following sources of information to name your applications: App type Naming source Background tasks The default application name from newrelic.yml Web transactions In order by priority: Request attribute (highest priority) Servlet init parameter Filter init parameter Web app context parameter Web app context name (display-name) Web app context path (lowest priority) Request attribute The APPLICATION_NAME request attribute takes precedence over any settings in the XML. Set this attribute as early as possible in the web transaction. If called multiple times, the last invocation determines the application name. Tip APPLICATION_NAME only works with ServletRequests. To use the request attribute for fine-grained application naming based on the request URI: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... String requestUri = httpServletRequest.getRequestURI(); if (requestUri.startsWith(\"/my-special-request/\")) { request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MySpecialWebApp\"); } ... Copy Servlet init parameter To set the application name for individual servlets in web.xml using init parameters: <servlet> <servlet-name>SqlServlet</servlet-name> <servlet-class>test.SqlServlet</servlet-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyServletApp</param-value> </init-param> </servlet> Copy The agent obtains the value of the init-param by calling javax.servlet.ServletConfig#getInitParameter(String) Copy with the argument com.newrelic.agent.APPLICATION_NAME. If a web request calls multiple servlets, the init-param of the first servlet to finish has precedence. A servlet that does not have an init-param uses the default application name for the web app. Besides declaring the application name in XML, you can also set it in your application code by storing an attribute in the javax.servlet.ServletRequest: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MyWebApp\"); ... Copy Filter init parameter If your web app does not have servlets, you can use an init parameter for a filter: <filter> <filter-name>SqlFilter</filter-name> <filter-class>test.SqlFilter</filter-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyFilterApp</param-value> </init-param> </filter> Copy The agent obtains the value of the init-param by calling javax.servlet.FilterConfig#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. Servlets takes precedence over filters for application naming, so the init parameter for a filter is used only if no servlets were invoked. The init-param of the first filter to finish has precedence. Context parameter To use a context parameter to set the application name: <context-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyWebApp</param-value> </context-param> Copy The agent obtains the value of the context parameter is by calling javax.servlet.ServletContext#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. The context parameter takes precedence over the display-name element. Display name To determine the application name by using the display-name element in the web.xml: <display-name>MyWebApp</display-name> Copy The agent obtains the value of the display-name element by calling javax.servlet.ServletContext#getServletContextName(). Context path If there is no display-name element, and none of the other higher hierarchy methods are used to set the app name, the application name comes from the context path of the web app. The agent obtains the context path by calling javax.servlet.ServletContext#getContextPath(). The context path is the portion of the request URI that is used to select the context of the request. The context path always comes first in a request URI. For example: Consider the following URL: http://example.com/newrelic-axis2-ws/getWeather Copy In this URL: The request URI is /newrelic-axis2-ws/getWeather. The context path is /newrelic-axis2-ws. The application is named newrelic-axis2-ws.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1.7258583,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "id": "617e7063e7b9d2b171c05f6d",
      "highlight": {}
    },
    {
      "sections": [
        "Introduction to New Relic for Go",
        "Monitor application and microservice performance",
        "Get New Relic for Go",
        "Additional instrumentation",
        "Check the source code"
      ],
      "title": "Introduction to New Relic for Go",
      "type": "docs",
      "tags": [
        "Agents",
        "Go agent",
        "Get started"
      ],
      "external_id": "caf9fff1b2d7cfb490aa6262f05d7993bf2678a7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/go-agent/get-started/introduction-new-relic-go/",
      "published_at": "2021-12-09T21:36:05Z",
      "updated_at": "2021-12-05T04:29:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Go monitors your Go language applications and microservices to help you identify and solve performance issues. You can also use your data to improve your customers' experience and make data-driven business decisions. Go is a compiled language, and doesn’t use a virtual machine. The best way to monitor Go applications is to use the Go API. Our API provides exceptional flexibility and control over what gets instrumented. Get New Relic for Go in a few simple steps. Monitor application and microservice performance The Go programming language, also called Golang, has become a popular coding choice for its ease of use, concurrency, and impressive speed. With New Relic for Go, you will gain a new level of visibility into your Golang applications: See the big picture: Monitor the throughput, response times, and errors of the transactions in your applications and services. Understand your application's runtime health by seeing memory usage, garbage collection behavior, and CPU usage over time. With deployment markers, see how code changes impact application performance and health. Use infrastructure monitoring to view detailed host and server data. Use distributed tracing to understand how your services and microservices are interacting. Identify and fix errors: Find bottlenecks by seeing time spent on database calls, external system calls, and key blocks of code. View Goroutine counts and identify possible Goroutine leaks. Get alerts for problems or errors before they affect users. Create custom dashboards for important metrics. View logs for your APM and infrastructure data: You can bring your logs and application's data together to make troubleshooting easier and faster. No need to switch to another UI page in New Relic One. With logs in context, you can see log messages related to your errors and traces directly in your app's UI. You can also see logs in context of your infrastructure data, such as Kubernetes clusters. Analyze business data: Query user-related data and improve business processes. Create custom queries of your Go application data. Send your own custom data to New Relic. Create and share visual, interactive displays of your data. Get New Relic for Go To use New Relic for Go: Check the compatibility and requirements. If you do not already have one, sign up for a free New Relic account. To install the agent, use our launcher, or follow the New Relic Go agent's installation and instrumentation procedures. Wait a few minutes to view data from your Go app in your New Relic account's UI. Read the install docs Add Go data We recommend instrumenting your Go code to get the maximum benefits from the New Relic Go agent. But we make it easy to get great data in couple of ways: Simply import the agent and create an application to get useful runtime information about your number of goroutines, garbage collection statistics, and memory and CPU usage. Use our many integration packages for out-of-the box support for many popular Go web frameworks and libraries. We continue to add integration packages based on your feedback. You can weigh in on potential integrations on the Explorers Hub and our New Relic Go agent GitHub project. Additional instrumentation After installing the agent, consider the Go Telemetry SDK Check the source code The Go agent is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more information, see the README.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1.725342,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "id": "617e6e9f196a6757b4f7ce1d",
      "highlight": {}
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/api-tutorial-template": [
    {
      "sections": [
        "apiStyleGuidelines (Example agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Return values",
        "Examples",
        "URL guidelines",
        "Title guidelines",
        "Short title guidelines",
        "Syntax guidelines",
        "Important"
      ],
      "title": "apiStyleGuidelines (Example agent API)",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "API writing guidelines"
      ],
      "external_id": "fb967e77ea9a94d7a35329c0c87062ff93ab2ff8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/apistyleguidelines-example-agent-api/",
      "published_at": "2021-12-10T13:34:04Z",
      "updated_at": "2021-11-26T09:14:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.apiStyleGuidelines(data type $parameter_name[, integer $optional_param]) newrelic.apiStyleGuidelines(data type $parameter_name, array $different_param, string $third_param) Copy Briefly describe the call. Ideally, one line or less on the \"View all methods\" page. Requirements Agent version 1.2.3.4 or higher. Additional requirements on their own line (do not use bullets). Do not use any callouts. If there are no special requirements, write: Compatible with all agent versions. Description Describe the behavior of the call with as much detail as possible. Do not describe what individual parameters do except in broad strokes; details of parameters and call variants belong under the Parameters heading. Similarly, do not describe return values. When cross-referencing another API call, format its name with code blocks, and include parentheses () like this: anotherCoolMethod(). Tip You can include callouts, but use discretion. These pages are already visually busy. Parameters If there are no parameters, leave this section blank. If there is only one call variant, do not include a syntax block in this section. Parameter Description newrelic.apiStyleGuidelines(data type $parameter_name[, integer $optional_param]) Copy $parameter_name data type Required. Brief description of parameter. $optional_param integer Optional. Brief description of parameter. newrelic.apiStyleGuidelines(data type $parameter_name, array $different_param) Copy $parameter_name data type Required. Brief description of parameter. $different_param array Required. Brief description of parameter. $third_param string Required. Brief description of parameter. Return values What does this call return, and in what circumstances? Are there any things we expect customers to do with that return value? If the call does not return anything, leave this section blank. Examples This section documents rules for oddballs that aren't self-documenting. The rest of the examples are embedded within the page itself. In general, this page is intended for style reference. For examples of how to write good API method pages, check out our existing API docs, such as the PHP API. URL guidelines For the doc's URL: Manually edit the URL slug to remove the agent name. Where the API call does not already include separators (as in newrelic_awesome_call), separate the bits with hyphens -. For example: https://docs.newrelic.com/docs/new-relic-only/advanced-style-guide/writing-guidelines/api-style-guidelines Copy Title guidelines For the doc's title: Include the method name and the agent name in parentheses. Do not include newrelic. prefixes unless they are integral to the call name (as in the PHP agent). Do not include parentheses () in the call itself. For example: apiStyleGuidelines (Example agent API) Copy Short title guidelines For the doc's short title: Include only the method name. Do not include newrelic. prefixes unless they are integral to the call name (as in the PHP agent). Do not include parentheses (). Adjust if necessary to fit on a single line in the category's sidebar. For example: apiStyleGuidelines Copy Syntax guidelines Important The Python and iOS agents use their own guidelines. For those guidelines, see the existing methods in those languages. Document each variant of a call on its own line. Do not use any formatting except italicizing the data type. Wrap optional parameters (including the comma separator) in square brackets []. Indicate the variable portion by prefacing it with a dollar sign $. If the call must be prefixed with newrelic. or similar, include that in the syntax. Optional: Include the return value, if that seems important for your particular agent. If you do, follow language conventions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 327.14813,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>apiStyleGuidelines</em> (Example agent <em>API</em>)",
        "sections": "URL <em>guidelines</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": ":&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;new-relic-only&#x2F;advanced-<em>style</em>-<em>guide</em>&#x2F;<em>writing</em>-<em>guidelines</em>&#x2F;<em>api</em>-<em>style</em>-<em>guidelines</em> Copy Title <em>guidelines</em> For the doc&#x27;s title: Include the method name and the agent name in parentheses. Do not include newrelic. prefixes unless they are integral to the call name (as in the PHP agent). Do"
      },
      "id": "61ab484ee7b9d293670e847e"
    },
    {
      "sections": [
        "Basic doc template",
        "Section example",
        "Code example",
        "List example",
        "Table example"
      ],
      "title": "Basic doc template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "13ab0e9d759903149944453fc4392998b6fab974",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/basic-doc-template/",
      "published_at": "2021-12-10T13:34:04Z",
      "updated_at": "2021-11-26T09:12:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the formatting tips in this template to organize the docs you create on the docs site. Then replace the template information with your own text, lists, and tables as needed. Before you create sections, start your doc with a brief introduction, usually no more than a paragraph, that helps readers understand what your doc will cover. Your introduction (and the structure of your doc) should help readers understand within ten seconds whether they are in the right place. Section example Begin each section with a meaningful H2 title. The docs site uses these to generate the contents, which appears automatically in the left navigation. If you want to include a screenshot with the section, provide a permalink for the Docs team to create the image for you. Due to security requirements, the Docs team manages all images on the docs site. Code example def article_url(category, article, options={}) url_for(options.reverse_merge( :controller => 'articles';, :action => 'show', :category => category, :article => article )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add require('newrelic'); as the first line of your app's main module. Use the command npm install newrelic --save for each application you want to monitor. For unordered lists, use bullets (ul in HTML or * in Markdown). For example: Black White For complex lists, consider using collapsers. Table example Tables help organize detailed lists so the information is easier to skim. Tables are easier to manage in HTML. For exammple: <table> <thead> <tr> <th width={200}> **Item** </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Some thing </td> <td> More detailed information about it </td> </tr> <tr> <td> Another thing </td> <td> More detailed information about another thing </td> </tr> </tbody> </table> Copy Tables created in Markdown use three or more hyphens --- to create each column’s header, and pipes | to separate each column. For example: | Item | Requirements ------------ | ------------ | Some thing | More detailed information about it | Another thing | More detailed information about another thing Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.34787,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61b3574c64441f1cc6aec5a4"
    },
    {
      "sections": [
        "GraphQL API tutorial template",
        "Example query #1 with GraphQL",
        "Example query #2 with GraphQL",
        "Example query #3 with GraphQL"
      ],
      "title": "GraphQL API tutorial template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "827639827da156b6a36096c0f6a3911052706a91",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/graphql-api-tutorial-template/",
      "published_at": "2021-12-10T13:29:35Z",
      "updated_at": "2021-11-26T09:09:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL API tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what problem or use case the users want to solve, or why the API can help them query to get this data Three to five query examples that show interesting data they can get from GraphQL Sample intro paragraph: You can use the New Relic GraphQL API to [ add key use cases here]. To construct these queries and see responses, you can use the New Relic GraphQL Explorer. This document explains some of the available functions to query [ data to be queried]. Example query #1 with GraphQL Add a description here for your example query. Tell users why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #2 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #3 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.34296,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "GraphQL <em>API</em> tutorial template",
        "sections": "GraphQL <em>API</em> tutorial template",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL <em>API</em> tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what"
      },
      "id": "61ab330c64441fd067927126"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/apistyleguidelines-example-agent-api": [
    {
      "sections": [
        "API tutorial template",
        "Introduction (this heading will not be visible)",
        "Optional: Provide an overview for complex processes",
        "Provide a procedure to accomplish the task",
        "Tip",
        "Step 1. Do something...",
        "If needed: Step 2. Do something else...",
        "If needed: Step 3. Do something else...",
        "Last step. Verify that the task was completed...",
        "Optional: Do something else with the API",
        "Optional: Large example code block",
        "Code block example",
        "Optional: Troubleshooting"
      ],
      "title": "API tutorial template  ",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "API writing guidelines"
      ],
      "external_id": "b69605a3a5585b2ee7f89c250bbdd5345c5d9311",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/api-tutorial-template/",
      "published_at": "2021-12-10T13:33:23Z",
      "updated_at": "2021-11-26T09:14:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is a template for an API tutorial document: Please skim the entire template first to understand the expected structure for this type of doc. Then, clone this doc using the Clone content link in the Page tools box. Delete all content up to Introduction (this heading won't be visible). For the doc title (the field at top of page): Doc should be named in a practical, use-case-focused way. Example: Add custom attributes to transactions Introduction (this heading will not be visible) Provide a brief explanation of what this document will teach customers, and why it is valuable for customers to know how to do that. Focus on the value the API provides to the customers and mention specific, common use cases. Any relevant notes about support/compatability should go here, too. Here's an example from the Java API asynchronous tutorial doc: New Relic for Java includes an API to instrument asynchronous activity. For supported frameworks, the Java agent usually instruments async work automatically. However, the async API can be useful for adding more detail to your data. This document provides examples of using tokens and segments to instrument your app. Optional: Provide an overview for complex processes This is an optional section for complicated tutorials that involve either using several methods in one procedure or that have different alternate steps you can take to achieve similar results. This section can link to lower-down sections to allow users to skip around as needed. For simple tutorials, this section isn't necessary. For an example, see this section of the Java async tutorial. Provide a procedure to accomplish the task Tell the user how to accomplish the task, and link to the methods necessary to accomplish that task. As much as possible, we're looking to describe tasks in \"procedures\" (procedure is tech writer jargon for a series of numbered steps). This may be tough to do for fairly open-ended/variable tasks, but it will usually be possible to chunk the content at a fairly high-level to make it into a procedure. Along the way, explain what the importance of the procedure step is, and how one might verify that the step was done correctly. For code samples, avoid using large chunks of code. Instead, use smaller pieces of code and give context for how they are being used. (If you think a large app code example would be helpful, place that later in the doc in the Example section.) Tip For an example of an open-ended task segmented into procedural chunks, see the Asynchronous doc section Connecting async threads. For another example, see this TomCat GAE Flex procedure. Base your procedure on the simple structure below. Tech writers will edit your content to match our style and formatting requirements: Step 1. Do something... Methods and example code to implement the first step. For each step, if applicable, indicate the significance of that step (why it's important) and how the user might verify that the step was done correctly (for example, something showing up in UI, or running a verification test of some sort). If needed: Step 2. Do something else... Methods and example code to implement step 2. If needed: Step 3. Do something else... Methods and example code to implement step 3. Last step. Verify that the task was completed... Explain how a user would know they'd completed the task correctly. In particular, how would the user find the new change or data in the New Relic UI. What New Relic products and pages would the change be noticed on? If new data shows up in Insights, what event types can it be found under? Optional: Do something else with the API Same as above. Make as many headings and separate procedures as needed. Optional: Large example code block If you think a large app code example would be useful, place here. Within any code block, explain all New Relic functions/methods, not just the main methods. Instead of in-line comments, consider using highlighted sections underneath the code block to give additional context. Here's an example: Code block example The following code example shows a segment starting in the storeItem method to measure how long the Lambda statement is waiting in the thread pool. To stop timing the segment, you must call either .end() or .ignore(). If you don't want to report the segment as part of its parent transaction, call .ignore(). Otherwise, to report the segment as part of its parent transaction, call .end(). private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal (DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()); // fire and forget DB_POOL.submit(() -> { segment.end(); insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For more on this method, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in APM with datastore data. For more information, see reportAsExternal API. segment.end(): Stops timing this segment. For more on this method, see the Javadoc. Optional: Troubleshooting Optional area for any common errors or troubleshooting tips.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 327.14758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>API</em> tutorial template  ",
        "sections": "<em>API</em> tutorial template",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " to describe tasks in &quot;procedures&quot; (procedure is <em>tech</em> <em>writer</em> jargon for a series of numbered steps). This may be tough to do for fairly open-ended&#x2F;variable tasks, but it will usually be possible to chunk the content at a fairly high-level to make it into a procedure. Along the way, explain what"
      },
      "id": "61b35723196a675e16a5b0a4"
    },
    {
      "sections": [
        "Basic doc template",
        "Section example",
        "Code example",
        "List example",
        "Table example"
      ],
      "title": "Basic doc template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "13ab0e9d759903149944453fc4392998b6fab974",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/basic-doc-template/",
      "published_at": "2021-12-10T13:34:04Z",
      "updated_at": "2021-11-26T09:12:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the formatting tips in this template to organize the docs you create on the docs site. Then replace the template information with your own text, lists, and tables as needed. Before you create sections, start your doc with a brief introduction, usually no more than a paragraph, that helps readers understand what your doc will cover. Your introduction (and the structure of your doc) should help readers understand within ten seconds whether they are in the right place. Section example Begin each section with a meaningful H2 title. The docs site uses these to generate the contents, which appears automatically in the left navigation. If you want to include a screenshot with the section, provide a permalink for the Docs team to create the image for you. Due to security requirements, the Docs team manages all images on the docs site. Code example def article_url(category, article, options={}) url_for(options.reverse_merge( :controller => 'articles';, :action => 'show', :category => category, :article => article )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add require('newrelic'); as the first line of your app's main module. Use the command npm install newrelic --save for each application you want to monitor. For unordered lists, use bullets (ul in HTML or * in Markdown). For example: Black White For complex lists, consider using collapsers. Table example Tables help organize detailed lists so the information is easier to skim. Tables are easier to manage in HTML. For exammple: <table> <thead> <tr> <th width={200}> **Item** </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Some thing </td> <td> More detailed information about it </td> </tr> <tr> <td> Another thing </td> <td> More detailed information about another thing </td> </tr> </tbody> </table> Copy Tables created in Markdown use three or more hyphens --- to create each column’s header, and pipes | to separate each column. For example: | Item | Requirements ------------ | ------------ | Some thing | More detailed information about it | Another thing | More detailed information about another thing Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.34787,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61b3574c64441f1cc6aec5a4"
    },
    {
      "sections": [
        "GraphQL API tutorial template",
        "Example query #1 with GraphQL",
        "Example query #2 with GraphQL",
        "Example query #3 with GraphQL"
      ],
      "title": "GraphQL API tutorial template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "827639827da156b6a36096c0f6a3911052706a91",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/graphql-api-tutorial-template/",
      "published_at": "2021-12-10T13:29:35Z",
      "updated_at": "2021-11-26T09:09:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL API tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what problem or use case the users want to solve, or why the API can help them query to get this data Three to five query examples that show interesting data they can get from GraphQL Sample intro paragraph: You can use the New Relic GraphQL API to [ add key use cases here]. To construct these queries and see responses, you can use the New Relic GraphQL Explorer. This document explains some of the available functions to query [ data to be queried]. Example query #1 with GraphQL Add a description here for your example query. Tell users why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #2 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #3 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.34296,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "GraphQL <em>API</em> tutorial template",
        "sections": "GraphQL <em>API</em> tutorial template",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL <em>API</em> tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what"
      },
      "id": "61ab330c64441fd067927126"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/basic-doc-template": [
    {
      "sections": [
        "GraphQL API tutorial template",
        "Example query #1 with GraphQL",
        "Example query #2 with GraphQL",
        "Example query #3 with GraphQL"
      ],
      "title": "GraphQL API tutorial template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "827639827da156b6a36096c0f6a3911052706a91",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/graphql-api-tutorial-template/",
      "published_at": "2021-12-10T13:29:35Z",
      "updated_at": "2021-11-26T09:09:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL API tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what problem or use case the users want to solve, or why the API can help them query to get this data Three to five query examples that show interesting data they can get from GraphQL Sample intro paragraph: You can use the New Relic GraphQL API to [ add key use cases here]. To construct these queries and see responses, you can use the New Relic GraphQL Explorer. This document explains some of the available functions to query [ data to be queried]. Example query #1 with GraphQL Add a description here for your example query. Tell users why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #2 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #3 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 300.017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "GraphQL API tutorial <em>template</em>",
        "sections": "GraphQL API tutorial <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61ab330c64441fd067927126"
    },
    {
      "sections": [
        "Add to data dictionary",
        "Data dictionary structure",
        "Add a new data type",
        "Add attributes",
        "Attribute style guidelines",
        "Using units of measurement"
      ],
      "title": "Add to data dictionary",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "05c35d88b970eee521e2af4e255666e31b915468",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/data-dictionary-style-guidelines/",
      "published_at": "2021-12-10T13:29:03Z",
      "updated_at": "2021-11-26T07:01:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We use the data dictionary to provide information about data types (for example, Transaction, Metric, Log) and attached attributes. This is exposed in the New Relic query experience, on hovering over the data types and attributes. And we also expose the dictionary to the public. This doc contains info on how to add data to the dictionary. Note that currently we don't have infrastructure integration data in the dictionary. We also have very few attributes for the Metric data type, just a few basic default ones, despite there being many potential attributes attached to that data type depending on what the data source is. Data dictionary structure The data in the data dictionary is structured like this: Data types: sometimes called \"events\" for historical reasons, these are the NRDB data objects, like Transaction, Metric, Log, Span, etc. Attributes: these are key:value pairs attached to data types. One attribute can have multiple data types listed for it. For example, appName is on multiple data types. Data source: The New Relic product from which the data originates. With the current implementation, a data type must have a single data source assigned. This isn't ideal, as theoretically a data type can come from multiple sources. Add a new data type To add a new data type: Make a new folder in this directory, alongside the other directories: src/data-dictionary/events Copy Duplicate a data type file (for example, this Metric data type), place it in the new folder, and fill it out with the new info. For how to add attributes on a new data type, keep reading. Add attributes To add attributes: Check if there's an existing attribute that has the same name and same general definition as the one you're trying to add. If it exists, edit that file to include the new data type (under events:). If an existing attribute is fairly close in definition but not exact, try to edit the definition so it works for all associated data types. If there is no existing attribute, create a new one. The easiest way is to copy an existing attribute file, edit all relevant fields to be accurate, and place it in the folder of the data type it's attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see Style. If the attribute has one of the units of measurement we use (like units: percentage (%)), add that to the front matter. For info on units, see Units. Attribute style guidelines When adding or editing attributes, some things to keep in mind: Aim for concise descriptions. Notes on this: Feel free to use sentence fragments. Feel free to edit definitions submitted from internal teams as sometimes their definitions will be overly long or have unneeded links. Some attributes are only present in some situations (for example, when a specific APM agent is used, or when a specific config option is true). We should avoid documenting most of these, with the idea that most customers will only care about the data because it's being reported for them, and won't care about the things that factor into the reasons why it wouldn't be reported. If it's thought that the addition would help customers who already have the data reporting understand the data better, you can include it. Write so it reads well as plain text. Details on this: Note that the docs site data dictionary has our usual docs styles available, but the query UI definitions have no styling available. This means that you should write definitions so that they are understandable without any styling, as plain text. You can often avoid any need for styling (for example, data types like Transaction are easy to understand as plain text, as are most phrasings that use attribute names or values. When plain text makes something too ambiguous and you need some styling, use back ticks to indicate attributes or values (for example, a definition like: Reported when ` category ` is ` http ` ). Using this also sets us up for success if we implement styling in the UI definitions in the future. We should avoid links because those aren't visible in the query UI; the query UI only displays plain text. However, every attribute entry in the query UI does display a 'See attribute in docs' link that links to the complete and normally formatted docs site entry. This means that we can use links provided that they will display in an easy to understand way in the query UI. For example, here's an example of an attribute that would read clearly in plain text despite not having a link. We should avoid using a link format like \"For more information, see Create an alert condition\", because it wouldn't read well in plain text, and would choose something like \"For more information, see our alert condition docs.\" Using units of measurement Attribute entries have an optional unit of measurement field in the front matter. For example, here the front matter for an attribute with a percent unit of measurement: --- name: cpuPercent type: attribute units: percentage (%) events: - ProcessSample --- Copy What unit of measurement to select for an attribute is sometimes obvious, like if the attribute value is measured in milliseconds (units: milliseconds (ms)) or seconds (units: seconds (s)) or a percentage (units: percentage (%)). We also have several units of measurement that are not obvious, like count, enum, rate, and ID. (Technically, these aren't actually \"units of measurement\" and are more just conceptual data types but we're doing it this way as a workaround so you can ignore the fact that units of measurement isn't actually accurate.) The main reason we want to specify this information is that this will control what kinds of queries or charts can be created or auto-suggested by New Relic. For example, the New Relic UI wouldn't want to auto-suggest a chart graphing the average of ID values because that wouldn't make any sense. So attributes with accurate units, such as data types, will help product provide more practical help/suggestions to customers in future. Here are some tips for the non-obvious unit types: count: This is a count of something, though not a count of time-based units. For a number to be a count, it must (a) only be capable of increasing during a given time/sampling period, and (b) have a theoretically uncapped range. This wouldn't be used for a count of time units; if it was a count of seconds, for example, you would just use 'seconds' as the unit of measurement. A couple of examples of a count: databaseCallCount threadConcurrency enum: enum is short for enumerated list. In other words, it is a specific range of numbers that represent other non-numeric elements. For example, an attribute that had HTTP error codes (404, 505, etc.) as possible values would be an enum. A range of numbers that represent color codes would be another example of an enum. (Theoretically, an enum can represent lists without numeric values but we have no need to categorize strings so we only care about numeric-value lists.) Example: httpResponsecode. rate: Use this for any rate (for example, count per second). These are typically for averaged rates over small units of time, like second or millisecond. We previously have used the unit of time for these attributes (for example, using seconds as the unit of measurement for a count per second rate), but now we want to use rate for these. This is necessary because the types of displays used for rates would be different than the types of displays used for a simpler duration/count measurement. Example: MySQL integration attribute db.innodb.dataReadBytesPerSecond, which has the definition \"Rate at which data is read from InnoDB tables in bytes per second.\" id: Use ID for any identification number attribute. Example: appId.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.6661,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Attribute <em>style</em> <em>guidelines</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " to be accurate, and place it in the folder of the data type it&#x27;s attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see <em>Style</em>. If the attribute has one of the units of measurement we use (like units: percentage"
      },
      "id": "61ab4782e7b9d278d80e6e03"
    },
    {
      "sections": [
        "Troubleshooting docs guide",
        "Problem",
        "Solution",
        "Cause",
        "Related info"
      ],
      "title": "Troubleshooting docs guide",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "55f439b9842d1f5df9e5ce1b06a5c5d9ae7829f6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/troubleshooting-docs-guide/",
      "published_at": "2021-12-10T14:17:51Z",
      "updated_at": "2021-11-25T11:25:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our troubleshooting docs have these main sections: problem, solution, and (optionally) cause. Otherwise, a troubleshooting doc uses the basic doc template Problem Generally, this is the who, what, when, and where of the troubleshooting doc. Provide a clear, concise description of the problem the user is trying to solve. Include steps for reproduction, symptoms, and other key points when applicable. Re-state the problem in different ways if needed, to ensure customers can find this doc via Google. If the problem text is very short, you can include the cause text here. Solution Generally, this is the how of the troubleshooting doc. Provide an ordered list of steps to guide users through the solution. If there are multiple causes and solutions, consider creating a standard, basic page doc rather than using the troubleshooting template. Consider the best approach to help the reader, and discuss your reasoning with your peer editor. If the issue you are documenting is more of a known issue (FYI in nature), or if it doesn't solve the issue: Incorporate the information into other relevant docs. Do not refer to it as a known issue. OR Create a troubleshooting doc that describes the problem and cause. Do not include a solution. Also, include any statements promising that the issue will be fixed in a future release. Cause Generally, this is the why of the troubleshooting doc, and is optional. The Cause section is particularly useful when the product works in an unintuitive way. Provide background information or context that gives the user additional insight into the problem. If the problem and the cause text are both very short, you can include the cause in the Problem section. Related info In general, leave blank. The standard For more help footer block will appear automatically when published. If necessary, use this section to link to other, related docs if it does not make sense to refer to them within the context of other information in the troubleshooting doc itself.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 296.57892,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting docs <em>guide</em>",
        "sections": "Troubleshooting docs <em>guide</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": ", this is the how of the troubleshooting doc. Provide an ordered list of steps to <em>guide</em> users through the solution. If there are multiple causes and solutions, consider creating a standard, basic page doc rather than using the troubleshooting template. Consider the best approach to help the reader"
      },
      "id": "61ab4826e7b9d293010e7a46"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/data-dictionary-style-guidelines": [
    {
      "sections": [
        "Basic doc template",
        "Section example",
        "Code example",
        "List example",
        "Table example"
      ],
      "title": "Basic doc template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "13ab0e9d759903149944453fc4392998b6fab974",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/basic-doc-template/",
      "published_at": "2021-12-10T13:34:04Z",
      "updated_at": "2021-11-26T09:12:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the formatting tips in this template to organize the docs you create on the docs site. Then replace the template information with your own text, lists, and tables as needed. Before you create sections, start your doc with a brief introduction, usually no more than a paragraph, that helps readers understand what your doc will cover. Your introduction (and the structure of your doc) should help readers understand within ten seconds whether they are in the right place. Section example Begin each section with a meaningful H2 title. The docs site uses these to generate the contents, which appears automatically in the left navigation. If you want to include a screenshot with the section, provide a permalink for the Docs team to create the image for you. Due to security requirements, the Docs team manages all images on the docs site. Code example def article_url(category, article, options={}) url_for(options.reverse_merge( :controller => 'articles';, :action => 'show', :category => category, :article => article )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add require('newrelic'); as the first line of your app's main module. Use the command npm install newrelic --save for each application you want to monitor. For unordered lists, use bullets (ul in HTML or * in Markdown). For example: Black White For complex lists, consider using collapsers. Table example Tables help organize detailed lists so the information is easier to skim. Tables are easier to manage in HTML. For exammple: <table> <thead> <tr> <th width={200}> **Item** </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Some thing </td> <td> More detailed information about it </td> </tr> <tr> <td> Another thing </td> <td> More detailed information about another thing </td> </tr> </tbody> </table> Copy Tables created in Markdown use three or more hyphens --- to create each column’s header, and pipes | to separate each column. For example: | Item | Requirements ------------ | ------------ | Some thing | More detailed information about it | Another thing | More detailed information about another thing Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 300.0251,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Basic doc <em>template</em>",
        "sections": "Basic doc <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " <em>article</em>_url(category, <em>article</em>, options={}) url_for(options.reverse_merge( :controller =&gt; &#x27;articles&#x27;;, :action =&gt; &#x27;show&#x27;, :category =&gt; category, :<em>article</em> =&gt; <em>article</em> )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add"
      },
      "id": "61b3574c64441f1cc6aec5a4"
    },
    {
      "sections": [
        "GraphQL API tutorial template",
        "Example query #1 with GraphQL",
        "Example query #2 with GraphQL",
        "Example query #3 with GraphQL"
      ],
      "title": "GraphQL API tutorial template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "827639827da156b6a36096c0f6a3911052706a91",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/graphql-api-tutorial-template/",
      "published_at": "2021-12-10T13:29:35Z",
      "updated_at": "2021-11-26T09:09:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL API tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what problem or use case the users want to solve, or why the API can help them query to get this data Three to five query examples that show interesting data they can get from GraphQL Sample intro paragraph: You can use the New Relic GraphQL API to [ add key use cases here]. To construct these queries and see responses, you can use the New Relic GraphQL Explorer. This document explains some of the available functions to query [ data to be queried]. Example query #1 with GraphQL Add a description here for your example query. Tell users why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #2 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #3 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 300.01697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "GraphQL API tutorial <em>template</em>",
        "sections": "GraphQL API tutorial <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61ab330c64441fd067927126"
    },
    {
      "sections": [
        "Troubleshooting docs guide",
        "Problem",
        "Solution",
        "Cause",
        "Related info"
      ],
      "title": "Troubleshooting docs guide",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "55f439b9842d1f5df9e5ce1b06a5c5d9ae7829f6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/troubleshooting-docs-guide/",
      "published_at": "2021-12-10T14:17:51Z",
      "updated_at": "2021-11-25T11:25:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our troubleshooting docs have these main sections: problem, solution, and (optionally) cause. Otherwise, a troubleshooting doc uses the basic doc template Problem Generally, this is the who, what, when, and where of the troubleshooting doc. Provide a clear, concise description of the problem the user is trying to solve. Include steps for reproduction, symptoms, and other key points when applicable. Re-state the problem in different ways if needed, to ensure customers can find this doc via Google. If the problem text is very short, you can include the cause text here. Solution Generally, this is the how of the troubleshooting doc. Provide an ordered list of steps to guide users through the solution. If there are multiple causes and solutions, consider creating a standard, basic page doc rather than using the troubleshooting template. Consider the best approach to help the reader, and discuss your reasoning with your peer editor. If the issue you are documenting is more of a known issue (FYI in nature), or if it doesn't solve the issue: Incorporate the information into other relevant docs. Do not refer to it as a known issue. OR Create a troubleshooting doc that describes the problem and cause. Do not include a solution. Also, include any statements promising that the issue will be fixed in a future release. Cause Generally, this is the why of the troubleshooting doc, and is optional. The Cause section is particularly useful when the product works in an unintuitive way. Provide background information or context that gives the user additional insight into the problem. If the problem and the cause text are both very short, you can include the cause in the Problem section. Related info In general, leave blank. The standard For more help footer block will appear automatically when published. If necessary, use this section to link to other, related docs if it does not make sense to refer to them within the context of other information in the troubleshooting doc itself.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 296.57886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting docs <em>guide</em>",
        "sections": "Troubleshooting docs <em>guide</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": ", this is the how of the troubleshooting doc. Provide an ordered list of steps to <em>guide</em> users through the solution. If there are multiple causes and solutions, consider creating a standard, basic page doc rather than using the troubleshooting template. Consider the best approach to help the reader"
      },
      "id": "61ab4826e7b9d293010e7a46"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/graphql-api-tutorial-template": [
    {
      "sections": [
        "Basic doc template",
        "Section example",
        "Code example",
        "List example",
        "Table example"
      ],
      "title": "Basic doc template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "13ab0e9d759903149944453fc4392998b6fab974",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/basic-doc-template/",
      "published_at": "2021-12-10T13:34:04Z",
      "updated_at": "2021-11-26T09:12:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the formatting tips in this template to organize the docs you create on the docs site. Then replace the template information with your own text, lists, and tables as needed. Before you create sections, start your doc with a brief introduction, usually no more than a paragraph, that helps readers understand what your doc will cover. Your introduction (and the structure of your doc) should help readers understand within ten seconds whether they are in the right place. Section example Begin each section with a meaningful H2 title. The docs site uses these to generate the contents, which appears automatically in the left navigation. If you want to include a screenshot with the section, provide a permalink for the Docs team to create the image for you. Due to security requirements, the Docs team manages all images on the docs site. Code example def article_url(category, article, options={}) url_for(options.reverse_merge( :controller => 'articles';, :action => 'show', :category => category, :article => article )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add require('newrelic'); as the first line of your app's main module. Use the command npm install newrelic --save for each application you want to monitor. For unordered lists, use bullets (ul in HTML or * in Markdown). For example: Black White For complex lists, consider using collapsers. Table example Tables help organize detailed lists so the information is easier to skim. Tables are easier to manage in HTML. For exammple: <table> <thead> <tr> <th width={200}> **Item** </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Some thing </td> <td> More detailed information about it </td> </tr> <tr> <td> Another thing </td> <td> More detailed information about another thing </td> </tr> </tbody> </table> Copy Tables created in Markdown use three or more hyphens --- to create each column’s header, and pipes | to separate each column. For example: | Item | Requirements ------------ | ------------ | Some thing | More detailed information about it | Another thing | More detailed information about another thing Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 300.0251,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Basic doc <em>template</em>",
        "sections": "Basic doc <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " <em>article</em>_url(category, <em>article</em>, options={}) url_for(options.reverse_merge( :controller =&gt; &#x27;articles&#x27;;, :action =&gt; &#x27;show&#x27;, :category =&gt; category, :<em>article</em> =&gt; <em>article</em> )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add"
      },
      "id": "61b3574c64441f1cc6aec5a4"
    },
    {
      "sections": [
        "Add to data dictionary",
        "Data dictionary structure",
        "Add a new data type",
        "Add attributes",
        "Attribute style guidelines",
        "Using units of measurement"
      ],
      "title": "Add to data dictionary",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "05c35d88b970eee521e2af4e255666e31b915468",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/data-dictionary-style-guidelines/",
      "published_at": "2021-12-10T13:29:03Z",
      "updated_at": "2021-11-26T07:01:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We use the data dictionary to provide information about data types (for example, Transaction, Metric, Log) and attached attributes. This is exposed in the New Relic query experience, on hovering over the data types and attributes. And we also expose the dictionary to the public. This doc contains info on how to add data to the dictionary. Note that currently we don't have infrastructure integration data in the dictionary. We also have very few attributes for the Metric data type, just a few basic default ones, despite there being many potential attributes attached to that data type depending on what the data source is. Data dictionary structure The data in the data dictionary is structured like this: Data types: sometimes called \"events\" for historical reasons, these are the NRDB data objects, like Transaction, Metric, Log, Span, etc. Attributes: these are key:value pairs attached to data types. One attribute can have multiple data types listed for it. For example, appName is on multiple data types. Data source: The New Relic product from which the data originates. With the current implementation, a data type must have a single data source assigned. This isn't ideal, as theoretically a data type can come from multiple sources. Add a new data type To add a new data type: Make a new folder in this directory, alongside the other directories: src/data-dictionary/events Copy Duplicate a data type file (for example, this Metric data type), place it in the new folder, and fill it out with the new info. For how to add attributes on a new data type, keep reading. Add attributes To add attributes: Check if there's an existing attribute that has the same name and same general definition as the one you're trying to add. If it exists, edit that file to include the new data type (under events:). If an existing attribute is fairly close in definition but not exact, try to edit the definition so it works for all associated data types. If there is no existing attribute, create a new one. The easiest way is to copy an existing attribute file, edit all relevant fields to be accurate, and place it in the folder of the data type it's attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see Style. If the attribute has one of the units of measurement we use (like units: percentage (%)), add that to the front matter. For info on units, see Units. Attribute style guidelines When adding or editing attributes, some things to keep in mind: Aim for concise descriptions. Notes on this: Feel free to use sentence fragments. Feel free to edit definitions submitted from internal teams as sometimes their definitions will be overly long or have unneeded links. Some attributes are only present in some situations (for example, when a specific APM agent is used, or when a specific config option is true). We should avoid documenting most of these, with the idea that most customers will only care about the data because it's being reported for them, and won't care about the things that factor into the reasons why it wouldn't be reported. If it's thought that the addition would help customers who already have the data reporting understand the data better, you can include it. Write so it reads well as plain text. Details on this: Note that the docs site data dictionary has our usual docs styles available, but the query UI definitions have no styling available. This means that you should write definitions so that they are understandable without any styling, as plain text. You can often avoid any need for styling (for example, data types like Transaction are easy to understand as plain text, as are most phrasings that use attribute names or values. When plain text makes something too ambiguous and you need some styling, use back ticks to indicate attributes or values (for example, a definition like: Reported when ` category ` is ` http ` ). Using this also sets us up for success if we implement styling in the UI definitions in the future. We should avoid links because those aren't visible in the query UI; the query UI only displays plain text. However, every attribute entry in the query UI does display a 'See attribute in docs' link that links to the complete and normally formatted docs site entry. This means that we can use links provided that they will display in an easy to understand way in the query UI. For example, here's an example of an attribute that would read clearly in plain text despite not having a link. We should avoid using a link format like \"For more information, see Create an alert condition\", because it wouldn't read well in plain text, and would choose something like \"For more information, see our alert condition docs.\" Using units of measurement Attribute entries have an optional unit of measurement field in the front matter. For example, here the front matter for an attribute with a percent unit of measurement: --- name: cpuPercent type: attribute units: percentage (%) events: - ProcessSample --- Copy What unit of measurement to select for an attribute is sometimes obvious, like if the attribute value is measured in milliseconds (units: milliseconds (ms)) or seconds (units: seconds (s)) or a percentage (units: percentage (%)). We also have several units of measurement that are not obvious, like count, enum, rate, and ID. (Technically, these aren't actually \"units of measurement\" and are more just conceptual data types but we're doing it this way as a workaround so you can ignore the fact that units of measurement isn't actually accurate.) The main reason we want to specify this information is that this will control what kinds of queries or charts can be created or auto-suggested by New Relic. For example, the New Relic UI wouldn't want to auto-suggest a chart graphing the average of ID values because that wouldn't make any sense. So attributes with accurate units, such as data types, will help product provide more practical help/suggestions to customers in future. Here are some tips for the non-obvious unit types: count: This is a count of something, though not a count of time-based units. For a number to be a count, it must (a) only be capable of increasing during a given time/sampling period, and (b) have a theoretically uncapped range. This wouldn't be used for a count of time units; if it was a count of seconds, for example, you would just use 'seconds' as the unit of measurement. A couple of examples of a count: databaseCallCount threadConcurrency enum: enum is short for enumerated list. In other words, it is a specific range of numbers that represent other non-numeric elements. For example, an attribute that had HTTP error codes (404, 505, etc.) as possible values would be an enum. A range of numbers that represent color codes would be another example of an enum. (Theoretically, an enum can represent lists without numeric values but we have no need to categorize strings so we only care about numeric-value lists.) Example: httpResponsecode. rate: Use this for any rate (for example, count per second). These are typically for averaged rates over small units of time, like second or millisecond. We previously have used the unit of time for these attributes (for example, using seconds as the unit of measurement for a count per second rate), but now we want to use rate for these. This is necessary because the types of displays used for rates would be different than the types of displays used for a simpler duration/count measurement. Example: MySQL integration attribute db.innodb.dataReadBytesPerSecond, which has the definition \"Rate at which data is read from InnoDB tables in bytes per second.\" id: Use ID for any identification number attribute. Example: appId.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.66608,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Attribute <em>style</em> <em>guidelines</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " to be accurate, and place it in the folder of the data type it&#x27;s attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see <em>Style</em>. If the attribute has one of the units of measurement we use (like units: percentage"
      },
      "id": "61ab4782e7b9d278d80e6e03"
    },
    {
      "sections": [
        "Troubleshooting docs guide",
        "Problem",
        "Solution",
        "Cause",
        "Related info"
      ],
      "title": "Troubleshooting docs guide",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "55f439b9842d1f5df9e5ce1b06a5c5d9ae7829f6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/troubleshooting-docs-guide/",
      "published_at": "2021-12-10T14:17:51Z",
      "updated_at": "2021-11-25T11:25:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our troubleshooting docs have these main sections: problem, solution, and (optionally) cause. Otherwise, a troubleshooting doc uses the basic doc template Problem Generally, this is the who, what, when, and where of the troubleshooting doc. Provide a clear, concise description of the problem the user is trying to solve. Include steps for reproduction, symptoms, and other key points when applicable. Re-state the problem in different ways if needed, to ensure customers can find this doc via Google. If the problem text is very short, you can include the cause text here. Solution Generally, this is the how of the troubleshooting doc. Provide an ordered list of steps to guide users through the solution. If there are multiple causes and solutions, consider creating a standard, basic page doc rather than using the troubleshooting template. Consider the best approach to help the reader, and discuss your reasoning with your peer editor. If the issue you are documenting is more of a known issue (FYI in nature), or if it doesn't solve the issue: Incorporate the information into other relevant docs. Do not refer to it as a known issue. OR Create a troubleshooting doc that describes the problem and cause. Do not include a solution. Also, include any statements promising that the issue will be fixed in a future release. Cause Generally, this is the why of the troubleshooting doc, and is optional. The Cause section is particularly useful when the product works in an unintuitive way. Provide background information or context that gives the user additional insight into the problem. If the problem and the cause text are both very short, you can include the cause in the Problem section. Related info In general, leave blank. The standard For more help footer block will appear automatically when published. If necessary, use this section to link to other, related docs if it does not make sense to refer to them within the context of other information in the troubleshooting doc itself.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 296.57886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting docs <em>guide</em>",
        "sections": "Troubleshooting docs <em>guide</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": ", this is the how of the troubleshooting doc. Provide an ordered list of steps to <em>guide</em> users through the solution. If there are multiple causes and solutions, consider creating a standard, basic page doc rather than using the troubleshooting template. Consider the best approach to help the reader"
      },
      "id": "61ab4826e7b9d293010e7a46"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/landing-page-template": [
    {
      "sections": [
        "Update the home page",
        "Update a link's URL",
        "Add a new tile to the home page",
        "Add a new section to the home page",
        "Edit the home page left nav"
      ],
      "title": "Update the home page",
      "type": "docs",
      "tags": [
        "home page",
        "landing pages"
      ],
      "external_id": "1d084fae5223f5b34cec91fcae0bcb35560c7b29",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/edit-homepage/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-12-04T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can't just hit the edit button docs.newrelic.com to make edits to the home page. The page that opens is index.js, the file that manages the parts of the home page, but not the content. It's rare that you'll need to make changes to this file. Most home page changes will be to add a new tile or section to the page, or update links. These types of changes are handled in two files: src/data/homepage.yml - contains home page section titles, section descriptions, and the URLs for tiles. src/i18n/translations/en/translation.json - contains tile info, including the title and short description of tiles. Update a link's URL Change or add new links using homepage.yml. In homepage.yml, search for the link you want to change. Edit the URL, save, commit, and PR the change. Add a new tile to the home page You'll make changes to both homepage.yml and translations.json On the translations.json doc, find the spot where you want to add the new tile (which section, and in what order you want it to appear), and add a new entry with this format: \"t#\": { \"title\": \"tile name\", \"description\": \"Short description.\" }, Copy Make sure you update the number on the tile. If you want to insert it in the middle of a group, update all the subsequent tile numbers as well. Save the file. Open homepage.yml, find the spot where the new tile will be, and add a new line with the relative link for the new tile. For example, - /docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster Save and check that your new tile builds properly on a local build. Commit, push, PR when you're ready. Add a new section to the home page On the translations.json page, add a new section modeled in the spot where you want the new section to appear. Include at least one title. For example, here's the TDP entry, with one tile: \"errors-inbox\": { \"title\": \"Errors Inbox\", \"description\": \"A single place to proactively detect, triage, and take action on all the errors before they impact customers.\", \"t1\": { \"title\": \"Introduction to Errors Inbox\", \"description\": \"How to manage all your monitoring in one place.\" }, Copy When you're done creating the info, save the file. In the homepage.yml page, find the corresponding location for the new section, and add the short name you provided in the translation.json file, title, description, and tile URLs. For example, here's the corresponding TDP section on homepage.yml. errors-inbox: title: Errors Inbox description: A single place to proactively detect, triage, and take action on all the errors before they impact customers. tiles: - /docs/errors-inbox/errors-inbox Copy Save, build locally, commit, PR. Edit the home page left nav The left nav of the home page is controlled by src/nav/root.yml. This is a basic yml file, similar to our taxonomy files. Each link on the left nav needs a title and a path: - title: Welcome to New Relic path: /docs/using-new-relic - title: New Relic One path: /docs/new-relic-one/use-new-relic-one - title: Guides and best practices path: /docs/new-relic-solutions - title: section-break - title: Alerts and Applied Intelligence path: /docs/alerts-applied-intelligence Copy You can add a new link by following the pattern above or delete a link by removing the corresponding title and path. Section breaks are added by including a - title: section-break line. The left nav reflects the exact order of root.yml, so it's easy to organize it as needed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.35504,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update the home <em>page</em>",
        "sections": "Update the home <em>page</em>",
        "tags": "<em>landing</em> <em>pages</em>",
        "body": "You can&#x27;t just hit the edit button docs.newrelic.com to make edits to the home <em>page</em>. The <em>page</em> that opens is index.js, the file that manages the parts of the home <em>page</em>, but not the content. It&#x27;s rare that you&#x27;ll need to make changes to this file. Most home <em>page</em> changes will be to add a new tile"
      },
      "id": "61ab480264441f9ef0927fb8"
    },
    {
      "sections": [
        "Integrations",
        "Early access",
        "Integration details",
        "Atlassian Jira",
        "Permissions",
        "Set up a Jira destination",
        "Important",
        "Two-way sync",
        "Configure the message template",
        "Send a test notification",
        "ServiceNow (Incident-Management)",
        "Roles",
        "Set up a destination",
        "Slack",
        "Prerequisites",
        "Set up a Slack destination",
        "Configure the Slack message settings",
        "Webhook",
        "Set up a webhook destination",
        "Configure the webhook event template",
        "Customize the webhook payload",
        "Email",
        "Configure the email settings"
      ],
      "title": "Integrations",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident Intelligence",
        "Destinations"
      ],
      "external_id": "7220c630fc187bb61784ff2cc2213e588b269b00",
      "image": "https://docs.newrelic.com/static/d4e9baecc3a76dd1a5945f8ec0aeca66/c1b63/webhook-notification-template.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/notification-integrations/",
      "published_at": "2021-12-10T06:26:14Z",
      "updated_at": "2021-12-10T06:26:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Early access The features described here are early access. You won't be able to use these features if you're not part of the early access program. For more information on related features, see our docs on Alerts notification channels, Incident Intelligence destinations, and Proactive Detection notifications. Alerts and Applied Intelligence notification integrations are specific services and platforms you can use to send notifications from New Relic. Integration details Read more about each of our specific notification integrations. Atlassian Jira Integrate New Relic with Atlassian Jira(Cloud) and automatically create and update Jira issues. Permissions The required permissions from the Jira API-Token are create, edit, and close tickets. To enable the two-way sync toggle, the provided Jira API-Key should have an Admin role. Set up a Jira destination Create Jira issues, then enable Jira and New Relic to share updates and stay synced. To create a Jira destination, enter the following information: Destination name: Custom name to identify the destination Jira account endpoint: the URL of the destination User-name: this will be the email address of the user making the connection API token: generated from your Atlassian account Important New Relic currently supports Atlassian-Jira Classic (company-managed) projects. Before saving the destination, we recommend you test the connection via the test connection button. Jira destination configuration. We recommand to test the connection before saving. Two-way sync You can enable a two-way integration with Jira to keep the issues' state synced with the corresponding state in New Relic. To enable two-way sync, turn on the ‘two-way integration’ toggle. When turned on, a Jira Webhook would be created in your Jira account at a later stage, for the selected project (see ‘customize a message template’). The webhook would contain access details to Newrelic (URL and Newrelic-API-KEY) Configure the message template To configure a template for a Jira issue, you first need to choose a destination. You will be able to create a new destination at this stage. Upon successful connection to the destination, you will need to choose a project, and then select the Jira issue type you would like to be used. Once the issue-type is selected, the configured project's fields are fetched from your account and automatically mapped to your Jira instance. To help you get started, we automatically present the required and recommended fields and values. Required fields must be set with a value. You can add or remove optional fields(use the X mark on their right side) Jira message template. Send a test notification You can see how the JIRA issue will appear by clicking a test notification with default field values. If successful, a JIRA issue will be created and a link will appear. ServiceNow (Incident-Management) Integrate New Relic with ServiceNow Incident-Management and automatically create and update incidents. Roles As part of the integrations, we fetch fields from the your serviceNow incident table and optional values. For this, the provided ServiceNow user details required read permissions for the tables: sys_dictionary, sys_choice, sys_user and task. A read/write permission to incident To be able to fetch users for the caller column, we required read permissions for the sys_users table. The above permissions can be achieved with the roles personalize_choices, personalize_dictionary, rest_service, itil. Read/Write permissions to the api_key_credentials table is required to enable two-way integration. This can be covered with the roles credentials_admin and discovery_admin. Set up a destination To create a ServiceNow destination, enter the following information: Destination Name: custom name to identify the destination Domain: the URL of the destination User-name: the name of the user Password: the user name’s password Before saving the destination, we recommend testing the connection by clicking the test connection button. Two-way sync You can configure a two-way integration with ServiceNow Incidents Management to keep the incidents' state synced with the corresponding state in New Relic. Here are some required steps to remember when configuring the two-way integration: Turn on the two-way integration toggle. Open and download this XML file, which includes the business rule triggering events back to New Relic One. In the ServiceNow sidebar menu, go to System Definition > Business Rules. Click the menu icon in one of the column headers, select Import XML and upload the XML file you downloaded. Once the Destination is saved, a New-Relic API-Key will be kept in the api_key_credentials. The key would sent in a header as part of the callback REST call to New-Relic Configure the message template Upon a successful connection, ServiceNow incident table columns are fetched from your account and automatically mapped to your ServiceNow instance. To help you get started, we automatically present the required and recommended fields and values. Required fields must be set with a value. You can add or remove optional fields(use the X mark on their right side) Select, edit or remove fields for the ServiceNow-Incident template. Send a test notification You can see how the ServiceNow incident will appear by clicking a test notification with default field values. If successful, an incident will be created and a link will appear. Slack Send notifications-messages to your Slack channels. Prerequisites Your Slack workspace needs to have the New Relic application installed. The application must be approved by a workspace admin before it can be individually installed by users Set up a Slack destination Click on the `one-click Slack authentication' will lead you to the Slack landing page to continue the OAuth2 authentication process. On the Slack landing page, if you're not signed into the required workspace, you're redirected to Slack to sign in. Add your workspace name or select the relevant workspace and click Continue. When signed in to the selected workspace, you are requested to allow New Relic to perform the specified actions. Clicking `Allow' will redirect you back to the Destination page. Configure the Slack message settings Select a Destination(Workspace) and select a Slack-channel where the messages will be sent. You can create a new destination if there is no pre-defined destination for the required workspace. Note that, for privacy reasons, users need to be authenticated to select private channels (one-time process) Send a test notification You can send a test notification with a pre-defined example payload to the channel. This creates a message in the selected Slack-channel. Webhook Use the webhook notifier to send the notification messages to any endpoint you like. Set up a webhook destination To create a webhook destination, you need the following: Destination Name: A unique destination name URL: the endpoint of the target application, authentication and custom headers if needed. Authorization mechanism (Optional):. Can be basic authentication or a bearer token Configure the webhook event template Pick a webhook destination from the list and configure the HTTP-POST request. The request configuration requires you to: Set a name for the template. Select a pre-configured destination from the destinations list or create a new one. Add custom headers (optional). Configure the request’s payload. Customize the webhook payload You can use the default payload or customize it to contain the required data. Pick Variables from the variables menu and apply handlebars syntax to enrich your webhook. Note that the request’s content-type is JSON by default. Hence, the payload needs to keep the JSON form. See Usage examples The ‘preview’ section on the right hand-side shows an expected payload after the template is rendered. If the eventual payload would not form a valid Json, an error will be shown and it won’t be possible to save the template. If the webhook payload conforms a valid Json, you can send a test notification to your defined webhook destination We recommend sending a test notification to make sure that everything's connected correctly. Email Send email notifications to users. Configure the email settings Add one or more recipients. Users with New Relic accounts can be found via autocomplete when searching for their name or email address. To add a user without a New Relic account or email distribution list, add the full email address. Every recipient will be translated into a 'destination'. You can follow the email notifications per destination in the notifications-log Send a test notification You can send a test notification to make sure the email notifications reach the inbox.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.38928,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Configure the message <em>template</em>",
        "body": " Click on the `one-click Slack authentication&#x27; will lead you to the Slack <em>landing</em> <em>page</em> to continue the OAuth2 authentication process. On the Slack <em>landing</em> <em>page</em>, if you&#x27;re not signed into the required workspace, you&#x27;re redirected to Slack to sign in. Add your workspace name or select the relevant"
      },
      "id": "618ff71628ccbc60710321e4"
    },
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-10T13:24:39Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.59035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Page</em> <em>templates</em>",
        "body": "Our docs site is made up of different content types and templates. Most of the time, the default <em>page</em> content type and the basic <em>template</em> will have everything you&#x27;ll need. Read on for more information about our <em>page</em> types. Docs meta content (frontmatter) Thr top of every doc begins with a set"
      },
      "id": "61b35517196a677196a59e07"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/more-help-section": [
    {
      "sections": [
        "Comet MLOps integration",
        "Integrate Comet with New Relic"
      ],
      "title": "Comet MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Comet integrations"
      ],
      "external_id": "c10a09aaa8c9b509281c991e45a8e59c9f82c964",
      "image": "https://docs.newrelic.com/static/f75787c4d9fd008aad94f01908ee9995/c1b63/comet03.png",
      "url": "https://docs.newrelic.com/docs/mlops/integrations/comet-mlops-integration/",
      "published_at": "2021-12-10T10:55:36Z",
      "updated_at": "2021-12-10T10:55:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Comet is an MLOps platform that extends full stack observability to machine learning models, and allows you to establish production performance baselines based on model performance. The Comet integration allows you to integrate machine learning metrics with New Relic, so you can continuosly monitor your data across the full machine learning lifecycle. This helps ensure optimal model performance, and helps you achieve better business outcomes. Integrate Comet with New Relic Use New Relic's Comet integration to get data and insights that help you build better, more accurate machine-learning models, while also improving productivity, collaboration, and visibility across your team. To setup the integration, follow these steps: Log into your New Relic account: Log into one.newrelic.com and click on Explorer. In the upper hand corner, on the main navigation menu, click +Add more data. Click on Comet: Type Comet in the search bar, or scroll down to the MLOps Integration section and click on the Comet icon. Select the account ID you want Comet to integrate with. Select or create an Insight API Key: You need an Insight API Key to integrate with Comet. Create or select an existing API key under the Real time training metric section. Contact Comet: For the next step to set up the integration and view the Model Production Monitoring dashboard in Comet, you'll need to contact Comet. The Comet team will walk you through each step of the integration process and get you all set up. View your insights: Now that you’ve set up your integration, you can start tracking the performance of your machine learning models in a dedicated New Relic One dashboard, which is automatically generated by Comet’s team.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.269135,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " your data across the full machine learning lifecycle. This helps ensure optimal model performance, and helps you achieve better business outcomes. Integrate Comet with New Relic Use New Relic&#x27;s Comet integration to get data and insights that <em>help</em> you build better, <em>more</em> accurate machine-learning"
      },
      "id": "61b33228196a676f3da5c5b9"
    },
    {
      "sections": [
        "Comet MLOps integration",
        "Integrate Comet with New Relic"
      ],
      "title": "Comet MLOps integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "MLOps integrations",
        "Comet integrations"
      ],
      "external_id": "72746044918c46e4ceadda088c8c3955cc7bd3f1",
      "image": "https://docs.newrelic.com/static/f75787c4d9fd008aad94f01908ee9995/c1b63/comet03.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/mlops/integrations/comet-mlops-integration/",
      "published_at": "2021-12-10T14:54:49Z",
      "updated_at": "2021-12-09T01:31:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Comet is an MLOps platform that extends full stack observability to machine learning models, and allows you to establish production performance baselines based on model performance. The Comet integration allows you to integrate machine learning metrics with New Relic, so you can continuosly monitor your data across the full machine learning lifecycle. This helps ensure optimal model performance, and helps you achieve better business outcomes. Integrate Comet with New Relic Use New Relic's Comet integration to get data and insights that help you build better, more accurate machine-learning models, while also improving productivity, collaboration, and visibility across your team. To setup the integration, follow these steps: Log into your New Relic account: Log into one.newrelic.com and click on Explorer. At the upper hand corner, on the main navigation menu, click +Add more data. Click on Comet: Type Comet in the search bar, or scroll down to the MLOps Integration section and click on the Comet icon. Select the account ID you want Comet to integrate with. Select or create an Insight API Key: You need an Insight API Key to integrate with Comet. Create or select an existing API key under the Real time training metric section. Contact Comet: To set up the integration and view the Model Production Monitoring dashboard in Comet, you need to contact Comet. The Comet team will walk you through each step of the integration process and get you all set up. View your insights: Now that you’ve set up your integration, you can start tracking the performance of your machine learning models in a dedicated New Relic One dashboard, which is automatically generated by Comet’s team.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 72.2466,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " your data across the full machine learning lifecycle. This helps ensure optimal model performance, and helps you achieve better business outcomes. Integrate Comet with New Relic Use New Relic&#x27;s Comet integration to get data and insights that <em>help</em> you build better, <em>more</em> accurate machine-learning"
      },
      "id": "61b15c8664441f7335e0b287"
    },
    {
      "sections": [
        "Basic doc template",
        "Section example",
        "Code example",
        "List example",
        "Table example"
      ],
      "title": "Basic doc template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "13ab0e9d759903149944453fc4392998b6fab974",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/basic-doc-template/",
      "published_at": "2021-12-10T13:34:04Z",
      "updated_at": "2021-11-26T09:12:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the formatting tips in this template to organize the docs you create on the docs site. Then replace the template information with your own text, lists, and tables as needed. Before you create sections, start your doc with a brief introduction, usually no more than a paragraph, that helps readers understand what your doc will cover. Your introduction (and the structure of your doc) should help readers understand within ten seconds whether they are in the right place. Section example Begin each section with a meaningful H2 title. The docs site uses these to generate the contents, which appears automatically in the left navigation. If you want to include a screenshot with the section, provide a permalink for the Docs team to create the image for you. Due to security requirements, the Docs team manages all images on the docs site. Code example def article_url(category, article, options={}) url_for(options.reverse_merge( :controller => 'articles';, :action => 'show', :category => category, :article => article )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add require('newrelic'); as the first line of your app's main module. Use the command npm install newrelic --save for each application you want to monitor. For unordered lists, use bullets (ul in HTML or * in Markdown). For example: Black White For complex lists, consider using collapsers. Table example Tables help organize detailed lists so the information is easier to skim. Tables are easier to manage in HTML. For exammple: <table> <thead> <tr> <th width={200}> **Item** </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Some thing </td> <td> More detailed information about it </td> </tr> <tr> <td> Another thing </td> <td> More detailed information about another thing </td> </tr> </tbody> </table> Copy Tables created in Markdown use three or more hyphens --- to create each column’s header, and pipes | to separate each column. For example: | Item | Requirements ------------ | ------------ | Some thing | More detailed information about it | Another thing | More detailed information about another thing Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 58.787354,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Section</em> example",
        "body": " than a paragraph, that helps readers understand what your doc will cover. Your introduction (and the structure of your doc) should <em>help</em> readers understand within ten seconds whether they are in the right place. <em>Section</em> example Begin each <em>section</em> with a meaningful H2 title. The docs site uses"
      },
      "id": "61b3574c64441f1cc6aec5a4"
    }
  ],
  "/docs/style-guide/writing-docs/article-templates/troubleshooting-docs-guide": [
    {
      "sections": [
        "Basic doc template",
        "Section example",
        "Code example",
        "List example",
        "Table example"
      ],
      "title": "Basic doc template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "13ab0e9d759903149944453fc4392998b6fab974",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/basic-doc-template/",
      "published_at": "2021-12-10T13:34:04Z",
      "updated_at": "2021-11-26T09:12:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the formatting tips in this template to organize the docs you create on the docs site. Then replace the template information with your own text, lists, and tables as needed. Before you create sections, start your doc with a brief introduction, usually no more than a paragraph, that helps readers understand what your doc will cover. Your introduction (and the structure of your doc) should help readers understand within ten seconds whether they are in the right place. Section example Begin each section with a meaningful H2 title. The docs site uses these to generate the contents, which appears automatically in the left navigation. If you want to include a screenshot with the section, provide a permalink for the Docs team to create the image for you. Due to security requirements, the Docs team manages all images on the docs site. Code example def article_url(category, article, options={}) url_for(options.reverse_merge( :controller => 'articles';, :action => 'show', :category => category, :article => article )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add require('newrelic'); as the first line of your app's main module. Use the command npm install newrelic --save for each application you want to monitor. For unordered lists, use bullets (ul in HTML or * in Markdown). For example: Black White For complex lists, consider using collapsers. Table example Tables help organize detailed lists so the information is easier to skim. Tables are easier to manage in HTML. For exammple: <table> <thead> <tr> <th width={200}> **Item** </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Some thing </td> <td> More detailed information about it </td> </tr> <tr> <td> Another thing </td> <td> More detailed information about another thing </td> </tr> </tbody> </table> Copy Tables created in Markdown use three or more hyphens --- to create each column’s header, and pipes | to separate each column. For example: | Item | Requirements ------------ | ------------ | Some thing | More detailed information about it | Another thing | More detailed information about another thing Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 300.025,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Basic doc <em>template</em>",
        "sections": "Basic doc <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " <em>article</em>_url(category, <em>article</em>, options={}) url_for(options.reverse_merge( :controller =&gt; &#x27;articles&#x27;;, :action =&gt; &#x27;show&#x27;, :category =&gt; category, :<em>article</em> =&gt; <em>article</em> )) end Copy List example For multi-step, actionable procedures, use ordered lists (ol in HTML or numbers in Markdown). For example: Add"
      },
      "id": "61b3574c64441f1cc6aec5a4"
    },
    {
      "sections": [
        "GraphQL API tutorial template",
        "Example query #1 with GraphQL",
        "Example query #2 with GraphQL",
        "Example query #3 with GraphQL"
      ],
      "title": "GraphQL API tutorial template",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "827639827da156b6a36096c0f6a3911052706a91",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/graphql-api-tutorial-template/",
      "published_at": "2021-12-10T13:29:35Z",
      "updated_at": "2021-11-26T09:09:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This is a template. Feel free to copy the text in this template to create your own GraphQL API tutorial, then fill in details that will help users learn how to use GraphQL in practical ways. Ideally the final version of your GraphQL doc will include: An introduction paragraph describing what problem or use case the users want to solve, or why the API can help them query to get this data Three to five query examples that show interesting data they can get from GraphQL Sample intro paragraph: You can use the New Relic GraphQL API to [ add key use cases here]. To construct these queries and see responses, you can use the New Relic GraphQL Explorer. This document explains some of the available functions to query [ data to be queried]. Example query #1 with GraphQL Add a description here for your example query. Tell users why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #2 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries. Example query #3 with GraphQL Add a description here for your example query. Tell the customer why they want to query this kind of data. Fill out the first block with your code, and the second with the data returned by the query: { actor { account(id: YOUR_ACCOUNT_ID) { nrql(query: \"SELECT count(*) FROM Transaction SINCE 1 HOUR AGO\") { results } } } } Copy This query returns the following: { \"data\": { \"actor\": { \"account\": { \"nrql\": { \"results\": [ { \"count\": 1000 } ] } } } } } Copy The actual value of the count varies depending on your data. Use the New Relic GraphQL Explorer to experiment with queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 300.01688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "GraphQL API tutorial <em>template</em>",
        "sections": "GraphQL API tutorial <em>template</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61ab330c64441fd067927126"
    },
    {
      "sections": [
        "Add to data dictionary",
        "Data dictionary structure",
        "Add a new data type",
        "Add attributes",
        "Attribute style guidelines",
        "Using units of measurement"
      ],
      "title": "Add to data dictionary",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "05c35d88b970eee521e2af4e255666e31b915468",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/data-dictionary-style-guidelines/",
      "published_at": "2021-12-10T13:29:03Z",
      "updated_at": "2021-11-26T07:01:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We use the data dictionary to provide information about data types (for example, Transaction, Metric, Log) and attached attributes. This is exposed in the New Relic query experience, on hovering over the data types and attributes. And we also expose the dictionary to the public. This doc contains info on how to add data to the dictionary. Note that currently we don't have infrastructure integration data in the dictionary. We also have very few attributes for the Metric data type, just a few basic default ones, despite there being many potential attributes attached to that data type depending on what the data source is. Data dictionary structure The data in the data dictionary is structured like this: Data types: sometimes called \"events\" for historical reasons, these are the NRDB data objects, like Transaction, Metric, Log, Span, etc. Attributes: these are key:value pairs attached to data types. One attribute can have multiple data types listed for it. For example, appName is on multiple data types. Data source: The New Relic product from which the data originates. With the current implementation, a data type must have a single data source assigned. This isn't ideal, as theoretically a data type can come from multiple sources. Add a new data type To add a new data type: Make a new folder in this directory, alongside the other directories: src/data-dictionary/events Copy Duplicate a data type file (for example, this Metric data type), place it in the new folder, and fill it out with the new info. For how to add attributes on a new data type, keep reading. Add attributes To add attributes: Check if there's an existing attribute that has the same name and same general definition as the one you're trying to add. If it exists, edit that file to include the new data type (under events:). If an existing attribute is fairly close in definition but not exact, try to edit the definition so it works for all associated data types. If there is no existing attribute, create a new one. The easiest way is to copy an existing attribute file, edit all relevant fields to be accurate, and place it in the folder of the data type it's attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see Style. If the attribute has one of the units of measurement we use (like units: percentage (%)), add that to the front matter. For info on units, see Units. Attribute style guidelines When adding or editing attributes, some things to keep in mind: Aim for concise descriptions. Notes on this: Feel free to use sentence fragments. Feel free to edit definitions submitted from internal teams as sometimes their definitions will be overly long or have unneeded links. Some attributes are only present in some situations (for example, when a specific APM agent is used, or when a specific config option is true). We should avoid documenting most of these, with the idea that most customers will only care about the data because it's being reported for them, and won't care about the things that factor into the reasons why it wouldn't be reported. If it's thought that the addition would help customers who already have the data reporting understand the data better, you can include it. Write so it reads well as plain text. Details on this: Note that the docs site data dictionary has our usual docs styles available, but the query UI definitions have no styling available. This means that you should write definitions so that they are understandable without any styling, as plain text. You can often avoid any need for styling (for example, data types like Transaction are easy to understand as plain text, as are most phrasings that use attribute names or values. When plain text makes something too ambiguous and you need some styling, use back ticks to indicate attributes or values (for example, a definition like: Reported when ` category ` is ` http ` ). Using this also sets us up for success if we implement styling in the UI definitions in the future. We should avoid links because those aren't visible in the query UI; the query UI only displays plain text. However, every attribute entry in the query UI does display a 'See attribute in docs' link that links to the complete and normally formatted docs site entry. This means that we can use links provided that they will display in an easy to understand way in the query UI. For example, here's an example of an attribute that would read clearly in plain text despite not having a link. We should avoid using a link format like \"For more information, see Create an alert condition\", because it wouldn't read well in plain text, and would choose something like \"For more information, see our alert condition docs.\" Using units of measurement Attribute entries have an optional unit of measurement field in the front matter. For example, here the front matter for an attribute with a percent unit of measurement: --- name: cpuPercent type: attribute units: percentage (%) events: - ProcessSample --- Copy What unit of measurement to select for an attribute is sometimes obvious, like if the attribute value is measured in milliseconds (units: milliseconds (ms)) or seconds (units: seconds (s)) or a percentage (units: percentage (%)). We also have several units of measurement that are not obvious, like count, enum, rate, and ID. (Technically, these aren't actually \"units of measurement\" and are more just conceptual data types but we're doing it this way as a workaround so you can ignore the fact that units of measurement isn't actually accurate.) The main reason we want to specify this information is that this will control what kinds of queries or charts can be created or auto-suggested by New Relic. For example, the New Relic UI wouldn't want to auto-suggest a chart graphing the average of ID values because that wouldn't make any sense. So attributes with accurate units, such as data types, will help product provide more practical help/suggestions to customers in future. Here are some tips for the non-obvious unit types: count: This is a count of something, though not a count of time-based units. For a number to be a count, it must (a) only be capable of increasing during a given time/sampling period, and (b) have a theoretically uncapped range. This wouldn't be used for a count of time units; if it was a count of seconds, for example, you would just use 'seconds' as the unit of measurement. A couple of examples of a count: databaseCallCount threadConcurrency enum: enum is short for enumerated list. In other words, it is a specific range of numbers that represent other non-numeric elements. For example, an attribute that had HTTP error codes (404, 505, etc.) as possible values would be an enum. A range of numbers that represent color codes would be another example of an enum. (Theoretically, an enum can represent lists without numeric values but we have no need to categorize strings so we only care about numeric-value lists.) Example: httpResponsecode. rate: Use this for any rate (for example, count per second). These are typically for averaged rates over small units of time, like second or millisecond. We previously have used the unit of time for these attributes (for example, using seconds as the unit of measurement for a count per second rate), but now we want to use rate for these. This is necessary because the types of displays used for rates would be different than the types of displays used for a simpler duration/count measurement. Example: MySQL integration attribute db.innodb.dataReadBytesPerSecond, which has the definition \"Rate at which data is read from InnoDB tables in bytes per second.\" id: Use ID for any identification number attribute. Example: appId.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.666,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Attribute <em>style</em> <em>guidelines</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " to be accurate, and place it in the folder of the data type it&#x27;s attached to (for example, Transaction). When writing an attribute, try to keep it as concise as possible, and avoid using links. For more on that, see <em>Style</em>. If the attribute has one of the units of measurement we use (like units: percentage"
      },
      "id": "61ab4782e7b9d278d80e6e03"
    }
  ],
  "/docs/style-guide/writing-docs/docs-translation": [
    {
      "sections": [
        "Translation disclaimer"
      ],
      "title": "Translation disclaimer",
      "type": "docs",
      "tags": [
        "Licenses",
        "License information",
        "Translation"
      ],
      "external_id": "cb23af79521feaaa6193002aef89648a9973cf1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/translated-documentation/translation-disclaimer/",
      "published_at": "2021-12-10T06:50:15Z",
      "updated_at": "2021-12-09T01:58:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The official version of the Documentation is in English. Portions of the New Relic Documentation may be translated for your convenience as shown on this site. Translated content may contain errors, discrepancies, or differences created in the translation, are not binding, and have no legal effect for enforcement or compliance purposes. New Relic does not make any warranty, express or implied, as to the accuracy, reliability, or correctness of any translated Documentation from the English original to any other language. Any guarantees or commitments in your Agreement with New Relic that the Services, products, or other offerings conform or are consistent with the Documentation do not apply to the extent to which the Documentation has been translated.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.2815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Translation</em> disclaimer",
        "sections": "<em>Translation</em> disclaimer",
        "tags": "<em>Translation</em>",
        "body": "The official version of the Documentation is in English. Portions of the New Relic Documentation may be translated for your convenience as shown on this site. Translated content may contain errors, discrepancies, or differences created in the <em>translation</em>, are not binding, and have no legal effect"
      },
      "id": "61b162bf196a672b190d46f7"
    },
    {
      "sections": [
        "Update the home page",
        "Update a link's URL",
        "Add a new tile to the home page",
        "Add a new section to the home page",
        "Edit the home page left nav"
      ],
      "title": "Update the home page",
      "type": "docs",
      "tags": [
        "home page",
        "landing pages"
      ],
      "external_id": "1d084fae5223f5b34cec91fcae0bcb35560c7b29",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/edit-homepage/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-12-04T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can't just hit the edit button docs.newrelic.com to make edits to the home page. The page that opens is index.js, the file that manages the parts of the home page, but not the content. It's rare that you'll need to make changes to this file. Most home page changes will be to add a new tile or section to the page, or update links. These types of changes are handled in two files: src/data/homepage.yml - contains home page section titles, section descriptions, and the URLs for tiles. src/i18n/translations/en/translation.json - contains tile info, including the title and short description of tiles. Update a link's URL Change or add new links using homepage.yml. In homepage.yml, search for the link you want to change. Edit the URL, save, commit, and PR the change. Add a new tile to the home page You'll make changes to both homepage.yml and translations.json On the translations.json doc, find the spot where you want to add the new tile (which section, and in what order you want it to appear), and add a new entry with this format: \"t#\": { \"title\": \"tile name\", \"description\": \"Short description.\" }, Copy Make sure you update the number on the tile. If you want to insert it in the middle of a group, update all the subsequent tile numbers as well. Save the file. Open homepage.yml, find the spot where the new tile will be, and add a new line with the relative link for the new tile. For example, - /docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster Save and check that your new tile builds properly on a local build. Commit, push, PR when you're ready. Add a new section to the home page On the translations.json page, add a new section modeled in the spot where you want the new section to appear. Include at least one title. For example, here's the TDP entry, with one tile: \"errors-inbox\": { \"title\": \"Errors Inbox\", \"description\": \"A single place to proactively detect, triage, and take action on all the errors before they impact customers.\", \"t1\": { \"title\": \"Introduction to Errors Inbox\", \"description\": \"How to manage all your monitoring in one place.\" }, Copy When you're done creating the info, save the file. In the homepage.yml page, find the corresponding location for the new section, and add the short name you provided in the translation.json file, title, description, and tile URLs. For example, here's the corresponding TDP section on homepage.yml. errors-inbox: title: Errors Inbox description: A single place to proactively detect, triage, and take action on all the errors before they impact customers. tiles: - /docs/errors-inbox/errors-inbox Copy Save, build locally, commit, PR. Edit the home page left nav The left nav of the home page is controlled by src/nav/root.yml. This is a basic yml file, similar to our taxonomy files. Each link on the left nav needs a title and a path: - title: Welcome to New Relic path: /docs/using-new-relic - title: New Relic One path: /docs/new-relic-one/use-new-relic-one - title: Guides and best practices path: /docs/new-relic-solutions - title: section-break - title: Alerts and Applied Intelligence path: /docs/alerts-applied-intelligence Copy You can add a new link by following the pattern above or delete a link by removing the corresponding title and path. Section breaks are added by including a - title: section-break line. The left nav reflects the exact order of root.yml, so it's easy to organize it as needed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 81.375946,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "You can&#x27;t just hit the edit button <em>docs</em>.newrelic.com to make edits to the home page. The page that opens is index.js, the file that manages the parts of the home page, but not the content. It&#x27;s rare that you&#x27;ll need to make changes to this file. Most home page changes will be to add a new tile"
      },
      "id": "61ab480264441f9ef0927fb8"
    },
    {
      "sections": [
        "Create smoother charts with sliding windows",
        "When to use sliding windows",
        "Valid NRQL syntax for SLIDE BY",
        "Translation from PromQL-style queries",
        "Use SLIDE BY with MAX and AUTO",
        "Tip"
      ],
      "title": "Create smoother charts with sliding windows",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "97fe07b51e5f2c6a2868c924d1c829d82fd8f585",
      "image": "https://docs.newrelic.com/static/9d882293c1b7b04e65b4bcf6f3ae4bbf/e5166/SlidingWindow2.jpg",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows/",
      "published_at": "2021-12-10T08:34:11Z",
      "updated_at": "2021-03-16T13:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Sliding windows are a technique for generating charts using the SLIDE BY clause in conjunction with the TIMESERIES clause. With sliding windows, data is gathered in time \"windows\" that overlap with each other. For example, in the image below, a query gathers data with 5 minute windows. The windows \"slide\" by 1 minute. Each window overlaps with the previous window by 4 minutes. 5-minute windows with 1-minute \"slide\" In contrast, with \"tumbling\" or \"cascading\" windows, the windows do not overlap. For example, in this TIMESERIES 3 minutes NRQL query, the windows are 3 minutes in length, with each beginning when the other ends. There is no overlap in the measurement interval. 3-minute windows with no overlap or \"slide\". When to use sliding windows Sliding windows are helpful when you need to smooth out \"spiky\" charts. One common use case is to use sliding windows to smooth line graphs that have a lot of variation over short periods of time in cases where the rolling aggregate (for example a rolling mean) is more important than aggregates from narrow windows of time. In the example below, data varies greatly from one minute to another, so the 1-minute tumbling window chart shows many high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are smoothed with the help of 1-minute SLIDE BY intervals. The query returns similar data but creates a much smoother chart. TIMESERIES query with SLIDE BY clause Valid NRQL syntax for SLIDE BY Valid NRQL syntax for the SLIDE BY clause will follow the format below. SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units Copy integer1 specifies the sliding window width and integer2 specifies the SLIDE BY interval. units is a time unit, such as second, minute, hour, or day. All standard NRQL time units are accepted. Here’s a real-life example. It shows 5-minute TIMESERIES windows with a 1-minute SLIDE BY interval. SELECT average(duration) from Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy Translation from PromQL-style queries When applicable, a PromQL-style query is translated into a NRQL sliding window query. For example, if your PromQL style query uses rate(request_count[5m]) for the past 60 minutes with a 1-minute window overlap, the NRQL translation would be the query below. SELECT rate(sum(request_count), 1 SECONDS) FROM Metric SINCE 3600 SECONDS AGO UNTIL NOW FACET dimensions() LIMIT 100 TIMESERIES 300000 SLIDE BY 60000 Copy In the translation output, the default unit of millisecond is used for TIMESERIES and SLIDE BY clauses. For TIMESERIES, 300000 ms is 300 seconds, or 5 minutes, specifying a window size of 5 minutes. For SLIDE BY, 60000 ms is 60 seconds, specifying a slide interval of 1 minute. Use SLIDE BY with MAX and AUTO You can combine SLIDE BY with MAX and AUTO arguments to further tailor query results, as shown in the examples below. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy Tip When paired with SLIDE BY, TIMESERIES does not support AUTO or MAX. The TIMESERIES value must be an integer time unit value. In other words, SLIDE BY AUTO or SLIDE BY MAX will work, but TIMESERIES AUTO or TIMESERIES MAX followed by SLIDE BY and MAX, AUTO, or a specific integer time unit is not supported. Tip The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which will show up as gaps and unexpected results. If you experience these issues with query results, consider checking for instances of SLIDE BY where the step interval exceeds the window size.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 55.37741,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Translation</em> from PromQL-style queries",
        "body": ", or day. All standard NRQL time units are accepted. Here’s a real-life example. It shows 5-minute TIMESERIES windows with a 1-minute SLIDE BY interval. SELECT average(duration) from Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy <em>Translation</em> from PromQL-style queries When applicable"
      },
      "id": "603e8a2528ccbc56e5eba774"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/create-edit-content": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-strategies/introduction-style-guide/",
      "sections": [
        "Introduction to the style guide"
      ],
      "published_at": "2021-12-09T22:36:58Z",
      "title": "Introduction to the style guide",
      "updated_at": "2021-11-24T09:23:43Z",
      "type": "docs",
      "external_id": "56adaf70b517da62915ac6a2a56ff50c6effb7a9",
      "document_type": "page",
      "popularity": 1,
      "body": "Welcome to New Relic's style guide. We've written these guidelines for content creators across New Relic, and for contributors to our open source content projects, like the Docs! This guide also gives you some insight into how we think about good technical writing. We focus on style and usage that's particular to New Relic. We follow American English conventions. For topics that aren't covered, please refer to the Microsoft Writing Style Guide (for guidelines on technical terminology) or the Chicago Manual of Style (for general writing and editing guidelines). Find the information you need: For our writing strategy, see docs in this section on voice, five questions for great content, how to organize your content, and more. For a quick reference for terms usage, see our Usage dictionary. For how to write and edit pages on docs.newrelic.com, see Create and edit content.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1017.3775,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ": For our writing strategy, see docs in this section on voice, five questions for great <em>content</em>, how to organize your <em>content</em>, and more. For a quick reference for terms usage, see our Usage dictionary. For how to write and <em>edit</em> pages on docs.newrelic.com, see <em>Create</em> and <em>edit</em> <em>content</em>."
      },
      "id": "619e049fe7b9d2f6effe7e25"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-strategies/organize-doc/",
      "sections": [
        "Organize your page",
        "Organize your page to make it easier to read",
        "Use action-oriented titles",
        "Start the document with an introductory paragraph",
        "Keep documents short",
        "Use the New Relic voice",
        "Change doc titles and anchors",
        "Create and edit categories",
        "Start writing and editing docs"
      ],
      "published_at": "2021-12-09T22:55:14Z",
      "title": "Organize your page",
      "updated_at": "2021-11-24T07:56:48Z",
      "type": "docs",
      "external_id": "a3e3c993c0bf65626e805676496bcae8ea8d2c64",
      "document_type": "page",
      "popularity": 1,
      "body": "These are some organization basics. Organize your page to make it easier to read Consider these organization guidelines when thinking about the order of information in a doc. By following these guidelines, you'll make it easier for readers to skim and find what they need. How to organize information Comments Separate what and why from how. Define any necessary prerequisites, policies, or background information (the what and the why) before you step through the how (step-by-step procedures). Examples: Explain what the feature is and why it matters before telling readers how to use it. Describe any limitations with user permissions or subscription levels that would prevent them from using the feature. If the feature is available for any user or subscription level, don't bother to say so. Provide a roadmap for what users will be able to accomplish, so they know before starting a procedure that they have everything they need. Front-load directions with context. Make sure readers know where they need to be, before telling them what to do. In general, use (select an app) to describe what users select from the product index. Examples: Go to one.newrelic.com > Explorer > (select an app or service). Select (account dropdown) > User preferences. On the command line, type gitk. Also, structure steps by front-loading context from the user's point of view. For example, instead of \"Go to x to do y,\" structure the step as \"To do y, go to x.\" Separate requirements from options. Example: Type the Email you use to sign in and to receive information from New Relic. Optional: Type additional user emails, separated by commas. Follow the \"five to nine\" guideline. Depending on the topic, organize the information so there is a maximum of five to nine chunks of information. For example, readers may start to get lost or overwhelmed after about five h2 sections or seven steps into a procedure. If you have more than nine h2 sections or steps, you might need to create an additional doc or procedure. Other organization tools to consider: Levels of headings Lists Collapsers Callouts Tables Code examples For more help section Use action-oriented titles Wherever possible, give your document or h2 heading a task- or action-oriented title. Focus on what users are trying to accomplish or the problem they're trying to solve. Use present-tense verbs, rather than \"-ing\" verbs. Quality Title example Bad The query history Okay View query history Good Query history: Create and edit NRQL queries Start the document with an introductory paragraph Unless the document is less than a single screen in length, begin with a brief paragraph that introduces the topic or summarizes the important points. Not sure where to start? Try writing all the content for your document first, and then add the introduction to the top to summarize your key points. Or use the introduction to expand on the text in your metaDescription in the metadata. Keep documents short The amount of content needed can help you decide whether you need one or more documents for the topic. If all of the document's contents apply directly to the title, then everything belongs in the same document. If several related sections could be logically split into individual documents, and the overall length of your document is more than about two screenfuls, split those sections into other documents. Be sure to include links to the related contents. If a large document needs to be broken into multiple smaller documents, consider whether they might be best grouped together in their own sub-category. Use the New Relic voice We strive for a voice that's approachable, expert, and visionary. Check out our voice guidelines for how to write content with these qualities. And keep in mind these essential writing tips that apply to any type of documentation. Guidelines Comments Be clear and direct. Remember to: Use present tense. Use active voice; avoid passive voice. Tell users what to do, not what they \"should\" do. If absolutely necessary, tell users what not to do in situations where unexpected results may occur. Whenever possible, provide an alternative suggestion when telling users what not to do. Example: Using active voice with an alternative suggestion for what not to do Do not use your config file to change this setting, because this could affect other processes. Instead, go to one.newrelic.com > APM > (select an app or service) > Settings > Application. Write to aid localization and translation. Do not use euphemisms, idioms, jargon, or slang. Use the same terms and wording consistently. If you need to include an abbreviation or acronym, spell it out the first time it appears in the document. Always take a moment to ask yourself whether people will really understand the terms you are using in the way you're using them. Change doc titles and anchors Because changes to doc titles, anchors, and redirects can break links to other docs, please create an issue to request these types of changes and we'll help you out with that. Create and edit categories Because changes to categories can affect large groups of docs at once, please create an issue to request these types of changes and we'll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see Create and edit content. To learn how to create and publish release notes, see Create release notes. To make it even easier to start a new doc, use templates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 652.50684,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Create</em> <em>and</em> <em>edit</em> categories",
        "body": " of docs at once, please <em>create</em> an issue to request these types of changes and we&#x27;ll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see <em>Create</em> and <em>edit</em> <em>content</em>. To learn how to <em>create</em> and publish release notes, see <em>Create</em> release notes. To make it even easier to start a new doc, use templates."
      },
      "id": "619df04028ccbc2730b9a00a"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/writer-workflow/github-intro/",
      "sections": [
        "Get around GitHub",
        "Who is who in an issue/PR?",
        "Track issues in the board",
        "Deal with references in GitHub (and the style guide)",
        "Merge releases into main work (or, when do we publish?)",
        "GitHub labels",
        "Check the edit history of a doc or file",
        "Docs site history before October 2021"
      ],
      "published_at": "2021-12-10T13:50:16Z",
      "title": "Get around GitHub",
      "updated_at": "2021-12-04T10:48:34Z",
      "type": "docs",
      "external_id": "539ae5620ae9be8f8c3752fd3eda664186fbb5c4",
      "document_type": "page",
      "popularity": 1,
      "body": "As tech doc writers (TW) we edit docs, do peer edits, or use the Docs Team GitHub board to track the status of issues and pull requests (PR). Who is who in an issue/PR? GitHub keeps track of all activity concerning an issue or PR, including, of course, the people involved. When a new issue or PR is filed, check on the filer’s username and see if they're listed as a member of the New Relic organization. If they aren't, try to find them on Slack based on their username. If you're not sure about someone's affiliation, treat them as external until you know otherwise. People in an issue/PR include: Creator: The person who opened the issue or PR. This could be a writer, a Relic, or an external user. We'll label the issue or PR differently depending on who created it. If you're not sure if a user is a Relic, a good trick is to click on their profile and see if they're a member of the New Relic GitHub org. Assignee: The person taking responsibility for a PR or issue. This will usually be used by the Hero or Sidekick to assign non-TW PRs and issues to themselves. It can also be used to take a TW’s PR or issue over from them. Reviewer: The person who reviews or peer edits the code/document and approves the changes. Not necessarily the person responsible for that area or responsible for merging the commit. You can pre-assign up to 100 reviewers to a given issue. Track issues in the board The docs board has the following columns: Column Description Needs triage The Hero or Sidekick review and label issues and PRs in this column, then drag them to the appropriate column. If a PR or issue is labeled eng, the Hero/Sidekick can go ahead and click its ellipses icon to archive it. Hero: to do PRs that the Hero needs to review, publish, and follow up with SMEs as needed. Hero: Assign yourself as Assignee. In review (Hero or any TW) Drag PRs to this column when they are being reviewed. This shows who is reviewing and what is being reviewed, so two writers don’t mistakenly work on the same PR. Any TW: Writer needs PR review PRs from Tech Docs team members that need a light edit pass to make sure everything in GitHub is correct. This should be checked by other writers every few hours so PRs don’t get stale. If you have a PR that’s been lingering here too long, ask for a reviewer in #doc_sprint_talk. Whoever takes it: assign yourself as Reviewer. Any TW: needs peer edit Like our Needs Peer Edit column in Jira: A writer has requested a review of their PR. Review their PR in GitHub and leave comments. Whoever takes it: assign yourself as Reviewer. Waiting on SME/Blocked For PRs that are blocked by need for SME info or confirmation (for example, as Hero you are waiting on an answer from the person who sent in a Hero pull request). Waiting on TW to merge All reviews are complete. The TW who created the PR (or who is assigned the issue) needs to merge this work into develop. Drafts A draft is a way to open a PR while indicating that the work is still in progress and not necessarily ready to merge immediately. You can't merge a Draft PR directly. Instead, you must move it out of draft status first. When you see a draft PR (especially from outside the team!), treat it as though it's a working draft, and reach out to the creator to discuss. Read more on GitHub's drafts. As a Hero, make sure you attend to the following throughout your day: Check in with the previous Hero at the start of your day (especially on Monday at the start of the week). Don’t forget to sync with the BCN Hero if necessary. Watch for incoming PRs in #docs_deploys, and review everything in the Needs triage column. Drag cards from that column to the appropriate column. Work through the cards in the Hero: to do column. Everyone on the team helps keep things moving: All writers should keep an eye on both Any TW columns. There's one column for PRs that need a simpler review before merging (typo fixes, drive-by edits, etc), and another column for PRs that need a peer edit. There are also two blocked columns: One for PRs blocked on a SME, and another column where we're waiting on the TW who created the PR to review feedback and/or merge. After merging, remove your ticket from the board. Deal with references in GitHub (and the style guide) Don't link to anything non-public from a public place. You can reference Jira tickets, but reference tickets by issue key (DOC-1234 is ok) rather than a link (https://newrelic.atlassian.net/browse/DOC-1234 is not). Don't mention traffic or usage numbers publicly. Don't reference internal people by name. If they have a GH account, @mention their GH handle. If they don't, talk instead about teams (\"talk to a browser team engineer\" or \"Support Engineer\") rather than people. You can mention the #documentation channel and hero. Merge releases into main work (or, when do we publish?) The Hero currently merges three times a day: At 9 AM (morning), 12 PM (noon), and 3 PM (evening) Pacific. We merge release branches into main to avoid interuptions when someone merges into develop during a release. To learn more about this workflow, see the gitflow documentation in Atlassian. To start a release: Create a branch based off develop Github Desktop by clicking Current Branch in the top header, clicking New Branch in the dropdown, and then selecting Develop. Name the branch following this pattern: daily-release/mm-dd-yy-morning/noon/evening. Here's an example: daily-release/10-27-21-morning. Push your changes by clicking Push Origin in GitHub Desktop. Create a pull request into main from your new daily release branch by clicking Create Pull Request. This will open a pull request screen on github.com. Pull requests default to merging into develop, so select main as the base branch in the left side of the page and then click Submit Pull Request. Wait until all the checks complete, and then merge the pull request. All branches that follow the daily-release/mm-dd-yy-morning pattern are protected branches. This means the branches can't be deleted or pushed to by non-admins. GitHub labels Every issue needs labels to help us triage and track the health of our backlog: content: Always add, this indicates the issue is content-related rather than a design or engineering issue. pg_*: Always add to indicate the product group. For full definitions, see the \"Doc Jira and GitHub fields\" doc in the internal team Google Drive. Indicate who created the issue: from_internal: A Relic created it. from_external: A user opened it in the repo OR it came in through #customer-feedback process. from_tw: One of us created it (unless we were passing along #customer-feedback). Optionally: docs-issues-migrate: Issues that are too large in scope for the docs team to handle without product team expertise. This label alerts the docs issues team to migrate these issues into the customer feedback channel where they will be triaged and sent to product teams. Jira’d: Issues that have a corresponding Jira ticket. Make sure you leave the Jira number in the comments of the issue (for example, DOC-1234). Every pull request needs these labels so we can see where our contributions come from: content: Always add, this indicates the PR is content-related rather than design or engineering. Indicate who created the pull request: from_internal: A Relic created it. from_external: A user opened it in the repo OR it came in through #customer-feedback process. from_tw: One of us created it (unless we were passing along #customer-feedback). If the PR fixes an external issue, label it as from_tw since the work was done by a tech writer. Check the edit history of a doc or file Use any of these options to check or \"diff\" the history of a file. Option 1: GitHub history tab Navigate to the doc on the doc site and click Edit page in the right nav. Click History in the top right corner of the doc. Option 2: githistory.xy Navigate to your specific file on GitHub.com: https://github.com/newrelic/docs-website/blob/develop/src/content/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action.mdx Copy In the url, replace github.com with github.githistory.xyz: https://github.githistory.xyz/newrelic/docs-website/blob/develop/src/content/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action.mdx Copy It will take you to a site which presents the visual history of that specific file. You can view changes by clicking through the commit history at the top of your page. Option 3: Git blame Follow GitHub's documentation. Alternatively, you can use the following command in your terminal: git log --follow \"**/file_name_here.mdx\" Copy This will output the commit history of that file. By default, it only shows the first few commits. You can scroll by pressing Return multiple times. For example, to find the commit history for vmware-vsphere-monitoring-integration.mdx, I would run: git log --follow \"**/vmware-vsphere-monitoring-integration.mdx\" Copy Docs site history before October 2021 We had a large site restructure in October 2021 which lost most of the file history for our docs. You can find an archived version of our site pre-rework in the pre-IA-2021 branch. By navigating the pre-rework version of our repo, you can find file history and more.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.40828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Check the <em>edit</em> history of a doc or file",
        "body": "As tech doc writers (TW) we <em>edit</em> docs, do peer edits, or use the Docs Team GitHub board to track the status of issues and pull requests (PR). Who is who in an issue&#x2F;PR? GitHub keeps track of all activity concerning an issue or PR, including, of course, the people involved. When a new issue or PR"
      },
      "id": "61ab4782196a672667d0efa1"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/create-release-notes": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-strategies/organize-doc/",
      "sections": [
        "Organize your page",
        "Organize your page to make it easier to read",
        "Use action-oriented titles",
        "Start the document with an introductory paragraph",
        "Keep documents short",
        "Use the New Relic voice",
        "Change doc titles and anchors",
        "Create and edit categories",
        "Start writing and editing docs"
      ],
      "published_at": "2021-12-09T22:55:14Z",
      "title": "Organize your page",
      "updated_at": "2021-11-24T07:56:48Z",
      "type": "docs",
      "external_id": "a3e3c993c0bf65626e805676496bcae8ea8d2c64",
      "document_type": "page",
      "popularity": 1,
      "body": "These are some organization basics. Organize your page to make it easier to read Consider these organization guidelines when thinking about the order of information in a doc. By following these guidelines, you'll make it easier for readers to skim and find what they need. How to organize information Comments Separate what and why from how. Define any necessary prerequisites, policies, or background information (the what and the why) before you step through the how (step-by-step procedures). Examples: Explain what the feature is and why it matters before telling readers how to use it. Describe any limitations with user permissions or subscription levels that would prevent them from using the feature. If the feature is available for any user or subscription level, don't bother to say so. Provide a roadmap for what users will be able to accomplish, so they know before starting a procedure that they have everything they need. Front-load directions with context. Make sure readers know where they need to be, before telling them what to do. In general, use (select an app) to describe what users select from the product index. Examples: Go to one.newrelic.com > Explorer > (select an app or service). Select (account dropdown) > User preferences. On the command line, type gitk. Also, structure steps by front-loading context from the user's point of view. For example, instead of \"Go to x to do y,\" structure the step as \"To do y, go to x.\" Separate requirements from options. Example: Type the Email you use to sign in and to receive information from New Relic. Optional: Type additional user emails, separated by commas. Follow the \"five to nine\" guideline. Depending on the topic, organize the information so there is a maximum of five to nine chunks of information. For example, readers may start to get lost or overwhelmed after about five h2 sections or seven steps into a procedure. If you have more than nine h2 sections or steps, you might need to create an additional doc or procedure. Other organization tools to consider: Levels of headings Lists Collapsers Callouts Tables Code examples For more help section Use action-oriented titles Wherever possible, give your document or h2 heading a task- or action-oriented title. Focus on what users are trying to accomplish or the problem they're trying to solve. Use present-tense verbs, rather than \"-ing\" verbs. Quality Title example Bad The query history Okay View query history Good Query history: Create and edit NRQL queries Start the document with an introductory paragraph Unless the document is less than a single screen in length, begin with a brief paragraph that introduces the topic or summarizes the important points. Not sure where to start? Try writing all the content for your document first, and then add the introduction to the top to summarize your key points. Or use the introduction to expand on the text in your metaDescription in the metadata. Keep documents short The amount of content needed can help you decide whether you need one or more documents for the topic. If all of the document's contents apply directly to the title, then everything belongs in the same document. If several related sections could be logically split into individual documents, and the overall length of your document is more than about two screenfuls, split those sections into other documents. Be sure to include links to the related contents. If a large document needs to be broken into multiple smaller documents, consider whether they might be best grouped together in their own sub-category. Use the New Relic voice We strive for a voice that's approachable, expert, and visionary. Check out our voice guidelines for how to write content with these qualities. And keep in mind these essential writing tips that apply to any type of documentation. Guidelines Comments Be clear and direct. Remember to: Use present tense. Use active voice; avoid passive voice. Tell users what to do, not what they \"should\" do. If absolutely necessary, tell users what not to do in situations where unexpected results may occur. Whenever possible, provide an alternative suggestion when telling users what not to do. Example: Using active voice with an alternative suggestion for what not to do Do not use your config file to change this setting, because this could affect other processes. Instead, go to one.newrelic.com > APM > (select an app or service) > Settings > Application. Write to aid localization and translation. Do not use euphemisms, idioms, jargon, or slang. Use the same terms and wording consistently. If you need to include an abbreviation or acronym, spell it out the first time it appears in the document. Always take a moment to ask yourself whether people will really understand the terms you are using in the way you're using them. Change doc titles and anchors Because changes to doc titles, anchors, and redirects can break links to other docs, please create an issue to request these types of changes and we'll help you out with that. Create and edit categories Because changes to categories can affect large groups of docs at once, please create an issue to request these types of changes and we'll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see Create and edit content. To learn how to create and publish release notes, see Create release notes. To make it even easier to start a new doc, use templates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 609.18054,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Create</em> and edit categories",
        "body": " of docs at once, please <em>create</em> an issue to request these types of changes and we&#x27;ll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see <em>Create</em> and edit content. To learn how to <em>create</em> and publish <em>release</em> <em>notes</em>, see <em>Create</em> <em>release</em> <em>notes</em>. To make it even easier to start a new doc, use templates."
      },
      "id": "619df04028ccbc2730b9a00a"
    },
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-10T13:24:39Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 590.3812,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " list views. For more information, see Working with landing pages. <em>Release</em> <em>notes</em> This format includes specific fields for <em>release</em> <em>notes</em>. Users rely on <em>release</em> <em>notes</em> to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see <em>Create</em>"
      },
      "id": "61b35517196a677196a59e07"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "835ddacc0acae04e05c8c2ddc694799819a7d696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-11-26T05:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.50191,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "This document describes how to change the title of a document and how to <em>create</em>, edit, and delete redirects. Procedures are the same for both standard docs (&quot;basic pages&quot;) and <em>release</em> <em>notes</em>. Caution Changing titles or updating redirects can <em>create</em> issues with finding content. If you need to change"
      },
      "id": "61b35af428ccbca9318c6b13"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/delete-document": [
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-10T13:24:39Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.9261,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use content types <em>and</em> text formats",
        "sections": "Use content types <em>and</em> text formats",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " release notes. What&#x27;s New posts This format includes specific fields for product announcements. What&#x27;s New posts are created by PMM for larger announcements. They&#x27;re available in the docs site, but they&#x27;re also visible in the New Relic One UI. For more information, see What&#x27;s New <em>style</em> guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs <em>guide</em>."
      },
      "id": "61b35517196a677196a59e07"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "835ddacc0acae04e05c8c2ddc694799819a7d696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-11-26T05:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.9223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. <em>Procedures</em> are the same for both standard docs (&quot;basic pages&quot;) and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change"
      },
      "id": "61b35af428ccbca9318c6b13"
    },
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "9ec2ccd8a8509ab1b54273206e84f9571164c4f9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-11-26T05:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.91882,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Procedures</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original <em>tech</em> <em>writer</em> or docs site contributor"
      },
      "id": "61b35af4e7b9d2769c5a38f9"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist": [
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-10T13:24:39Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.9261,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use content types <em>and</em> text formats",
        "sections": "Use content types <em>and</em> text formats",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " release notes. What&#x27;s New posts This format includes specific fields for product announcements. What&#x27;s New posts are created by PMM for larger announcements. They&#x27;re available in the docs site, but they&#x27;re also visible in the New Relic One UI. For more information, see What&#x27;s New <em>style</em> guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs <em>guide</em>."
      },
      "id": "61b35517196a677196a59e07"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "835ddacc0acae04e05c8c2ddc694799819a7d696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-11-26T05:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.9223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. <em>Procedures</em> are the same for both standard docs (&quot;basic pages&quot;) and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change"
      },
      "id": "61b35af428ccbca9318c6b13"
    },
    {
      "sections": [
        "Delete a document",
        "Caution"
      ],
      "title": "Delete a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "2cd80eef8b60c58847511bbd58fd38abdac22d75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/delete-document/",
      "published_at": "2021-12-10T13:48:54Z",
      "updated_at": "2021-11-26T05:12:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Caution When you delete a document, its content and its redirects will still be available in the GitHub commit history. In general, if you're not on the New Relic Docs team, please don't delete any docs. Instead, file an issue and someone on our team will help you out. If you are certain you want to delete a document, do this: Locate the mdx file of the doc you want to delete. Take care of redirects: Find the most relevant doc to redirect readers to. Add the deleted doc's URL as a redirect. Copy any existing redirects from the deleted doc and add them to the new doc. Delete the doc's title and path from the appropriate nav file. Delete the doc mdx file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.91736,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61ab47d9196a679242d10141"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/edit-homepage": [
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-10T13:24:39Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.04252,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Page</em> templates",
        "body": " is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. <em>Landing</em> <em>pages</em> This format is for a more user-friendly and readable <em>landing</em> <em>page</em>, which replaces the standard taxonomy"
      },
      "id": "61b35517196a677196a59e07"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/landing-page-template/",
      "sections": [
        "Landing page template",
        "Important",
        "Front matter",
        "Tip",
        "Introduction section",
        "Tiles",
        "Button for viewing all docs in the category",
        "Code sample"
      ],
      "published_at": "2021-12-10T13:29:43Z",
      "title": "Landing page template",
      "updated_at": "2021-11-26T05:11:08Z",
      "type": "docs",
      "external_id": "7f97d929091de18beb47bff4f6dff62e9676bbb5",
      "document_type": "page",
      "popularity": 1,
      "body": "Landing pages are a specialized type of page that serve as the starting pages for various New Relic products. For example, you'll see landing pages for Application monitoring (APM) and Browser monitoring. Important This landing page information does not apply to the docs home page. If you need to create a new landing page, you can either copy an existing landing page, or you can modify the sample landing page shown at the bottom. The next sections look at what you need to include for each landing page. Front matter When you insert the front matter, be sure to designate the type as landingPage. Here's an example: --- title: APM type: landingPage --- Copy Tip In the front matter, the following are optional: tags, translate, and redirects. So, you can leave them out if they don't have any values. Introduction section Following the front matter, the first content section is a two-column introduction (also called the hero section). This includes the following: A <LandingPageHero> component wrapping all the introductory content. A <HeroContent> component wrapping the text portion of the introduction (the content in the left column). An image or video (appears in the right column). A caption (optional), which is wrapped by the <figcaption> component. Here's an example of the hero section that shows you where to insert your content: <LandingPageHero> <HeroContent> INSERT_PARAGRAPHS_FOR_YOUR_INTRODUCTION </HeroContent> ![INSERT_ALT-TEXT_HERE](./images/INSERT_IMAGE_FILE_NAME.png \"INSERT_THE_IMAGE_TITLE_HERE\") <figcaption> INSERT_OPTIONAL_CAPTION_USING_SAME_INDENTATION_AS_IMAGE </figcaption> </LandingPageHero> Copy Tiles Tiles are a series of boxes after the introduction. They contain the main subject areas for your product. You should just list these in order you want them to appear, and the cascading style sheet will render them across the page. Here's an example of a tile: <LandingPageTileGrid> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE.\" href=\"/docs/INSERT_THE_DIRECTORY_PATH_TO_THE_TARGET_LANDING_PAGE_INDEX.HTML\" icon=\"fe-INSERT_THE_ICON_NAME\" > INSERT_TILE_CONTENT_HERE... </LandingPageTile> ... Copy For each tile, do the following: Insert a value for title that explains the purpose of the category. Insert a value for href that links to the target landing page. If the target landing page is index.html, you can just include the directory path with no filename since index.html is the default (it doesn't cause any problems if you include index.html). Insert a value for icon by prefixing the icon name with fe- (Feather icons), logo- (third-party logos), or nr- (New Relic logos). For example, here is the format for a feather icon: fe-alert-triangle). Tip For more details about icons, see Embed images. Between the LandingPageTile tags, insert text, such as a bullet list with links to product documentation. Button for viewing all docs in the category After your tiles, you should have a single button that offers to take users to all the documentation for that category. The table of contents page that gets linked here is always at the same path as the landing page, but with /table-of-contents appended to it. These table of contents pages get built automatically for every landing page. For example, if this landing page was located at /docs/apm, this link should be /docs/apm/table-of-contents. Here's an example: <ButtonLink role=\"button\" to=\"INSERT_LINK_TO_DIRECTORY_WITH_ALL_THESE_DOCS/table-of-contents\" variant=\"normal\" > View all INSERT_YOUR_CATEGORY_HERE docs </ButtonLink> Copy Code sample Here's a sample landing page you could modify to suit your needs: --- title: INSERT_YOUR_TITLE_HERE type: landingPage --- <LandingPageHero> <HeroContent> INSERT_PARAGRAPHS_FOR_YOUR_INTRODUCTION </HeroContent> ![INSERT_ALT-TEXT_HERE](./images/INSERT_IMAGE_FILE_NAME.png \"INSERT_THE_IMAGE_TITLE_HERE\") <figcaption> INSERT_OPTIONAL_CAPTION_USING_SAME_INDENTATION_AS_IMAGE </figcaption> </LandingPageHero> <LandingPageTileGrid> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * [INSERT_LINK_NAME](INSERT_LINK_URL) Aliquam auctor mattis nisl ut iaculis. * [INSERT_LINK_NAME](INSERT_LINK_URL) Suspendisse pharetra elit sit amet risus euismod, a consectetur tortor vulputate. </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) to lectus diam, ornare vitae dui suscipit, laoreet ultrices lacus. * Mauris tempor massa ac augue mattis, nec pharetra quam mollis [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) rhoncus tortor vitae libero laoreet feugiat. * Donec dui elit, fermentum vel faucibus sed, rhoncus in felis [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) uspendisse pharetra elit sit amet risus euismod. * Pellentesque finibus magna vitae hendrerit gravida [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) Etiam imperdiet felis eu ipsum consequat tristique. * Etiam imperdiet felis eu ipsum consequat tristique [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> <LandingPageTile title=\"INSERT_YOUR_BOX_TITLE_HERE\" icon=\"fe-INSERT_ICON_NAME_HERE\" > * Use [INSERT_LINK_NAME](INSERT_LINK_URL) Quisque hendrerit, dolor sed sodales aliquet. * Vestibulum varius lectus ac velit euismod [INSERT_LINK_NAME](INSERT_LINK_URL). </LandingPageTile> </LandingPageTileGrid> <ButtonLink role=\"button\" to=\"INSERT_LINK_TO_DIRECTORY_WITH_ALL_THESE_DOCS/table-of-contents\" variant=\"normal\" > View all INSERT_YOUR_CATEGORY_HERE docs </ButtonLink> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.08646,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Landing</em> <em>page</em> template",
        "sections": "<em>Landing</em> <em>page</em> template",
        "body": "<em>Landing</em> <em>pages</em> are a specialized type of <em>page</em> that serve as the starting <em>pages</em> for various New Relic products. For example, you&#x27;ll see <em>landing</em> <em>pages</em> for Application monitoring (APM) and Browser monitoring. Important This <em>landing</em> <em>page</em> information does not apply to the docs <em>home</em> <em>page</em>. If you need"
      },
      "id": "61ab487d28ccbcd127c24e10"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/create-release-notes/",
      "sections": [
        "Create release notes",
        "New release note",
        "What makes a great release note?",
        "New release notes category",
        "Category landing page",
        "Landing page",
        "Links from other categories"
      ],
      "published_at": "2021-12-10T13:48:54Z",
      "title": "Create release notes",
      "updated_at": "2021-11-26T05:11:39Z",
      "type": "docs",
      "external_id": "ed8f28b2ba2020f4e61fd1499c5bc9c97472857b",
      "document_type": "page",
      "popularity": 1,
      "body": "This page is for release notes for downloadable software. For product announcements, see What's new style guidelines. New release note To add a release note to the docs site: Find the most recent release note for your agent, and make a copy of it in the same folder. When you rename your copy, avoid potential version naming conflicts by using a - separator in your file name. For example, instead of agent-123, use agent-1-2-3 for version 1.2.3 and agent-12-3 for version 12.3. Fill in the subject, releaseDate, and version. If applicable, include the downloadLink field. Using our standard headings for New features, Improvements, and Bug fixes, add enough summary information in these sections to make a great release note. Link to docs or other resources where they can learn more. Commit your changes and submit a pull request. If your release is date-sensitive, make a note in your PR. A Tech Docs hero will review your release note content and approve your PR to get it published. You can also request others on your team to review your PR. We build and deploy the docs site a few times a day, and sometimes builds can take a few hours to complete. If your release is time-sensitive, ensure you've planned for enough time to get your docs live. What makes a great release note? Great release notes help users quickly become familiar with your important update, so they know why it matters. Great release notes also help our support and security teams. By encouraging users to keep current with your latest release, this reduces support time to solve problems on outdated versions. It also mitigates risks if any potential vulnerabilities have been resolved with your latest version. To write a great release note, be as specific as possible. For example: Briefly describe new functionality. Give an example of the value it provides, and link to more detailed information. Don't use vague wording such as \"various bug fixes.\" Instead, clearly state what has been improved, so readers will know if an issue they’ve experienced has been resolved. New release notes category This information is primarily for the Tech Docs team's use. To add a new release notes category, update the following areas of the docs site. (You do not need to update the releaseNote.js or releaseNoteLandingPage.js files in the nav/templates folder.) Before you submit your pull request to the GitHub docs site, check that the landing pages and placeholder release note build correctly in your localhost. Category landing page In /src/content/docs/release-notes, add the following: A folder for your new release notes category. The RSS feed link, page format, and date order for release notes listed on this page are generated automatically. For example, see the C SDK category landing page format. An index.mdx file in your new folder containing the subject. The subject is the name that will appear on the Release notes landing page. A placeholder release note in this folder for the agent team to fill out. If used, the downloadLink field in the release note will be formatted automatically in the published release note. Before the new category goes live, check with the team's Product Marketing Management (PMM) rep whether they want to include the link in an upcoming What's new post. Landing page In /src/content/docs/release-notes/index.mdx, add a new tile section in alphabetical order for your release notes category. Example: <TechTile name=\"Logs\" icon=\"logo-newrelic\" to=\"/docs/release-notes/logs-release-notes\" /> Copy Logos come from @newrelic/gatsby-theme-newrelic/icons/logo/. If a logo does not already exist for the new agent, use the standard logo-newrelic icon or an image in @newrelic/gatsby-theme-newrelic/icons/feathers.js. If you need other options, talk to the team's designer. Links from other categories Add a link to your new release notes category in the agent's documentation, typically in its Get started category. For more information, see our documentation about docs in multiple menus. Optional: Add a link in the agent's landing page text by updating the index.mdx file in its taxonomy.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.107517,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Category <em>landing</em> <em>page</em>",
        "body": " that the <em>landing</em> <em>pages</em> and placeholder release note build correctly in your localhost. Category <em>landing</em> <em>page</em> In &#x2F;src&#x2F;content&#x2F;docs&#x2F;release-notes, add the following: A folder for your new release notes category. The RSS feed link, <em>page</em> format, and date order for release notes listed on this <em>page</em>"
      },
      "id": "61ab4941e7b9d25eae0e8af0"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document": [
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-10T13:24:39Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.92606,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use content types <em>and</em> text formats",
        "sections": "Use content types <em>and</em> text formats",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " release notes. What&#x27;s New posts This format includes specific fields for product announcements. What&#x27;s New posts are created by PMM for larger announcements. They&#x27;re available in the docs site, but they&#x27;re also visible in the New Relic One UI. For more information, see What&#x27;s New <em>style</em> guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs <em>guide</em>."
      },
      "id": "61b35517196a677196a59e07"
    },
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "9ec2ccd8a8509ab1b54273206e84f9571164c4f9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-11-26T05:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.9188,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Procedures</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original <em>tech</em> <em>writer</em> or docs site contributor"
      },
      "id": "61b35af4e7b9d2769c5a38f9"
    },
    {
      "sections": [
        "Delete a document",
        "Caution"
      ],
      "title": "Delete a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "2cd80eef8b60c58847511bbd58fd38abdac22d75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/delete-document/",
      "published_at": "2021-12-10T13:48:54Z",
      "updated_at": "2021-11-26T05:12:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Caution When you delete a document, its content and its redirects will still be available in the GitHub commit history. In general, if you're not on the New Relic Docs team, please don't delete any docs. Instead, file an issue and someone on our team will help you out. If you are certain you want to delete a document, do this: Locate the mdx file of the doc you want to delete. Take care of redirects: Find the most relevant doc to redirect readers to. Add the deleted doc's URL as a redirect. Copy any existing redirects from the deleted doc and add them to the new doc. Delete the doc's title and path from the appropriate nav file. Delete the doc mdx file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.9173,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61ab47d9196a679242d10141"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/understand-edit-docs-site-structure": [
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "606039ea3f3b44fdecc1bd2d03fd61d77c594db8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-12-10T13:24:39Z",
      "updated_at": "2021-11-26T05:15:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Through some technical wizardry, they generate Related resources links in the right nav area. Start each topic with a - on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.50012,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use content types <em>and</em> text formats",
        "sections": "<em>Docs</em> meta content (frontmatter)",
        "tags": "Processes <em>and</em> procedures",
        "body": " not capitalize any other word in the title unless it&#x27;s a proper noun, such as a specific product name, or it follows a colon (:). If you&#x27;re looking for ideas on how to choose a title, browse the titles of similar <em>docs</em>. The title used in the <em>sidebar</em> (left navigation pane) is set in the <em>nav</em> <em>file</em>. type"
      },
      "id": "61b35517196a677196a59e07"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "835ddacc0acae04e05c8c2ddc694799819a7d696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-11-26T05:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.30063,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Rename or redirect a <em>document</em>",
        "sections": "Rename or redirect a <em>document</em>",
        "tags": "Processes <em>and</em> procedures",
        "body": " a document title, change the title being used in the title field in the frontmatter at the top of the <em>doc</em>. If you want to update a title in the <em>sidebar</em>, change the title for that <em>doc</em> in the <em>nav</em> <em>file</em>. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser"
      },
      "id": "61b35af428ccbca9318c6b13"
    },
    {
      "sections": [
        "Update the home page",
        "Update a link's URL",
        "Add a new tile to the home page",
        "Add a new section to the home page",
        "Edit the home page left nav"
      ],
      "title": "Update the home page",
      "type": "docs",
      "tags": [
        "home page",
        "landing pages"
      ],
      "external_id": "1d084fae5223f5b34cec91fcae0bcb35560c7b29",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/edit-homepage/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-12-04T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can't just hit the edit button docs.newrelic.com to make edits to the home page. The page that opens is index.js, the file that manages the parts of the home page, but not the content. It's rare that you'll need to make changes to this file. Most home page changes will be to add a new tile or section to the page, or update links. These types of changes are handled in two files: src/data/homepage.yml - contains home page section titles, section descriptions, and the URLs for tiles. src/i18n/translations/en/translation.json - contains tile info, including the title and short description of tiles. Update a link's URL Change or add new links using homepage.yml. In homepage.yml, search for the link you want to change. Edit the URL, save, commit, and PR the change. Add a new tile to the home page You'll make changes to both homepage.yml and translations.json On the translations.json doc, find the spot where you want to add the new tile (which section, and in what order you want it to appear), and add a new entry with this format: \"t#\": { \"title\": \"tile name\", \"description\": \"Short description.\" }, Copy Make sure you update the number on the tile. If you want to insert it in the middle of a group, update all the subsequent tile numbers as well. Save the file. Open homepage.yml, find the spot where the new tile will be, and add a new line with the relative link for the new tile. For example, - /docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster Save and check that your new tile builds properly on a local build. Commit, push, PR when you're ready. Add a new section to the home page On the translations.json page, add a new section modeled in the spot where you want the new section to appear. Include at least one title. For example, here's the TDP entry, with one tile: \"errors-inbox\": { \"title\": \"Errors Inbox\", \"description\": \"A single place to proactively detect, triage, and take action on all the errors before they impact customers.\", \"t1\": { \"title\": \"Introduction to Errors Inbox\", \"description\": \"How to manage all your monitoring in one place.\" }, Copy When you're done creating the info, save the file. In the homepage.yml page, find the corresponding location for the new section, and add the short name you provided in the translation.json file, title, description, and tile URLs. For example, here's the corresponding TDP section on homepage.yml. errors-inbox: title: Errors Inbox description: A single place to proactively detect, triage, and take action on all the errors before they impact customers. tiles: - /docs/errors-inbox/errors-inbox Copy Save, build locally, commit, PR. Edit the home page left nav The left nav of the home page is controlled by src/nav/root.yml. This is a basic yml file, similar to our taxonomy files. Each link on the left nav needs a title and a path: - title: Welcome to New Relic path: /docs/using-new-relic - title: New Relic One path: /docs/new-relic-one/use-new-relic-one - title: Guides and best practices path: /docs/new-relic-solutions - title: section-break - title: Alerts and Applied Intelligence path: /docs/alerts-applied-intelligence Copy You can add a new link by following the pattern above or delete a link by removing the corresponding title and path. Section breaks are added by including a - title: section-break line. The left nav reflects the exact order of root.yml, so it's easy to organize it as needed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.54802,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Edit</em> the home page left <em>nav</em>",
        "body": "You can&#x27;t just hit the <em>edit</em> button <em>docs</em>.newrelic.com to make edits to the home page. The page that opens is index.js, the <em>file</em> that manages the parts of the home page, but not the content. It&#x27;s rare that you&#x27;ll need to make changes to this <em>file</em>. Most home page changes will be to add a new tile"
      },
      "id": "61ab480264441f9ef0927fb8"
    }
  ],
  "/docs/style-guide/writing-docs/processes-procedures/use-content-types-text-formats": [
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "835ddacc0acae04e05c8c2ddc694799819a7d696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-11-26T05:14:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.9222,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. <em>Procedures</em> are the same for both standard docs (&quot;basic pages&quot;) and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change"
      },
      "id": "61b35af428ccbca9318c6b13"
    },
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "9ec2ccd8a8509ab1b54273206e84f9571164c4f9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-11-26T05:13:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.91876,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Procedures</em>",
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>",
        "body": " describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original <em>tech</em> <em>writer</em> or docs site contributor"
      },
      "id": "61b35af4e7b9d2769c5a38f9"
    },
    {
      "sections": [
        "Delete a document",
        "Caution"
      ],
      "title": "Delete a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "2cd80eef8b60c58847511bbd58fd38abdac22d75",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/delete-document/",
      "published_at": "2021-12-10T13:48:54Z",
      "updated_at": "2021-11-26T05:12:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Caution When you delete a document, its content and its redirects will still be available in the GitHub commit history. In general, if you're not on the New Relic Docs team, please don't delete any docs. Instead, file an issue and someone on our team will help you out. If you are certain you want to delete a document, do this: Locate the mdx file of the doc you want to delete. Take care of redirects: Find the most relevant doc to redirect readers to. Add the deleted doc's URL as a redirect. Copy any existing redirects from the deleted doc and add them to the new doc. Delete the doc's title and path from the appropriate nav file. Delete the doc mdx file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.91727,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> <em>style</em> <em>guide</em>"
      },
      "id": "61ab47d9196a679242d10141"
    }
  ],
  "/docs/style-guide/writing-docs/writer-workflow/github-intro": [
    {
      "sections": [
        "SNMP device profiles",
        "Get started",
        "Tip",
        "Make requests through GitHub",
        "Contribute profiles and modifications publicly",
        "What kinds of OIDs should I actually include in a profile?",
        "Use custom profiles privately"
      ],
      "title": "SNMP device profiles",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "b4ab57f62e80e24dd95e80b68602bb4e7a86fad9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/snmp-profiles/",
      "published_at": "2021-12-10T10:56:20Z",
      "updated_at": "2021-12-10T10:56:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Profiles define what SNMP OIDs we want to collect and send to your New Relic account. This document explains how to modify an existing profile or create a new profile. Get started If you've decided to build a custom profile or modify one of our open source profiles, you need a few essential tools: A GitHub account: This enables you to raise issues and contribute changes to Kentik's open source profiles. An SNMP walk from a network device where you want to work on a profile. For more information, see our documentation on setting up SNMP and using snmpwalk. Permissions to perform Docker pull on the server that hosts your ktranslate container. This document covers: Making requests for new or modified profiles through GitHub to be worked on by the maintainers Contributing your own profiles and modifications publicly Using custom profiles privately Tip Support for all things relating to kentik/snmp-profiles is handled through GitHub issues. New Relic technical support is not able to provide any additional help beyond redirecting you back to raise an issue there. Make requests through GitHub This is the most common and simple scenario, for cases where you don't have the time or expertise with SNMP to do these yourself. After you provide the relevant data, our team will build the profile for you. Log into GitHub and go to the snmp-profiles repo. Click the Issues tab near the top. Click New issue. To request a new profile, look for the SNMP Profile Request section, and click Get started. Provide all requested information in the template, such as the device vendor, model, snmp object identifier, and a sanitized SNMP walk. For all other requests, use Open a blank issue. Tip Providing an SNMP walk is critical as we cannot do any work on the profile without these. This is not the same as an MIB file. The maintainers of the repo will review the information you provided and, if there is anything missing, they will follow up with you. Once all the necessary data is provided, they will add it to the queue of profiles to be built. After it is added to the repo, the issue will be closed, and all you have to do is update the ktranslate docker container on your end, and the newest profiles will automatically be loaded. Contribute profiles and modifications publicly We gladly accept contributions from anyone who wants to help out to either create new profiles or improve the existing profiles. To familiarize yourself with the structure of a profile, review this highly commented template.yml on GitHub. Log into GitHub and go to the snmp-profiles repo. To create a copy of the same information in your account, click the fork button near the top. Within your fork,make necessary changes to the files, or create new vendor directories and profiles as needed. Be sure to pass your profile through a YAML validator, such as codebeautify, before submitting a pull request. When you are done with your changes, submit a pull request to the upstream repo. The maintainers will review the change, and discuss any necessary feedback. When everyone is aligned, it will be merged. Shortly after a merge, new SNMP profiles are automatically available by pulling the new version of the Docker image and launching a new container in your environment. For more information, see our documentation about SNMP manual setup. Tip Be sure to sync your fork regularly to keep it up to date with changes in the upstream repo. What kinds of OIDs should I actually include in a profile? In many cases SNMP offers a lot of data, but much of that data does not provide actionable information. Or, the data provides value that is so uncommon and low impact, it might not be worth bringing into your New Relic account. You want to focus on collecting data that lets you know if there is anything that would stop the device from being able to perform whatever functions you expect it to perform. Building on from that, you should collect measurements that tell you how well it is performing those functions. Example 1: For a device operating as a VPN concentrator, we would collect high-level system metrics like: CPU and memory utilization Hardware sensor information to make sure that the device isn't going to shut itself down due to things like fan failures OIDs that tell us about the aggregated connections and throughput Example 2: An example of data that is available but provides very poor value is an OID table that lists all the running processes on a network appliance. Coming from a server admin perspective, that might sound useful, but since this is an appliance, you normally do not have the capability or the need to do anything with the processes that run inside it. Polling and storing tables with hundreds of items that you can't actually do anything with would not be efficient. Use custom profiles privately For cases where you want to make a change to a profile, but you know that it is a scenario that is very unique and would not apply to other customers you can locally edit the profiles. The way this is done is by using Docker's volume mount to pass in your customized files to the ktranslate container inside the etc/ktranslate/profiles/ directory. There are other ways you could accomplish this but in this example we will demonstrate using a git fork and clone. Ensure you are in the directory you want to keep the files in, then clone your fork of the GitHub repo to your Docker host: git clone https://github.com/<YourGitUser>/snmp-profiles.git Copy Get the command you would normally use to launch the SNMP container, and add a second volume mount argument after the one where we passed in the snmp-base.yaml. -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ Copy The mount command replaces the built-in profiles directory with your customized data. The end result will be be similar to this: docker run -ti --name ktranslate-discovery --rm --net=host \\ --user `id -u`:`id -g` \\ -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ kentik/ktranslate:v2 \\ -snmp /snmp-base.yaml \\ -log_level info \\ -snmp_discovery=true Copy Tip Be sure to pass your custom version of the profiles in every time you launch a discovery container or SNMP polling container. If you don't use it consistently for all SNMP instances sets, this can cause unreliable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.45734,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Make requests through <em>GitHub</em>",
        "body": " or expertise with SNMP to do these yourself. After you provide the relevant data, our team will build the profile for you. Log into <em>GitHub</em> and go to the snmp-profiles repo. Click the Issues tab near the top. Click New issue. To request a new profile, look for the SNMP Profile Request section, and click <em>Get</em>"
      },
      "id": "61b33254196a67414ea5c67b"
    },
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "d883a07b7ede4c3beaba4077c507b95f9a228435",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-12-09T22:04:44Z",
      "updated_at": "2021-12-04T21:44:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To learn more about our integrations built using our Telemetry SDKs, see Intro to open source telemetry integrations. For all monitoring solutions, see our New Relic Instant Observability.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.47198,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " to <em>get</em> library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on <em>GitHub</em> Metrics Events Logs Traces Node&#x2F;TypeScript NodeJS library"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/writer-workflow/github-troubleshooting/",
      "sections": [
        "GitHub troubleshooting",
        "GitHub authentication fails",
        "My build is failing mysteriously",
        "Diagnose markdown errors with yarn-verify",
        "Example: Troubleshoot with yarn-verify",
        "Issues with the local site",
        "Stop and restart yarn",
        "Ensure the problem isn't with your branch",
        "Clean your local cache",
        "Remove corrupted cache files",
        "Start a build from start",
        "Important",
        "Run your local build in private mode",
        "My redirect throws a 404 error when testing it locally",
        "A check fails in the PR",
        "Reset the 'build the docs site' build check",
        "Caution",
        "Troubleshoot merging conflicts",
        "What’s new related merge conflicts"
      ],
      "published_at": "2021-12-10T13:45:06Z",
      "title": "GitHub troubleshooting",
      "updated_at": "2021-12-04T10:44:53Z",
      "type": "docs",
      "external_id": "8ac23cfb3c3f1453d33e2082e46967a6f29cd508",
      "document_type": "page",
      "popularity": 1,
      "body": "Are you having problems working on a doc in GitHub? Check out the following common issues. GitHub authentication fails If you suddenly find that you can no longer push to your remote branch in GitHub Desktop, you may have developed a problem with SSH. If logging out of GitHub Desktop via Preferences doesn’t seem to help, you can confirm if you have an SSH issue by switching to the command line and trying to push manually. For example: git push --set-upstream origin second-kafka-pr-for-issue-1123 If this command prompts you for a passphrase, your SSH was somehow confused. By entering your passphrase, you should be back in business. If you can’t remember your passphrase, check out this article. My build is failing mysteriously Here’s a few things you can check if your build is failing: Indenting in the nav files Front matter If there's apostrophes and colons in frontmatter fields, surround them with quotes to avoid problems. Missing closed brackets or tags Poorly formatted image links Be careful when renaming images and their filename paths. A mismatch can cause the entire local build to fail. Be especially careful when dealing with image files that are imported. Image filenames Image filenames are case-sensitive. Using the wrong capitalization results in a missing image in the doc. Images with encoded values (like %) in the filename can be especially tricky, try to avoid them. Diagnose markdown errors with yarn-verify If you know which file is causing an error, you can further troubleshoot with the yarn verify-mdx path/to/file.mdx command. This command returns more information about the error than the normal Gatsby output. This includes things such as the specific character and line number causing the error. Example: Troubleshoot with yarn-verify Let's pretend I've made a changes to multiple docs in my branch. When I try to either run the site locally or access the Gatsby Cloud build, I get the following error: Unexpected character = (U+003D) before name, expected a character that can start a name, such as a letter, $, or _/usr/src/app/www/src/content/docs/new-relic-solutions/observability-maturity/uptime-performance-reliability/aqm-implementation-guide.mdx: Unexpected character = (U+003D) before name, expected a character that can start a name, such as a letter, $, or _ Copy The error does tell me that the doc with an error is /docs/new-relic-solutions/observability-maturity/uptime-performance-reliability/aqm-implementation-guide.mdx. Other than that, all I know is that there is a = character messing things up somewhere. Cool, but this is a NRQL doc, there are a dozens of = characters. So, I run yarn verify-mdx src/content/docs/new-relic-solutions/observability-maturity/uptime-performance-reliability/aqm-implementation-guide.mdx. This returns the following: reading src/content/docs/new-relic-solutions/observability-maturity/uptime-performance-reliability/aqm-implementation-guide.mdx { \"message\": \"Unexpected character `=` (U+003D) before name, expected a character that can start a name, such as a letter, `$`, or `_`\", \"name\": \"284:227\", \"reason\": \"Unexpected character `=` (U+003D) before name, expected a character that can start a name, such as a letter, `$`, or `_`\", \"line\": 284, \"column\": 227, \"location\": { \"start\": { \"line\": 284, \"column\": 227, \"offset\": 19129, \"index\": 1 }, \"end\": { \"line\": null, \"column\": null } }, \"source\": \"remark-mdx\", \"ruleId\": \"unexpected-character\", \"fatal\": true } [ Copy In this case, the relvant info is: \"line\": 284, \"column\": 227, Copy and \"source\": \"remark-mdx\", \"ruleId\": \"unexpected-character\", \"fatal\": true Copy This tells me that there is an unexpected character in line 284, column 227. Then I can go to that section of the doc and further troubleshoot, knowing exactly where the error comes from. In this case, I likely just need to wrap a NRQL example in quotes. Issues with the local site If you're running with issues with your local build, try these options: Stop and restart yarn In the terminal, ensure you're in the /docs-website directory. Hit CONTROL+C to interrupt the yarn process, if necessary. Run yarn && yarn start. Ensure the problem isn't with your branch In the terminal, ensure you're in the docs-website directory. Hit CONTROL+C to stop yarn, if necessary. In GitHub Desktop, commit any changes needed on your branch, and then switch to the Develop branch. Back in the terminal, run yarn && yarn start. If the site now builds correctly, the issue is with the changes in your branch. Stop Yarn again, go back to your branch, and troubleshoot. Clean your local cache Run yarn clean to blow away your local cache. This will make your next build slower, so make sure you have time! In the terminal, ensure you're in the docs-website directory. Hit CONTROL+C to stop yarn, if necessary. Begin a new build by running yarn clean && yarn && yarn start. Remove corrupted cache files There may be times when your .cache directory has been corrupted. This directory is ignored by Git, which means that it travels with you from branch to branch. This might be the problem if your local builds are failing regardless of which branch you’re on. To solve this from your /docs-website directory, run rm -rf .cache. Start a build from start Blow away all your node modules, hidden .cache folder, and local cache and start a build from scratch. This takes a long time to run, around 10–20 minutes. In the terminal, ensure you're in the docs-website directory. Hit CONTROL+C to stop yarn, if necessary. Blow away modules and cache and start from scratch by running the kknuke Keyboard Maestro command, or run yarn reboot in your terminal. Important If you use the kknuke Keyboard Maestro command, when everything completes, start the site by running yarn start. Run your local build in private mode Sometimes the local site builds, but pages within the site don't. Running the local build in a private/incognito session may to fix this issue. You can also try clearing out your browser's cache. My redirect throws a 404 error when testing it locally Redirects are a bit strange on local builds. To test them, navigate to the page that is being redirected, wait until it throws a 404, and then wait ~1-2 minutes. It should redirect you after a while. If it doesn’t, ensure you set up the redirect correctly. You can also test the redirects out in the Gatsby build. A check fails in the PR Important The only checks needed to merge a PR are the checks marked as required on the PR. These are run linter, run tests, license/cla, and unpaired translations removed for merges to develop, and build the docs site for merges to main. If a required check fails, the failure must be addressed in order for the PR to be merged. If an optional check fails, reach out in the help channel so that the hero can look into the failure, but feel free to merge the PR since optional checks don't block releases. Rarely, a build or check will fail due to some internal error. You can re-run the check by going to the PR, clicking Details, and then clicking Re-run jobs. If that doesn't fix it, you probably have genuine build errors. Pull down locally and troubleshoot. Reset the 'build the docs site' build check Caution This adds a LOT of time to the build check. There are times when this check fails. If this happens after your local builds have built successfully, you may need to force a rebuild of the cache. In your local repo, find the file gatsby-config.js (use CMD-P to jump to it fast in VSCode). Swap the first and second line of code. It doesn’t matter what order these lines are in, except to make the Gatsby Build check rebuild the cache. const fs = require('fs'); const parse = require('rehype-parse'); Save the file and commit the change to your PR. Re-run the build checks. Wait a LOOOOONG time. Troubleshoot merging conflicts Merge conflicts can seem pretty scary, but it’s ultimately just deciding between two different versions of a doc. Here are some tips on how to get through it. Fix your merge conflict as soon as possible. Especially if you’re working on taxonomy changes. If your branch lingers for a while it can get outdated from develop pretty fast and that can cause some unexpected issues. Check your fix locally to make sure that it looks good there. Ask your PR approver to review your PR after you fix the merge conflict. Here are two options to resolve conflicts: When you see the conflicts in GitHub desktop, click the option to resolve these in VS Code. Use the GitHub website editor (click the Resolve conflict button) to fix these. What’s new related merge conflicts Merge conflicts pop up pretty often with what’s new posts because the whats-new-ids.json file that’s automatically updated when the site builds can get out-of-date pretty fast. If you see changes to this file show up in GitHub Desktop, make sure to discard them, rather than push them up to your branch. This will make it less likely that other people will have to deal with merge conflicts related to this file. Caution Never merge a PR that changes whats-new-ids.json.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.83893,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>GitHub</em> troubleshooting",
        "sections": "<em>GitHub</em> troubleshooting",
        "body": " automatically updated when the site builds can <em>get</em> out-of-date pretty fast. If you see changes to this file show up in <em>GitHub</em> Desktop, make sure to discard them, rather than push them up to your branch. This will make it less likely that other people will have to deal with merge conflicts related to this file. Caution Never merge a PR that changes whats-new-ids.json."
      },
      "id": "61a9ebd264441f22bd9286ae"
    }
  ],
  "/docs/style-guide/writing-docs/writer-workflow/github-troubleshooting": [
    {
      "sections": [
        "Diagnostics CLI (nrdiag)",
        "Compatibility",
        "Get started"
      ],
      "title": "Diagnostics CLI (nrdiag)",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Diagnostics CLI (nrdiag)"
      ],
      "external_id": "973501f4752e56caf3d68e37bf21b823d0e42078",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/diagnostics-cli-nrdiag/diagnostics-cli-nrdiag/",
      "published_at": "2021-12-09T21:19:55Z",
      "updated_at": "2021-10-25T16:26:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Download latest version The Diagnostics CLI (nrdiag) is a utility that automatically detects common problems with New Relic products. If the Diagnostics CLI detects a problem, it suggests troubleshooting steps. The Diagnostics CLI can automatically upload troubleshooting data to a New Relic account. The Diagnostics CLI is open source and is located in GitHub. For additional troubleshooting steps for your agent, check out Not seeing data. Here's an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped troubleshooting logs that are ready to be attached to support tickets. Compatibility The Diagnostics CLI is available for Linux, macOS, and Windows. It can detect common configuration issues for: APM: Available for all APM agents except C SDK. For the Go agent, only basic connectivity checks are available. Browser monitoring: Browser agent detection Infrastructure monitoring: Linux and Windows agents Mobile agents: iOS and Android Synthetic monitoring: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those permissions for some checks. It will return an error if it does not have permissions to read the files it scans. Get started To use the Diagnostics CLI: Run the Diagnostics CLI, including task suites and command line options as needed. Supply the -attach flag for uploading results to your New Relic account. Optional: Validate your config file settings. Interpret the output. Like any other New Relic tool, the Diagnostics CLI service is designed to protect you and your customers' data privacy. For detailed information, see our Diagnostics CLI licensing and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 647.4351,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ". The Diagnostics CLI is open source and is located in <em>GitHub</em>. For additional <em>troubleshooting</em> steps for your agent, check out Not seeing data. Here&#x27;s an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped"
      },
      "id": "604469f8e7b9d2abb65799f0"
    },
    {
      "sections": [
        "SNMP device profiles",
        "Get started",
        "Tip",
        "Make requests through GitHub",
        "Contribute profiles and modifications publicly",
        "What kinds of OIDs should I actually include in a profile?",
        "Use custom profiles privately"
      ],
      "title": "SNMP device profiles",
      "type": "docs",
      "tags": [
        "Integrations",
        "Network performance monitoring",
        "Advanced configuration"
      ],
      "external_id": "b4ab57f62e80e24dd95e80b68602bb4e7a86fad9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/network-performance-monitoring/setup-performance-monitoring/snmp-profiles/",
      "published_at": "2021-12-10T10:56:20Z",
      "updated_at": "2021-12-10T10:56:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Profiles define what SNMP OIDs we want to collect and send to your New Relic account. This document explains how to modify an existing profile or create a new profile. Get started If you've decided to build a custom profile or modify one of our open source profiles, you need a few essential tools: A GitHub account: This enables you to raise issues and contribute changes to Kentik's open source profiles. An SNMP walk from a network device where you want to work on a profile. For more information, see our documentation on setting up SNMP and using snmpwalk. Permissions to perform Docker pull on the server that hosts your ktranslate container. This document covers: Making requests for new or modified profiles through GitHub to be worked on by the maintainers Contributing your own profiles and modifications publicly Using custom profiles privately Tip Support for all things relating to kentik/snmp-profiles is handled through GitHub issues. New Relic technical support is not able to provide any additional help beyond redirecting you back to raise an issue there. Make requests through GitHub This is the most common and simple scenario, for cases where you don't have the time or expertise with SNMP to do these yourself. After you provide the relevant data, our team will build the profile for you. Log into GitHub and go to the snmp-profiles repo. Click the Issues tab near the top. Click New issue. To request a new profile, look for the SNMP Profile Request section, and click Get started. Provide all requested information in the template, such as the device vendor, model, snmp object identifier, and a sanitized SNMP walk. For all other requests, use Open a blank issue. Tip Providing an SNMP walk is critical as we cannot do any work on the profile without these. This is not the same as an MIB file. The maintainers of the repo will review the information you provided and, if there is anything missing, they will follow up with you. Once all the necessary data is provided, they will add it to the queue of profiles to be built. After it is added to the repo, the issue will be closed, and all you have to do is update the ktranslate docker container on your end, and the newest profiles will automatically be loaded. Contribute profiles and modifications publicly We gladly accept contributions from anyone who wants to help out to either create new profiles or improve the existing profiles. To familiarize yourself with the structure of a profile, review this highly commented template.yml on GitHub. Log into GitHub and go to the snmp-profiles repo. To create a copy of the same information in your account, click the fork button near the top. Within your fork,make necessary changes to the files, or create new vendor directories and profiles as needed. Be sure to pass your profile through a YAML validator, such as codebeautify, before submitting a pull request. When you are done with your changes, submit a pull request to the upstream repo. The maintainers will review the change, and discuss any necessary feedback. When everyone is aligned, it will be merged. Shortly after a merge, new SNMP profiles are automatically available by pulling the new version of the Docker image and launching a new container in your environment. For more information, see our documentation about SNMP manual setup. Tip Be sure to sync your fork regularly to keep it up to date with changes in the upstream repo. What kinds of OIDs should I actually include in a profile? In many cases SNMP offers a lot of data, but much of that data does not provide actionable information. Or, the data provides value that is so uncommon and low impact, it might not be worth bringing into your New Relic account. You want to focus on collecting data that lets you know if there is anything that would stop the device from being able to perform whatever functions you expect it to perform. Building on from that, you should collect measurements that tell you how well it is performing those functions. Example 1: For a device operating as a VPN concentrator, we would collect high-level system metrics like: CPU and memory utilization Hardware sensor information to make sure that the device isn't going to shut itself down due to things like fan failures OIDs that tell us about the aggregated connections and throughput Example 2: An example of data that is available but provides very poor value is an OID table that lists all the running processes on a network appliance. Coming from a server admin perspective, that might sound useful, but since this is an appliance, you normally do not have the capability or the need to do anything with the processes that run inside it. Polling and storing tables with hundreds of items that you can't actually do anything with would not be efficient. Use custom profiles privately For cases where you want to make a change to a profile, but you know that it is a scenario that is very unique and would not apply to other customers you can locally edit the profiles. The way this is done is by using Docker's volume mount to pass in your customized files to the ktranslate container inside the etc/ktranslate/profiles/ directory. There are other ways you could accomplish this but in this example we will demonstrate using a git fork and clone. Ensure you are in the directory you want to keep the files in, then clone your fork of the GitHub repo to your Docker host: git clone https://github.com/<YourGitUser>/snmp-profiles.git Copy Get the command you would normally use to launch the SNMP container, and add a second volume mount argument after the one where we passed in the snmp-base.yaml. -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ Copy The mount command replaces the built-in profiles directory with your customized data. The end result will be be similar to this: docker run -ti --name ktranslate-discovery --rm --net=host \\ --user `id -u`:`id -g` \\ -v `pwd`/snmp-base.yaml:/snmp-base.yaml \\ -v `pwd`/snmp-profiles/profiles:/etc/ktranslate/profiles \\ kentik/ktranslate:v2 \\ -snmp /snmp-base.yaml \\ -log_level info \\ -snmp_discovery=true Copy Tip Be sure to pass your custom version of the profiles in every time you launch a discovery container or SNMP polling container. If you don't use it consistently for all SNMP instances sets, this can cause unreliable behavior.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.36362,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Make requests through <em>GitHub</em>",
        "body": ": A <em>GitHub</em> account: This enables you to raise issues and contribute changes to Kentik&#x27;s open source profiles. An SNMP walk from a network device where you want to work on a profile. For more information, see our documentation on setting up SNMP and using snmpwalk. Permissions to perform Docker pull"
      },
      "id": "61b33254196a67414ea5c67b"
    },
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "d883a07b7ede4c3beaba4077c507b95f9a228435",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-12-09T22:04:44Z",
      "updated_at": "2021-12-04T21:44:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To learn more about our integrations built using our Telemetry SDKs, see Intro to open source telemetry integrations. For all monitoring solutions, see our New Relic Instant Observability.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.42975,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " key, so you&#x27;ll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on <em>GitHub</em>. Use the language-specific <em>GitHub</em> links below"
      },
      "id": "603ea196196a670192a83d83"
    }
  ],
  "/docs/style-guide/writing-docs/writer-workflow/peer-editor-workflow": [
    {
      "image": "https://docs.newrelic.com/static/aa5797a9c6aaadf52a7bac18b3ac8e83/c1b63/dealing_with_interrupts.png",
      "url": "https://docs.newrelic.com/docs/agile-handbook/sprint-mechanics/sprint-workflow-and-jira-boards/",
      "sections": [
        "Sprint workflow",
        "Planned work",
        "Unplanned work (surprises!)",
        "Jira boards: Backlog and future sprints",
        "Jira boards: Current sprint",
        "Proposed",
        "In Progress",
        "Needs Peer Editor",
        "In Peer Edit",
        "Peer Edit Done",
        "Blocked",
        "Done",
        "Incomplete (\"carry-over\") tickets",
        "Tip"
      ],
      "published_at": "2021-12-10T06:25:34Z",
      "title": "Sprint workflow",
      "updated_at": "2021-11-06T12:49:01Z",
      "type": "docs",
      "external_id": "e18dcb23b9a43a083a2c4496d6fb9a20b9efc496",
      "document_type": "page",
      "popularity": 1,
      "body": "All of our sprint work is tracked in Jira. The workflow depends on what type of work we're dealing with: Planned or unplanned (\"surprise!\") work. Planned work Planned work includes all work that is currently in our backlog or has been added to the current sprint as a result of a Sprint Planning session. This could include writing or updating documentation, research, meeting with SMEs, information architecture, incorporating peer edits, SME review, and so on. Unplanned work (surprises!) Usually, we get notified of major requests far enough in advance that we can include them in liaison project plans, backlog grooming, and sprint planning. Occasionally, something bigger surprises us that needs emergency support. Follow this process with new docs asks to assess the scope of work and ensure we address valid docs needs within a reasonable amount of time. Our goal is to treat the sprint as sacred and insulate against \"surprise\" work that is not absolutely crucial. But we also want to ensure we're providing good internal customer service, and not getting hung up on process niceties for things that are small. Jira boards: Backlog and future sprints This is where the vast majority of tickets spend their time. Most tickets (even for active projects) spend at least a little time here before moving into a sprint to be actively worked. Being in the backlog doesn't mean something isn't important---just that we haven't committed to it yet.  You can also add tickets straight to a future sprint. This is where tickets tentatively assigned to a future sprint will be found. Tickets can be assigned here to be held for backlog grooming and sprint planning.  Jira boards: Current sprint Proposed This step is for work that has been assigned to the current sprint during Sprint Planning and is available to be picked up by a tech writer. When you're ready to take on a new ticket, try to work the queue from the top-down and avoid cherry picking. It's also better to pick up Needs Peer Edit tickets before committing to a new ticket. Something that needs a peer edit is close to done, and helping things across the finish line helps get value into users hands, and frees us up to think about new problems. In Progress This step is for all of the work to be done by the assignee: Research, meeting with SMEs, information architecture, writing, incorporating peer edits, SME review, and so on. Tickets are moved to this step once work is started by the TW, and remain here until the work is either complete, ready for peer review, or it becomes blocked. If additional large edits are needed after the peer review, the ticket can be moved back to In Progress for those edits. Needs Peer Editor Work that is ready for a peer edit. Once a peer editor picks it up, they move it into In Peer Edit. In Peer Edit This step is for a peer editor to review docs before they go live. Follow the Peer editor workflow, then move the ticket into Peer Edit Done.  Peer Edit Done This step is a holding state once peer editing is complete. After completing their peer edit and delivering their feedback, the peer editor moves the ticket into Peer Edit Done. From there, the assignee on the ticket (not the peer editor) moves the ticket into the appropriate column (In Progress, Blocked, or Closed). Minor edits can be completed from this column but for major doc rework, the ticket should be moved back into the In Progress column. Blocked This step is for tickets that cannot be moved forward by the team. This could be because we're waiting for a response from a SME, or for a feature to deploy, or for final signoff. The team keeps an eye on this column for tickets that may need escalation. Putting something in Blocked rather than In Progress lets us see the status of every ticket at a glance. This column can also be used for extended time out of the office for the assigned writer, if it's work that can be safely held. (If the work cannot be held while you're out, find another writer to step in and take over.) Once you're un-blocked, move the ticket to the appropriate column. If the ticket remains blocked at the end of the current sprint, it will need to be re-reviewed during backlog grooming to determine if the ticket will carry-over into the upcoming sprint, or return to the backlog until a future sprint. Done This step is for work that is 100% finished. Work gets cleared out this column before we start a new sprint. Incomplete (\"carry-over\") tickets Ticket don't carry over automatically between sprints. Instead, any ticket that gets carried over is treated as a \"new\" ticket in the next sprint planning. Before sprint planning, review any open tickets in the board that are assigned to you and figure out what to do with them. For each open ticket assigned to you (or \"carry over\"), decide if you should: Recommended: Clone the ticket and close the old one. This is the best option for partially completed work because it makes metrics easier. If you do: Clone the ticket. Note why we closed the ticket. Add an estimate of points completed in the Points Completed field. Create a follow-up ticket if necessary. Move the ticket to the next sprint. If you do: Review the ticket's action items and description to make sure they're still current. Clear out the ticket points. Move the ticket back to the backlog. If you do: Update the action items and description to make sure they're still current. Note why we moved to the backlog rather than carry over. ← Planning poker Liaisonships → Tip We welcome thoughts or questions on our handbook! The easiest way to get in touch is to file a GitHub issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 773.98486,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Sprint <em>workflow</em>",
        "sections": "Needs <em>Peer</em> <em>Editor</em>",
        "body": " that is ready for a <em>peer</em> edit. Once a <em>peer</em> <em>editor</em> picks it up, they move it into In <em>Peer</em> Edit. In <em>Peer</em> Edit This step is for a <em>peer</em> <em>editor</em> to review docs before they go live. Follow the <em>Peer</em> <em>editor</em> <em>workflow</em>, then move the ticket into <em>Peer</em> Edit Done.  <em>Peer</em> Edit Done This step is a holding state once"
      },
      "id": "616c0dc0196a67e6583c8164"
    },
    {
      "sections": [
        "Troubleshooting docs guide",
        "Problem",
        "Solution",
        "Cause",
        "Related info"
      ],
      "title": "Troubleshooting docs guide",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "55f439b9842d1f5df9e5ce1b06a5c5d9ae7829f6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/troubleshooting-docs-guide/",
      "published_at": "2021-12-10T14:17:51Z",
      "updated_at": "2021-11-25T11:25:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our troubleshooting docs have these main sections: problem, solution, and (optionally) cause. Otherwise, a troubleshooting doc uses the basic doc template Problem Generally, this is the who, what, when, and where of the troubleshooting doc. Provide a clear, concise description of the problem the user is trying to solve. Include steps for reproduction, symptoms, and other key points when applicable. Re-state the problem in different ways if needed, to ensure customers can find this doc via Google. If the problem text is very short, you can include the cause text here. Solution Generally, this is the how of the troubleshooting doc. Provide an ordered list of steps to guide users through the solution. If there are multiple causes and solutions, consider creating a standard, basic page doc rather than using the troubleshooting template. Consider the best approach to help the reader, and discuss your reasoning with your peer editor. If the issue you are documenting is more of a known issue (FYI in nature), or if it doesn't solve the issue: Incorporate the information into other relevant docs. Do not refer to it as a known issue. OR Create a troubleshooting doc that describes the problem and cause. Do not include a solution. Also, include any statements promising that the issue will be fixed in a future release. Cause Generally, this is the why of the troubleshooting doc, and is optional. The Cause section is particularly useful when the product works in an unintuitive way. Provide background information or context that gives the user additional insight into the problem. If the problem and the cause text are both very short, you can include the cause in the Problem section. Related info In general, leave blank. The standard For more help footer block will appear automatically when published. If necessary, use this section to link to other, related docs if it does not make sense to refer to them within the context of other information in the troubleshooting doc itself.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.520706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", and discuss your reasoning with your <em>peer</em> <em>editor</em>. If the issue you are documenting is more of a known issue (FYI in nature), or if it doesn&#x27;t solve the issue: Incorporate the information into other relevant docs. Do not refer to it as a known issue. OR Create a troubleshooting doc that describes"
      },
      "id": "61ab4826e7b9d293010e7a46"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/writer-workflow/github-intro/",
      "sections": [
        "Get around GitHub",
        "Who is who in an issue/PR?",
        "Track issues in the board",
        "Deal with references in GitHub (and the style guide)",
        "Merge releases into main work (or, when do we publish?)",
        "GitHub labels",
        "Check the edit history of a doc or file",
        "Docs site history before October 2021"
      ],
      "published_at": "2021-12-10T13:50:16Z",
      "title": "Get around GitHub",
      "updated_at": "2021-12-04T10:48:34Z",
      "type": "docs",
      "external_id": "539ae5620ae9be8f8c3752fd3eda664186fbb5c4",
      "document_type": "page",
      "popularity": 1,
      "body": "As tech doc writers (TW) we edit docs, do peer edits, or use the Docs Team GitHub board to track the status of issues and pull requests (PR). Who is who in an issue/PR? GitHub keeps track of all activity concerning an issue or PR, including, of course, the people involved. When a new issue or PR is filed, check on the filer’s username and see if they're listed as a member of the New Relic organization. If they aren't, try to find them on Slack based on their username. If you're not sure about someone's affiliation, treat them as external until you know otherwise. People in an issue/PR include: Creator: The person who opened the issue or PR. This could be a writer, a Relic, or an external user. We'll label the issue or PR differently depending on who created it. If you're not sure if a user is a Relic, a good trick is to click on their profile and see if they're a member of the New Relic GitHub org. Assignee: The person taking responsibility for a PR or issue. This will usually be used by the Hero or Sidekick to assign non-TW PRs and issues to themselves. It can also be used to take a TW’s PR or issue over from them. Reviewer: The person who reviews or peer edits the code/document and approves the changes. Not necessarily the person responsible for that area or responsible for merging the commit. You can pre-assign up to 100 reviewers to a given issue. Track issues in the board The docs board has the following columns: Column Description Needs triage The Hero or Sidekick review and label issues and PRs in this column, then drag them to the appropriate column. If a PR or issue is labeled eng, the Hero/Sidekick can go ahead and click its ellipses icon to archive it. Hero: to do PRs that the Hero needs to review, publish, and follow up with SMEs as needed. Hero: Assign yourself as Assignee. In review (Hero or any TW) Drag PRs to this column when they are being reviewed. This shows who is reviewing and what is being reviewed, so two writers don’t mistakenly work on the same PR. Any TW: Writer needs PR review PRs from Tech Docs team members that need a light edit pass to make sure everything in GitHub is correct. This should be checked by other writers every few hours so PRs don’t get stale. If you have a PR that’s been lingering here too long, ask for a reviewer in #doc_sprint_talk. Whoever takes it: assign yourself as Reviewer. Any TW: needs peer edit Like our Needs Peer Edit column in Jira: A writer has requested a review of their PR. Review their PR in GitHub and leave comments. Whoever takes it: assign yourself as Reviewer. Waiting on SME/Blocked For PRs that are blocked by need for SME info or confirmation (for example, as Hero you are waiting on an answer from the person who sent in a Hero pull request). Waiting on TW to merge All reviews are complete. The TW who created the PR (or who is assigned the issue) needs to merge this work into develop. Drafts A draft is a way to open a PR while indicating that the work is still in progress and not necessarily ready to merge immediately. You can't merge a Draft PR directly. Instead, you must move it out of draft status first. When you see a draft PR (especially from outside the team!), treat it as though it's a working draft, and reach out to the creator to discuss. Read more on GitHub's drafts. As a Hero, make sure you attend to the following throughout your day: Check in with the previous Hero at the start of your day (especially on Monday at the start of the week). Don’t forget to sync with the BCN Hero if necessary. Watch for incoming PRs in #docs_deploys, and review everything in the Needs triage column. Drag cards from that column to the appropriate column. Work through the cards in the Hero: to do column. Everyone on the team helps keep things moving: All writers should keep an eye on both Any TW columns. There's one column for PRs that need a simpler review before merging (typo fixes, drive-by edits, etc), and another column for PRs that need a peer edit. There are also two blocked columns: One for PRs blocked on a SME, and another column where we're waiting on the TW who created the PR to review feedback and/or merge. After merging, remove your ticket from the board. Deal with references in GitHub (and the style guide) Don't link to anything non-public from a public place. You can reference Jira tickets, but reference tickets by issue key (DOC-1234 is ok) rather than a link (https://newrelic.atlassian.net/browse/DOC-1234 is not). Don't mention traffic or usage numbers publicly. Don't reference internal people by name. If they have a GH account, @mention their GH handle. If they don't, talk instead about teams (\"talk to a browser team engineer\" or \"Support Engineer\") rather than people. You can mention the #documentation channel and hero. Merge releases into main work (or, when do we publish?) The Hero currently merges three times a day: At 9 AM (morning), 12 PM (noon), and 3 PM (evening) Pacific. We merge release branches into main to avoid interuptions when someone merges into develop during a release. To learn more about this workflow, see the gitflow documentation in Atlassian. To start a release: Create a branch based off develop Github Desktop by clicking Current Branch in the top header, clicking New Branch in the dropdown, and then selecting Develop. Name the branch following this pattern: daily-release/mm-dd-yy-morning/noon/evening. Here's an example: daily-release/10-27-21-morning. Push your changes by clicking Push Origin in GitHub Desktop. Create a pull request into main from your new daily release branch by clicking Create Pull Request. This will open a pull request screen on github.com. Pull requests default to merging into develop, so select main as the base branch in the left side of the page and then click Submit Pull Request. Wait until all the checks complete, and then merge the pull request. All branches that follow the daily-release/mm-dd-yy-morning pattern are protected branches. This means the branches can't be deleted or pushed to by non-admins. GitHub labels Every issue needs labels to help us triage and track the health of our backlog: content: Always add, this indicates the issue is content-related rather than a design or engineering issue. pg_*: Always add to indicate the product group. For full definitions, see the \"Doc Jira and GitHub fields\" doc in the internal team Google Drive. Indicate who created the issue: from_internal: A Relic created it. from_external: A user opened it in the repo OR it came in through #customer-feedback process. from_tw: One of us created it (unless we were passing along #customer-feedback). Optionally: docs-issues-migrate: Issues that are too large in scope for the docs team to handle without product team expertise. This label alerts the docs issues team to migrate these issues into the customer feedback channel where they will be triaged and sent to product teams. Jira’d: Issues that have a corresponding Jira ticket. Make sure you leave the Jira number in the comments of the issue (for example, DOC-1234). Every pull request needs these labels so we can see where our contributions come from: content: Always add, this indicates the PR is content-related rather than design or engineering. Indicate who created the pull request: from_internal: A Relic created it. from_external: A user opened it in the repo OR it came in through #customer-feedback process. from_tw: One of us created it (unless we were passing along #customer-feedback). If the PR fixes an external issue, label it as from_tw since the work was done by a tech writer. Check the edit history of a doc or file Use any of these options to check or \"diff\" the history of a file. Option 1: GitHub history tab Navigate to the doc on the doc site and click Edit page in the right nav. Click History in the top right corner of the doc. Option 2: githistory.xy Navigate to your specific file on GitHub.com: https://github.com/newrelic/docs-website/blob/develop/src/content/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action.mdx Copy In the url, replace github.com with github.githistory.xyz: https://github.githistory.xyz/newrelic/docs-website/blob/develop/src/content/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action.mdx Copy It will take you to a site which presents the visual history of that specific file. You can view changes by clicking through the commit history at the top of your page. Option 3: Git blame Follow GitHub's documentation. Alternatively, you can use the following command in your terminal: git log --follow \"**/file_name_here.mdx\" Copy This will output the commit history of that file. By default, it only shows the first few commits. You can scroll by pressing Return multiple times. For example, to find the commit history for vmware-vsphere-monitoring-integration.mdx, I would run: git log --follow \"**/vmware-vsphere-monitoring-integration.mdx\" Copy Docs site history before October 2021 We had a large site restructure in October 2021 which lost most of the file history for our docs. You can find an archived version of our site pre-rework in the pre-IA-2021 branch. By navigating the pre-rework version of our repo, you can find file history and more.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.50157,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "As tech doc writers (TW) we edit docs, do <em>peer</em> edits, or use the Docs Team GitHub board to track the status of issues and pull requests (PR). Who is who in an issue&#x2F;PR? GitHub keeps track of all activity concerning an issue or PR, including, of course, the people involved. When a new issue or PR"
      },
      "id": "61ab4782196a672667d0efa1"
    }
  ],
  "/docs/style-guide/writing-docs/writer-workflow/tech-writer-workflow": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/writer-workflow/peer-editor-workflow/",
      "sections": [
        "Peer editor workflow",
        "Peer editing workflow in GitHub",
        "Developmental edit pass",
        "Copy edit workflow"
      ],
      "published_at": "2021-12-10T13:41:20Z",
      "title": "Peer editor workflow",
      "updated_at": "2021-11-26T05:18:04Z",
      "type": "docs",
      "external_id": "2445f390d928b9af124196fb5aaed74597083b36",
      "document_type": "page",
      "popularity": 1,
      "body": "Use this document to learn how to review and peer edit docs for you fellow writers in GitHub. Check the Tech Writer workflow doc for info on how to set up your local environment. To troubleshoot GitHub issues, see our guide. Peer editing workflow in GitHub If you’re peer editing a doc or have been otherwise assigned to a PR as a reviewer, you have a few choices for how and where to do the work. The most streamlined and open-source approach is to do the edit using GitHub options, rather than copying the file to Google Docs and editing there. Developmental edit pass For cases where you have questions and suggestions rather than straight copy edits, follow these steps. Open the PR that you’re assigned to review. On the Files changed tab, you can either: Click Review changes and then select one of the following: Comment - use if you have a comment that doesn’t require follow up. Approve - use if you just want to approve the PR. You can request changes in the Leave a comment area, and select Approve if you want to let the writer make the edits and merge the file without a follow-up review from you. Request changes - use for times when you want to make sure the changes you request are included. You’ll be notified with any updates that the writer makes. OR, start making comments on lines or sections of the doc. To do this, click the add comment icon , and leave an edit or comment for that specific line in the page. With this option, you get the choice between adding a single comment or starting a review. If you’re going to make comments throughout a doc, choose Start a review so the comments will all be rolled into one commit. Click Finish your review to complete your review. This triggers a notification to the writer alerting them that you’ve made suggestions. Copy edit workflow If you have copy edits for a file rather than comments and suggestions, you can make the changes to the file in different ways. Here are two main options: Edit using the GitHub browser: On the Files changed tab, in the diff window click the editing button (three dots). When you finish your edits, add a comment at the bottom of the file and choose to either commit the changes directly, or create a branch and start a pull request. Choose to branch and start a pull request if you expect a writer to review the diff and accept or revise your edits. Edit locally: Check out the branch containing the file you want to edit. In GitHub Desktop, click the Current branch down arrow and select the branch. Then, make the edits on your local drive, save, and commit your changes to the branch. Note that this approach adds your edits to the open pull request. You can now see the changes you added to the file on the Files changed tab in the PR. These are just a few of many editing options. You’ll find your preferred way, just as with any other tool.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1128.9402,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Peer editor <em>workflow</em>",
        "sections": "Peer editor <em>workflow</em>",
        "body": "Use this document to learn how to review and peer edit docs for you fellow writers in GitHub. Check the <em>Tech</em> <em>Writer</em> <em>workflow</em> doc for info on how to set up your local environment. To troubleshoot GitHub issues, see our guide. Peer editing <em>workflow</em> in GitHub If you’re peer editing a doc or have been"
      },
      "id": "61b35900196a67bd1da5b38b"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/create-edit-content/",
      "sections": [
        "Create and edit content",
        "Edit a doc",
        "Create new docs",
        "Clone (copy) an existing doc",
        "For bigger projects",
        "Delete pages",
        "Private edits",
        "Request a future publication date (for New Relic employees)"
      ],
      "published_at": "2021-12-10T13:48:07Z",
      "title": "Create and edit content",
      "updated_at": "2021-11-26T09:11:58Z",
      "type": "docs",
      "external_id": "aa49bd1d71b168fd3da1eaaf781f230c6e603a81",
      "document_type": "page",
      "popularity": 1,
      "body": "We welcome your contributions, whether you are a New Relic employee or a New Relic user! And we don't want you to worry about style. When you edit a file, tech writers on our team review it for style, grammar, and formatting. That said, if you're curious about our style guidelines, you're welcome (but not obligated) to take a look. Edit a doc If you see a minor problem in our documentation that you want to quickly fix, you can use GitHub to edit the file and submit your pull request. A member of the Docs team will review your edit and publish your changes. We'll follow up with you if we have any questions. To edit existing content without building the site locally: On the docs site, navigate to the doc you'd like to edit. Click Edit page on the top corner of the right nav. A GitHub page will open with the source of the doc. Click the pencil icon in the top right. Make your edits (don't worry too much about formatting or grammar, we're happy to take care of that). At the bottom of the page, enter a commit message that describes your change, then click Commit changes. Follow the prompts to submit your pull request. A member of the Docs team will review your pull request and comment with any feedback. Once we've merged your pull request into the Develop branch, your changes will go live with our next deploy (usually within a few hours). Create new docs You can use article templates or clone an existing doc as a template. To create a new doc: Clone the repo on your computer. In /src/content/docs/, find a good location for your doc. Using your text editor, create a new .mdx file or copy an existing doc. Write your content. Optional: Add your doc to the right nav .yml file. The navigation files can be a bit hard to work with, so feel free to leave this step for a Docs writer to handle when they review your pull request. Commit your changes and create a pull request. The Tech Docs team has two heroes watching for new pull requests. We'll help you get the content finalized and make sure that it's in the right place. Clone (copy) an existing doc Once you've cloned the docs-website repository, use your text editor to copy an existing doc. Rename and edit the copy and then save it as a new doc. Your cloned doc automatically inherits the original doc's frontmatter content. Make sure to change that, too. If you want your cloned doc to be translated, follow standard procedures to request translation. For bigger projects If you're making larger changes like adding a whole new doc or editing many existing docs, it can be helpful to run the site locally. For instructions, see Tech writer workflow. Delete pages If you are comfortable with deleting the page yourself, go for it. If not, ask us by: File an issue in the docs-website repo, or contact the @hero in the #documentation channel if you're a New Relic employee. We'll take a look at your issue and help out. Private edits If you need to stage content for a private beta or limited release, contact the docs hero in the #documentation Slack channel. Request a future publication date (for New Relic employees) If your draft needs to be released on a specific date or within a specific timeframe (for example, right before a release), contact the Tech Docs @hero in the #documentation Slack channel. If you're not a New Relic employee, please create a GitHub issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1110.5035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " procedures to request translation. For bigger projects If you&#x27;re making larger changes like adding a whole new doc or editing many existing docs, it can be helpful to run the site locally. For instructions, see <em>Tech</em> <em>writer</em> <em>workflow</em>. Delete pages If you are comfortable with deleting the page yourself, go"
      },
      "id": "61b35a97196a67b744a5b860"
    },
    {
      "sections": [
        "apiStyleGuidelines (Example agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Return values",
        "Examples",
        "URL guidelines",
        "Title guidelines",
        "Short title guidelines",
        "Syntax guidelines",
        "Important"
      ],
      "title": "apiStyleGuidelines (Example agent API)",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "API writing guidelines"
      ],
      "external_id": "fb967e77ea9a94d7a35329c0c87062ff93ab2ff8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/article-templates/apistyleguidelines-example-agent-api/",
      "published_at": "2021-12-10T13:34:04Z",
      "updated_at": "2021-11-26T09:14:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.apiStyleGuidelines(data type $parameter_name[, integer $optional_param]) newrelic.apiStyleGuidelines(data type $parameter_name, array $different_param, string $third_param) Copy Briefly describe the call. Ideally, one line or less on the \"View all methods\" page. Requirements Agent version 1.2.3.4 or higher. Additional requirements on their own line (do not use bullets). Do not use any callouts. If there are no special requirements, write: Compatible with all agent versions. Description Describe the behavior of the call with as much detail as possible. Do not describe what individual parameters do except in broad strokes; details of parameters and call variants belong under the Parameters heading. Similarly, do not describe return values. When cross-referencing another API call, format its name with code blocks, and include parentheses () like this: anotherCoolMethod(). Tip You can include callouts, but use discretion. These pages are already visually busy. Parameters If there are no parameters, leave this section blank. If there is only one call variant, do not include a syntax block in this section. Parameter Description newrelic.apiStyleGuidelines(data type $parameter_name[, integer $optional_param]) Copy $parameter_name data type Required. Brief description of parameter. $optional_param integer Optional. Brief description of parameter. newrelic.apiStyleGuidelines(data type $parameter_name, array $different_param) Copy $parameter_name data type Required. Brief description of parameter. $different_param array Required. Brief description of parameter. $third_param string Required. Brief description of parameter. Return values What does this call return, and in what circumstances? Are there any things we expect customers to do with that return value? If the call does not return anything, leave this section blank. Examples This section documents rules for oddballs that aren't self-documenting. The rest of the examples are embedded within the page itself. In general, this page is intended for style reference. For examples of how to write good API method pages, check out our existing API docs, such as the PHP API. URL guidelines For the doc's URL: Manually edit the URL slug to remove the agent name. Where the API call does not already include separators (as in newrelic_awesome_call), separate the bits with hyphens -. For example: https://docs.newrelic.com/docs/new-relic-only/advanced-style-guide/writing-guidelines/api-style-guidelines Copy Title guidelines For the doc's title: Include the method name and the agent name in parentheses. Do not include newrelic. prefixes unless they are integral to the call name (as in the PHP agent). Do not include parentheses () in the call itself. For example: apiStyleGuidelines (Example agent API) Copy Short title guidelines For the doc's short title: Include only the method name. Do not include newrelic. prefixes unless they are integral to the call name (as in the PHP agent). Do not include parentheses (). Adjust if necessary to fit on a single line in the category's sidebar. For example: apiStyleGuidelines Copy Syntax guidelines Important The Python and iOS agents use their own guidelines. For those guidelines, see the existing methods in those languages. Document each variant of a call on its own line. Do not use any formatting except italicizing the data type. Wrap optional parameters (including the comma separator) in square brackets []. Indicate the variable portion by prefacing it with a dollar sign $. If the call must be prefixed with newrelic. or similar, include that in the syntax. Optional: Include the return value, if that seems important for your particular agent. If you do, follow language conventions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.02074,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> style guide"
      },
      "id": "61ab484ee7b9d293670e847e"
    }
  ],
  "/docs/style-guide/writing-strategies/five-questions-help-write-docs": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-strategies/introduction-style-guide/",
      "sections": [
        "Introduction to the style guide"
      ],
      "published_at": "2021-12-09T22:36:58Z",
      "title": "Introduction to the style guide",
      "updated_at": "2021-11-24T09:23:43Z",
      "type": "docs",
      "external_id": "56adaf70b517da62915ac6a2a56ff50c6effb7a9",
      "document_type": "page",
      "popularity": 1,
      "body": "Welcome to New Relic's style guide. We've written these guidelines for content creators across New Relic, and for contributors to our open source content projects, like the Docs! This guide also gives you some insight into how we think about good technical writing. We focus on style and usage that's particular to New Relic. We follow American English conventions. For topics that aren't covered, please refer to the Microsoft Writing Style Guide (for guidelines on technical terminology) or the Chicago Manual of Style (for general writing and editing guidelines). Find the information you need: For our writing strategy, see docs in this section on voice, five questions for great content, how to organize your content, and more. For a quick reference for terms usage, see our Usage dictionary. For how to write and edit pages on docs.newrelic.com, see Create and edit content.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.85768,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction <em>to</em> the style guide",
        "sections": "Introduction <em>to</em> the style guide",
        "body": ": For our writing strategy, see <em>docs</em> in this section on voice, <em>five</em> <em>questions</em> for great content, how to organize your content, and more. For a quick reference for terms usage, see our Usage dictionary. For how to <em>write</em> and edit pages on <em>docs</em>.newrelic.com, see Create and edit content."
      },
      "id": "619e049fe7b9d2f6effe7e25"
    },
    {
      "sections": [
        "Infrastructure monitoring Hosts page",
        "System tab",
        "System tab functions",
        "APM and infrastructure data",
        "Important",
        "Network tab",
        "Network tab functions",
        "Processes tab",
        "Tip",
        "Processes tab functions",
        "Storage tab",
        "Storage tab functions",
        "Docker containers tab",
        "Docker containers tab functions"
      ],
      "title": "Infrastructure monitoring Hosts page",
      "type": "docs",
      "tags": [
        "Infrastructure",
        "Infrastructure monitoring UI",
        "Infrastructure UI"
      ],
      "external_id": "bcf66a1a7ca3866692418735dc4898084660ca76",
      "image": "",
      "url": "https://docs.newrelic.com/docs/infrastructure/infrastructure-ui-pages/infrastructure-hosts-page/",
      "published_at": "2021-12-11T04:38:24Z",
      "updated_at": "2021-12-04T21:53:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Hosts page to better understand important performance metrics, like resource usage, network and processes performance, and data about your containers. You can filter your hosts by attributes and compare their performance with inventory change events to help determine root causes. You can also set alert notifications to help prevent problems. To view your hosts information, go to one.newrelic.com > Infrastructure > Hosts, then click any of the following tabs: System: Overview of your hosts' performance Network: Bandwidth and error data about your network interfaces Processes: Data about CPU percentage, I/O bytes, and memory usage for individual or groups of processes Storage: Resources' capacity and efficiency, including your devices' overall utilization, disk usage, or I/O operations Docker containers: CPU percentage, I/O bytes, and memory usage for individual or group of containers System tab Here are the default graphs shown on the Hosts page. For additional chart options, select the dropdown for any chart. CPU %: On the System tab, CPU Percent is a derived metric that is part of the SystemSample event. The CPU percentage is not collected by New Relic, but derived from several other metrics. Specifically, the cpuPercent attribute is an aggregation of cpuUserPercent, cpuSystemPercent, cpuIoWaitPercent and cpuStealPercent. Load average five minute: represents an average of the number of tasks waiting to do work on a system over the last 5 minutes. Memory free %: compares the amount of free memory bytes to the amount of used memory bytes. For explanations of different chart metrics, see Default infrastructure attributes and events. Functions for adjusting chart data include: Select different host groups: Use the host filter. Change time range: Use the time picker above the charts, or drag and select a time range on a chart. Change the number of elements on charts: use the Chart shows dropdown. Change data used to order hosts: Use the table below the charts to order the chart elements by different metrics; for example, from highest to lowest CPU user % to lowest, or from lowest to highest Disk free. System tab functions Here are some of the things you can do from the System tab: If you want to... Do this... Filter and group hosts Use filter sets to show only hosts matching certain criteria, or use group by to aggregate the results. Understand host health Use the Health column of the table. To see more details about specific violations, select the health status icons. Find root causes of issues Use the Events heatmap at the top of the page to compare performance to important events happening in your infrastructure. For more, see Events heatmap. Set an alert condition for a metric Mouse over a chart, select and then Create alert. View host's alert threshold violation If present, select the host's Critical icon or Warning icon. APM and infrastructure data If you have APM data associated with your infrastructure data, there are several ways to access your APM data on the Hosts page: Use the hosts filter to filter on hosts running specific applications. In the host list below the charts, select the Application column to filter on specific applications. From the chart selector dropdown beside a chart's name, select one of the application-related charts. Important APM charts in infrastructure monitoring do not have View query or Create alert options like the other infrastructure charts do. For more about using APM and infrastructure monitoring together, see APM data in infrastructure. Network tab The Network page provides real-time visibility into the health and performance of individual hosts, web servers, or other groups of resources across your network. Default charts show bandwidth metrics by packet, bandwidth by bytes, and errors per second. Details about individual interfaces can help you: Examine saturation levels across your network or for selected filter sets. Compare load balances between specific resources. Identify unexpected differences in capacity patterns between similar hosts. Evaluate the top five network errors that New Relic automatically presents for the selected time period. This real-time network data can then help you determine whether to resolve errors by reconfiguring your network, rebalancing the loads, or taking other preventative maintenance actions before needing to make a purchase decision. From the Network tab you can view bandwidth and error data about your network interfaces. The Network page includes an Events heatmap, which provides a snapshot of the events occurring within the same time range as the displayed metrics. For a technical explanation of the attributes used to populate the Network page chart, see NetworkSample attributes. Network tab functions Here are some of the things you can do from the Network tab: If you want to... Do this... Filter and group Use filter sets to show only hosts matching certain criteria, or use Group by to aggregate the results. Select a time range Use the time picker to change the range of time selected. You can also click and drag on the chart to select a custom time range. When you select a time range, it carries over when you go from one infrastructure page to another. Change metrics displayed in chart Use the sorting dropdown to switch what metric the chart is displaying for the chosen process groupings, including: Received Bytes Received Dropped Received Errors Received Packets Transmitted Bytes Transmitted Dropped Transmitted Errors Transmitted Packets Search and filter the list Type in the Search interfaces search bar to filter the list to only those items containing the text you've typed. You can also filter the list by simply selecting the list item or user name you want to filter for. The chosen filters are displayed beside the filter icon above the chart. Add items to chart The chart, by default, displays the top five results. Use the Chart shows dropdown to display more results. To remove an item from a chart, select its name below the chart. Set an alert condition for a metric Mouse over a chart, select and then Create alert. (Not available on APM charts.) View host's alert threshold violation Select the host's Critical icon or Warning icon. Processes tab Important By default, the infrastructure agent doesn't send data about the operating system's processes unless you use guided install. To enable the sending of process data set enable_process_metrics to true. To fine-tune which processes you want to monitor, configure include_matching_metrics. Use the Processes tab to get information about processes running on your hosts, and to set alerts on process metrics. The Processes tab shows data such as CPU percentage, I/O bytes, and memory usage for individual processes or groupings of processes. The page also includes an events heatmap, which provides a snapshot of the events occurring within the same time range as the displayed metrics. Use this information to: Pinpoint processes that are causing performance issues. Create alerts for conditions such as CPU percentage and memory usage. On the Processes page, CPU percent is scoped to individual processes, rather than hosts. Because of this, the CPU percent metric does not take into account the resources of the entire system. Instead, it shows how much of a single CPU core each process is taking. Example Here's an example of how to pinpoint an issue and set an alert: You notice on the Hosts page that a cluster has a CPU percentage much higher than normal. You go to the Processes page and filter down to that cluster's processes. You notice that several instances of the same process have excessive CPU percentage. After fixing the issue, you decide to create an alert condition that triggers when the CPU percentage for that process type exceeds a certain threshold. For a technical explanation of the attributes used to populate the Processes page chart, see ProcessSample attributes. Tip You cannot start, stop, or restart processes from the UI. Instead, follow standard procedures to start, stop, check, or restart the infrastructure agent manually. Processes tab functions Here are some of the things you can do from the Processes tab: If you want to... Do this... Only show hosts matching certain criteria Use filter sets. Aggregate results or group by host attributes Use Group by to change how the processes are grouped in the chart and the list. The dropdown contains host-related attributes such as hostID and entityName. If you are monitoring AWS EC2 instances, EC2-related attributes such as awsRegion will be available. Select a time range Use either of these options: Select any of the time picker options at the top of the page. Click and drag on the chart to select a custom time range. After you select a time range, it carries over from one infrastructure page to another. View Docker metrics To view process usage by Docker containers, see Docker instrumentation. Change charts Select the dropdown beside the chart's name to switch what metric the chart displays. Choices include: Memory: Resident or virtual size CPU percentage Disk I/O: Read or write Search and filter the list Use either of these options: Type in the Search processes search bar. Select the list item or user name you want to filter for. The selected filters appear beside the filter icon above the chart, where you can select and remove them as needed. Set an alert condition for a metric Mouse over a chart. Select and then Create alert. (Not available on APM charts.) View host's alert threshold violation Select the host's Critical icon or Warning icon. Storage tab The Storage page allows you to monitor your resources' capacity and efficiency, including your devices' overall utilization, disk usage, or I/O operations. This can help you to: Examine unexpected patterns; for example, a cluster of mirrored machines that do not process I/O tasks uniformly. Monitor usage levels before disk space completely runs out. Set alert conditions to notify you about problems with one or more hosts; for example, long processing times for read or write operations, disk availability or utilization based on percentage or bytes, etc. Make informed decisions about where to redistribute hosts with higher or lower than normal processing requests. Use data to help plan for additions or changes to your infrastructure budget before an emergency arises. The Storage page includes an Events heatmap, which provides a snapshot of the events occurring within the same time range as the displayed metrics. For a technical explanation of the attributes used to populate the Storage page chart, see StorageSample attributes. Storage tab functions Here are some of the things you can do from the Storage tab: If you want to... Do this... Filter and group Use filter sets to show only hosts matching certain criteria, or use Group by to aggregate the results. Select a time range Use the time picker on the upper right to change the range of time selected. You can also click and drag on the chart to select a custom time range. When you select a time range, it carries over when you go from one infrastructure page to another. Change metrics displayed in chart Use the sorting dropdown to switch what metric the chart is displaying for the chosen process groupings. Choices include: Total Utilization % Read Utilization % Write Utilization % Disk Used Bytes Disk Free Bytes I/O Read Operations I/O Write Operations Search and filter the list Type in the Search devices search bar to filter the list. You can also filter the list by simply selecting the list item or user name you want to filter for. The chosen filters are displayed beside the filter icon above the chart. Add/remove chart items The chart, by default, displays the top five results. Use the Chart shows dropdown to display more results. To remove an item, select its name below the chart. Set an alert condition for a metric Mouse over a chart. Select and then Create alert. (Not available on APM charts.) View host's alert threshold violation Select the host's Critical icon or Warning icon. Docker containers tab Use the Docker containers tab to get information about the containers running on your hosts, and to set alerts on container metrics. The Docker containers tab shows data such as CPU percentage, I/O bytes, and memory usage for individual containers or groupings of containers. The page also includes an events heatmap, which provides a snapshot of the events occurring within the same time range as the displayed metrics. Use this information to: Identify containers that are experiencing performance issues. Create alerts for conditions such as CPU percentage and memory usage. Docker containers tab functions Here are some of the things you can do from the Docker containers tab: If you want to... Do this... Only show hosts matching certain criteria Use filter sets. Aggregate results or group by host attributes Use Group by to change how the processes are grouped in the chart and the list. The dropdown contains host-related attributes such as image and operatingSystem. Select a time range Use either of these options: Select any of the time picker options at the top of the page. Click and drag on the chart to select a custom time range. After you select a time range, it carries over from one infrastructure page to another. View Docker integration dashboard To open the Docker integration dashboard, click the Dashboard link above the data table. Change charts Select the dropdown beside the chart's name to switch what metric the chart displays. Choices include: CPU: Used cores, kernel percentage Memory: Size limit, cache bytes I/O: Write count per second, total bytes Network: Errors per second, packets Process: Process count, restart count Search and filter the list Use either of these options: Type in the Search processes search bar. Select the list item or user name you want to filter for. The selected filters appear beside the filter icon above the chart, where you can select and remove them as needed. Set an alert condition for a metric Mouse over a chart. Select and then Create alert. View host's alert threshold violation Select the host's Critical icon or Warning icon.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.13138,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Docker</em> containers tab",
        "body": "Use the Hosts page to better understand important performance metrics, like resource usage, network and processes performance, and data about your containers. You can filter your hosts by attributes and compare their performance with inventory change events to <em>help</em> determine root causes. You can"
      },
      "id": "60440a6d196a675f6c960f58"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-strategies/organize-doc/",
      "sections": [
        "Organize your page",
        "Organize your page to make it easier to read",
        "Use action-oriented titles",
        "Start the document with an introductory paragraph",
        "Keep documents short",
        "Use the New Relic voice",
        "Change doc titles and anchors",
        "Create and edit categories",
        "Start writing and editing docs"
      ],
      "published_at": "2021-12-09T22:55:14Z",
      "title": "Organize your page",
      "updated_at": "2021-11-24T07:56:48Z",
      "type": "docs",
      "external_id": "a3e3c993c0bf65626e805676496bcae8ea8d2c64",
      "document_type": "page",
      "popularity": 1,
      "body": "These are some organization basics. Organize your page to make it easier to read Consider these organization guidelines when thinking about the order of information in a doc. By following these guidelines, you'll make it easier for readers to skim and find what they need. How to organize information Comments Separate what and why from how. Define any necessary prerequisites, policies, or background information (the what and the why) before you step through the how (step-by-step procedures). Examples: Explain what the feature is and why it matters before telling readers how to use it. Describe any limitations with user permissions or subscription levels that would prevent them from using the feature. If the feature is available for any user or subscription level, don't bother to say so. Provide a roadmap for what users will be able to accomplish, so they know before starting a procedure that they have everything they need. Front-load directions with context. Make sure readers know where they need to be, before telling them what to do. In general, use (select an app) to describe what users select from the product index. Examples: Go to one.newrelic.com > Explorer > (select an app or service). Select (account dropdown) > User preferences. On the command line, type gitk. Also, structure steps by front-loading context from the user's point of view. For example, instead of \"Go to x to do y,\" structure the step as \"To do y, go to x.\" Separate requirements from options. Example: Type the Email you use to sign in and to receive information from New Relic. Optional: Type additional user emails, separated by commas. Follow the \"five to nine\" guideline. Depending on the topic, organize the information so there is a maximum of five to nine chunks of information. For example, readers may start to get lost or overwhelmed after about five h2 sections or seven steps into a procedure. If you have more than nine h2 sections or steps, you might need to create an additional doc or procedure. Other organization tools to consider: Levels of headings Lists Collapsers Callouts Tables Code examples For more help section Use action-oriented titles Wherever possible, give your document or h2 heading a task- or action-oriented title. Focus on what users are trying to accomplish or the problem they're trying to solve. Use present-tense verbs, rather than \"-ing\" verbs. Quality Title example Bad The query history Okay View query history Good Query history: Create and edit NRQL queries Start the document with an introductory paragraph Unless the document is less than a single screen in length, begin with a brief paragraph that introduces the topic or summarizes the important points. Not sure where to start? Try writing all the content for your document first, and then add the introduction to the top to summarize your key points. Or use the introduction to expand on the text in your metaDescription in the metadata. Keep documents short The amount of content needed can help you decide whether you need one or more documents for the topic. If all of the document's contents apply directly to the title, then everything belongs in the same document. If several related sections could be logically split into individual documents, and the overall length of your document is more than about two screenfuls, split those sections into other documents. Be sure to include links to the related contents. If a large document needs to be broken into multiple smaller documents, consider whether they might be best grouped together in their own sub-category. Use the New Relic voice We strive for a voice that's approachable, expert, and visionary. Check out our voice guidelines for how to write content with these qualities. And keep in mind these essential writing tips that apply to any type of documentation. Guidelines Comments Be clear and direct. Remember to: Use present tense. Use active voice; avoid passive voice. Tell users what to do, not what they \"should\" do. If absolutely necessary, tell users what not to do in situations where unexpected results may occur. Whenever possible, provide an alternative suggestion when telling users what not to do. Example: Using active voice with an alternative suggestion for what not to do Do not use your config file to change this setting, because this could affect other processes. Instead, go to one.newrelic.com > APM > (select an app or service) > Settings > Application. Write to aid localization and translation. Do not use euphemisms, idioms, jargon, or slang. Use the same terms and wording consistently. If you need to include an abbreviation or acronym, spell it out the first time it appears in the document. Always take a moment to ask yourself whether people will really understand the terms you are using in the way you're using them. Change doc titles and anchors Because changes to doc titles, anchors, and redirects can break links to other docs, please create an issue to request these types of changes and we'll help you out with that. Create and edit categories Because changes to categories can affect large groups of docs at once, please create an issue to request these types of changes and we'll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see Create and edit content. To learn how to create and publish release notes, see Create release notes. To make it even easier to start a new doc, use templates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.89265,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Start <em>writing</em> and editing <em>docs</em>",
        "body": " you&#x27;re using them. Change <em>doc</em> titles and anchors Because changes to <em>doc</em> titles, anchors, and redirects can break links to other <em>docs</em>, please create an issue to request these types of changes and we&#x27;ll <em>help</em> you out with that. Create and edit categories Because changes to categories can affect large groups"
      },
      "id": "619df04028ccbc2730b9a00a"
    }
  ],
  "/docs/style-guide/writing-strategies/introduction-style-guide": [
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-09T22:55:57Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.59854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>introduction</em>",
        "tags": "Basic <em>style</em> <em>guide</em>",
        "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft <em>Style</em> <em>Guide</em>, which is based on the Chicago Manual of <em>Style</em>. We follow American English conventions, rather than British English ones. We defer to the official product names"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution",
        "Important",
        "Tip",
        "User-related permissions",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "046f0435c8098009144e40689b5a0f0ffc07755f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/formatting/callouts/",
      "published_at": "2021-12-09T22:13:57Z",
      "updated_at": "2021-12-04T10:53:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts We have a number of callout types, and each is controlled by the variant you include in the <Callout> tag. Here's an example of the format for a tip callout: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy Here are examples of our callout variants: Caution Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use <Callout variant=\"caution\">. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use <Callout variant=\"important\">. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use <Callout variant=\"tip\">. At a traffic light, a Tip would be a green light. User-related permissions For recommended wording, see User-related language and styles. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, add a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.05539,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Basic <em>style</em> <em>guide</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-09T22:16:38Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.38228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Tables <em>to</em> describe UI functions",
        "tags": "Basic <em>style</em> <em>guide</em>",
        "body": " or code value that requires lower case or all caps. Table template This is a basic table template. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th <em>style</em>={{ width: &quot;200px&quot; }}&gt; Item &lt;&#x2F;th&gt; &lt;th&gt; **Requirements** &lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; Item name &lt;&#x2F;td&gt; &lt;td&gt; Description of item &lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt; &lt;&#x2F;table&gt; Copy"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/writing-strategies/organize-doc": [
    {
      "sections": [
        "Update the home page",
        "Update a link's URL",
        "Add a new tile to the home page",
        "Add a new section to the home page",
        "Edit the home page left nav"
      ],
      "title": "Update the home page",
      "type": "docs",
      "tags": [
        "home page",
        "landing pages"
      ],
      "external_id": "1d084fae5223f5b34cec91fcae0bcb35560c7b29",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-docs/processes-procedures/edit-homepage/",
      "published_at": "2021-12-10T13:49:40Z",
      "updated_at": "2021-12-04T10:50:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can't just hit the edit button docs.newrelic.com to make edits to the home page. The page that opens is index.js, the file that manages the parts of the home page, but not the content. It's rare that you'll need to make changes to this file. Most home page changes will be to add a new tile or section to the page, or update links. These types of changes are handled in two files: src/data/homepage.yml - contains home page section titles, section descriptions, and the URLs for tiles. src/i18n/translations/en/translation.json - contains tile info, including the title and short description of tiles. Update a link's URL Change or add new links using homepage.yml. In homepage.yml, search for the link you want to change. Edit the URL, save, commit, and PR the change. Add a new tile to the home page You'll make changes to both homepage.yml and translations.json On the translations.json doc, find the spot where you want to add the new tile (which section, and in what order you want it to appear), and add a new entry with this format: \"t#\": { \"title\": \"tile name\", \"description\": \"Short description.\" }, Copy Make sure you update the number on the tile. If you want to insert it in the middle of a group, update all the subsequent tile numbers as well. Save the file. Open homepage.yml, find the spot where the new tile will be, and add a new line with the relative link for the new tile. For example, - /docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster Save and check that your new tile builds properly on a local build. Commit, push, PR when you're ready. Add a new section to the home page On the translations.json page, add a new section modeled in the spot where you want the new section to appear. Include at least one title. For example, here's the TDP entry, with one tile: \"errors-inbox\": { \"title\": \"Errors Inbox\", \"description\": \"A single place to proactively detect, triage, and take action on all the errors before they impact customers.\", \"t1\": { \"title\": \"Introduction to Errors Inbox\", \"description\": \"How to manage all your monitoring in one place.\" }, Copy When you're done creating the info, save the file. In the homepage.yml page, find the corresponding location for the new section, and add the short name you provided in the translation.json file, title, description, and tile URLs. For example, here's the corresponding TDP section on homepage.yml. errors-inbox: title: Errors Inbox description: A single place to proactively detect, triage, and take action on all the errors before they impact customers. tiles: - /docs/errors-inbox/errors-inbox Copy Save, build locally, commit, PR. Edit the home page left nav The left nav of the home page is controlled by src/nav/root.yml. This is a basic yml file, similar to our taxonomy files. Each link on the left nav needs a title and a path: - title: Welcome to New Relic path: /docs/using-new-relic - title: New Relic One path: /docs/new-relic-one/use-new-relic-one - title: Guides and best practices path: /docs/new-relic-solutions - title: section-break - title: Alerts and Applied Intelligence path: /docs/alerts-applied-intelligence Copy You can add a new link by following the pattern above or delete a link by removing the corresponding title and path. Section breaks are added by including a - title: section-break line. The left nav reflects the exact order of root.yml, so it's easy to organize it as needed.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.41874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update the home <em>page</em>",
        "sections": "Update the home <em>page</em>",
        "tags": "home <em>page</em>",
        "body": "-faster Save and check that <em>your</em> new tile builds properly on a local build. Commit, push, PR when you&#x27;re ready. Add a new section to the home <em>page</em> On the translations.json <em>page</em>, add a new section modeled in the spot where you want the new section to appear. Include at least one title. For example, here"
      },
      "id": "61ab480264441f9ef0927fb8"
    },
    {
      "sections": [
        "Introduction to New Relic for Python",
        "Monitor app performance",
        "Install the Python agent",
        "Monitor non-web scripts, background tasks, and functions",
        "What's next after installation?",
        "Troubleshooting",
        "Check the source code"
      ],
      "title": "Introduction to New Relic for Python",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Getting started"
      ],
      "external_id": "e3621b5589469c2b3b20d5d140027e5c105e1dd3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/python-agent/getting-started/introduction-new-relic-python/",
      "published_at": "2021-12-10T01:17:02Z",
      "updated_at": "2021-12-05T09:30:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Python agent monitors your Python application to help you identify and solve performance issues. You can also extend your performance monitoring to collect and analyze business data to help you improve the customer experience and make data-driven business decisions. With flexible options for custom instrumentation and APIs, The Python agent offers multiple building blocks to customize the data you need from your app. Our Python works with a wide variety of web frameworks and hosting mechanisms, including Django, Gunicorn, WSGI, CherryPy, uWSGI, and more. You can also install the Python agent in a Google App Engine flexible environment. Monitor app performance After you install the Python agent, it begins to collect data about your app. You can view the data as charts and tables in New Relic One. View the big picture of your app. Monitor your app's Apdex (user satisfaction). Get a high-level summary of your app with Summary page. Enable distributed tracing to see activity across an architecture having many services. Install Infrastructure monitoring and view detailed server/host data for your app. Find errors and problems quickly. Track key transactions specific to your business. Create custom dashboards for important metrics. Alert your team when an error or problem occurs before it affects your users. View performance after a deployment. Drill down into performance details. Examine code-level transaction traces. Examine database query traces. Examine error traces. Use thread profiler sessions to see detailed stack traces of sampled threads View logs for your APM and infrastructure data Bring your logs and application's data together to make troubleshooting easier and faster. No need to switch to another UI page in New Relic One. With logs in context, you can see log messages related to your errors and traces directly in your app's UI. You can also see logs in context of your infrastructure data, such as Kubernetes clusters. Extend agent instrumentation Other helpful tools include: Tools Description Browser monitoring Integrate the Python agent with browser monitoring to gain visibility into end-user browser activity. Simple scripts and background tasks Monitor job-based or task queuing systems, like Celery, or other standalone non-web functions. Business data analysis with data exploration. Use the Python agent with our data explorer to organize, query, and visualize your data to answer key questions about application performance and customer experience. Use default transaction attributes, or add your own. Query your data using the New Relic Query Language (NRQL). Send your own event data. Create and share customizable, interactive dashboards. Install the Python agent Before you install the Python agent, make sure your system meets the system requirements. You must also create a New Relic account. We support a number of web frameworks and libraries right out of the box, including Django, WSGI, and Gunicorn. If you use one of the supported web frameworks, installation is easy. If you use an unsupported framework, the process will involve some additions to your app code and/or web server files. For a quick and simple install process that will work for the majority of setups, follow these simple steps: Download and install the Python package. Create config file. Integrate the Python agent with your application. Read the Quick Start guide Add Python data Monitor non-web scripts, background tasks, and functions The Python agent also lets you monitor non-web scripts, worker processes, tasks, and functions. The installation process for these non-web transactions is similar to the one used for a web app, with one major difference: instead of going through the standard integration process described in the install instructions, you would manually \"wrap\" any function you want to monitor. For more information, see Non-web tasks and processes. For instructions on monitoring Celery tasks, see Celery background tasks. What's next after installation? Once you get the agent up and running, some suggested next steps are: Explore your data in and get comfortable with the user interface. Read our docs on our other observability solutions and the APM page. Change your application's name, or other configuration options. Learn about setting up custom instrumentation for application activity not monitored by default. Consider the Python Telemetry SDK. Troubleshooting After you complete the install process, your data should appear in the APM UI within five minutes. If it does not, use these troubleshooting resources: If no data appears, follow these troubleshooting steps. If you experience issues when installing or running the Python agent on a new host, test that the package is installed correctly and that it can contact New Relic's data collector service. For other problems, see the full list of troubleshooting documentation. Check the source code The Python agent is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more information, see the README.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.71655,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " a high-level summary of <em>your</em> app with Summary <em>page</em>. Enable distributed tracing to see activity across an architecture having many services. Install Infrastructure monitoring and view detailed server&#x2F;host data for <em>your</em> app. Find errors and problems quickly. Track key transactions specific to <em>your</em>"
      },
      "id": "61749d4d196a6727702f1368"
    },
    {
      "sections": [
        "Tables",
        "Table template",
        "Tables to describe UI functions"
      ],
      "title": "Tables",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "88023a9ec5f4275d779fb9bd7b5e74aae24041ad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/structure/tables/",
      "published_at": "2021-12-09T22:16:38Z",
      "updated_at": "2021-11-24T09:18:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tables help you organize information to make it easier for readers to skim. However, if your table becomes too long, follow the \"five to nine\" guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it's a specific file name or code value that requires lower case or all caps. Table template This is a basic table template. <table> <thead> <tr> <th style={{ width: \"200px\" }}> Item </th> <th> **Requirements** </th> </tr> </thead> <tbody> <tr> <td> Item name </td> <td> Description of item </td> </tr> </tbody> </table> Copy Additional options: If you want to... Do this Shade every other row Use <table class=\"alternate\">. Create a table within a clamshell Use <table class=\"spec\">. Highlight row in gray on hover Add the class table-hover to the <table> element. Specify individual column widths Set style=\"width:###px;\" in the header row. In general, for two-column tables on the docs site: Set the first column as 200 pixels: <th style=\"width:200px\">. To allow the table to adjust automatically to the remaining page width, do not set a width for the second column. Tables to describe UI functions When using tables to describe available functions, give readers a roadmap. They may know what they want to find or accomplish, but they may not know what it's called or how to do it. For example, to provide a list of features for a particular UI page, label the header's first column If you want to... and label the second column Do this.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.39375,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Tables help you <em>organize</em> information to make it easier for readers to skim. However, if <em>your</em> table becomes too long, follow the &quot;five to nine&quot; guideline and consider restructuring the information in other ways. Use sentence case for text in every table column unless it&#x27;s a specific file name"
      },
      "id": "60421e8228ccbc65f1eba7a0"
    }
  ],
  "/docs/style-guide/writing-strategies/voice-strategies-docs-sound-new-relic": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Build queries with NerdGraph",
        "Create custom events",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2021-12-12T01:36:52Z",
      "title": "Collect data",
      "updated_at": "2021-12-12T01:36:52Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.72839,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Monitor your network devices with <em>New</em> <em>Relic</em>",
        "body": "Through our opensource agents or APIs, <em>New</em> <em>Relic</em> makes it easy to collect data from any source. The guides in this section provide <em>strategies</em> for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "BETA FEATURE",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation, docs site",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "1a874659169393e08e5c0cb986f258482797af4d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/word-choice/usage-dictionary/",
      "published_at": "2021-12-09T22:55:57Z",
      "updated_at": "2021-12-09T22:55:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For consistency across New Relic content, here are our general word usage guidelines: We generally follow the Microsoft Style Guide, which is based on the Chicago Manual of Style. We follow American English conventions, rather than British English ones. We defer to the official product names for references to products. (For example, for Amazon Web Services (AWS), see aws.amazon.com/products.) For terminology specific to New Relic, we use the product glossary. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta Use the beta callout. In the body text, use lowercase. For example: BETA FEATURE This feature is currently in beta. If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation, docs site If you need to refer to the docs themselves—don't. Generally it's better to directly link to the doc you're referencing and use the doc title as your link text. For example, See [Install the .NET agent](URL) rather than See our [.NET agent install docs](URL). If there's not a good alternative, doc generally sounds more natural than document or documentation. If you're tempted to use a longer form, try reading it aloud to see which reads best. If you must refer to the site as a whole, call it the docs site rather than Docs site or documentation site. Internally, you can also refer to the whole URL docs.newrelic.com to avoid ambiguity with other sources of docs like internal platform docs or API explorer docs. To refer to our docs GitHub repo, use the repo name docs-website or the repo path newrelic/docs-website. dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Avoid these Latin abbreviations. Instead of e.g., use for example or such as. Subbing for i.e. is tricker, because sometimes people use it to mean that is, while at other times it's mis-used to mean for example. Read the context to be clear, but usually the best solution is to rewrite so the description is clear without needing explanatory text. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. It should have a period at the end (etc.). Ensure that you have several meaningful examples, though, before using it. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Avoid using generically, to avoid confusion with infrastructure monitoring. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS, Mac OS X, or OS X. master account We previously used master account and sub-account but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with New Relic. For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original user model but still plays a role for some behind-the-scenes features on our New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say we and our when it works with the flow of your writing. Avoid overloading paragraphs with New Relic mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use you and your liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.79312,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "collector vs. connect to <em>New</em> <em>Relic</em>",
        "body": " or .net or dotnet. <em>New</em> <em>Relic</em> One <em>New</em> <em>Relic</em> One isn&#x27;t a product. It&#x27;s a way to view <em>New</em> <em>Relic</em> data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes <em>New</em> <em>Relic</em> One <em>sound</em> <em>like</em> a separate product"
      },
      "id": "619e1c0a64441fb97e9858d2"
    },
    {
      "image": "https://developer.newrelic.com/static/developer-champions-c61b7fb3b08d228679edab34b2d15a0e.jpg",
      "url": "https://developer.newrelic.com/developer-champion/",
      "sections": [
        "New Relic Developer Champions",
        "What do Developer Champions do?",
        "Open-source contributions",
        "Content creation",
        "Community engagement",
        "Why should you join and how will we support?",
        "Developer Champions benefits:"
      ],
      "published_at": "2021-12-12T01:37:43Z",
      "title": "New Relic Developers",
      "updated_at": "2020-12-04T01:45:02Z",
      "type": "developer",
      "external_id": "2cef9996dadc081ed4331e85992a4af9defc87ff",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Champions are the voice of the developer community. As experts and innovators, they are given the resources to not only share the newest product innovations and updates but also to provide feedback of the community back to New Relic product and engineering teams. Champions solve big problems using New Relic as their toolkit and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion What do Developer Champions do? New Relic Champions demonstrate expertise in using New Relic products by solving large problems and positioning New Relic as a central force in their strategies. The New Relic Champions is a recognition and partnership program designed to acknowledge the developers that are driving innovation within their companies and making top contributions to the developer community.They also commit to making their work public by: Open-source contributions Serving as an open-source author or maintainer for an accepted public project related to New Relic One Content creation Authoring two pieces of content in the New Relic Explorers Hub / Dev website Community engagement Delivering and/or organizing two events focused on an observability platform theme in which New Relic plays a crucial role Nominate a Developer Champion Why should you join and how will we support? As a benefit of being a Developer Champion, New Relic provides unique access to our Developer Advocacy team and the resources of our product organization, as well as specialized recognition and rewards. Developer Champions benefits: Formal, specialized access to the New Relic Product organization Champions have direct access to the New Relic’s Developer Ecosystem team Custom badge to wear with pride at events Public recognition on the New Relic Developer website and badging in the New Relic Explorers Hub as a Champion Exclusive Champion-only swag Early access program for some of our products (under NDA) Priority access to off-site FutureHack events (including when Lew is participating) Increased Explorer’s Hub support SLA Access to private Developer Champion Explorer’s Hub group",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.75324,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> Developer Champions",
        "body": "<em>New</em> <em>Relic</em> Champions are the <em>voice</em> of the developer community. As experts and innovators, they are given the resources to not only share the newest product innovations and updates but also to provide feedback of the community back to <em>New</em> <em>Relic</em> product and engineering teams. Champions solve big"
      },
      "id": "5efa993c64441fc2a25f7e65"
    }
  ],
  "/docs/synthetics/index": [
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 56.19766,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> monitoring",
        "sections": "User roles in <em>synthetic</em> monitoring",
        "tags": "<em>Synthetics</em>"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-12-09T21:14:22Z",
      "updated_at": "2021-11-26T09:10:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher. macOS: 10.11 or higher. Windows: Windows 10 64-bit or higher. You must also configure Docker to run Linux containers in order for CPMs to work on Windows systems. Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution The Docker CPM is not designed for use with container orchestrators like AWS ECS, Docker Swarm, Apache Mesos, Azure Container Instances, etc. Running the Docker CPM in a container orchestrator will result in unexpected issues because it is itself a container orchestrator. If you're using container orchestration, see our Kubernetes CPM requirements. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Unless hosting the images in a local image repository, connections to either quay.io or docker.io will need to be allowed through your firewall in order for Docker to pull the synthetics-minion and synthetics-minion-runner images. The \"runner\" image is pulled automatically on startup of the synthetics-minion container. See Docker environment configuration and Kubernetes environment configuration for details on how to set a local repository and the runner registry endpoint. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 53.271904,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetics</em>",
        "body": " to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-09T21:19:08Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 52.664986,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetics</em>",
        "body": " or simple browser monitor Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring"
      },
      "id": "604526d064441f3ecc378f03"
    }
  ],
  "/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs": [
    {
      "sections": [
        "Synthetic monitoring: Aggregate monitor metrics",
        "View synthetic monitoring SLA reports",
        "Understand SLA report metrics",
        "Use page functions",
        "Generate SLA values"
      ],
      "title": "Synthetic monitoring: Aggregate monitor metrics",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "bbead36a5b36d126243f0beb2d60e9ccf23763f5",
      "image": "https://docs.newrelic.com/static/d0dc46884c112568daf4e491098e1951/c1b63/sla-report.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-aggregate-monitor-metrics/",
      "published_at": "2021-12-09T21:12:39Z",
      "updated_at": "2021-11-15T07:04:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View synthetic monitoring SLA reports To view your account-wide SLA report: Go to one.newrelic.com > Synthetics > SLA Report. Choose from reports aggregated by day, week, or month by selecting Daily, Weekly, or Monthly as appropriate. You can also view SLA reports for individual monitors: Go to one.newrelic.com > Synthetics > (select a monitor) > SLA. one.newrelic.com > Synthetics > SLA Report: Use SLA reports to understand your monitors' performance over time. Understand SLA report metrics Use SLA reports to view aggregated performance metrics for a single monitor, or for all your monitors from the account-wide SLA Reports page. SLA reports include the following metrics: Duration: The average duration across all monitor results. Uptime: The percentage of all monitor results that ended successfully. For example, Monitor A might check 50 times per day, and Monitor B might check 150 times per day. If Monitor A has 29 successes out of 50 and Monitor B has 148 successes out of 150, the Uptime would be 88.5: (29+148)/(50+150)=88.5 For individual SLA reports, the uptime score only includes the selected monitor. Apdex: The average Apdex across all monitors. Monitors have a default Apdex T of 7 seconds, but you can customize Apdex T for individual monitors by editing their settings. Apdex F, which defines a frustrating result, is always four times Apdex T. For more information about Apdex, see Apdex: Measuring user satisfaction. For individual SLA reports, the Apdex score only includes the selected monitor. % Satisfied: The percentage of monitor results which complete in a \"satisfying\" time. A satisfying time is defined as a monitor result that completes in Apdex T or less. % Toleration: The percentage of monitor results which complete in a \"tolerable\" time. A tolerable time is greater than Apdex T, but less than Apdex F (four times Apdex T). % Frustrated: The percentage of monitor results which complete in a \"frustrating\" time. A frustrating time is greater than Apdex F (four times Apdex T). The account-wide SLA report includes all monitor types (ping, simple browser, scripted browser, and API test). Use page functions SLA reports support the following features: If you want to... Do this... View the report in Excel or an external program Select Download this report as .csv to download a copy of your SLA data. Open the file in Excel, Google Drive, or another spreadsheet editor to analyze your data. Change your Apdex targets The default Apdex T for all monitors is 7 seconds. You can customize your Apdex T target for individual monitors by editing your monitor. Change the time frame Choose from daily, weekly, or monthly aggregation by selecting the appropriate tab. Make the report public Change the Public SLA setting to ON to allow non-authenticated users to view the report. Select Share Report to get the public URL to share. Generate SLA values The values in the SLA report are generated from Insights queries against the available synthetic monitoring data. You can easily recreate these values and modify the queries to meet your needs. This query returns the average duration, the apdex, and the uptime. Substitute your values for the variables highlighted and described below. SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod Copy Variable Value t: Supply the Apdex T that you would like to calculate your apdex against. The duration attribute in the SyntheticCheck event is stored in milliseconds, so an Apdex T value of 7 seconds should be included as 7000. timeperiod This is the period that you would like to calculate on. For a daily report, facet on dateOf(timestamp), for a weekly report facet on weekOf(timestamp) and for a monthly report facet on monthOf(timestamp). NRQL queries default to querying against the last hour of data. In order to widen the scope of your data you will need to include a SINCE clause at the end of your query. Example #1: Daily report for the last week To generate a daily report for the last week you would add SINCE 1 week ago: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET dateOf(timestamp) SINCE 1 week ago Copy Example #2: Report for a particular monitor To scope the results to a particular monitor you can edit the below query to include a specific monitor name: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName = 'mymonitorname' Copy Example #3: Report for multiple monitors To scope the results to a collection of monitors: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName IN ('mymonitor1', 'mymonitor2', 'mymonitor3') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.37964,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View <em>synthetic</em> <em>monitoring</em> SLA reports To view your account-wide SLA report: Go to one.newrelic.com &gt; <em>Synthetics</em>"
      },
      "id": "603ec399196a67e073a83d96"
    },
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-12-09T21:12:39Z",
      "updated_at": "2021-11-07T09:25:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. Avoid extra noise and get notified after three failures Read our blog post on the three strikes rule.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.85136,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures <em>page</em> To access your <em>monitor</em>&#x27;s failures: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Failures. Hover the mouse over a failure to get"
      },
      "id": "603e9efd64441faf344e8865"
    },
    {
      "sections": [
        "Synthetic monitoring: Understand load times",
        "View the Resources page",
        "Understand resource metrics",
        "View detailed resource metrics",
        "View individual resource loads",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Understand load times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "a6d91eef3b89f682ce06d4408928f0c8b70b90e6",
      "image": "https://docs.newrelic.com/static/fe6794ec2ba009717f08a91fae4841fc/8c557/resource-load.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-understand-load-times/",
      "published_at": "2021-12-09T21:13:36Z",
      "updated_at": "2021-10-31T07:59:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Resources page to understand the load time impact of each resource on your website. Use the resources load time, time spent by third parties, and irregular response codes graphs for a high-level overview, and use the resources list to identify high-impact resources such as large CSS files or images. You can also investigate a specific resource with detailed resource metrics, which aggregate performance information for a single resource. Go even deeper and view one load of that resource, using the exact request and response headers to pinpoint a performance issue. View the Resources page To access your monitor's Resources page: Go to one.newrelic.com > Synthetics > (select a monitor) > Resources. one.newrelic.com > Synthetics > (select a monitor) > Resources: Use the Resources page to analyze the performance of each resource on your website, and to access detailed metrics with individual resource loads. Understand resource metrics Use the Resources page to understand the performance impact of each resource on your website: Resources list: Lists the resources on your monitored website by average download time. Use this list to optimize your website's performance by reducing download times. You can also view the load time for any particular resource by searching for it in the Search all resources field. Select a resource to view individual resource metrics. Load time: Graphs the average load time for all resources, broken down by resource type (such as jpeg, json, or javascript). Use this graph to understand how the load time of your website changes over time. Time spent by third parties: Graphs the average load time of all third-party resources, such as web fonts, an embedded Twitter timeline, or an externally hosted image. Use this graph to see if third-party websites are affecting your website's performance. Irregular response codes: Graphs the number of negative HTTP response codes (also called HTTP status codes) received by the monitor. This graph includes all responses in the 300 (redirection), 400 (client error), and 500 (server error) ranges. It does not count responses in the 100 or 200 ranges. Synthetics also collects a number of custom response codes. By analyzing these metrics, you can track down troublesome resources and improve their performance. For example, an unoptimized logo image might cause slowdowns for every visitor of your site, while a tracker that is served only from a US-based server could result in slow performance for non-US visitors. View detailed resource metrics You can also view detailed metrics for each resource on your site. To view detailed metrics, locate a specific resource, or simply select an interesting resource from the Resources page. After selecting a resource, you can view overview metrics for that resource, or view an individual resource load: Max duration, Min duration, Avg duration: Load time metrics for this resource over the selected time frame. For 50% of requests: The maximum download time for the fastest 50% of requests. This means that 50% of requests for this resource were completed in the specified time or faster. For 95% of requests: The maximum download time for the fastest 95% of requests. This means that 95% of requests for this resource were completed in the specified time or faster. Average load time: Graphs the average load time for this resource over the selected time frame. Use this graph to verify that optimizations to your website (such as decreasing the size of an image or minifying your CSS) are working. You can also hide and unhide chart elements, filter by location, and sort the resource results list by Download time or DNS lookup. Mouse over the resource name to view the full path (useful with very long dynamically generated resource names). View individual resource loads After viewing detailed metrics for a particular resource, you can select an individual resource load for an in-depth understanding of one poor performance incident. You can then view a breakdown of the total connection time to understand where the issue occurred, and examine request and response headers. one.newrelic.com > Synthetics > (select a monitor) > Resources > (select a resource) > (select a resource load): Select an individual resource load to see a detailed breakdown of connection time, request headers, and response headers. Network timing structure taken from the HTTP Archive 1.2 specification. Use page functions The Resources page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select a sort option: Sort by Average download time to view your slowest-loading resources. Sort by Average size to view your largest resources. Hide and unhide chart elements Select chart elements to hide and unhide them. Locate a specific resource Enter part of your resource name in the Search all resources field (for example, search-icon.png or latest.json). Select the resource to view detailed metrics for that resource. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.13786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Understand load times",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Understand load times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>page</em> To access your <em>monitor</em>&#x27;s Resources <em>page</em>: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Resources. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Resources: Use the Resources <em>page</em> to analyze the performance of each resource on your website, and to access detailed metrics"
      },
      "id": "604525b864441f0943378ebb"
    }
  ],
  "/docs/synthetics/new-relic-synthetics/synthetics-api/synthetics-rest-api-version-1": [
    {
      "sections": [
        "Payload attributes for the Synthetics REST API",
        "Synthetic monitoring attributes",
        "Specific monitor endpoint"
      ],
      "title": "Payload attributes for the Synthetics REST API",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "ed3202f6715ae367d5c7c58d63a332d073535995",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/payload-attributes-synthetics-rest-api/",
      "published_at": "2021-12-09T22:27:43Z",
      "updated_at": "2021-10-31T04:10:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For REST API requirements for synthetics, see Use the API. Synthetic monitoring attributes Here are the attributes that can be used when creating and managing monitors with the Synthetics REST API: Synthetics API attribute Definition apiVersion String: The version number. count Integer: The number of monitors returned. emails Array of strings: Email addresses for alert notifications with New Relic. frequency Integer: Number of minutes between checks. Valid values include 1, 5, 15, 30, 60, 360, 720, and 1440. id The UUID for the specific synthetic monitor. locations Array of strings: Array of locations by full label. name String: The monitor's name. scriptLocations String: The name and hmac values for private locations using Verified Script Execution. scriptText String: The BASE64 encoded text for scripted monitors. slaThreshold Double: Value for the Synthetics SLA report, in seconds. status String: Valid values include ENABLED, MUTED, and DISABLED. type String: Type of monitor. Valid values include: SIMPLE (Ping) BROWSER SCRIPT_BROWSER SCRIPT_API uri String: The URI for SIMPLE and BROWSER monitor types; for example, http://my-site.com. Optional for SCRIPT_BROWSER and SCRIPT_API. userID Integer: The specific user ID. options Object: options for SIMPLE and BROWSER monitor types. Options include: validationString: string verifySSL: boolean (true, false) bypassHEADRequest: boolean (true, false) treatRedirectAsFailure: boolean (true, false) Specific monitor endpoint When making REST API calls for a specific monitor, include the monitor_uuid as part of the endpoint. The monitor_uuid is the GUID which is part of the URL. For example, a selected synthetic monitor has this URL: https://synthetics.newrelic.com/accounts/nnnn/monitors/ab123-c456d-e78-90123-f45g Copy The monitor_uuid is the value that follows /monitors/.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.03185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Payload attributes for the <em>Synthetics</em> <em>REST</em> <em>API</em>",
        "sections": "Payload attributes for the <em>Synthetics</em> <em>REST</em> <em>API</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " <em>REST</em> <em>API</em> calls for a specific <em>monitor</em>, include the <em>monitor</em>_uuid as part of the endpoint. The <em>monitor</em>_uuid is the GUID which is part of the URL. For example, a selected synthetic <em>monitor</em> has this URL: https:&#x2F;&#x2F;<em>synthetics</em>.newrelic.com&#x2F;accounts&#x2F;nnnn&#x2F;monitors&#x2F;ab123-c456d-e78-90123-f45g Copy The <em>monitor</em>_uuid is the value that follows &#x2F;monitors&#x2F;."
      },
      "id": "6043f9ae28ccbc98002c607a"
    },
    {
      "sections": [
        "Manage synthetic monitors via REST API",
        "Features",
        "Monitor types in API",
        "Use the API",
        "Caution",
        "Get all monitors",
        "Get a specific monitor",
        "Create a monitor",
        "Update an existing monitor",
        "Patch an existing monitor",
        "Delete an existing monitor",
        "Get a list of valid locations",
        "Script API for scripted browser and API test monitors",
        "Get monitor script",
        "Add scripted monitor",
        "Update monitor script",
        "Using private location scripts with verified script execution",
        "Important",
        "Scripted browser example",
        "Scripted browser API example",
        "Bash script example",
        "Tip"
      ],
      "title": "Manage synthetic monitors via REST API",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "83a3e8ad751c7f0865785a1c2fad193604a7f7da",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/manage-synthetics-monitors-rest-api/",
      "published_at": "2021-12-09T23:01:25Z",
      "updated_at": "2021-09-14T18:17:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Synthetics REST API to create and manage synthetic monitors of all types: ping, simple browser, scripted browser, and API test monitors. All synthetic monitoring data is available via the REST API. To use the Synthetics REST API, you must have a user role that allows that capability and a user key. For an overview of all available New Relic APIs, see Intro to APIs. Features The newest version of the Synthetics API (v3) adds these features: Synthetics API (v3) Features Options field for POST and PUT request You can specify the options for SIMPLE and BROWSER type monitors, similar to the way these options are available in the UI. PATCH request You can update only the fields of a monitor you want to change, rather than having to specify the entire monitor entity in a PUT. You can also specify the OPTION, assuming you are using the appropriate type of monitor. More detail with 400 Bad Request errors As of v3, the Synthetics API attempts to return as much information as possible when a validation failure occurs. This will help you figure out what might be wrong with the request. The API runs all validations and returns any failed validation messages, rather than failing on the first validation error as occurred in previous API versions. Pagination Large API responses are properly paginated. You can also use NRQL queries to analyze past changes made via the API. Monitor types in API These are the monitor types and how they're referred to in the API: Monitor type API name Ping SIMPLE Simple browser BROWSER Scripted browser SCRIPT_BROWSER API test SCRIPT_API Use the API To use the Synthetics REST API, you must have the ability to manage synthetics monitors and use a user key (the REST API key won't work). This API can be used for all Synthetics monitors. (Additional API methods for scripted browser and API test monitors are also available to update the script associated with those monitors.) All Synthetics data is available via the API. API examples show cURL commands. For US-based accounts, use the following endpoint: https://synthetics.newrelic.com/synthetics/api Copy For EU-based accounts, use the following endpoint: https://synthetics.eu.newrelic.com/synthetics/api Copy Caution The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Get all monitors To view a list of all the monitors in your New Relic account, send a GET request to $API_ENDPOINT/v3/monitors. For example: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"monitors\": [ { \"id\": \"2a1bc369-7654-489d-918e-f6g135h7i2jk\", \"name\": \"monitor1\", \"type\": \"BROWSER\", \"frequency\": 60, \"uri\": \"http://example.com\", \"locations\": [ \"AWS_US_WEST_1\" ], \"status\": \"DISABLED\", \"slaThreshold\": 7, \"options\": {}, \"modifiedAt\": \"2016-09-26T23:12:46.981+0000\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"userId\": 0, \"apiVersion\": \"0.2.2\" } ], \"count\": 1 } Copy Query arguments: offset: The monitor count offset. Defaults to 0. For example, if you have 40 monitors and you use an offset value of 20, it will return monitors 21-40. limit: The number of results per page, maximum 100. Defaults to 50. You can include these in your cURL command as follows: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors \\ -G -d 'offset=20&limit=100' Copy The headers include a Link to help you easily page your monitors. For example: <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=0&limit=20>; rel=\"first\", <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=40&limit=20>; rel=\"last\" Copy Get a specific monitor To view a single Synthetics monitor, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } Copy An invalid monitor ID will return 404 Not Found: The specified monitor doesn't exist. Create a monitor To add a new monitor to your Synthetics account, send a POST request to $API_ENDPOINT/v3/monitors with a JSON payload that describes the monitor. All fields in the following example are required unless stated otherwise: { \"name\": string [required], \"type\": string (SIMPLE, BROWSER, SCRIPT_API, SCRIPT_BROWSER) [required], \"frequency\": integer (minutes) [required, must be one of 1, 5, 10, 15, 30, 60, 360, 720, or 1440], \"uri\": string [required for SIMPLE and BROWSER type], \"locations\": array of strings [at least one required], \"status\": string (ENABLED, MUTED, DISABLED) [required], \"slaThreshold\": double, \"options\": { \"validationString\": string [only valid for SIMPLE and BROWSER types], \"verifySSL\": boolean (true, false) [only valid for SIMPLE and BROWSER types], \"bypassHEADRequest\": boolean (true, false) [only valid for SIMPLE types], \"treatRedirectAsFailure\": boolean (true, false) [only valid for SIMPLE types] } } Copy In addition, to add the script for a scripted monitor via the REST API, call an additional API endpoint to send the script for the monitor just created. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Replace the Synthetics REST API attributes in the following example with your specific values: curl -v \\ -X POST -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors \\ -d '{ \"name\" : \"monitor1\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"type\" : \"browser\", \"status\" : \"enabled\", \"slaThreshold\" : \"1.0\"}' Copy A successful request will return a 201 Created response, with the URI of the newly-created monitor specified in the location header. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example: the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 402 Payment Required: Creating the monitor will increase your scheduled checks past your account's purchased check limit. Update an existing monitor To update an existing monitor in New Relic, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. In addition, for scripted monitors, follow the procedures to update the BASE64 encoded script. All fields are required. However, the TYPE of the monitor cannot be changed. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PUT -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\", \"type\": \"monitor type\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com/\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"status\" : \"enabled\", \"slaThreshold\": \"7.0\" }' Copy PUT requests are intended to replace target entities, so all attributes required in the JSON payload when creating a new monitor are also required when updating an existing monitor. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Patch an existing monitor To patch an existing monitor in New Relic, send a PATCH request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PATCH -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\" }' Copy PATCH requests are intended to update individual attributes of your New Relic Synthetics monitor rather than updating the entire entity, so you may provide only the attributes you want to update. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds, or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Delete an existing monitor To delete an existing monitor in New Relic Synthetics, send a DELETE request to $API_ENDPOINT/v3/monitors/$MONITOR_ID: curl -v \\ -H 'Api-Key:$API_KEY' \\ -X DELETE $API_ENDPOINT/v3/monitors/$MONITOR_ID Copy A successful request will return a 204 No Content response, with an empty body. An unsuccessful request will return the response 404 Not Found: The specified monitor does not exist. Get a list of valid locations To retrieve the list of valid locations in New Relic Synthetics, use the following command: curl -v \\ -X GET -H 'Api-Key:$API_KEY' $API_ENDPOINT/v1/locations Copy Script API for scripted browser and API test monitors In addition to the general API, there are several API methods for the scripted browsers (SCRIPT_BROWSER) and API test browsers (SCRIPT_API). These examples show cURL commands. Get monitor script To view the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script. For example: curl -v -H 'Api-Key: $API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID/script Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"scriptText\": BASE64 encoded string } Copy Possible error codes include: 403 Forbidden: The specified monitor is not of type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor doesn't exist or the script associated with the monitor doesn't exist. Add scripted monitor To add a new scripted monitor to New Relic Synthetics with the REST API: Follow standard API procedures to add a new monitor, and identify the type as a SCRIPT_BROWSER or SCRIPT_API. Update the new monitor with a BASE64 encoded version of the script to the $MONITOR_UUID/script endpoint. For more information, refer to the example. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Update monitor script To update the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script with a JSON payload that contains the scriptText (required). scriptPayload='{\"scriptText\":BASE64 encoded string}' curl -v -X PUT \\ -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' \\ $API_ENDPOINT/v3/monitors/$MONITOR_UUID/script \\ -d $scriptPayload Copy If you are using private locations with verified script execution enabled, see script locations with verified script execution. A successful request will return a 204 No Content response with an empty body. Possible error codes include: 400 Bad Request: Invalid BASE64 encoded string for scriptText or hmac. 403 Forbidden: The specified monitor is not of the type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor does not exist. Using private location scripts with verified script execution When creating or updating monitors for private locations that have verified script execution turned on, you must use scriptLocations to set the password: { \"scriptText\": BASE64 encoded String, \"scriptLocations\": [ { \"name\": Location name, \"hmac\" BASE64 encoded String of SHA256 HMAC for location } ] } Copy The password used to generate the HMAC string must match the password set for the private location. If you have multiple locations with Verified script execution enabled each location must have the HMAC calculated. When generating the HMAC string, use the SHA256 algorithm with the script and password. Here's an example for the script: var assert = require('assert'); assert.equal('1', '1'); Copy This example uses password as the password for the scriptLocation: curl -v -X PUT -H 'Api-Key: '$API_KEY' -H 'content-type: application/json' $API_ENDPOINT}/v3/monitors/$MONITOR_ID/script -d '{ \"scriptText\": \"dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOw0KYXNzZXJ0LmVxdWFsKCcxJywgJzEnKTs=\",\"scriptLocations\": [ { \"name\": \"my_vse_enabled_location\", \"hmac\": \"MjhiNGE4MjVlMDE1N2M4NDQ4MjNjNDFkZDEyYTRjMmUzZDE3NGJlNjU0MWFmOTJlMzNiODExOGU2ZjhkZTY4ZQ==\"} ]}' Copy Important You must remove the last newline character from both the script and the calculated HMAC value before encoding in BASE64. Calculation steps: Calculate the HMAC value from the script. One way is to use: cat script | openssl dgst -sha256 -hmac \"password\" > hmac Remove the newline character if one was added by openssl. Encode the HMAC in BASE64 without line breaks. Scripted browser example Here is an example of using New Relic's REST API and the bash script to create a scripted browser monitor. Scripted browser API example The following example shows cURL commands to create a scripted browser monitor. At the top of the script, replace the variables with your specific values. For the scriptfile variable, identify the filename for the script to be created. Here is a sample script that can be saved as sample_synth_script.js to use in the example: var assert = require(\"assert\"); $browser.get(\"http://example.com\").then(function(){ // Check the H1 title matches \"Example Domain\" return $browser.findElement($driver.By.css(\"h1\")).then(function(element){ return element.getText().then(function(text){ assert.equal(\"Example Domain\", text, \"Page H1 title did not match\"); }); }); }).then(function(){ // Check that the external link matches \"http://www.iana.org/domains/example\" return $browser.findElement($driver.By.css(\"div > p > a\")).then(function(element){ return element.getAttribute(\"href\").then(function(link){ assert.equal(\"http://www.iana.org/domains/example\", link, \"More information link did not match\"); }); }); }); Copy Bash script example This example shows the bash script that will create the SCRIPTED_BROWSER monitor. Tip In some cases you may want to use -w 0, which will disable line wrapping: base64 -w 0 $scriptfile #!/bin/bash # API key from your account settings API_KEY='' # Other attributes found at https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/attributes-synthetics-rest-api#api-attributes monitorName='Test API Script' monitorType='SCRIPT_BROWSER' frequency=1440 locations='\"AWS_US_WEST_1\", \"AWS_US_EAST_1\"' slaThreshold=7.0 # Location of the file with your script scriptfile=sample_synth_script.js # Test that the script file exists (does not validate content) if [ -e \"$scriptfile\" ] then script=$(cat \"$scriptfile\") payload=\"{ \\\"name\\\" : \\\"$monitorName\\\", \\\"frequency\\\" : $frequency, \\\"locations\\\" : [ $locations ], \\\"status\\\" : \\\"ENABLED\\\", \\\"type\\\" : \\\"$monitorType\\\", \\\"slaThreshold\\\" : $slaThreshold, \\\"uri\\\":\\\"\\\"}\" echo \"Creating monitor\" # Make cURL call to API and parse response headers to get monitor UUID shopt -s extglob # Required to trim whitespace; see below while IFS=':' read key value; do # trim whitespace in \"value\" value=${value##+([[:space:]])}; value=${value%%+([[:space:]])} case \"$key\" in location) LOCATION=\"$value\" ;; HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\" ;; esac done < <(curl -sS -i -X POST -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' https://synthetics.newrelic.com/synthetics/api/v3/monitors -d \"$payload\") # Validate monitor creation & add script unless it failed if [ $STATUS = 201 ]; then echo \"Monitor created, $LOCATION \" echo \"Uploading script\" # base64 encode script encoded=`echo \"$script\" | base64` scriptPayload=\"{\\\"scriptText\\\":\\\"$encoded\\\"}\" curl -s -X PUT -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' \"$LOCATION/script\" -d $scriptPayload echo \"Script uploaded\" else echo \"Monitor creation failed\" fi else echo \"script file not found, not creating monitor\" fi Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.05324,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>synthetic</em> <em>monitors</em> via <em>REST</em> <em>API</em>",
        "sections": "Manage <em>synthetic</em> <em>monitors</em> via <em>REST</em> <em>API</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " will disable line wrapping: base64 -w 0 $scriptfile #!&#x2F;bin&#x2F;bash # <em>API</em> key from your account settings <em>API</em>_KEY=&#x27;&#x27; # Other attributes found at https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>apis</em>&#x2F;<em>synthetics</em>-<em>rest</em>-<em>api</em>&#x2F;<em>monitor</em>-<em>examples</em>&#x2F;attributes-<em>synthetics</em>-<em>rest</em>-<em>api</em>#<em>api</em>-attributes <em>monitor</em>Name=&#x27;Test <em>API</em> Script&#x27; <em>monitor</em>"
      },
      "id": "60440d4628ccbc74532c606a"
    },
    {
      "sections": [
        "Use synthetic monitoring secure credentials APIs",
        "Requirements and rules",
        "API examples",
        "Add a secure credential",
        "Get all secure credentials",
        "Get a specific secure credential",
        "Update an existing secure credential",
        "Delete an existing secure credential"
      ],
      "title": "Use synthetic monitoring secure credentials APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Secure credentials examples"
      ],
      "external_id": "bd66e43160c1fd4c9f66bfdfa2d9a3223eb5d4d7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/secure-credentials-examples/use-synthetics-secure-credentials-apis/",
      "published_at": "2021-12-09T22:20:51Z",
      "updated_at": "2021-10-31T04:10:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the Synthetics REST API, you can make API calls to change or retrieve secure credentials data. This document explains the API requirements and contains API curl command examples. For general guidelines for setting secure credentials and setting them in the UI, see Secure credentials. Requirements and rules For general rules about this feature, see the secure credentials requirements. API requirements and rules include: See general Synthetics REST API requirements. An account's rate of requests is limited to three requests per second. Requests that exceed this threshold will return a 429 response code. A key's value cannot be accessed via the API; an unauthorized user would not have access to the secure key values. API examples Add a secure credential To send a secure credential to your New Relic account, send a POST request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials with a JSON payload that describes the secure credential. Here's an example: { \"key\": string [required, 1-64 characters uppercase], \"value\": string [required, 1-3,000 characters], \"description\": string [optional] } Copy Here's an example of doing this with a curl command: curl -v \\ -X POST -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials \\ -d '{ \"key\": \"MYKEY\", \"value\": \"my value\", \"description\": \"Description of MYKEY\" }' Copy A successful request will return a 201 Created response, with the URI of the newly-created secure credential specified in the location header. Possible error codes include: 303 See Other: The specified key already exists. The returned location header will contain the URI to the key. 400 Bad Request: Key too long or missing, value too long or missing, non-parsable JSON payload. Get all secure credentials To view a list of all the secure credentials in your New Relic account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials. For example: curl -v \\ -H 'Api-Key:$API_KEY' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"secureCredentials\": [ { \"key\": \"MYKEY1\", \"description\": \"Description of MYKEY1\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"lastUpdated\": \"2016-09-26T23:12:46.981+0000\" }, { \"key\": \"MYKEY2\", \"description\": \"Description of MYKEY2\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"lastUpdated\": \"2016-09-26T23:12:46.981+0000\" } ], \"count\": 2 } Copy Get a specific secure credential To view a single secure credential, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY. curl -v \\ -H 'Api-Key:$API_KEY' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"key\": string, \"description\": string, \"createdAt\": date,​ \"lastUpdated\": date } Copy An invalid key will return 404 Not Found: The specified key doesn't exist. Update an existing secure credential To update an existing credential in New Relic, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY. curl -v \\ -X PUT -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY \\ -d '{ \"key\": \"MYKEY\", \"value\": \"my value\", \"description\": \"Description of MYKEY\" }' Copy An invalid key will return 404 Not Found: The specified key doesn't exist. Delete an existing secure credential To delete an existing credential in New Relic, send a DELETE request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY. curl -v \\ -H 'Api-Key:$API_KEY' \\ -X DELETE https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY Copy Please note that if the specified key does not exist, no error will occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.25251,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>synthetic</em> <em>monitoring</em> secure credentials <em>APIs</em>",
        "sections": "Use <em>synthetic</em> <em>monitoring</em> secure credentials <em>APIs</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": "With the <em>Synthetics</em> <em>REST</em> <em>API</em>, you can make <em>API</em> calls to change or retrieve secure credentials data. This document explains the <em>API</em> requirements and contains <em>API</em> curl command <em>examples</em>. For general guidelines for setting secure credentials and setting them in the UI, see Secure credentials"
      },
      "id": "6044070d196a67b171960f76"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring": [
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.16312,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Synthetic monitor public minion IPs",
        "IP addresses are not personal data",
        "Daily JSON listings for IP addresses",
        "Important",
        "Tip",
        "Public minion locations and location labels"
      ],
      "title": "Synthetic monitor public minion IPs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "773534b4f076c3b421b6e0ca0dfc26f1e1ef6f73",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/",
      "published_at": "2021-12-10T13:22:29Z",
      "updated_at": "2021-08-08T21:09:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic uses a group of minions to execute your synthetic monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses are publicly available in JSON format, so you can easily read and parse them. Recommendation: For easier maintenance, use these options: Automate your rules for your allow list based on these files. Add the IP addresses to your allow list by using a custom header. IP addresses are not personal data Minions are deployed on servers, and the agents are expected to be activated using non-personal credentials. IP addresses associated with minions running on servers are not personal data under data protection and privacy laws. For more information, see the Synthetic's security documentation. Daily JSON listings for IP addresses IP addresses for released locations are subject to change. If a change is needed, we'll attempt to proactively notify customers prior to any changes via e-mail. You can also check the Explorers Hub for updates. Important Synthetics is adding new IP addresses on July 15 2021. Tip In the S3 URL paths for this feature, production represents US-based accounts and eu represents EU-based accounts. US accounts IP-only list DNS name-only list IP and DNS name list EU accounts IP-only list DNS name-only list IP and DNS name list Public minion locations and location labels The following table cross-references the synthetic's public minion locations with their location labels. You can query the location and locationLabel attributes from the SyntheticCheck and SyntheticRequest events. Public minion location Location label AWS_AP_EAST_1 \"Hong Kong, HK\" AWS_AP_SOUTH_1 \"Mumbai, IN\" AWS_AP_SOUTHEAST_1 \"Singapore, SG\" AWS_AP_NORTHEAST_2 \"Seoul, KR\" AWS_AP_NORTHEAST_1 \"Tokyo, JP\" AWS_AP_SOUTHEAST_2 \"Sydney, AU\" AWS_US_WEST_1 \"San Francisco, CA, USA\" AWS_US_WEST_2 \"Portland, OR, USA\" AWS_US_EAST_2 \"Columbus, OH, USA\" AWS_US_EAST_1 \"Washington, DC, USA\" AWS_CA_CENTRAL_1 \"Montreal, Québec, CA\" AWS_SA_EAST_1 \"São Paulo, BR\" AWS_EU_WEST_1 \"Dublin, IE\" AWS_EU_WEST_2 \"London, England, UK\" AWS_EU_WEST_3 \"Paris, FR\" AWS_EU_CENTRAL_1 \"Frankfurt, DE\" AWS_EU_NORTH_1 \"Stockholm, SE\" AWS_EU_SOUTH_1 \"Milan, IT\" AWS_ME_SOUTH_1 \"Manama, BH\" AWS_AF_SOUTH_1 \"Cape Town, ZA\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.23163,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "sections": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "New Relic uses a group of minions to execute your <em>synthetic</em> monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses"
      },
      "id": "6045257d28ccbcdc552c60a5"
    },
    {
      "sections": [
        "Upcoming synthetic monitor public minion IP addresses",
        "US public minions: Upcoming IP addresses",
        "EU public minions: Upcoming IP addresses"
      ],
      "title": "Upcoming synthetic monitor public minion IP addresses",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "81c0e0d3f87a627ad01f220f215f7b848f54608d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/new-synthetic-public-minion-ips/",
      "published_at": "2021-12-10T13:25:24Z",
      "updated_at": "2021-04-04T20:14:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "On July 15 2021, we'll be adding new IP addresses for several synthetics locations for both US locations and EU locations. To ensure your monitors are not affected by these changes, please add the appropriate IP addresses to your firewalls allow list. For the current list of IP addresses and more about this topic, see Synthetic monitor public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 54.250.11.193 3.113.102.86 52.193.74.189 18.177.40.17 ec2-54-250-11-193.ap-northeast-1.compute.amazonaws.com ec2-3-113-102-86.ap-northeast-1.compute.amazonaws.com ec2-52-193-74-189.ap-northeast-1.compute.amazonaws.com ec2-18-177-40-17.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 3.34.173.249 52.79.48.153 ec2-3-34-173-249.ap-northeast-2.compute.amazonaws.com ec2-52-79-48-153.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 65.1.222.35 ec2-65-1-222-35.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 52.76.41.181 54.179.195.220 18.138.16.42 ec2-52-76-41-181.ap-southeast-1.compute.amazonaws.com ec2-54-179-195-220.ap-southeast-1.compute.amazonaws.com ec2-18-138-16-42.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 3.96.243.128 3.97.226.155 ec2-3-96-243-128.ca-central-1.compute.amazonaws.com ec2-3-97-226-155.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.94.27.80 18.229.241.206 ec2-54-94-27-80.sa-east-1.compute.amazonaws.com ec2-18-229-241-206.sa-east-1.compute.amazonaws.com AWS_US_WEST_2 \"Portland, OR, USA\" 44.236.111.66 54.203.108.135 ec2-44-236-111-66.us-west-2.compute.amazonaws.com ec2-54-203-108-135.us-west-2.compute.amazonaws.com EU public minions: Upcoming IP addresses The following table lists the upcoming IP addresses that will be added to public minions on July 15 2021 for EU customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 35.72.129.240 35.73.187.89 ec2-35-72-129-240.ap-northeast-1.compute.amazonaws.com ec2-35-73-187-89.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 13.125.155.211 15.164.119.0 ec2-13-125-155-211.ap-northeast-2.compute.amazonaws.com ec2-15-164-119-0.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 15.207.93.61 ec2-15-207-93-61.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 3.0.28.216 ec2-3-0-28-216.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 99.79.17.185 ec2-99-79-17-185.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.207.198.234 ec2-54-207-198-234.sa-east-1.compute.amazonaws.com",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.90244,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "sections": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " about this topic, see <em>Synthetic</em> <em>monitor</em> public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses"
      },
      "id": "606a1e4364441fbec2617a7c"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/identify-synthetic-monitoring-requests-your-app": [
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.1631,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Synthetic monitor public minion IPs",
        "IP addresses are not personal data",
        "Daily JSON listings for IP addresses",
        "Important",
        "Tip",
        "Public minion locations and location labels"
      ],
      "title": "Synthetic monitor public minion IPs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "773534b4f076c3b421b6e0ca0dfc26f1e1ef6f73",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/",
      "published_at": "2021-12-10T13:22:29Z",
      "updated_at": "2021-08-08T21:09:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic uses a group of minions to execute your synthetic monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses are publicly available in JSON format, so you can easily read and parse them. Recommendation: For easier maintenance, use these options: Automate your rules for your allow list based on these files. Add the IP addresses to your allow list by using a custom header. IP addresses are not personal data Minions are deployed on servers, and the agents are expected to be activated using non-personal credentials. IP addresses associated with minions running on servers are not personal data under data protection and privacy laws. For more information, see the Synthetic's security documentation. Daily JSON listings for IP addresses IP addresses for released locations are subject to change. If a change is needed, we'll attempt to proactively notify customers prior to any changes via e-mail. You can also check the Explorers Hub for updates. Important Synthetics is adding new IP addresses on July 15 2021. Tip In the S3 URL paths for this feature, production represents US-based accounts and eu represents EU-based accounts. US accounts IP-only list DNS name-only list IP and DNS name list EU accounts IP-only list DNS name-only list IP and DNS name list Public minion locations and location labels The following table cross-references the synthetic's public minion locations with their location labels. You can query the location and locationLabel attributes from the SyntheticCheck and SyntheticRequest events. Public minion location Location label AWS_AP_EAST_1 \"Hong Kong, HK\" AWS_AP_SOUTH_1 \"Mumbai, IN\" AWS_AP_SOUTHEAST_1 \"Singapore, SG\" AWS_AP_NORTHEAST_2 \"Seoul, KR\" AWS_AP_NORTHEAST_1 \"Tokyo, JP\" AWS_AP_SOUTHEAST_2 \"Sydney, AU\" AWS_US_WEST_1 \"San Francisco, CA, USA\" AWS_US_WEST_2 \"Portland, OR, USA\" AWS_US_EAST_2 \"Columbus, OH, USA\" AWS_US_EAST_1 \"Washington, DC, USA\" AWS_CA_CENTRAL_1 \"Montreal, Québec, CA\" AWS_SA_EAST_1 \"São Paulo, BR\" AWS_EU_WEST_1 \"Dublin, IE\" AWS_EU_WEST_2 \"London, England, UK\" AWS_EU_WEST_3 \"Paris, FR\" AWS_EU_CENTRAL_1 \"Frankfurt, DE\" AWS_EU_NORTH_1 \"Stockholm, SE\" AWS_EU_SOUTH_1 \"Milan, IT\" AWS_ME_SOUTH_1 \"Manama, BH\" AWS_AF_SOUTH_1 \"Cape Town, ZA\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.23163,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "sections": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "New Relic uses a group of minions to execute your <em>synthetic</em> monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses"
      },
      "id": "6045257d28ccbcdc552c60a5"
    },
    {
      "sections": [
        "Compare page load performance in browser and synthetic monitoring",
        "Compare performance and trends",
        "What you need",
        "Enable comparison data",
        "Enable comparative charting from Synthetics UI",
        "Enable comparative charting from browser monitoring UI",
        "View comparison data",
        "Hide or return comparison data",
        "Data sources"
      ],
      "title": "Compare page load performance in browser and synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "a789c407a0fecbd2ce888fdee7805abe8152f0a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring/",
      "published_at": "2021-12-10T13:45:06Z",
      "updated_at": "2021-07-09T23:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring regularly checks your websites, critical business transactions, and API endpoints to measure optimal performance. Browser monitoring tracks the actual results of webpage performance across all variations of devices, browsers, and connection speeds. Used together, they provide a direct page load time comparison between real user (browser) interactions and the synthetic monitors. Compare performance and trends New Relic's comparative charting feature helps operations managers and teams by providing: Benchmarks for page load times Additional insights to help you plan where to optimize your site Comparisons of synthetic trends vs. actual browser performance without needing to switch between our monitoring capabilities. For example, during a page outage, you can compare synthetic monitoring trends to actual browser monitoring comparisons to see if an issue is also visible in Synthetics UI, or if it is caused by variables outside of New Relic. This helps you more efficiently know where to take action. What you need The comparative charting feature requires: Browser monitoring enabled with the browser SPA agent (version 885 or higher). A synthetic browser or scripted monitor with one or more tests on the same URLs monitored by the browser agent. After you enable the comparative charting feature either from synthetic or from browser monitoring, no additional setup is required. The comparative charting feature will appear when New Relic finds matching URLs. Enable comparison data After you enable the comparative charting feature from either synthetic or browser monitoring, no additional setup is required. The comparative charting feature will appear whenever synthetics or browser monitoring finds matching URLs. Enable comparative charting from Synthetics UI To enable the comparative charting feature from Synthetics UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. Above the selected monitor's Availability chart, select the ellipsis icon. Select Enable Synthetics comparison. Enable comparative charting from browser monitoring UI To enable the comparison data feature from browser monitoring: Go to one.newrelic.com > Browser > (select a browser app) > Page views. Select a page monitored by synthetic monitoring. From the selected page's Performance tab, select the ellipsis icon. Select Enable Synthetics comparison. View comparison data The comparative charting feature appears whenever synthetic monitoring identifies a URL match with browser monitoring and can compare it. You can compare browser and synthetic's performance either from the synthetic monitoring Summary page or from the browser monitoring Page views page (for browser apps or single page apps) without needing to switch between New Relic capabilities. Based on the selected data sources, the summary shows: Overall speed percentage comparison between browser (real user) page views and any matching URLs found in synthetic monitors that the user has permissions to view Number of URLs found in synthetic monitors that match the browser rollup URL To view the comparative charting summary: From synthetic monitoring UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. OR From browser monitoring UI: Go to one.newrelic.com > Browser > (select a browser app) > Page views, then select a page monitored by synthetic monitoring. Review the comparative charting feature's summary of overall speed percentage and number of matching URLs. To view additional details, select the summary's right arrow icon. Please note that in some cases the simple browser monitor ends before the browser agent has had a chance to collect the BrowserInteraction event. In this case, no comparative charting data is displayed in the UI. In order to resolve this issue, create a scripted browser monitor instead, and add a call to wait (sleep) after the page is loaded. Here is an example: $browser.get('https://www.mywebsite.com').then(function(){ return $browser.sleep(1000); }) Copy Hide or return comparison data To hide the comparative charting feature, select the ellipsis icon. To keep it visible but move it away from the top of the page, select Move to bottom. To return it to its original place on the page, select Move to top. To remove it from the page, select Hide all Synthetics/Browser comparisons. To return it to the page after removing it, follow standard procedures to enable comparison charting. Data sources New Relic uses these data sources for the synthetics and browser comparison in the UI. For deeper analysis of the comparative chart data you see in the UI, use the query builder to run NRQL queries. Variable Description Monitor account ID The account from which you are running the monitor: SELECT monitorAccountId FROM BrowserInteraction Copy Monitor ID The unique ID assigned to your synthetic monitor: SELECT monitorId FROM BrowserInteraction Copy Monitor job ID The ID of a single synthetics monitor run, which began at a specific time and originated from a specific location: SELECT monitorJobId FROM BrowserInteraction LIMIT 1 Copy Real user average The average page load time for real users viewing your website (excludes synthetic monitors). Real user page views Page view details coming from visitors to your website (exclude synthetic monitors). Synthetic's average The average page load time from the synthetic simple or scripted monitors that ran on your website. Synthetic's page views Only traffic generated by synthetic simple or scripted monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.22299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "sections": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " permissions to view Number of URLs found in <em>synthetic</em> monitors that match the browser rollup URL To view the comparative charting summary: From <em>synthetic</em> <em>monitoring</em> UI: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Summary. OR From browser <em>monitoring</em> UI: Go to one.newrelic.com &gt; Browser"
      },
      "id": "604525b7e7b9d251f85799e1"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/new-synthetic-public-minion-ips": [
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.1631,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Synthetic monitor public minion IPs",
        "IP addresses are not personal data",
        "Daily JSON listings for IP addresses",
        "Important",
        "Tip",
        "Public minion locations and location labels"
      ],
      "title": "Synthetic monitor public minion IPs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "773534b4f076c3b421b6e0ca0dfc26f1e1ef6f73",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/",
      "published_at": "2021-12-10T13:22:29Z",
      "updated_at": "2021-08-08T21:09:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic uses a group of minions to execute your synthetic monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses are publicly available in JSON format, so you can easily read and parse them. Recommendation: For easier maintenance, use these options: Automate your rules for your allow list based on these files. Add the IP addresses to your allow list by using a custom header. IP addresses are not personal data Minions are deployed on servers, and the agents are expected to be activated using non-personal credentials. IP addresses associated with minions running on servers are not personal data under data protection and privacy laws. For more information, see the Synthetic's security documentation. Daily JSON listings for IP addresses IP addresses for released locations are subject to change. If a change is needed, we'll attempt to proactively notify customers prior to any changes via e-mail. You can also check the Explorers Hub for updates. Important Synthetics is adding new IP addresses on July 15 2021. Tip In the S3 URL paths for this feature, production represents US-based accounts and eu represents EU-based accounts. US accounts IP-only list DNS name-only list IP and DNS name list EU accounts IP-only list DNS name-only list IP and DNS name list Public minion locations and location labels The following table cross-references the synthetic's public minion locations with their location labels. You can query the location and locationLabel attributes from the SyntheticCheck and SyntheticRequest events. Public minion location Location label AWS_AP_EAST_1 \"Hong Kong, HK\" AWS_AP_SOUTH_1 \"Mumbai, IN\" AWS_AP_SOUTHEAST_1 \"Singapore, SG\" AWS_AP_NORTHEAST_2 \"Seoul, KR\" AWS_AP_NORTHEAST_1 \"Tokyo, JP\" AWS_AP_SOUTHEAST_2 \"Sydney, AU\" AWS_US_WEST_1 \"San Francisco, CA, USA\" AWS_US_WEST_2 \"Portland, OR, USA\" AWS_US_EAST_2 \"Columbus, OH, USA\" AWS_US_EAST_1 \"Washington, DC, USA\" AWS_CA_CENTRAL_1 \"Montreal, Québec, CA\" AWS_SA_EAST_1 \"São Paulo, BR\" AWS_EU_WEST_1 \"Dublin, IE\" AWS_EU_WEST_2 \"London, England, UK\" AWS_EU_WEST_3 \"Paris, FR\" AWS_EU_CENTRAL_1 \"Frankfurt, DE\" AWS_EU_NORTH_1 \"Stockholm, SE\" AWS_EU_SOUTH_1 \"Milan, IT\" AWS_ME_SOUTH_1 \"Manama, BH\" AWS_AF_SOUTH_1 \"Cape Town, ZA\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.23163,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "sections": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "New Relic uses a group of minions to execute your <em>synthetic</em> monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses"
      },
      "id": "6045257d28ccbcdc552c60a5"
    },
    {
      "sections": [
        "Compare page load performance in browser and synthetic monitoring",
        "Compare performance and trends",
        "What you need",
        "Enable comparison data",
        "Enable comparative charting from Synthetics UI",
        "Enable comparative charting from browser monitoring UI",
        "View comparison data",
        "Hide or return comparison data",
        "Data sources"
      ],
      "title": "Compare page load performance in browser and synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "a789c407a0fecbd2ce888fdee7805abe8152f0a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring/",
      "published_at": "2021-12-10T13:45:06Z",
      "updated_at": "2021-07-09T23:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring regularly checks your websites, critical business transactions, and API endpoints to measure optimal performance. Browser monitoring tracks the actual results of webpage performance across all variations of devices, browsers, and connection speeds. Used together, they provide a direct page load time comparison between real user (browser) interactions and the synthetic monitors. Compare performance and trends New Relic's comparative charting feature helps operations managers and teams by providing: Benchmarks for page load times Additional insights to help you plan where to optimize your site Comparisons of synthetic trends vs. actual browser performance without needing to switch between our monitoring capabilities. For example, during a page outage, you can compare synthetic monitoring trends to actual browser monitoring comparisons to see if an issue is also visible in Synthetics UI, or if it is caused by variables outside of New Relic. This helps you more efficiently know where to take action. What you need The comparative charting feature requires: Browser monitoring enabled with the browser SPA agent (version 885 or higher). A synthetic browser or scripted monitor with one or more tests on the same URLs monitored by the browser agent. After you enable the comparative charting feature either from synthetic or from browser monitoring, no additional setup is required. The comparative charting feature will appear when New Relic finds matching URLs. Enable comparison data After you enable the comparative charting feature from either synthetic or browser monitoring, no additional setup is required. The comparative charting feature will appear whenever synthetics or browser monitoring finds matching URLs. Enable comparative charting from Synthetics UI To enable the comparative charting feature from Synthetics UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. Above the selected monitor's Availability chart, select the ellipsis icon. Select Enable Synthetics comparison. Enable comparative charting from browser monitoring UI To enable the comparison data feature from browser monitoring: Go to one.newrelic.com > Browser > (select a browser app) > Page views. Select a page monitored by synthetic monitoring. From the selected page's Performance tab, select the ellipsis icon. Select Enable Synthetics comparison. View comparison data The comparative charting feature appears whenever synthetic monitoring identifies a URL match with browser monitoring and can compare it. You can compare browser and synthetic's performance either from the synthetic monitoring Summary page or from the browser monitoring Page views page (for browser apps or single page apps) without needing to switch between New Relic capabilities. Based on the selected data sources, the summary shows: Overall speed percentage comparison between browser (real user) page views and any matching URLs found in synthetic monitors that the user has permissions to view Number of URLs found in synthetic monitors that match the browser rollup URL To view the comparative charting summary: From synthetic monitoring UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. OR From browser monitoring UI: Go to one.newrelic.com > Browser > (select a browser app) > Page views, then select a page monitored by synthetic monitoring. Review the comparative charting feature's summary of overall speed percentage and number of matching URLs. To view additional details, select the summary's right arrow icon. Please note that in some cases the simple browser monitor ends before the browser agent has had a chance to collect the BrowserInteraction event. In this case, no comparative charting data is displayed in the UI. In order to resolve this issue, create a scripted browser monitor instead, and add a call to wait (sleep) after the page is loaded. Here is an example: $browser.get('https://www.mywebsite.com').then(function(){ return $browser.sleep(1000); }) Copy Hide or return comparison data To hide the comparative charting feature, select the ellipsis icon. To keep it visible but move it away from the top of the page, select Move to bottom. To return it to its original place on the page, select Move to top. To remove it from the page, select Hide all Synthetics/Browser comparisons. To return it to the page after removing it, follow standard procedures to enable comparison charting. Data sources New Relic uses these data sources for the synthetics and browser comparison in the UI. For deeper analysis of the comparative chart data you see in the UI, use the query builder to run NRQL queries. Variable Description Monitor account ID The account from which you are running the monitor: SELECT monitorAccountId FROM BrowserInteraction Copy Monitor ID The unique ID assigned to your synthetic monitor: SELECT monitorId FROM BrowserInteraction Copy Monitor job ID The ID of a single synthetics monitor run, which began at a specific time and originated from a specific location: SELECT monitorJobId FROM BrowserInteraction LIMIT 1 Copy Real user average The average page load time for real users viewing your website (excludes synthetic monitors). Real user page views Page view details coming from visitors to your website (exclude synthetic monitors). Synthetic's average The average page load time from the synthetic simple or scripted monitors that ran on your website. Synthetic's page views Only traffic generated by synthetic simple or scripted monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.22299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "sections": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " permissions to view Number of URLs found in <em>synthetic</em> monitors that match the browser rollup URL To view the comparative charting summary: From <em>synthetic</em> <em>monitoring</em> UI: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Summary. OR From browser <em>monitoring</em> UI: Go to one.newrelic.com &gt; Browser"
      },
      "id": "604525b7e7b9d251f85799e1"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/synthetic-monitoring-audit-log-track-changes-made-users": [
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.16307,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Synthetic monitor public minion IPs",
        "IP addresses are not personal data",
        "Daily JSON listings for IP addresses",
        "Important",
        "Tip",
        "Public minion locations and location labels"
      ],
      "title": "Synthetic monitor public minion IPs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "773534b4f076c3b421b6e0ca0dfc26f1e1ef6f73",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/",
      "published_at": "2021-12-10T13:22:29Z",
      "updated_at": "2021-08-08T21:09:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic uses a group of minions to execute your synthetic monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses are publicly available in JSON format, so you can easily read and parse them. Recommendation: For easier maintenance, use these options: Automate your rules for your allow list based on these files. Add the IP addresses to your allow list by using a custom header. IP addresses are not personal data Minions are deployed on servers, and the agents are expected to be activated using non-personal credentials. IP addresses associated with minions running on servers are not personal data under data protection and privacy laws. For more information, see the Synthetic's security documentation. Daily JSON listings for IP addresses IP addresses for released locations are subject to change. If a change is needed, we'll attempt to proactively notify customers prior to any changes via e-mail. You can also check the Explorers Hub for updates. Important Synthetics is adding new IP addresses on July 15 2021. Tip In the S3 URL paths for this feature, production represents US-based accounts and eu represents EU-based accounts. US accounts IP-only list DNS name-only list IP and DNS name list EU accounts IP-only list DNS name-only list IP and DNS name list Public minion locations and location labels The following table cross-references the synthetic's public minion locations with their location labels. You can query the location and locationLabel attributes from the SyntheticCheck and SyntheticRequest events. Public minion location Location label AWS_AP_EAST_1 \"Hong Kong, HK\" AWS_AP_SOUTH_1 \"Mumbai, IN\" AWS_AP_SOUTHEAST_1 \"Singapore, SG\" AWS_AP_NORTHEAST_2 \"Seoul, KR\" AWS_AP_NORTHEAST_1 \"Tokyo, JP\" AWS_AP_SOUTHEAST_2 \"Sydney, AU\" AWS_US_WEST_1 \"San Francisco, CA, USA\" AWS_US_WEST_2 \"Portland, OR, USA\" AWS_US_EAST_2 \"Columbus, OH, USA\" AWS_US_EAST_1 \"Washington, DC, USA\" AWS_CA_CENTRAL_1 \"Montreal, Québec, CA\" AWS_SA_EAST_1 \"São Paulo, BR\" AWS_EU_WEST_1 \"Dublin, IE\" AWS_EU_WEST_2 \"London, England, UK\" AWS_EU_WEST_3 \"Paris, FR\" AWS_EU_CENTRAL_1 \"Frankfurt, DE\" AWS_EU_NORTH_1 \"Stockholm, SE\" AWS_EU_SOUTH_1 \"Milan, IT\" AWS_ME_SOUTH_1 \"Manama, BH\" AWS_AF_SOUTH_1 \"Cape Town, ZA\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.23163,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "sections": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "New Relic uses a group of minions to execute your <em>synthetic</em> monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses"
      },
      "id": "6045257d28ccbcdc552c60a5"
    },
    {
      "sections": [
        "Compare page load performance in browser and synthetic monitoring",
        "Compare performance and trends",
        "What you need",
        "Enable comparison data",
        "Enable comparative charting from Synthetics UI",
        "Enable comparative charting from browser monitoring UI",
        "View comparison data",
        "Hide or return comparison data",
        "Data sources"
      ],
      "title": "Compare page load performance in browser and synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "a789c407a0fecbd2ce888fdee7805abe8152f0a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring/",
      "published_at": "2021-12-10T13:45:06Z",
      "updated_at": "2021-07-09T23:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring regularly checks your websites, critical business transactions, and API endpoints to measure optimal performance. Browser monitoring tracks the actual results of webpage performance across all variations of devices, browsers, and connection speeds. Used together, they provide a direct page load time comparison between real user (browser) interactions and the synthetic monitors. Compare performance and trends New Relic's comparative charting feature helps operations managers and teams by providing: Benchmarks for page load times Additional insights to help you plan where to optimize your site Comparisons of synthetic trends vs. actual browser performance without needing to switch between our monitoring capabilities. For example, during a page outage, you can compare synthetic monitoring trends to actual browser monitoring comparisons to see if an issue is also visible in Synthetics UI, or if it is caused by variables outside of New Relic. This helps you more efficiently know where to take action. What you need The comparative charting feature requires: Browser monitoring enabled with the browser SPA agent (version 885 or higher). A synthetic browser or scripted monitor with one or more tests on the same URLs monitored by the browser agent. After you enable the comparative charting feature either from synthetic or from browser monitoring, no additional setup is required. The comparative charting feature will appear when New Relic finds matching URLs. Enable comparison data After you enable the comparative charting feature from either synthetic or browser monitoring, no additional setup is required. The comparative charting feature will appear whenever synthetics or browser monitoring finds matching URLs. Enable comparative charting from Synthetics UI To enable the comparative charting feature from Synthetics UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. Above the selected monitor's Availability chart, select the ellipsis icon. Select Enable Synthetics comparison. Enable comparative charting from browser monitoring UI To enable the comparison data feature from browser monitoring: Go to one.newrelic.com > Browser > (select a browser app) > Page views. Select a page monitored by synthetic monitoring. From the selected page's Performance tab, select the ellipsis icon. Select Enable Synthetics comparison. View comparison data The comparative charting feature appears whenever synthetic monitoring identifies a URL match with browser monitoring and can compare it. You can compare browser and synthetic's performance either from the synthetic monitoring Summary page or from the browser monitoring Page views page (for browser apps or single page apps) without needing to switch between New Relic capabilities. Based on the selected data sources, the summary shows: Overall speed percentage comparison between browser (real user) page views and any matching URLs found in synthetic monitors that the user has permissions to view Number of URLs found in synthetic monitors that match the browser rollup URL To view the comparative charting summary: From synthetic monitoring UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. OR From browser monitoring UI: Go to one.newrelic.com > Browser > (select a browser app) > Page views, then select a page monitored by synthetic monitoring. Review the comparative charting feature's summary of overall speed percentage and number of matching URLs. To view additional details, select the summary's right arrow icon. Please note that in some cases the simple browser monitor ends before the browser agent has had a chance to collect the BrowserInteraction event. In this case, no comparative charting data is displayed in the UI. In order to resolve this issue, create a scripted browser monitor instead, and add a call to wait (sleep) after the page is loaded. Here is an example: $browser.get('https://www.mywebsite.com').then(function(){ return $browser.sleep(1000); }) Copy Hide or return comparison data To hide the comparative charting feature, select the ellipsis icon. To keep it visible but move it away from the top of the page, select Move to bottom. To return it to its original place on the page, select Move to top. To remove it from the page, select Hide all Synthetics/Browser comparisons. To return it to the page after removing it, follow standard procedures to enable comparison charting. Data sources New Relic uses these data sources for the synthetics and browser comparison in the UI. For deeper analysis of the comparative chart data you see in the UI, use the query builder to run NRQL queries. Variable Description Monitor account ID The account from which you are running the monitor: SELECT monitorAccountId FROM BrowserInteraction Copy Monitor ID The unique ID assigned to your synthetic monitor: SELECT monitorId FROM BrowserInteraction Copy Monitor job ID The ID of a single synthetics monitor run, which began at a specific time and originated from a specific location: SELECT monitorJobId FROM BrowserInteraction LIMIT 1 Copy Real user average The average page load time for real users viewing your website (excludes synthetic monitors). Real user page views Page view details coming from visitors to your website (exclude synthetic monitors). Synthetic's average The average page load time from the synthetic simple or scripted monitors that ran on your website. Synthetic's page views Only traffic generated by synthetic simple or scripted monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.22299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "sections": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " permissions to view Number of URLs found in <em>synthetic</em> monitors that match the browser rollup URL To view the comparative charting summary: From <em>synthetic</em> <em>monitoring</em> UI: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Summary. OR From browser <em>monitoring</em> UI: Go to one.newrelic.com &gt; Browser"
      },
      "id": "604525b7e7b9d251f85799e1"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips": [
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.16307,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Compare page load performance in browser and synthetic monitoring",
        "Compare performance and trends",
        "What you need",
        "Enable comparison data",
        "Enable comparative charting from Synthetics UI",
        "Enable comparative charting from browser monitoring UI",
        "View comparison data",
        "Hide or return comparison data",
        "Data sources"
      ],
      "title": "Compare page load performance in browser and synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "a789c407a0fecbd2ce888fdee7805abe8152f0a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring/",
      "published_at": "2021-12-10T13:45:06Z",
      "updated_at": "2021-07-09T23:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring regularly checks your websites, critical business transactions, and API endpoints to measure optimal performance. Browser monitoring tracks the actual results of webpage performance across all variations of devices, browsers, and connection speeds. Used together, they provide a direct page load time comparison between real user (browser) interactions and the synthetic monitors. Compare performance and trends New Relic's comparative charting feature helps operations managers and teams by providing: Benchmarks for page load times Additional insights to help you plan where to optimize your site Comparisons of synthetic trends vs. actual browser performance without needing to switch between our monitoring capabilities. For example, during a page outage, you can compare synthetic monitoring trends to actual browser monitoring comparisons to see if an issue is also visible in Synthetics UI, or if it is caused by variables outside of New Relic. This helps you more efficiently know where to take action. What you need The comparative charting feature requires: Browser monitoring enabled with the browser SPA agent (version 885 or higher). A synthetic browser or scripted monitor with one or more tests on the same URLs monitored by the browser agent. After you enable the comparative charting feature either from synthetic or from browser monitoring, no additional setup is required. The comparative charting feature will appear when New Relic finds matching URLs. Enable comparison data After you enable the comparative charting feature from either synthetic or browser monitoring, no additional setup is required. The comparative charting feature will appear whenever synthetics or browser monitoring finds matching URLs. Enable comparative charting from Synthetics UI To enable the comparative charting feature from Synthetics UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. Above the selected monitor's Availability chart, select the ellipsis icon. Select Enable Synthetics comparison. Enable comparative charting from browser monitoring UI To enable the comparison data feature from browser monitoring: Go to one.newrelic.com > Browser > (select a browser app) > Page views. Select a page monitored by synthetic monitoring. From the selected page's Performance tab, select the ellipsis icon. Select Enable Synthetics comparison. View comparison data The comparative charting feature appears whenever synthetic monitoring identifies a URL match with browser monitoring and can compare it. You can compare browser and synthetic's performance either from the synthetic monitoring Summary page or from the browser monitoring Page views page (for browser apps or single page apps) without needing to switch between New Relic capabilities. Based on the selected data sources, the summary shows: Overall speed percentage comparison between browser (real user) page views and any matching URLs found in synthetic monitors that the user has permissions to view Number of URLs found in synthetic monitors that match the browser rollup URL To view the comparative charting summary: From synthetic monitoring UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. OR From browser monitoring UI: Go to one.newrelic.com > Browser > (select a browser app) > Page views, then select a page monitored by synthetic monitoring. Review the comparative charting feature's summary of overall speed percentage and number of matching URLs. To view additional details, select the summary's right arrow icon. Please note that in some cases the simple browser monitor ends before the browser agent has had a chance to collect the BrowserInteraction event. In this case, no comparative charting data is displayed in the UI. In order to resolve this issue, create a scripted browser monitor instead, and add a call to wait (sleep) after the page is loaded. Here is an example: $browser.get('https://www.mywebsite.com').then(function(){ return $browser.sleep(1000); }) Copy Hide or return comparison data To hide the comparative charting feature, select the ellipsis icon. To keep it visible but move it away from the top of the page, select Move to bottom. To return it to its original place on the page, select Move to top. To remove it from the page, select Hide all Synthetics/Browser comparisons. To return it to the page after removing it, follow standard procedures to enable comparison charting. Data sources New Relic uses these data sources for the synthetics and browser comparison in the UI. For deeper analysis of the comparative chart data you see in the UI, use the query builder to run NRQL queries. Variable Description Monitor account ID The account from which you are running the monitor: SELECT monitorAccountId FROM BrowserInteraction Copy Monitor ID The unique ID assigned to your synthetic monitor: SELECT monitorId FROM BrowserInteraction Copy Monitor job ID The ID of a single synthetics monitor run, which began at a specific time and originated from a specific location: SELECT monitorJobId FROM BrowserInteraction LIMIT 1 Copy Real user average The average page load time for real users viewing your website (excludes synthetic monitors). Real user page views Page view details coming from visitors to your website (exclude synthetic monitors). Synthetic's average The average page load time from the synthetic simple or scripted monitors that ran on your website. Synthetic's page views Only traffic generated by synthetic simple or scripted monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.22299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "sections": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " permissions to view Number of URLs found in <em>synthetic</em> monitors that match the browser rollup URL To view the comparative charting summary: From <em>synthetic</em> <em>monitoring</em> UI: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Summary. OR From browser <em>monitoring</em> UI: Go to one.newrelic.com &gt; Browser"
      },
      "id": "604525b7e7b9d251f85799e1"
    },
    {
      "sections": [
        "Upcoming synthetic monitor public minion IP addresses",
        "US public minions: Upcoming IP addresses",
        "EU public minions: Upcoming IP addresses"
      ],
      "title": "Upcoming synthetic monitor public minion IP addresses",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "81c0e0d3f87a627ad01f220f215f7b848f54608d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/new-synthetic-public-minion-ips/",
      "published_at": "2021-12-10T13:25:24Z",
      "updated_at": "2021-04-04T20:14:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "On July 15 2021, we'll be adding new IP addresses for several synthetics locations for both US locations and EU locations. To ensure your monitors are not affected by these changes, please add the appropriate IP addresses to your firewalls allow list. For the current list of IP addresses and more about this topic, see Synthetic monitor public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 54.250.11.193 3.113.102.86 52.193.74.189 18.177.40.17 ec2-54-250-11-193.ap-northeast-1.compute.amazonaws.com ec2-3-113-102-86.ap-northeast-1.compute.amazonaws.com ec2-52-193-74-189.ap-northeast-1.compute.amazonaws.com ec2-18-177-40-17.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 3.34.173.249 52.79.48.153 ec2-3-34-173-249.ap-northeast-2.compute.amazonaws.com ec2-52-79-48-153.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 65.1.222.35 ec2-65-1-222-35.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 52.76.41.181 54.179.195.220 18.138.16.42 ec2-52-76-41-181.ap-southeast-1.compute.amazonaws.com ec2-54-179-195-220.ap-southeast-1.compute.amazonaws.com ec2-18-138-16-42.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 3.96.243.128 3.97.226.155 ec2-3-96-243-128.ca-central-1.compute.amazonaws.com ec2-3-97-226-155.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.94.27.80 18.229.241.206 ec2-54-94-27-80.sa-east-1.compute.amazonaws.com ec2-18-229-241-206.sa-east-1.compute.amazonaws.com AWS_US_WEST_2 \"Portland, OR, USA\" 44.236.111.66 54.203.108.135 ec2-44-236-111-66.us-west-2.compute.amazonaws.com ec2-54-203-108-135.us-west-2.compute.amazonaws.com EU public minions: Upcoming IP addresses The following table lists the upcoming IP addresses that will be added to public minions on July 15 2021 for EU customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 35.72.129.240 35.73.187.89 ec2-35-72-129-240.ap-northeast-1.compute.amazonaws.com ec2-35-73-187-89.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 13.125.155.211 15.164.119.0 ec2-13-125-155-211.ap-northeast-2.compute.amazonaws.com ec2-15-164-119-0.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 15.207.93.61 ec2-15-207-93-61.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 3.0.28.216 ec2-3-0-28-216.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 99.79.17.185 ec2-99-79-17-185.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.207.198.234 ec2-54-207-198-234.sa-east-1.compute.amazonaws.com",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.90244,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "sections": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " about this topic, see <em>Synthetic</em> <em>monitor</em> public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses"
      },
      "id": "606a1e4364441fbec2617a7c"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring": [
    {
      "sections": [
        "Synthetic monitor public minion IPs",
        "IP addresses are not personal data",
        "Daily JSON listings for IP addresses",
        "Important",
        "Tip",
        "Public minion locations and location labels"
      ],
      "title": "Synthetic monitor public minion IPs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "773534b4f076c3b421b6e0ca0dfc26f1e1ef6f73",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/",
      "published_at": "2021-12-10T13:22:29Z",
      "updated_at": "2021-08-08T21:09:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic uses a group of minions to execute your synthetic monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses are publicly available in JSON format, so you can easily read and parse them. Recommendation: For easier maintenance, use these options: Automate your rules for your allow list based on these files. Add the IP addresses to your allow list by using a custom header. IP addresses are not personal data Minions are deployed on servers, and the agents are expected to be activated using non-personal credentials. IP addresses associated with minions running on servers are not personal data under data protection and privacy laws. For more information, see the Synthetic's security documentation. Daily JSON listings for IP addresses IP addresses for released locations are subject to change. If a change is needed, we'll attempt to proactively notify customers prior to any changes via e-mail. You can also check the Explorers Hub for updates. Important Synthetics is adding new IP addresses on July 15 2021. Tip In the S3 URL paths for this feature, production represents US-based accounts and eu represents EU-based accounts. US accounts IP-only list DNS name-only list IP and DNS name list EU accounts IP-only list DNS name-only list IP and DNS name list Public minion locations and location labels The following table cross-references the synthetic's public minion locations with their location labels. You can query the location and locationLabel attributes from the SyntheticCheck and SyntheticRequest events. Public minion location Location label AWS_AP_EAST_1 \"Hong Kong, HK\" AWS_AP_SOUTH_1 \"Mumbai, IN\" AWS_AP_SOUTHEAST_1 \"Singapore, SG\" AWS_AP_NORTHEAST_2 \"Seoul, KR\" AWS_AP_NORTHEAST_1 \"Tokyo, JP\" AWS_AP_SOUTHEAST_2 \"Sydney, AU\" AWS_US_WEST_1 \"San Francisco, CA, USA\" AWS_US_WEST_2 \"Portland, OR, USA\" AWS_US_EAST_2 \"Columbus, OH, USA\" AWS_US_EAST_1 \"Washington, DC, USA\" AWS_CA_CENTRAL_1 \"Montreal, Québec, CA\" AWS_SA_EAST_1 \"São Paulo, BR\" AWS_EU_WEST_1 \"Dublin, IE\" AWS_EU_WEST_2 \"London, England, UK\" AWS_EU_WEST_3 \"Paris, FR\" AWS_EU_CENTRAL_1 \"Frankfurt, DE\" AWS_EU_NORTH_1 \"Stockholm, SE\" AWS_EU_SOUTH_1 \"Milan, IT\" AWS_ME_SOUTH_1 \"Manama, BH\" AWS_AF_SOUTH_1 \"Cape Town, ZA\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.23163,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "sections": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "New Relic uses a group of minions to execute your <em>synthetic</em> monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses"
      },
      "id": "6045257d28ccbcdc552c60a5"
    },
    {
      "sections": [
        "Compare page load performance in browser and synthetic monitoring",
        "Compare performance and trends",
        "What you need",
        "Enable comparison data",
        "Enable comparative charting from Synthetics UI",
        "Enable comparative charting from browser monitoring UI",
        "View comparison data",
        "Hide or return comparison data",
        "Data sources"
      ],
      "title": "Compare page load performance in browser and synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "a789c407a0fecbd2ce888fdee7805abe8152f0a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring/",
      "published_at": "2021-12-10T13:45:06Z",
      "updated_at": "2021-07-09T23:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring regularly checks your websites, critical business transactions, and API endpoints to measure optimal performance. Browser monitoring tracks the actual results of webpage performance across all variations of devices, browsers, and connection speeds. Used together, they provide a direct page load time comparison between real user (browser) interactions and the synthetic monitors. Compare performance and trends New Relic's comparative charting feature helps operations managers and teams by providing: Benchmarks for page load times Additional insights to help you plan where to optimize your site Comparisons of synthetic trends vs. actual browser performance without needing to switch between our monitoring capabilities. For example, during a page outage, you can compare synthetic monitoring trends to actual browser monitoring comparisons to see if an issue is also visible in Synthetics UI, or if it is caused by variables outside of New Relic. This helps you more efficiently know where to take action. What you need The comparative charting feature requires: Browser monitoring enabled with the browser SPA agent (version 885 or higher). A synthetic browser or scripted monitor with one or more tests on the same URLs monitored by the browser agent. After you enable the comparative charting feature either from synthetic or from browser monitoring, no additional setup is required. The comparative charting feature will appear when New Relic finds matching URLs. Enable comparison data After you enable the comparative charting feature from either synthetic or browser monitoring, no additional setup is required. The comparative charting feature will appear whenever synthetics or browser monitoring finds matching URLs. Enable comparative charting from Synthetics UI To enable the comparative charting feature from Synthetics UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. Above the selected monitor's Availability chart, select the ellipsis icon. Select Enable Synthetics comparison. Enable comparative charting from browser monitoring UI To enable the comparison data feature from browser monitoring: Go to one.newrelic.com > Browser > (select a browser app) > Page views. Select a page monitored by synthetic monitoring. From the selected page's Performance tab, select the ellipsis icon. Select Enable Synthetics comparison. View comparison data The comparative charting feature appears whenever synthetic monitoring identifies a URL match with browser monitoring and can compare it. You can compare browser and synthetic's performance either from the synthetic monitoring Summary page or from the browser monitoring Page views page (for browser apps or single page apps) without needing to switch between New Relic capabilities. Based on the selected data sources, the summary shows: Overall speed percentage comparison between browser (real user) page views and any matching URLs found in synthetic monitors that the user has permissions to view Number of URLs found in synthetic monitors that match the browser rollup URL To view the comparative charting summary: From synthetic monitoring UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. OR From browser monitoring UI: Go to one.newrelic.com > Browser > (select a browser app) > Page views, then select a page monitored by synthetic monitoring. Review the comparative charting feature's summary of overall speed percentage and number of matching URLs. To view additional details, select the summary's right arrow icon. Please note that in some cases the simple browser monitor ends before the browser agent has had a chance to collect the BrowserInteraction event. In this case, no comparative charting data is displayed in the UI. In order to resolve this issue, create a scripted browser monitor instead, and add a call to wait (sleep) after the page is loaded. Here is an example: $browser.get('https://www.mywebsite.com').then(function(){ return $browser.sleep(1000); }) Copy Hide or return comparison data To hide the comparative charting feature, select the ellipsis icon. To keep it visible but move it away from the top of the page, select Move to bottom. To return it to its original place on the page, select Move to top. To remove it from the page, select Hide all Synthetics/Browser comparisons. To return it to the page after removing it, follow standard procedures to enable comparison charting. Data sources New Relic uses these data sources for the synthetics and browser comparison in the UI. For deeper analysis of the comparative chart data you see in the UI, use the query builder to run NRQL queries. Variable Description Monitor account ID The account from which you are running the monitor: SELECT monitorAccountId FROM BrowserInteraction Copy Monitor ID The unique ID assigned to your synthetic monitor: SELECT monitorId FROM BrowserInteraction Copy Monitor job ID The ID of a single synthetics monitor run, which began at a specific time and originated from a specific location: SELECT monitorJobId FROM BrowserInteraction LIMIT 1 Copy Real user average The average page load time for real users viewing your website (excludes synthetic monitors). Real user page views Page view details coming from visitors to your website (exclude synthetic monitors). Synthetic's average The average page load time from the synthetic simple or scripted monitors that ran on your website. Synthetic's page views Only traffic generated by synthetic simple or scripted monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.22299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "sections": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " permissions to view Number of URLs found in <em>synthetic</em> monitors that match the browser rollup URL To view the comparative charting summary: From <em>synthetic</em> <em>monitoring</em> UI: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Summary. OR From browser <em>monitoring</em> UI: Go to one.newrelic.com &gt; Browser"
      },
      "id": "604525b7e7b9d251f85799e1"
    },
    {
      "sections": [
        "Upcoming synthetic monitor public minion IP addresses",
        "US public minions: Upcoming IP addresses",
        "EU public minions: Upcoming IP addresses"
      ],
      "title": "Upcoming synthetic monitor public minion IP addresses",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "81c0e0d3f87a627ad01f220f215f7b848f54608d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/new-synthetic-public-minion-ips/",
      "published_at": "2021-12-10T13:25:24Z",
      "updated_at": "2021-04-04T20:14:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "On July 15 2021, we'll be adding new IP addresses for several synthetics locations for both US locations and EU locations. To ensure your monitors are not affected by these changes, please add the appropriate IP addresses to your firewalls allow list. For the current list of IP addresses and more about this topic, see Synthetic monitor public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 54.250.11.193 3.113.102.86 52.193.74.189 18.177.40.17 ec2-54-250-11-193.ap-northeast-1.compute.amazonaws.com ec2-3-113-102-86.ap-northeast-1.compute.amazonaws.com ec2-52-193-74-189.ap-northeast-1.compute.amazonaws.com ec2-18-177-40-17.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 3.34.173.249 52.79.48.153 ec2-3-34-173-249.ap-northeast-2.compute.amazonaws.com ec2-52-79-48-153.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 65.1.222.35 ec2-65-1-222-35.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 52.76.41.181 54.179.195.220 18.138.16.42 ec2-52-76-41-181.ap-southeast-1.compute.amazonaws.com ec2-54-179-195-220.ap-southeast-1.compute.amazonaws.com ec2-18-138-16-42.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 3.96.243.128 3.97.226.155 ec2-3-96-243-128.ca-central-1.compute.amazonaws.com ec2-3-97-226-155.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.94.27.80 18.229.241.206 ec2-54-94-27-80.sa-east-1.compute.amazonaws.com ec2-18-229-241-206.sa-east-1.compute.amazonaws.com AWS_US_WEST_2 \"Portland, OR, USA\" 44.236.111.66 54.203.108.135 ec2-44-236-111-66.us-west-2.compute.amazonaws.com ec2-54-203-108-135.us-west-2.compute.amazonaws.com EU public minions: Upcoming IP addresses The following table lists the upcoming IP addresses that will be added to public minions on July 15 2021 for EU customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 35.72.129.240 35.73.187.89 ec2-35-72-129-240.ap-northeast-1.compute.amazonaws.com ec2-35-73-187-89.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 13.125.155.211 15.164.119.0 ec2-13-125-155-211.ap-northeast-2.compute.amazonaws.com ec2-15-164-119-0.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 15.207.93.61 ec2-15-207-93-61.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 3.0.28.216 ec2-3-0-28-216.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 99.79.17.185 ec2-99-79-17-185.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.207.198.234 ec2-54-207-198-234.sa-east-1.compute.amazonaws.com",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.90244,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "sections": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " about this topic, see <em>Synthetic</em> <em>monitor</em> public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses"
      },
      "id": "606a1e4364441fbec2617a7c"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/getting-started/get-started-synthetic-monitoring": [
    {
      "sections": [
        "Browser Summary page",
        "View the Summary page",
        "Core Web Vitals widgets",
        "User time on the site",
        "Initial page load and route change chart",
        "User-centric page load times chart",
        "Throughput chart",
        "Tip",
        "Front end vs. back end chart",
        "First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL",
        "Related Entities widget",
        "View Synthetics monitors"
      ],
      "title": "Browser Summary page",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "a69bb31a3bff73ef8badce5ce435da62e9e7b644",
      "image": "https://docs.newrelic.com/static/e61bbb246d462250e94c99bf637b9cca/c1b63/browser_summary_page.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/browser-summary-page/",
      "published_at": "2021-12-10T02:30:10Z",
      "updated_at": "2021-12-10T02:30:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's Summary page summarizes the real-user browser performance of your app. Use the Summary page to: View trends in an app's browser-side performance Quickly troubleshoot page load timing issues Navigate to other browser UI pages View the Summary page To view a summary of browser performance for an app: Go to one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. Alternatively, go to one.newrelic.com, click Browser, and select an app from the Browser index. From the app's Summary page, use standard New Relic page functions to drill down into detailed information. one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the browser apps index, the Summary page shows a summary of browser performance for that app. The Summary page includes: Core Web Vitals widgets User time on the site Initial page load and route change chart User-centric page load times chart Throughput chart Front end vs. back end chart First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL Related Entities widget View Synthetics monitors Core Web Vitals widgets The Core Web Vitals widgets show how your browser performs according to Google's Core Web Vitals. The Core Web Vitals widgets include: LCP - Largest Contentful Paint FID - First Input Delay CLS - Cumulative Layout Shift User time on the site The User time on the site widget shows the time a user remains on the site. Initial page load and route change chart The Initial page load and route change chart shows the load time of a traditional URL change stemming from a load or reload of a URL. This chart appears with more detail about the page load timing process on the page load time page. User-centric page load times chart The User-centric page load times chart shows the load time of a page for a user. This chart appears with more detail about the page load timing process on the page load time page. Throughput chart The Throughput chart displays browser throughput as pages per minute (ppm). The value in the upper right of the chart is the average value for the selected time range. If you have enabled SPA monitoring enabled and the Summary page shows the SPA load time chart, the Throughput chart will also use SPA data. Tip App server requests per minute (rpm) may show a different measurement than the browser page load timing's pages per minute (ppm). Front end vs. back end chart The Front end vs. back end chart links to the connect APM service application. For details on APM and tracing, see Language agents and distributed tracing. First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL You'll also see summary versions of these metrics from the page load time page and JavaScript errors page: First interaction by device type First interaction by user agent JavaScript errors Longest first input delay by URL Related Entities widget The Related Entities widget shows all the entities that are related to the browser. To understand more about connections between entities, read about Entity relationships. View Synthetics monitors The button directs you to the Synthetics page. To read more about Synthetics, see Synthetic monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.5438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View <em>Synthetics</em> <em>monitors</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " page: First interaction by device type First interaction by user agent JavaScript errors Longest first input delay by URL Related Entities widget The Related Entities widget shows all the entities that are related to the browser. To understand more about connections between entities, read about Entity relationships. View <em>Synthetics</em> monitors The button directs you to the <em>Synthetics</em> page. To read more about <em>Synthetics</em>, see <em>Synthetic</em> <em>monitoring</em>."
      },
      "id": "60440d9c196a674ac8960f5b"
    },
    {
      "sections": [
        "Types of synthetic monitors",
        "Types of monitors"
      ],
      "title": "Types of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "f7fe7faff740058c77bdf27b2c1bfb5c6a206b40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/types-synthetic-monitors/",
      "published_at": "2021-12-09T21:11:48Z",
      "updated_at": "2021-10-18T21:27:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can proactively monitor your website or API endpoints with synthetic monitors. Depending on the type of monitor, you can: Add and edit monitors. Use the Synthetics REST API to manage monitors. Set up monitors from specific locations or for private servers. You can also use the host not reporting feature in infrastructure monitoring. This allows you to take advantage of enhanced monitoring options and be notified when New Relic has stopped receiving data from your hosts. Types of monitors These are the seven types of synthetic monitors: Type of synthetic monitor Description Broken links monitor API name: SCRIPT_API Provide a url and this monitor will test all the links on the page for success. If a failure is detected you can view the individual non-successful links that caused the failure. Certificate check monitor API name: SCRIPT_API Proactively ping your domain certificates based on a configurable threshold. Pair with an alert to ensure you are notified when your certificates need renewed. Ping monitor API name: SIMPLE Ping monitors are the simplest type of monitor. They simply check to see if an application is online. The synthetic ping monitor uses a simple Java HTTP client to make requests to your site. For consistency with other synthetic monitor types, the user agent is identified as Google Chrome. However, the HTTP client is not a full browser, and it does not execute JavaScript. If you need JavaScript functionality, use a simple browser monitor. Step monitor API name: STEP_MONITOR Step monitors are advanced monitors which require no code to set up. The monitor can be configured to: Assert modal Assert text Assert title Assert an element Click an element Dismiss a modal Double click an element Enter a secure credential Hover over an element Locate an element by CSS class, HTML ID, link text, Xpath, or value Navigate to a URL Select from a dropdown Type text Simple browser monitors API name: BROWSER Simple browser monitors essentially are simple, pre-built scripted browser monitors. They make a request to your site using an instance of Google Chrome. Compared to a simple ping monitor, this is a more accurate emulation of an actual customer visit. The user agent is identified as Google Chrome. Scripted browser monitors API name: SCRIPT_BROWSER Scripted browser monitors are used for more sophisticated, customized monitoring. You can create a custom script that navigates your website, takes specific actions, and ensures specific resources are present. The monitor uses Google Chrome browser. You can also use a variety of third-party modules to build your custom monitor. API tests API name: SCRIPT_API API tests are used to monitor your API endpoints. This can ensure that your app server works in addition to your website. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.07141,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Types of <em>synthetic</em> <em>monitors</em>",
        "sections": "Types of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can proactively <em>monitor</em> your website or API endpoints with <em>synthetic</em> monitors. Depending on the type of <em>monitor</em>, you can: Add and edit monitors. Use the <em>Synthetics</em> REST API to manage monitors. Set up monitors from specific locations or for private servers. You can also use the host"
      },
      "id": "603e873864441f3e154e888f"
    },
    {
      "sections": [
        "Security for synthetic monitoring",
        "What we do",
        "What you can do"
      ],
      "title": "Security for synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "c36cbaf0bec47e56e54e66f7eb39484a3ef7f426",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/security-synthetic-monitoring/",
      "published_at": "2021-12-09T21:11:48Z",
      "updated_at": "2021-07-27T18:44:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's synthetic monitoring uses monitors distributed throughout data centers around the world. By design, it captures what is essentially performance data for simulated traffic. It does not capture or handle any personal data by default. All data handled by synthetic monitors is expected to be non-personal. This document provides additional details about what we do to ensure data privacy and security with synthetic monitoring, plus additional options you can use. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. What we do Here's a summary of the data privacy and security measures that New Relic provides for you. Data privacy and security Comments No personal data By definition, all data collected through synthetic monitoring is test data created for the purpose of monitoring. None of this data includes personal data from any individual. TLS TLS encryption is required for all domains. This applies to public locations and private locations. Authentication Synthetic monitoring supports a variety of authentication mechanisms, including Basic, Digest, NTLM, and NTLMv2. Available options depend on the type of monitor you choose. Data collection The data transferred to the synthetic endpoint includes: Monitor run results, including full request and response headers of all requests, a complete HAR file of the session, and any screenshots captured (on failure or manually) Polling for available jobs in the private location's queue Private minion \"heartbeat\" every 30 seconds The SyntheticsPrivateMinion event contains basic minion status, including job success and failure counts, queue size, minion version, etc. Data received Data received from the synthetic monitoring endpoint contains the scheduled check's details. This includes the information necessary to complete the check for the minion: Target URL Validation text Full script (for synthetic scripted browser monitors) Data storage location Data collected by synthetic monitoring is stored in the region selected by each customer for their account (US or EU). Monitor configuration details (including frequency, check locations, target URL, and the full script for any scripted browser or API test monitors) are stored on our end. We also store all monitor check results for each monitor type. Data storage by monitor type For ping monitors, data storage includes the HAR file, which includes all requests and responses made during the check. For simple browsers, scripted browsers, and API tests, data storage includes the following: The HAR file includes full request and response headers for all requests made during the check. Any screenshots taken during the check are automatically included for simple and scripted browser monitors only on failure. However, you can manually configure this with scripting. The browser log (JS console) is automatically included for simple and scripted browsers. Any script output is included for scripted browsers and API test monitors. Response bodies New Relic never stores response bodies from requests originated by synthetic monitoring, unless you have manually configured a monitor script to do so. IP addresses Synthetic public minions are expected to be activated using non-personal credentials. Their IP addresses are not defined as personal data under data protection and privacy laws. What you can do For additional levels of security and data privacy, consider using these options. Additional measures Comments User access To control which of your users can access your monitors and private locations, set up role-based synthetic monitoring permissions and user groups. In addition, to track and be notified about changes, use audit logs and alert notifications. Passwords, API keys, user names, etc. To securely store sensitive information, use secured credentials for scripted browsers and API tests. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). Sites behind firewalls To control what sites you want to monitor behind your firewall, you can: Add the synthetic public minion IP addresses to your allow list or deny list. Use private locations to monitor sites or endpoints. This can provide an extra layer of security when monitoring your internally hosted sites and services. Web pages behind login pages If you configure synthetic monitoring to track website areas that are located behind a login page, be sure to create a non-personal login specifically for this purpose. This unique login will reduce the risk of unintended personal data exposure. Proxy configuration Aside from the target URLs monitored by New Relic, private minions will regularly send data to and receive from the synthetic monitoring endpoint. To configure a proxy for all traffic to and from this endpoint, set the MINION_API_PROXY environment variable on the minion host. Private minions security To ensure that only the scripts you intend to run are allowed to run on private minions, use verified script execution.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.18832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for <em>synthetic</em> <em>monitoring</em>",
        "sections": "Security for <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " for available jobs in the private location&#x27;s queue Private minion &quot;heartbeat&quot; every 30 seconds The <em>Synthetics</em>PrivateMinion event contains basic minion status, including job success and failure counts, queue size, minion version, etc. Data received Data received from the <em>synthetic</em> <em>monitoring</em> endpoint"
      },
      "id": "604525b8e7b9d270a35799c8"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/getting-started/security-synthetic-monitoring": [
    {
      "sections": [
        "Get started with synthetic monitoring",
        "Why it matters",
        "Advanced testing",
        "Enhanced monitoring and reporting",
        "Additional features",
        "Data protection and privacy",
        "Compatibility and requirements",
        "Important",
        "Permissions"
      ],
      "title": "Get started with synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "0e5bba5ee7c140314180bff96253dce241ced14f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/get-started-synthetic-monitoring/",
      "published_at": "2021-12-10T01:46:32Z",
      "updated_at": "2021-11-25T01:41:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring is a suite of automated, scriptable tools to monitor your websites, critical business transactions, and API endpoints. You can simulate user traffic to proactively detect and resolve outages and poor performance of critical endpoints before your customers notice. Why it matters With synthetic monitoring, you can: Get the context of failures by connecting the availability and performance of endpoints to the underlying applications and infrastructure. Easily diagnose if an issue stems from the network or AWS location, a slow third party resource, or the health of backend services or infrastructure. Add synthetic monitoring into build automation and CI/CD pipelines to automatically track performance and check functionality for each deployment. Expand your monitoring further with real, Selenium-powered scripted browsers, which test login procedures, searches, and other critical business transactions. Monitor your API endpoints with API tests. Ready to get started? If you don't already have one, sign up for a New Relic account. It's free, forever! Advanced testing Synthetic monitoring allows you to proactively monitor your website or API endpoint to ensure your content is not only available, but fully functional. Synthetic monitoring browser tests send real, Selenium-powered Google Chrome browsers to your site from locations around the world to ensure your content is always up, everywhere. Scripted browsers expand your testing capabilities, so you can test uncommon user flows or beta-test complex procedures. For example, ensure your users are able to sign up for your newsletter, add an item to their cart, or search for and find a piece of critical content with a simple JavaScript-like language. Test your backend with API monitors, which allow you to run scripted tests against any API endpoint. Enhanced monitoring and reporting Synthetic monitoring aggregates the results of each check into metrics, allowing you to see patterns and identify causes of poor performance. Synthetic monitoring also stores each and every monitor result, so you can see exactly where your website broke down. Alerts notify you if your website or API endpoint is inaccessible. You can even expand your geographical coverage or monitor internal websites by creating private locations. You can also query your monitor results for a closer look. New Relic retains monitor results for thirteen months, ensuring you can compare usage year over year. Additional features Synthetic monitoring includes the following features: Feature Description Real browsers With simple browser and scripted browser monitors, synthetic monitoring doesn't simply check that your host is up. It loads the actual page content in a real, fully virtualized Google Chrome browser (powered by Selenium) to provide testing that mirrors your users' actions. Detailed results view Synthetic monitoring stores every single run of your monitor for 13 months, so you can view a detailed breakdown of each and every check. You can get a snapshot of your website's performance and availability, or hunt down specific problems. Comparative charts with browser monitoring Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the synthetic monitors. For example, during a page outage, you can compare trends to see if an issue is also visible in synthetic monitoring, or if it is caused by other variables. Advanced scripted monitoring Use scripted browsers to run complex test cases against your website. Ensure critical processes like checkout and login are always running smoothly, and build a baseline to compare against when things go wrong. With a built-in scripting IDE based on Node.js, create scripts quickly without leaving your browser. Global test coverage Check coverage from locations around the world to ensure your users can access your website from anywhere, anytime. Monitor sites behind your firewall by adding the synthetic monitoring static IP addresses to your allow list. Use private locations to monitor internal sites or to expand your coverage to new locations. Compatibility with popular analytics platforms Synthetic monitoring specifically excludes scripts for popular analytics services, like Google Analytics. This ensures your analytics tools continue to receive the exact same data, even with thousands of monitors checking your website each month. You can unblock any of the services blocked by default, or block additional services. REST API functions Synthetic monitoring includes a REST API, which you can use to manage: Simple monitors and scripted monitors Categories and labels for monitors Alert notifications Data protection and privacy The data from synthetic monitoring is test data, representing typical interaction with the webpage or application. It is never actual data from human beings. The data collected when you use synthetic monitoring therefore is not personal data. For more information, see the Synthetic monitoring security documentation. Compatibility and requirements Synthetic monitoring does not require any software except a supported browser. Important To monitor a site behind your firewall, add the synthetic monitoring public minion IP addresses to your allow list. Permissions By default, all users in your account can: View synthetic monitoring pages. Add, edit, and delete monitors. For more fine-grained control, you can enable the optional permissions system. The permissions system allows you to manage the level of access for users to view and edit within synthetic monitoring (for example, monitors and private locations).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.69363,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with <em>synthetic</em> <em>monitoring</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " critical business transactions. <em>Monitor</em> your API endpoints with API tests. Ready to <em>get</em> <em>started</em>? If you don&#x27;t already have one, sign up for a New Relic account. It&#x27;s free, forever! Advanced testing <em>Synthetic</em> <em>monitoring</em> allows you to proactively <em>monitor</em> your website or API endpoint to ensure your"
      },
      "id": "6045257e64441fa637378efe"
    },
    {
      "sections": [
        "Browser Summary page",
        "View the Summary page",
        "Core Web Vitals widgets",
        "User time on the site",
        "Initial page load and route change chart",
        "User-centric page load times chart",
        "Throughput chart",
        "Tip",
        "Front end vs. back end chart",
        "First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL",
        "Related Entities widget",
        "View Synthetics monitors"
      ],
      "title": "Browser Summary page",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "a69bb31a3bff73ef8badce5ce435da62e9e7b644",
      "image": "https://docs.newrelic.com/static/e61bbb246d462250e94c99bf637b9cca/c1b63/browser_summary_page.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/browser-summary-page/",
      "published_at": "2021-12-10T02:30:10Z",
      "updated_at": "2021-12-10T02:30:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's Summary page summarizes the real-user browser performance of your app. Use the Summary page to: View trends in an app's browser-side performance Quickly troubleshoot page load timing issues Navigate to other browser UI pages View the Summary page To view a summary of browser performance for an app: Go to one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. Alternatively, go to one.newrelic.com, click Browser, and select an app from the Browser index. From the app's Summary page, use standard New Relic page functions to drill down into detailed information. one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the browser apps index, the Summary page shows a summary of browser performance for that app. The Summary page includes: Core Web Vitals widgets User time on the site Initial page load and route change chart User-centric page load times chart Throughput chart Front end vs. back end chart First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL Related Entities widget View Synthetics monitors Core Web Vitals widgets The Core Web Vitals widgets show how your browser performs according to Google's Core Web Vitals. The Core Web Vitals widgets include: LCP - Largest Contentful Paint FID - First Input Delay CLS - Cumulative Layout Shift User time on the site The User time on the site widget shows the time a user remains on the site. Initial page load and route change chart The Initial page load and route change chart shows the load time of a traditional URL change stemming from a load or reload of a URL. This chart appears with more detail about the page load timing process on the page load time page. User-centric page load times chart The User-centric page load times chart shows the load time of a page for a user. This chart appears with more detail about the page load timing process on the page load time page. Throughput chart The Throughput chart displays browser throughput as pages per minute (ppm). The value in the upper right of the chart is the average value for the selected time range. If you have enabled SPA monitoring enabled and the Summary page shows the SPA load time chart, the Throughput chart will also use SPA data. Tip App server requests per minute (rpm) may show a different measurement than the browser page load timing's pages per minute (ppm). Front end vs. back end chart The Front end vs. back end chart links to the connect APM service application. For details on APM and tracing, see Language agents and distributed tracing. First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL You'll also see summary versions of these metrics from the page load time page and JavaScript errors page: First interaction by device type First interaction by user agent JavaScript errors Longest first input delay by URL Related Entities widget The Related Entities widget shows all the entities that are related to the browser. To understand more about connections between entities, read about Entity relationships. View Synthetics monitors The button directs you to the Synthetics page. To read more about Synthetics, see Synthetic monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.54369,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View <em>Synthetics</em> <em>monitors</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " page: First interaction by device type First interaction by user agent JavaScript errors Longest first input delay by URL Related Entities widget The Related Entities widget shows all the entities that are related to the browser. To understand more about connections between entities, read about Entity relationships. View <em>Synthetics</em> monitors The button directs you to the <em>Synthetics</em> page. To read more about <em>Synthetics</em>, see <em>Synthetic</em> <em>monitoring</em>."
      },
      "id": "60440d9c196a674ac8960f5b"
    },
    {
      "sections": [
        "Types of synthetic monitors",
        "Types of monitors"
      ],
      "title": "Types of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "f7fe7faff740058c77bdf27b2c1bfb5c6a206b40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/types-synthetic-monitors/",
      "published_at": "2021-12-09T21:11:48Z",
      "updated_at": "2021-10-18T21:27:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can proactively monitor your website or API endpoints with synthetic monitors. Depending on the type of monitor, you can: Add and edit monitors. Use the Synthetics REST API to manage monitors. Set up monitors from specific locations or for private servers. You can also use the host not reporting feature in infrastructure monitoring. This allows you to take advantage of enhanced monitoring options and be notified when New Relic has stopped receiving data from your hosts. Types of monitors These are the seven types of synthetic monitors: Type of synthetic monitor Description Broken links monitor API name: SCRIPT_API Provide a url and this monitor will test all the links on the page for success. If a failure is detected you can view the individual non-successful links that caused the failure. Certificate check monitor API name: SCRIPT_API Proactively ping your domain certificates based on a configurable threshold. Pair with an alert to ensure you are notified when your certificates need renewed. Ping monitor API name: SIMPLE Ping monitors are the simplest type of monitor. They simply check to see if an application is online. The synthetic ping monitor uses a simple Java HTTP client to make requests to your site. For consistency with other synthetic monitor types, the user agent is identified as Google Chrome. However, the HTTP client is not a full browser, and it does not execute JavaScript. If you need JavaScript functionality, use a simple browser monitor. Step monitor API name: STEP_MONITOR Step monitors are advanced monitors which require no code to set up. The monitor can be configured to: Assert modal Assert text Assert title Assert an element Click an element Dismiss a modal Double click an element Enter a secure credential Hover over an element Locate an element by CSS class, HTML ID, link text, Xpath, or value Navigate to a URL Select from a dropdown Type text Simple browser monitors API name: BROWSER Simple browser monitors essentially are simple, pre-built scripted browser monitors. They make a request to your site using an instance of Google Chrome. Compared to a simple ping monitor, this is a more accurate emulation of an actual customer visit. The user agent is identified as Google Chrome. Scripted browser monitors API name: SCRIPT_BROWSER Scripted browser monitors are used for more sophisticated, customized monitoring. You can create a custom script that navigates your website, takes specific actions, and ensures specific resources are present. The monitor uses Google Chrome browser. You can also use a variety of third-party modules to build your custom monitor. API tests API name: SCRIPT_API API tests are used to monitor your API endpoints. This can ensure that your app server works in addition to your website. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.07141,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Types of <em>synthetic</em> <em>monitors</em>",
        "sections": "Types of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can proactively <em>monitor</em> your website or API endpoints with <em>synthetic</em> monitors. Depending on the type of <em>monitor</em>, you can: Add and edit monitors. Use the <em>Synthetics</em> REST API to manage monitors. Set up monitors from specific locations or for private servers. You can also use the host"
      },
      "id": "603e873864441f3e154e888f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/getting-started/types-synthetic-monitors": [
    {
      "sections": [
        "Get started with synthetic monitoring",
        "Why it matters",
        "Advanced testing",
        "Enhanced monitoring and reporting",
        "Additional features",
        "Data protection and privacy",
        "Compatibility and requirements",
        "Important",
        "Permissions"
      ],
      "title": "Get started with synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "0e5bba5ee7c140314180bff96253dce241ced14f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/get-started-synthetic-monitoring/",
      "published_at": "2021-12-10T01:46:32Z",
      "updated_at": "2021-11-25T01:41:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring is a suite of automated, scriptable tools to monitor your websites, critical business transactions, and API endpoints. You can simulate user traffic to proactively detect and resolve outages and poor performance of critical endpoints before your customers notice. Why it matters With synthetic monitoring, you can: Get the context of failures by connecting the availability and performance of endpoints to the underlying applications and infrastructure. Easily diagnose if an issue stems from the network or AWS location, a slow third party resource, or the health of backend services or infrastructure. Add synthetic monitoring into build automation and CI/CD pipelines to automatically track performance and check functionality for each deployment. Expand your monitoring further with real, Selenium-powered scripted browsers, which test login procedures, searches, and other critical business transactions. Monitor your API endpoints with API tests. Ready to get started? If you don't already have one, sign up for a New Relic account. It's free, forever! Advanced testing Synthetic monitoring allows you to proactively monitor your website or API endpoint to ensure your content is not only available, but fully functional. Synthetic monitoring browser tests send real, Selenium-powered Google Chrome browsers to your site from locations around the world to ensure your content is always up, everywhere. Scripted browsers expand your testing capabilities, so you can test uncommon user flows or beta-test complex procedures. For example, ensure your users are able to sign up for your newsletter, add an item to their cart, or search for and find a piece of critical content with a simple JavaScript-like language. Test your backend with API monitors, which allow you to run scripted tests against any API endpoint. Enhanced monitoring and reporting Synthetic monitoring aggregates the results of each check into metrics, allowing you to see patterns and identify causes of poor performance. Synthetic monitoring also stores each and every monitor result, so you can see exactly where your website broke down. Alerts notify you if your website or API endpoint is inaccessible. You can even expand your geographical coverage or monitor internal websites by creating private locations. You can also query your monitor results for a closer look. New Relic retains monitor results for thirteen months, ensuring you can compare usage year over year. Additional features Synthetic monitoring includes the following features: Feature Description Real browsers With simple browser and scripted browser monitors, synthetic monitoring doesn't simply check that your host is up. It loads the actual page content in a real, fully virtualized Google Chrome browser (powered by Selenium) to provide testing that mirrors your users' actions. Detailed results view Synthetic monitoring stores every single run of your monitor for 13 months, so you can view a detailed breakdown of each and every check. You can get a snapshot of your website's performance and availability, or hunt down specific problems. Comparative charts with browser monitoring Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the synthetic monitors. For example, during a page outage, you can compare trends to see if an issue is also visible in synthetic monitoring, or if it is caused by other variables. Advanced scripted monitoring Use scripted browsers to run complex test cases against your website. Ensure critical processes like checkout and login are always running smoothly, and build a baseline to compare against when things go wrong. With a built-in scripting IDE based on Node.js, create scripts quickly without leaving your browser. Global test coverage Check coverage from locations around the world to ensure your users can access your website from anywhere, anytime. Monitor sites behind your firewall by adding the synthetic monitoring static IP addresses to your allow list. Use private locations to monitor internal sites or to expand your coverage to new locations. Compatibility with popular analytics platforms Synthetic monitoring specifically excludes scripts for popular analytics services, like Google Analytics. This ensures your analytics tools continue to receive the exact same data, even with thousands of monitors checking your website each month. You can unblock any of the services blocked by default, or block additional services. REST API functions Synthetic monitoring includes a REST API, which you can use to manage: Simple monitors and scripted monitors Categories and labels for monitors Alert notifications Data protection and privacy The data from synthetic monitoring is test data, representing typical interaction with the webpage or application. It is never actual data from human beings. The data collected when you use synthetic monitoring therefore is not personal data. For more information, see the Synthetic monitoring security documentation. Compatibility and requirements Synthetic monitoring does not require any software except a supported browser. Important To monitor a site behind your firewall, add the synthetic monitoring public minion IP addresses to your allow list. Permissions By default, all users in your account can: View synthetic monitoring pages. Add, edit, and delete monitors. For more fine-grained control, you can enable the optional permissions system. The permissions system allows you to manage the level of access for users to view and edit within synthetic monitoring (for example, monitors and private locations).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.69363,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with <em>synthetic</em> <em>monitoring</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " critical business transactions. <em>Monitor</em> your API endpoints with API tests. Ready to <em>get</em> <em>started</em>? If you don&#x27;t already have one, sign up for a New Relic account. It&#x27;s free, forever! Advanced testing <em>Synthetic</em> <em>monitoring</em> allows you to proactively <em>monitor</em> your website or API endpoint to ensure your"
      },
      "id": "6045257e64441fa637378efe"
    },
    {
      "sections": [
        "Browser Summary page",
        "View the Summary page",
        "Core Web Vitals widgets",
        "User time on the site",
        "Initial page load and route change chart",
        "User-centric page load times chart",
        "Throughput chart",
        "Tip",
        "Front end vs. back end chart",
        "First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL",
        "Related Entities widget",
        "View Synthetics monitors"
      ],
      "title": "Browser Summary page",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "a69bb31a3bff73ef8badce5ce435da62e9e7b644",
      "image": "https://docs.newrelic.com/static/e61bbb246d462250e94c99bf637b9cca/c1b63/browser_summary_page.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/browser-summary-page/",
      "published_at": "2021-12-10T02:30:10Z",
      "updated_at": "2021-12-10T02:30:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's Summary page summarizes the real-user browser performance of your app. Use the Summary page to: View trends in an app's browser-side performance Quickly troubleshoot page load timing issues Navigate to other browser UI pages View the Summary page To view a summary of browser performance for an app: Go to one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. Alternatively, go to one.newrelic.com, click Browser, and select an app from the Browser index. From the app's Summary page, use standard New Relic page functions to drill down into detailed information. one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the browser apps index, the Summary page shows a summary of browser performance for that app. The Summary page includes: Core Web Vitals widgets User time on the site Initial page load and route change chart User-centric page load times chart Throughput chart Front end vs. back end chart First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL Related Entities widget View Synthetics monitors Core Web Vitals widgets The Core Web Vitals widgets show how your browser performs according to Google's Core Web Vitals. The Core Web Vitals widgets include: LCP - Largest Contentful Paint FID - First Input Delay CLS - Cumulative Layout Shift User time on the site The User time on the site widget shows the time a user remains on the site. Initial page load and route change chart The Initial page load and route change chart shows the load time of a traditional URL change stemming from a load or reload of a URL. This chart appears with more detail about the page load timing process on the page load time page. User-centric page load times chart The User-centric page load times chart shows the load time of a page for a user. This chart appears with more detail about the page load timing process on the page load time page. Throughput chart The Throughput chart displays browser throughput as pages per minute (ppm). The value in the upper right of the chart is the average value for the selected time range. If you have enabled SPA monitoring enabled and the Summary page shows the SPA load time chart, the Throughput chart will also use SPA data. Tip App server requests per minute (rpm) may show a different measurement than the browser page load timing's pages per minute (ppm). Front end vs. back end chart The Front end vs. back end chart links to the connect APM service application. For details on APM and tracing, see Language agents and distributed tracing. First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL You'll also see summary versions of these metrics from the page load time page and JavaScript errors page: First interaction by device type First interaction by user agent JavaScript errors Longest first input delay by URL Related Entities widget The Related Entities widget shows all the entities that are related to the browser. To understand more about connections between entities, read about Entity relationships. View Synthetics monitors The button directs you to the Synthetics page. To read more about Synthetics, see Synthetic monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.54369,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View <em>Synthetics</em> <em>monitors</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " page: First interaction by device type First interaction by user agent JavaScript errors Longest first input delay by URL Related Entities widget The Related Entities widget shows all the entities that are related to the browser. To understand more about connections between entities, read about Entity relationships. View <em>Synthetics</em> monitors The button directs you to the <em>Synthetics</em> page. To read more about <em>Synthetics</em>, see <em>Synthetic</em> <em>monitoring</em>."
      },
      "id": "60440d9c196a674ac8960f5b"
    },
    {
      "sections": [
        "Security for synthetic monitoring",
        "What we do",
        "What you can do"
      ],
      "title": "Security for synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "c36cbaf0bec47e56e54e66f7eb39484a3ef7f426",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/security-synthetic-monitoring/",
      "published_at": "2021-12-09T21:11:48Z",
      "updated_at": "2021-07-27T18:44:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's synthetic monitoring uses monitors distributed throughout data centers around the world. By design, it captures what is essentially performance data for simulated traffic. It does not capture or handle any personal data by default. All data handled by synthetic monitors is expected to be non-personal. This document provides additional details about what we do to ensure data privacy and security with synthetic monitoring, plus additional options you can use. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. What we do Here's a summary of the data privacy and security measures that New Relic provides for you. Data privacy and security Comments No personal data By definition, all data collected through synthetic monitoring is test data created for the purpose of monitoring. None of this data includes personal data from any individual. TLS TLS encryption is required for all domains. This applies to public locations and private locations. Authentication Synthetic monitoring supports a variety of authentication mechanisms, including Basic, Digest, NTLM, and NTLMv2. Available options depend on the type of monitor you choose. Data collection The data transferred to the synthetic endpoint includes: Monitor run results, including full request and response headers of all requests, a complete HAR file of the session, and any screenshots captured (on failure or manually) Polling for available jobs in the private location's queue Private minion \"heartbeat\" every 30 seconds The SyntheticsPrivateMinion event contains basic minion status, including job success and failure counts, queue size, minion version, etc. Data received Data received from the synthetic monitoring endpoint contains the scheduled check's details. This includes the information necessary to complete the check for the minion: Target URL Validation text Full script (for synthetic scripted browser monitors) Data storage location Data collected by synthetic monitoring is stored in the region selected by each customer for their account (US or EU). Monitor configuration details (including frequency, check locations, target URL, and the full script for any scripted browser or API test monitors) are stored on our end. We also store all monitor check results for each monitor type. Data storage by monitor type For ping monitors, data storage includes the HAR file, which includes all requests and responses made during the check. For simple browsers, scripted browsers, and API tests, data storage includes the following: The HAR file includes full request and response headers for all requests made during the check. Any screenshots taken during the check are automatically included for simple and scripted browser monitors only on failure. However, you can manually configure this with scripting. The browser log (JS console) is automatically included for simple and scripted browsers. Any script output is included for scripted browsers and API test monitors. Response bodies New Relic never stores response bodies from requests originated by synthetic monitoring, unless you have manually configured a monitor script to do so. IP addresses Synthetic public minions are expected to be activated using non-personal credentials. Their IP addresses are not defined as personal data under data protection and privacy laws. What you can do For additional levels of security and data privacy, consider using these options. Additional measures Comments User access To control which of your users can access your monitors and private locations, set up role-based synthetic monitoring permissions and user groups. In addition, to track and be notified about changes, use audit logs and alert notifications. Passwords, API keys, user names, etc. To securely store sensitive information, use secured credentials for scripted browsers and API tests. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). Sites behind firewalls To control what sites you want to monitor behind your firewall, you can: Add the synthetic public minion IP addresses to your allow list or deny list. Use private locations to monitor sites or endpoints. This can provide an extra layer of security when monitoring your internally hosted sites and services. Web pages behind login pages If you configure synthetic monitoring to track website areas that are located behind a login page, be sure to create a non-personal login specifically for this purpose. This unique login will reduce the risk of unintended personal data exposure. Proxy configuration Aside from the target URLs monitored by New Relic, private minions will regularly send data to and receive from the synthetic monitoring endpoint. To configure a proxy for all traffic to and from this endpoint, set the MINION_API_PROXY environment variable on the minion host. Private minions security To ensure that only the scripts you intend to run are allowed to run on private minions, use verified script execution.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.18832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for <em>synthetic</em> <em>monitoring</em>",
        "sections": "Security for <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " for available jobs in the private location&#x27;s queue Private minion &quot;heartbeat&quot; every 30 seconds The <em>Synthetics</em>PrivateMinion event contains basic minion status, including job success and failure counts, queue size, minion version, etc. Data received Data received from the <em>synthetic</em> <em>monitoring</em> endpoint"
      },
      "id": "604525b8e7b9d270a35799c8"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-aggregate-monitor-metrics": [
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-12-09T21:12:39Z",
      "updated_at": "2021-11-07T09:25:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. Avoid extra noise and get notified after three failures Read our blog post on the three strikes rule.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.85133,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures <em>page</em> To access your <em>monitor</em>&#x27;s failures: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Failures. Hover the mouse over a failure to get"
      },
      "id": "603e9efd64441faf344e8865"
    },
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-10T13:37:34Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.18904,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results <em>page</em> To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results <em>page</em> to locate interesting runs of your <em>monitor</em> for troubleshooting"
      },
      "id": "603eb5da64441f07ae4e8850"
    },
    {
      "sections": [
        "Synthetic monitoring: Understand load times",
        "View the Resources page",
        "Understand resource metrics",
        "View detailed resource metrics",
        "View individual resource loads",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Understand load times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "a6d91eef3b89f682ce06d4408928f0c8b70b90e6",
      "image": "https://docs.newrelic.com/static/fe6794ec2ba009717f08a91fae4841fc/8c557/resource-load.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-understand-load-times/",
      "published_at": "2021-12-09T21:13:36Z",
      "updated_at": "2021-10-31T07:59:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Resources page to understand the load time impact of each resource on your website. Use the resources load time, time spent by third parties, and irregular response codes graphs for a high-level overview, and use the resources list to identify high-impact resources such as large CSS files or images. You can also investigate a specific resource with detailed resource metrics, which aggregate performance information for a single resource. Go even deeper and view one load of that resource, using the exact request and response headers to pinpoint a performance issue. View the Resources page To access your monitor's Resources page: Go to one.newrelic.com > Synthetics > (select a monitor) > Resources. one.newrelic.com > Synthetics > (select a monitor) > Resources: Use the Resources page to analyze the performance of each resource on your website, and to access detailed metrics with individual resource loads. Understand resource metrics Use the Resources page to understand the performance impact of each resource on your website: Resources list: Lists the resources on your monitored website by average download time. Use this list to optimize your website's performance by reducing download times. You can also view the load time for any particular resource by searching for it in the Search all resources field. Select a resource to view individual resource metrics. Load time: Graphs the average load time for all resources, broken down by resource type (such as jpeg, json, or javascript). Use this graph to understand how the load time of your website changes over time. Time spent by third parties: Graphs the average load time of all third-party resources, such as web fonts, an embedded Twitter timeline, or an externally hosted image. Use this graph to see if third-party websites are affecting your website's performance. Irregular response codes: Graphs the number of negative HTTP response codes (also called HTTP status codes) received by the monitor. This graph includes all responses in the 300 (redirection), 400 (client error), and 500 (server error) ranges. It does not count responses in the 100 or 200 ranges. Synthetics also collects a number of custom response codes. By analyzing these metrics, you can track down troublesome resources and improve their performance. For example, an unoptimized logo image might cause slowdowns for every visitor of your site, while a tracker that is served only from a US-based server could result in slow performance for non-US visitors. View detailed resource metrics You can also view detailed metrics for each resource on your site. To view detailed metrics, locate a specific resource, or simply select an interesting resource from the Resources page. After selecting a resource, you can view overview metrics for that resource, or view an individual resource load: Max duration, Min duration, Avg duration: Load time metrics for this resource over the selected time frame. For 50% of requests: The maximum download time for the fastest 50% of requests. This means that 50% of requests for this resource were completed in the specified time or faster. For 95% of requests: The maximum download time for the fastest 95% of requests. This means that 95% of requests for this resource were completed in the specified time or faster. Average load time: Graphs the average load time for this resource over the selected time frame. Use this graph to verify that optimizations to your website (such as decreasing the size of an image or minifying your CSS) are working. You can also hide and unhide chart elements, filter by location, and sort the resource results list by Download time or DNS lookup. Mouse over the resource name to view the full path (useful with very long dynamically generated resource names). View individual resource loads After viewing detailed metrics for a particular resource, you can select an individual resource load for an in-depth understanding of one poor performance incident. You can then view a breakdown of the total connection time to understand where the issue occurred, and examine request and response headers. one.newrelic.com > Synthetics > (select a monitor) > Resources > (select a resource) > (select a resource load): Select an individual resource load to see a detailed breakdown of connection time, request headers, and response headers. Network timing structure taken from the HTTP Archive 1.2 specification. Use page functions The Resources page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select a sort option: Sort by Average download time to view your slowest-loading resources. Sort by Average size to view your largest resources. Hide and unhide chart elements Select chart elements to hide and unhide them. Locate a specific resource Enter part of your resource name in the Search all resources field (for example, search-icon.png or latest.json). Select the resource to view detailed metrics for that resource. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.13785,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Understand load times",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Understand load times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>page</em> To access your <em>monitor</em>&#x27;s Resources <em>page</em>: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Resources. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Resources: Use the Resources <em>page</em> to analyze the performance of each resource on your website, and to access detailed metrics"
      },
      "id": "604525b864441f0943378ebb"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary": [
    {
      "sections": [
        "Synthetic monitoring: Aggregate monitor metrics",
        "View synthetic monitoring SLA reports",
        "Understand SLA report metrics",
        "Use page functions",
        "Generate SLA values"
      ],
      "title": "Synthetic monitoring: Aggregate monitor metrics",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "bbead36a5b36d126243f0beb2d60e9ccf23763f5",
      "image": "https://docs.newrelic.com/static/d0dc46884c112568daf4e491098e1951/c1b63/sla-report.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-aggregate-monitor-metrics/",
      "published_at": "2021-12-09T21:12:39Z",
      "updated_at": "2021-11-15T07:04:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View synthetic monitoring SLA reports To view your account-wide SLA report: Go to one.newrelic.com > Synthetics > SLA Report. Choose from reports aggregated by day, week, or month by selecting Daily, Weekly, or Monthly as appropriate. You can also view SLA reports for individual monitors: Go to one.newrelic.com > Synthetics > (select a monitor) > SLA. one.newrelic.com > Synthetics > SLA Report: Use SLA reports to understand your monitors' performance over time. Understand SLA report metrics Use SLA reports to view aggregated performance metrics for a single monitor, or for all your monitors from the account-wide SLA Reports page. SLA reports include the following metrics: Duration: The average duration across all monitor results. Uptime: The percentage of all monitor results that ended successfully. For example, Monitor A might check 50 times per day, and Monitor B might check 150 times per day. If Monitor A has 29 successes out of 50 and Monitor B has 148 successes out of 150, the Uptime would be 88.5: (29+148)/(50+150)=88.5 For individual SLA reports, the uptime score only includes the selected monitor. Apdex: The average Apdex across all monitors. Monitors have a default Apdex T of 7 seconds, but you can customize Apdex T for individual monitors by editing their settings. Apdex F, which defines a frustrating result, is always four times Apdex T. For more information about Apdex, see Apdex: Measuring user satisfaction. For individual SLA reports, the Apdex score only includes the selected monitor. % Satisfied: The percentage of monitor results which complete in a \"satisfying\" time. A satisfying time is defined as a monitor result that completes in Apdex T or less. % Toleration: The percentage of monitor results which complete in a \"tolerable\" time. A tolerable time is greater than Apdex T, but less than Apdex F (four times Apdex T). % Frustrated: The percentage of monitor results which complete in a \"frustrating\" time. A frustrating time is greater than Apdex F (four times Apdex T). The account-wide SLA report includes all monitor types (ping, simple browser, scripted browser, and API test). Use page functions SLA reports support the following features: If you want to... Do this... View the report in Excel or an external program Select Download this report as .csv to download a copy of your SLA data. Open the file in Excel, Google Drive, or another spreadsheet editor to analyze your data. Change your Apdex targets The default Apdex T for all monitors is 7 seconds. You can customize your Apdex T target for individual monitors by editing your monitor. Change the time frame Choose from daily, weekly, or monthly aggregation by selecting the appropriate tab. Make the report public Change the Public SLA setting to ON to allow non-authenticated users to view the report. Select Share Report to get the public URL to share. Generate SLA values The values in the SLA report are generated from Insights queries against the available synthetic monitoring data. You can easily recreate these values and modify the queries to meet your needs. This query returns the average duration, the apdex, and the uptime. Substitute your values for the variables highlighted and described below. SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod Copy Variable Value t: Supply the Apdex T that you would like to calculate your apdex against. The duration attribute in the SyntheticCheck event is stored in milliseconds, so an Apdex T value of 7 seconds should be included as 7000. timeperiod This is the period that you would like to calculate on. For a daily report, facet on dateOf(timestamp), for a weekly report facet on weekOf(timestamp) and for a monthly report facet on monthOf(timestamp). NRQL queries default to querying against the last hour of data. In order to widen the scope of your data you will need to include a SINCE clause at the end of your query. Example #1: Daily report for the last week To generate a daily report for the last week you would add SINCE 1 week ago: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET dateOf(timestamp) SINCE 1 week ago Copy Example #2: Report for a particular monitor To scope the results to a particular monitor you can edit the below query to include a specific monitor name: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName = 'mymonitorname' Copy Example #3: Report for multiple monitors To scope the results to a collection of monitors: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName IN ('mymonitor1', 'mymonitor2', 'mymonitor3') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.37958,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View <em>synthetic</em> <em>monitoring</em> SLA reports To view your account-wide SLA report: Go to one.newrelic.com &gt; <em>Synthetics</em>"
      },
      "id": "603ec399196a67e073a83d96"
    },
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-12-09T21:12:39Z",
      "updated_at": "2021-11-07T09:25:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. Avoid extra noise and get notified after three failures Read our blog post on the three strikes rule.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.85132,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures <em>page</em> To access your <em>monitor</em>&#x27;s failures: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Failures. Hover the mouse over a failure to get"
      },
      "id": "603e9efd64441faf344e8865"
    },
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-10T13:37:34Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.18904,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results <em>page</em> To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results <em>page</em> to locate interesting runs of your <em>monitor</em> for troubleshooting"
      },
      "id": "603eb5da64441f07ae4e8850"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime": [
    {
      "sections": [
        "Synthetic monitoring: Aggregate monitor metrics",
        "View synthetic monitoring SLA reports",
        "Understand SLA report metrics",
        "Use page functions",
        "Generate SLA values"
      ],
      "title": "Synthetic monitoring: Aggregate monitor metrics",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "bbead36a5b36d126243f0beb2d60e9ccf23763f5",
      "image": "https://docs.newrelic.com/static/d0dc46884c112568daf4e491098e1951/c1b63/sla-report.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-aggregate-monitor-metrics/",
      "published_at": "2021-12-09T21:12:39Z",
      "updated_at": "2021-11-15T07:04:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View synthetic monitoring SLA reports To view your account-wide SLA report: Go to one.newrelic.com > Synthetics > SLA Report. Choose from reports aggregated by day, week, or month by selecting Daily, Weekly, or Monthly as appropriate. You can also view SLA reports for individual monitors: Go to one.newrelic.com > Synthetics > (select a monitor) > SLA. one.newrelic.com > Synthetics > SLA Report: Use SLA reports to understand your monitors' performance over time. Understand SLA report metrics Use SLA reports to view aggregated performance metrics for a single monitor, or for all your monitors from the account-wide SLA Reports page. SLA reports include the following metrics: Duration: The average duration across all monitor results. Uptime: The percentage of all monitor results that ended successfully. For example, Monitor A might check 50 times per day, and Monitor B might check 150 times per day. If Monitor A has 29 successes out of 50 and Monitor B has 148 successes out of 150, the Uptime would be 88.5: (29+148)/(50+150)=88.5 For individual SLA reports, the uptime score only includes the selected monitor. Apdex: The average Apdex across all monitors. Monitors have a default Apdex T of 7 seconds, but you can customize Apdex T for individual monitors by editing their settings. Apdex F, which defines a frustrating result, is always four times Apdex T. For more information about Apdex, see Apdex: Measuring user satisfaction. For individual SLA reports, the Apdex score only includes the selected monitor. % Satisfied: The percentage of monitor results which complete in a \"satisfying\" time. A satisfying time is defined as a monitor result that completes in Apdex T or less. % Toleration: The percentage of monitor results which complete in a \"tolerable\" time. A tolerable time is greater than Apdex T, but less than Apdex F (four times Apdex T). % Frustrated: The percentage of monitor results which complete in a \"frustrating\" time. A frustrating time is greater than Apdex F (four times Apdex T). The account-wide SLA report includes all monitor types (ping, simple browser, scripted browser, and API test). Use page functions SLA reports support the following features: If you want to... Do this... View the report in Excel or an external program Select Download this report as .csv to download a copy of your SLA data. Open the file in Excel, Google Drive, or another spreadsheet editor to analyze your data. Change your Apdex targets The default Apdex T for all monitors is 7 seconds. You can customize your Apdex T target for individual monitors by editing your monitor. Change the time frame Choose from daily, weekly, or monthly aggregation by selecting the appropriate tab. Make the report public Change the Public SLA setting to ON to allow non-authenticated users to view the report. Select Share Report to get the public URL to share. Generate SLA values The values in the SLA report are generated from Insights queries against the available synthetic monitoring data. You can easily recreate these values and modify the queries to meet your needs. This query returns the average duration, the apdex, and the uptime. Substitute your values for the variables highlighted and described below. SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod Copy Variable Value t: Supply the Apdex T that you would like to calculate your apdex against. The duration attribute in the SyntheticCheck event is stored in milliseconds, so an Apdex T value of 7 seconds should be included as 7000. timeperiod This is the period that you would like to calculate on. For a daily report, facet on dateOf(timestamp), for a weekly report facet on weekOf(timestamp) and for a monthly report facet on monthOf(timestamp). NRQL queries default to querying against the last hour of data. In order to widen the scope of your data you will need to include a SINCE clause at the end of your query. Example #1: Daily report for the last week To generate a daily report for the last week you would add SINCE 1 week ago: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET dateOf(timestamp) SINCE 1 week ago Copy Example #2: Report for a particular monitor To scope the results to a particular monitor you can edit the below query to include a specific monitor name: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName = 'mymonitorname' Copy Example #3: Report for multiple monitors To scope the results to a collection of monitors: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName IN ('mymonitor1', 'mymonitor2', 'mymonitor3') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.37958,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View <em>synthetic</em> <em>monitoring</em> SLA reports To view your account-wide SLA report: Go to one.newrelic.com &gt; <em>Synthetics</em>"
      },
      "id": "603ec399196a67e073a83d96"
    },
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-10T13:37:34Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.18904,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results <em>page</em> To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results <em>page</em> to locate interesting runs of your <em>monitor</em> for troubleshooting"
      },
      "id": "603eb5da64441f07ae4e8850"
    },
    {
      "sections": [
        "Synthetic monitoring: Understand load times",
        "View the Resources page",
        "Understand resource metrics",
        "View detailed resource metrics",
        "View individual resource loads",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Understand load times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "a6d91eef3b89f682ce06d4408928f0c8b70b90e6",
      "image": "https://docs.newrelic.com/static/fe6794ec2ba009717f08a91fae4841fc/8c557/resource-load.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-understand-load-times/",
      "published_at": "2021-12-09T21:13:36Z",
      "updated_at": "2021-10-31T07:59:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Resources page to understand the load time impact of each resource on your website. Use the resources load time, time spent by third parties, and irregular response codes graphs for a high-level overview, and use the resources list to identify high-impact resources such as large CSS files or images. You can also investigate a specific resource with detailed resource metrics, which aggregate performance information for a single resource. Go even deeper and view one load of that resource, using the exact request and response headers to pinpoint a performance issue. View the Resources page To access your monitor's Resources page: Go to one.newrelic.com > Synthetics > (select a monitor) > Resources. one.newrelic.com > Synthetics > (select a monitor) > Resources: Use the Resources page to analyze the performance of each resource on your website, and to access detailed metrics with individual resource loads. Understand resource metrics Use the Resources page to understand the performance impact of each resource on your website: Resources list: Lists the resources on your monitored website by average download time. Use this list to optimize your website's performance by reducing download times. You can also view the load time for any particular resource by searching for it in the Search all resources field. Select a resource to view individual resource metrics. Load time: Graphs the average load time for all resources, broken down by resource type (such as jpeg, json, or javascript). Use this graph to understand how the load time of your website changes over time. Time spent by third parties: Graphs the average load time of all third-party resources, such as web fonts, an embedded Twitter timeline, or an externally hosted image. Use this graph to see if third-party websites are affecting your website's performance. Irregular response codes: Graphs the number of negative HTTP response codes (also called HTTP status codes) received by the monitor. This graph includes all responses in the 300 (redirection), 400 (client error), and 500 (server error) ranges. It does not count responses in the 100 or 200 ranges. Synthetics also collects a number of custom response codes. By analyzing these metrics, you can track down troublesome resources and improve their performance. For example, an unoptimized logo image might cause slowdowns for every visitor of your site, while a tracker that is served only from a US-based server could result in slow performance for non-US visitors. View detailed resource metrics You can also view detailed metrics for each resource on your site. To view detailed metrics, locate a specific resource, or simply select an interesting resource from the Resources page. After selecting a resource, you can view overview metrics for that resource, or view an individual resource load: Max duration, Min duration, Avg duration: Load time metrics for this resource over the selected time frame. For 50% of requests: The maximum download time for the fastest 50% of requests. This means that 50% of requests for this resource were completed in the specified time or faster. For 95% of requests: The maximum download time for the fastest 95% of requests. This means that 95% of requests for this resource were completed in the specified time or faster. Average load time: Graphs the average load time for this resource over the selected time frame. Use this graph to verify that optimizations to your website (such as decreasing the size of an image or minifying your CSS) are working. You can also hide and unhide chart elements, filter by location, and sort the resource results list by Download time or DNS lookup. Mouse over the resource name to view the full path (useful with very long dynamically generated resource names). View individual resource loads After viewing detailed metrics for a particular resource, you can select an individual resource load for an in-depth understanding of one poor performance incident. You can then view a breakdown of the total connection time to understand where the issue occurred, and examine request and response headers. one.newrelic.com > Synthetics > (select a monitor) > Resources > (select a resource) > (select a resource load): Select an individual resource load to see a detailed breakdown of connection time, request headers, and response headers. Network timing structure taken from the HTTP Archive 1.2 specification. Use page functions The Resources page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select a sort option: Sort by Average download time to view your slowest-loading resources. Sort by Average size to view your largest resources. Hide and unhide chart elements Select chart elements to hide and unhide them. Locate a specific resource Enter part of your resource name in the Search all resources field (for example, search-icon.png or latest.json). Select the resource to view detailed metrics for that resource. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.13783,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Understand load times",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Understand load times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>page</em> To access your <em>monitor</em>&#x27;s Resources <em>page</em>: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Resources. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Resources: Use the Resources <em>page</em> to analyze the performance of each resource on your website, and to access detailed metrics"
      },
      "id": "604525b864441f0943378ebb"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-understand-load-times": [
    {
      "sections": [
        "Synthetic monitoring: Aggregate monitor metrics",
        "View synthetic monitoring SLA reports",
        "Understand SLA report metrics",
        "Use page functions",
        "Generate SLA values"
      ],
      "title": "Synthetic monitoring: Aggregate monitor metrics",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "bbead36a5b36d126243f0beb2d60e9ccf23763f5",
      "image": "https://docs.newrelic.com/static/d0dc46884c112568daf4e491098e1951/c1b63/sla-report.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-aggregate-monitor-metrics/",
      "published_at": "2021-12-09T21:12:39Z",
      "updated_at": "2021-11-15T07:04:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View synthetic monitoring SLA reports To view your account-wide SLA report: Go to one.newrelic.com > Synthetics > SLA Report. Choose from reports aggregated by day, week, or month by selecting Daily, Weekly, or Monthly as appropriate. You can also view SLA reports for individual monitors: Go to one.newrelic.com > Synthetics > (select a monitor) > SLA. one.newrelic.com > Synthetics > SLA Report: Use SLA reports to understand your monitors' performance over time. Understand SLA report metrics Use SLA reports to view aggregated performance metrics for a single monitor, or for all your monitors from the account-wide SLA Reports page. SLA reports include the following metrics: Duration: The average duration across all monitor results. Uptime: The percentage of all monitor results that ended successfully. For example, Monitor A might check 50 times per day, and Monitor B might check 150 times per day. If Monitor A has 29 successes out of 50 and Monitor B has 148 successes out of 150, the Uptime would be 88.5: (29+148)/(50+150)=88.5 For individual SLA reports, the uptime score only includes the selected monitor. Apdex: The average Apdex across all monitors. Monitors have a default Apdex T of 7 seconds, but you can customize Apdex T for individual monitors by editing their settings. Apdex F, which defines a frustrating result, is always four times Apdex T. For more information about Apdex, see Apdex: Measuring user satisfaction. For individual SLA reports, the Apdex score only includes the selected monitor. % Satisfied: The percentage of monitor results which complete in a \"satisfying\" time. A satisfying time is defined as a monitor result that completes in Apdex T or less. % Toleration: The percentage of monitor results which complete in a \"tolerable\" time. A tolerable time is greater than Apdex T, but less than Apdex F (four times Apdex T). % Frustrated: The percentage of monitor results which complete in a \"frustrating\" time. A frustrating time is greater than Apdex F (four times Apdex T). The account-wide SLA report includes all monitor types (ping, simple browser, scripted browser, and API test). Use page functions SLA reports support the following features: If you want to... Do this... View the report in Excel or an external program Select Download this report as .csv to download a copy of your SLA data. Open the file in Excel, Google Drive, or another spreadsheet editor to analyze your data. Change your Apdex targets The default Apdex T for all monitors is 7 seconds. You can customize your Apdex T target for individual monitors by editing your monitor. Change the time frame Choose from daily, weekly, or monthly aggregation by selecting the appropriate tab. Make the report public Change the Public SLA setting to ON to allow non-authenticated users to view the report. Select Share Report to get the public URL to share. Generate SLA values The values in the SLA report are generated from Insights queries against the available synthetic monitoring data. You can easily recreate these values and modify the queries to meet your needs. This query returns the average duration, the apdex, and the uptime. Substitute your values for the variables highlighted and described below. SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod Copy Variable Value t: Supply the Apdex T that you would like to calculate your apdex against. The duration attribute in the SyntheticCheck event is stored in milliseconds, so an Apdex T value of 7 seconds should be included as 7000. timeperiod This is the period that you would like to calculate on. For a daily report, facet on dateOf(timestamp), for a weekly report facet on weekOf(timestamp) and for a monthly report facet on monthOf(timestamp). NRQL queries default to querying against the last hour of data. In order to widen the scope of your data you will need to include a SINCE clause at the end of your query. Example #1: Daily report for the last week To generate a daily report for the last week you would add SINCE 1 week ago: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET dateOf(timestamp) SINCE 1 week ago Copy Example #2: Report for a particular monitor To scope the results to a particular monitor you can edit the below query to include a specific monitor name: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName = 'mymonitorname' Copy Example #3: Report for multiple monitors To scope the results to a collection of monitors: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName IN ('mymonitor1', 'mymonitor2', 'mymonitor3') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.37956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View <em>synthetic</em> <em>monitoring</em> SLA reports To view your account-wide SLA report: Go to one.newrelic.com &gt; <em>Synthetics</em>"
      },
      "id": "603ec399196a67e073a83d96"
    },
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-12-09T21:12:39Z",
      "updated_at": "2021-11-07T09:25:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. Avoid extra noise and get notified after three failures Read our blog post on the three strikes rule.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.85132,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures <em>page</em> To access your <em>monitor</em>&#x27;s failures: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Failures. Hover the mouse over a failure to get"
      },
      "id": "603e9efd64441faf344e8865"
    },
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-10T13:37:34Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.18903,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results <em>page</em> To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results <em>page</em> to locate interesting runs of your <em>monitor</em> for troubleshooting"
      },
      "id": "603eb5da64441f07ae4e8850"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/pages/synthetic-monitors-index": [
    {
      "sections": [
        "Synthetic monitoring: Aggregate monitor metrics",
        "View synthetic monitoring SLA reports",
        "Understand SLA report metrics",
        "Use page functions",
        "Generate SLA values"
      ],
      "title": "Synthetic monitoring: Aggregate monitor metrics",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "bbead36a5b36d126243f0beb2d60e9ccf23763f5",
      "image": "https://docs.newrelic.com/static/d0dc46884c112568daf4e491098e1951/c1b63/sla-report.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-aggregate-monitor-metrics/",
      "published_at": "2021-12-09T21:12:39Z",
      "updated_at": "2021-11-15T07:04:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View synthetic monitoring SLA reports To view your account-wide SLA report: Go to one.newrelic.com > Synthetics > SLA Report. Choose from reports aggregated by day, week, or month by selecting Daily, Weekly, or Monthly as appropriate. You can also view SLA reports for individual monitors: Go to one.newrelic.com > Synthetics > (select a monitor) > SLA. one.newrelic.com > Synthetics > SLA Report: Use SLA reports to understand your monitors' performance over time. Understand SLA report metrics Use SLA reports to view aggregated performance metrics for a single monitor, or for all your monitors from the account-wide SLA Reports page. SLA reports include the following metrics: Duration: The average duration across all monitor results. Uptime: The percentage of all monitor results that ended successfully. For example, Monitor A might check 50 times per day, and Monitor B might check 150 times per day. If Monitor A has 29 successes out of 50 and Monitor B has 148 successes out of 150, the Uptime would be 88.5: (29+148)/(50+150)=88.5 For individual SLA reports, the uptime score only includes the selected monitor. Apdex: The average Apdex across all monitors. Monitors have a default Apdex T of 7 seconds, but you can customize Apdex T for individual monitors by editing their settings. Apdex F, which defines a frustrating result, is always four times Apdex T. For more information about Apdex, see Apdex: Measuring user satisfaction. For individual SLA reports, the Apdex score only includes the selected monitor. % Satisfied: The percentage of monitor results which complete in a \"satisfying\" time. A satisfying time is defined as a monitor result that completes in Apdex T or less. % Toleration: The percentage of monitor results which complete in a \"tolerable\" time. A tolerable time is greater than Apdex T, but less than Apdex F (four times Apdex T). % Frustrated: The percentage of monitor results which complete in a \"frustrating\" time. A frustrating time is greater than Apdex F (four times Apdex T). The account-wide SLA report includes all monitor types (ping, simple browser, scripted browser, and API test). Use page functions SLA reports support the following features: If you want to... Do this... View the report in Excel or an external program Select Download this report as .csv to download a copy of your SLA data. Open the file in Excel, Google Drive, or another spreadsheet editor to analyze your data. Change your Apdex targets The default Apdex T for all monitors is 7 seconds. You can customize your Apdex T target for individual monitors by editing your monitor. Change the time frame Choose from daily, weekly, or monthly aggregation by selecting the appropriate tab. Make the report public Change the Public SLA setting to ON to allow non-authenticated users to view the report. Select Share Report to get the public URL to share. Generate SLA values The values in the SLA report are generated from Insights queries against the available synthetic monitoring data. You can easily recreate these values and modify the queries to meet your needs. This query returns the average duration, the apdex, and the uptime. Substitute your values for the variables highlighted and described below. SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod Copy Variable Value t: Supply the Apdex T that you would like to calculate your apdex against. The duration attribute in the SyntheticCheck event is stored in milliseconds, so an Apdex T value of 7 seconds should be included as 7000. timeperiod This is the period that you would like to calculate on. For a daily report, facet on dateOf(timestamp), for a weekly report facet on weekOf(timestamp) and for a monthly report facet on monthOf(timestamp). NRQL queries default to querying against the last hour of data. In order to widen the scope of your data you will need to include a SINCE clause at the end of your query. Example #1: Daily report for the last week To generate a daily report for the last week you would add SINCE 1 week ago: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET dateOf(timestamp) SINCE 1 week ago Copy Example #2: Report for a particular monitor To scope the results to a particular monitor you can edit the below query to include a specific monitor name: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName = 'mymonitorname' Copy Example #3: Report for multiple monitors To scope the results to a collection of monitors: SELECT average(duration), apdex(duration, t:), percentage(count(*), WHERE result='SUCCESS') FROM SyntheticCheck FACET timeperiod WHERE monitorName IN ('mymonitor1', 'mymonitor2', 'mymonitor3') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.37956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Aggregate <em>monitor</em> metrics",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Use SLA reports to view summary performance metrics across time or multiple monitors. Compare your current performance to historical metrics with daily, weekly, and monthly reporting. View <em>synthetic</em> <em>monitoring</em> SLA reports To view your account-wide SLA report: Go to one.newrelic.com &gt; <em>Synthetics</em>"
      },
      "id": "603ec399196a67e073a83d96"
    },
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-12-09T21:12:39Z",
      "updated_at": "2021-11-07T09:25:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. Avoid extra noise and get notified after three failures Read our blog post on the three strikes rule.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.85132,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures <em>page</em> To access your <em>monitor</em>&#x27;s failures: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Failures. Hover the mouse over a failure to get"
      },
      "id": "603e9efd64441faf344e8865"
    },
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-10T13:37:34Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.18903,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results <em>page</em> To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results <em>page</em> to locate interesting runs of your <em>monitor</em> for troubleshooting"
      },
      "id": "603eb5da64441f07ae4e8850"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration": [
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-12-09T21:14:22Z",
      "updated_at": "2021-11-26T09:10:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher. macOS: 10.11 or higher. Windows: Windows 10 64-bit or higher. You must also configure Docker to run Linux containers in order for CPMs to work on Windows systems. Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution The Docker CPM is not designed for use with container orchestrators like AWS ECS, Docker Swarm, Apache Mesos, Azure Container Instances, etc. Running the Docker CPM in a container orchestrator will result in unexpected issues because it is itself a container orchestrator. If you're using container orchestration, see our Kubernetes CPM requirements. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Unless hosting the images in a local image repository, connections to either quay.io or docker.io will need to be allowed through your firewall in order for Docker to pull the synthetics-minion and synthetics-minion-runner images. The \"runner\" image is pulled automatically on startup of the synthetics-minion container. See Docker environment configuration and Kubernetes environment configuration for details on how to set a local repository and the runner registry endpoint. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.63371,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.13411,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and <em>private</em> <em>locations</em>. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials <em>Private</em> <em>locations</em> (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Private locations overview: Monitor internal sites and add new locations",
        "What you need",
        "Create a private location",
        "Tip",
        "Ping monitor checks",
        "Add jobs to the location queue",
        "Manage private locations",
        "Set proxy configuration"
      ],
      "title": "Private locations overview: Monitor internal sites and add new locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "169a071fc32eb5229ebc4e32deac6eb53481e61d",
      "image": "https://docs.newrelic.com/static/e24392abbb29035544f7fc902cf3deea/8c557/screen-assign-to-private-location-synthetics-monitor_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/private-locations-overview-monitor-internal-sites-add-new-locations/",
      "published_at": "2021-12-09T21:15:09Z",
      "updated_at": "2021-10-13T00:50:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In synthetic monitoring, a private location is a collection of private minions. A minion is a containerized application that receives and manages jobs set up through the Synthetics UI. A private location can contain any number of private minions. Private locations allow you to extend your synthetic monitoring coverage to new geographical locations, and to monitor websites behind your firewall (like an intranet site). What you need To use private locations, first review these requirements and other factors: Compatibility for... Requirements Check budget Checks from a private location count against your budget. Synthetics horde endpoint For US-based accounts: https://synthetics-horde.nr-data.net/ For EU-based accounts: https://synthetics-horde.eu01.nr-data.net/ Outbound network access The minion needs to connect to the synthetic monitoring's horde endpoint to receive and process jobs. If your firewall rules don't permit direct access, you must configure proxy access. Test your connection to the horde endpoint with a successful response from the following command: curl -X GET https://synthetics-horde.nr-data.net/synthetics/api/v1/ping Copy Account access and permissions How access works depends on your user model: Original user model: If a private location is set up by an account with child accounts, it can be used by users with access to those child accounts. But if it's set up on a child account, it can only be used by users in that account. New Relic One user model: user access to an account depends on whether they've been granted access to that account. Create a private location one.newrelic.com > Synthetics > Private Locations: Use the Private Locations page to create, edit, and delete private locations. Before installing private minions, you need to create a private location. To create a new private location: Ensure you meet the requirements, including account access requirements. Go to one.newrelic.com > Synthetics > Private locations. Then select Create private location. Tip The private locations sub menu becomes available after you create your first monitor. Type a location name. Optional: Configure these additional settings: Description: Describe your private location for other account users. Verified script execution: Require a passphrase when assigning scripts to this location, or when adding minions to the location. Select Create. After creating the location, Synthetics lists your Private location key so you can install a private minion. Ping monitor checks Each minion can run about 200 ping monitor checks per minute (about 8,640,000 checks per month). If the job queue for a particular location is growing, add additional minions. The exact capacity of the minions can vary, depending on: Your network performance The complexity of your scripts The hardware configuration for the private minion Add jobs to the location queue To add jobs to the queue for your location, follow standard procedures to add or edit a monitor, and select your location from the Private locations list. To assign an existing monitor, edit that monitor's settings. one.newrelic.com > Synthetics > Create monitor: To assign new jobs to your private location and its minions, select its name from the Create monitor page. Manage private locations Tip If you can't access this feature, check the Factors affecting access to features and data. Synthetic monitoring includes tools to manage locations and individual minions. You can also install new minions, and clear the job queue if it backs up. To access these tools, go to one.newrelic.com > Synthetics > Private locations. Then follow the steps: If you want to... Do this... Clear the job queue Click the icon, and select Clear queue. This is useful when the number of scheduled jobs has increased faster than the minions can process them, such as when the minion is offline. View the status of an individual minion Select the parent location's name from the list. The green health status indicator identifies active minions. You can also view the last reported time for each minion, and check whether the minion software is out of date. Change location or view the private location key Click the icon, and select Edit. Delete a location Click the icon for the location, and select Delete. This does not shut down any minions assigned to that location. The minions must be shut down manually or reassigned. Enable or disable verified script execution Legacy minions: Verified script execution requires that you set up a passphrase on the minion before assigning any scripts to the location. CPM: You need to pass the MINION_VSE_PASSPHRASE variable to the minion. Then, at the Private locations tab, click on Edit and, in the menu, enable the Verified script execution option. Set proxy configuration You can set proxy server configuration for synthetic scripted monitors that run from local private locations. For more information, see Synthetic's proxy settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.49991,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "sections": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In <em>synthetic</em> <em>monitoring</em>, a <em>private</em> location is a collection of <em>private</em> minions. A minion is a containerized application that receives and manages jobs set up through the <em>Synthetics</em> UI. A <em>private</em> location can contain any number of <em>private</em> minions. <em>Private</em> <em>locations</em> allow you to extend your <em>synthetic</em>"
      },
      "id": "604525f1e7b9d2d88d579a1c"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-maintenance-monitoring": [
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-12-09T21:14:22Z",
      "updated_at": "2021-11-26T09:10:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher. macOS: 10.11 or higher. Windows: Windows 10 64-bit or higher. You must also configure Docker to run Linux containers in order for CPMs to work on Windows systems. Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution The Docker CPM is not designed for use with container orchestrators like AWS ECS, Docker Swarm, Apache Mesos, Azure Container Instances, etc. Running the Docker CPM in a container orchestrator will result in unexpected issues because it is itself a container orchestrator. If you're using container orchestration, see our Kubernetes CPM requirements. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Unless hosting the images in a local image repository, connections to either quay.io or docker.io will need to be allowed through your firewall in order for Docker to pull the synthetics-minion and synthetics-minion-runner images. The \"runner\" image is pulled automatically on startup of the synthetics-minion container. See Docker environment configuration and Kubernetes environment configuration for details on how to set a local repository and the runner registry endpoint. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.63371,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.13411,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and <em>private</em> <em>locations</em>. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials <em>Private</em> <em>locations</em> (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Containerized private minion (CPM) configuration",
        "Guidelines for mounting volumes",
        "Custom npm modules",
        "Custom module directory",
        "Node version-specific overrides",
        "Docker",
        "Kubernetes",
        "Change package.json for custom modules",
        "Caution",
        "Permanent data storage",
        "User-defined environment variables for scripted monitors",
        "Mounting JSON file",
        "Passing as an environment variable",
        "Tip",
        "Accessing user-defined environment variables from scripts",
        "Environment variables",
        "Docker environment configuration",
        "Kubernetes environment configuration"
      ],
      "title": "Containerized private minion (CPM) configuration",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "5c65dd79f361d23da2154f6a4227515a40dae944",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration/",
      "published_at": "2021-12-09T21:13:26Z",
      "updated_at": "2021-11-15T07:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to configure your containerized private minion (CPM). You can do the following to customize your CPMs: Set up custom modules for scripted browsers in New Relic. Preserve launch data with permanent data storage. Use environment variables in your configuration. You may not modify any CPM files and New Relic is not liable for any modifications you make. Guidelines for mounting volumes All directories and files must be assigned group ownership as 3729 with read/write permissions. This ensures that the Runner, which uses uid: 1000 and gid: 3729, has access to all the mounted volumes. However, the Minion is able to run as root (uid: 0) or with any uid between the range of [2000, 4000], inclusive. For more information, see running as non-root in Kubernetes or Docker. Docker Directories are mounted onto a container as volumes by specifying a -v argument within docker run For example, docker run ... -v /path/to/src:/path/to/dest:rw Kubernetes It is possible to add a directory onto a persistent volume (PV) by using kubectl cp. However, alternative approaches are supported as long as the file permissions are set appropriately. For example, kubectl cp /path/to/src <POD_NAME>:/path/to/dest will add a directory onto each PV in the specified pod Each PV must have a separate copy of the directories. For example, a cluster with n Minion replicas must have n PVs, each with their own copy of directories The directories and files must be added prior to the Minion boot up, otherwise the Minion must be restarted to detect the updates Custom npm modules Custom npm modules are exclusive to the CPM. They allow you to provide an arbitrary set of npm modules, and make them available for scripted monitors in Synthetics. To set up the modules: Create a directory which contains a package.json, following the npm official guidelines, in the root of the directory. Anything contained in the dependencies field will be installed by the CPM at start, and made available when running monitors on that private minion. Optionally, you can override the root level package.json with a Node version-specific directory. This allows a script to be updated per monitor runtime if a Node version of a runtime is no longer compatible with your dependencies. See an example of this below. Custom module directory In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file Copy The package.json defines dependencies as both a local module (for example, counter) and an npm hosted modules (for example, async version ^2.6.1): { \"name\": \"custom-modules\", \"version\": \"1.0.0\", ⇦ optional \"description\": \"example custom modules directory\", ⇦ optional \"dependencies\": { \"async\": \"^2.6.1\", ⇦ npm hosted module \"counter\": \"file:./counter\" ⇦ Local module } } Copy Node version-specific overrides You can declare a package.json per Node version that will override the root level package.json. This allows a monitor script to be updated per monitor runtime in the event that the Node version of a runtime is no longer compatible with your dependencies. As shown in the first example, local modules can still be defined within a version specific directory. If a package.json is not defined for a specific Node version, then the root level package.json will be used to install dependencies. In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── 6.11.2 ⇦ optional Node specific directory │ └── package.json └── 10.15.0 ⇦ optional Node specific directory │ └── package.json ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file ​ Copy Once you create the custom modules directory and the package.json you can apply it to your CPM for Docker and Kubernetes. Docker For Docker, launch CPM mounting the directory at /var/lib/newrelic/synthetics/modules. For example: docker run ... -v /example-custom-modules-dir:/var/lib/newrelic/synthetics/modules:rw ... Copy Kubernetes Complete the following: Launch the CPM, setting a value for the persistence.customModules configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where your custom modules files exist. For example: helm install ... --set persistence.customModules=<custom-modules-subpath> ... Copy Make sure that your custom modules directory is available on the Minion Pod. You can use kubectl cp as one method to copy the directory from your host to the Minion. For example: kubectl cp /example-custom-modules-dir <namespace>/<pod_name>:/var/lib/newrelic/synthetics/modules Copy Look at the CPM logs for \"... Initialization of Custom Modules ...\" to see if the modules were installed properly, or if there were any errors. The npm installation logs will be shown. Now you can add \"require('async');\" into the script of monitors you send to this private location. Change package.json for custom modules Along with npm modules, you can also use Node.js modules. To change the custom modules used by your CPM, modify package.json and reboot the CPM. It will detect the change in configuration during the reboot, and then clean up and re-install. Caution Local modules: While your package.json can include any local module, these modules must reside inside the tree under your custom module directory. If stored outside the tree, the initialization process will fail and you will see an error message in the docker logs after launching CPM. Permanent data storage CPM is a stateless application and does not preserve information from prior requests or sessions by default. However, you can preserve data between launches by enabling permanent data storage. For example, you can permanently set how the minion identifies itself (for example, Minion_ID), and use it to associate the data visible in Synthetics and Insights events with the exact minion that produced it. To set permanent data storage on Docker: Create a directory. Launch the CPM, mounting the directory at /var/lib/newrelic/synthetics. Example: docker run ... -v /example-permanent-dir:/var/lib/newrelic/synthetics:rw ... Copy To set permanent data storage on Kubernetes: Launch the CPM, setting a value for the persistence.permanentData configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where you want the data to be saved. Example: helm install ... --set persistence.permanentData=<permanent-data-subpath> ... Copy User-defined environment variables for scripted monitors Containerized private minions let you configure environment variables for use in scripted monitors. These variables are hosted locally on the CPM and can be accessed via $env.USER_DEFINED_VARIABLES. There are two ways to set user-defined variables: by mounting a JSON file or by supplying an environment variable to the CPM on launch. If both are provided, the CPM will use values provided from the environment only. Mounting JSON file The JSON file must have read permissions and contain a JSON formatted map. Example user-defined variable file: { \"KEY\" : \"VALUE\", \"User_Name\": \"MINION\", \"My_Password\": \"PASSW0RD 1 2 3\", \"my_URL\": \"https://newrelic.com/\", \"ETC\" : \"ETC\" } Copy The file must be available or mounted to the path in your container: /var/lib/newrelic/synthetics/variables/user_defined_variables.json Docker example: docker run ... -v /example-user-defined-variables.json:/var/lib/newrelic/synthetics/variables/user_defined_variables.json:rw ... Copy Kubernetes example: When mounting a JSON file to your Minion Pod in Kubernetes, you can either copy the file directly to the Minion Pod or to a Pod that has access to the same Persistent Volume and Persistent Volume Claim that the Minion will use. After successfully loading the file, you may need to restart your Minion Pod for the change to take effect. kubectl cp path/to/user_defined_variables.json <namespace>/<pod_name>:/var/lib/newrelic/synthetics/variables/user_defined_variables.json Copy Passing as an environment variable Use the -e flag to set up an environment variable named MINION_USER_DEFINED_VARIABLES and give it a value of a JSON formatted map string. docker run ... -e MINION_USER_DEFINED_ENV_VARIABLES='{\"KEY\":\"VALUE\",\"NAME\":\"MINION\",\"ETC\":\"ETC\"}' ... Copy Tip The CPM on Kubernetes does not currently support loading user-defined environment variables via environment variable. You will have to configure your Kubernetes CPM by mounting a JSON file. Accessing user-defined environment variables from scripts To reference a configured user-defined environment variable, use the reserved $env.USER_DEFINED_VARIABLES followed by the name of a given variable with dot notation. For example, $env.USER_DEFINED_VARIABLES.MY_VARIABLE Caution User-defined environment variables are not sanitized from logs. For sensitive information, consider using the secure credentials feature. Environment variables Environmental variables allow you to fine-tune the CPM configuration to meet your specific environmental and functional needs. Docker environment configuration The variables are provided at startup using the -e, --env argument. The following table shows all the environment variables that CPM supports. MINION_PRIVATE_LOCATION_KEY is required, and all other variables are optional. Name Description MINION_PRIVATE_LOCATION_KEY REQUIRED. UUID of the Private Location, as found on the Private Location Web page. DOCKER_API_VERSION Format: \"vX.Y\" API version to be used with the given Docker service. Default: v1.35. DOCKER_HOST Points the minion to a given DOCKER_HOST. If absent, the default value is /var/run/docker.sock. MINION_API_ENDPOINT For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. MINION_DOCKER_RUNNER_REGISTRY_ENDPOINT The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic). MINION_API_PROXY Format: \"host:port\". MINION_API_PROXY_AUTH Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. MINION_API_PROXY_SELF_SIGNED_CERT Acceptable values: true, 1, or yes (any case). MINION_CHECK_TIMEOUT The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. MINION_DOCKER_API_VERSION Synonym of DOCKER_API_VERSION. MINION_DOCKER_HOST Synonym of DOCKER_HOST. MINION_RUNNER_APPARMOR (CPM version > 3.0.2) OR MINION_DOCKER_RUNNER_APPARMOR (CPM version <= 3.0.2) The AppArmor profile name, if it has been applied to Docker containers running monitor scripts (for example, Docker Runner). The AppArmor profile name must exist and be set up on the machine to work. MINION_JVM_MB Default: \"2560\" (2.5GB). MINION_JVM_OPTS Passes command line options to the internal JVM. See Oracle's Java documentation for more information. Default: -server. MINION_LOG_LEVEL When contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. MINION_NETWORK_HEALTHCHECK_DISABLED (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. MINION_USER_DEFINED_ENV_VARIABLES Format: Example. A locally hosted set of user defined key value pairs. MINION_HEAVY_WORKERS The number of workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. MINION_LIGHTWEIGHT_WORKERS The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 1250. For more information on monitor types, see Types of Synthetics monitors. MINION_VSE_PASSPHRASE If set, enables verified script execution and uses this value as a passphrase. Kubernetes environment configuration The variables are provided at startup using the --set argument. The following list shows all the environment variables that CPM supports. synthetics.privateLocationKey is required, and all other variables are optional. Name Description synthetics.privateLocationKey REQUIRED if synthetics.privateLocationKeySecretName is not set. UUID/Private location key of the private location, as found on the private location web page. synthetics.privateLocationKeySecretName REQUIRED if synthetics.privateLocationKey is not set. Name of the Kubernetes secret that contains the key privateLocationKey, which contains the authentication key associated with your Synthetics private location. replicaCount Number of replicas to maintain with your StatefulSet installation Default: 1. imagePullSecrets The name of the secret object used to pull an image from a specified container registry. fullnameOverride Name override used for your StatefulSet installation, replacing the default. appVersionOverride Release version of CPM to use instead of the version specified in chart.yml. synthetics.minionLogLevel If contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. synthetics.heavyWorkers The number of concurrent workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use the value 2. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. synthetics.lightweightWorkers The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * synthetics.heavyWorkers, where synthetics.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on monitor types, see Types of synthetic monitors. synthetics.minionApiEndpoint For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. synthetics.minionDockerRunnerRegistryEndpoint The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic) synthetics.minionVsePassphrase If set, it enables verified script execution, and uses this value as a passphrase. synthetics.minionVsePassphraseSecretName If set, enables verified script execution and uses this value to retrieve the passphrase from a Kubernetes secret with a key called minionVsePassphrase. synthetics.minionApiProxy Format: \"host:port\". synthetics.minionApiProxySelfSignedCert Acceptable values: true, 1, or yes (any case). synthetics.minionApiProxyAuth Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. synthetics.minionCheckTimeout The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. synthetics.minionUserDefinedEnvVariable Format: Example. A locally hosted set of user-defined key value pairs. synthetics.minionJVMOpts Passes command line options to the internal JVM. Default: -server -XX:-UsePerfData synthetics.minionNetworkHealthCheckDisabled (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. image.repository The container to pull. Default: quay.io/newrelic/synthetics-minion image.pullPolicy The pull policy. Default: IfNotPresent persistence.claimName The name of the PVC to use. If undefined or not set, Statefulset will dynamically create a PVC for each replica. persistence.storageClass Overrides StorageClass for VolumeClaimTemplates, relevant only if claimName is undefined or empty. For more details see persistent volumes. persistence.accessMode Access mode to be defined for the PVC, relevant only if claimName is undefined or empty. Default: ReadWriteOnce. persistence.annotations Annotations to add to the PVC, relevant only if claimName is undefined or empty. persistence.size Size to be defined for the PVC, relevant only if claimName is undefined or empty. Default: 10Gi. persistence.permanentData Path on the volume to the permanent data storage directory. For more details, see permanent data storage. persistence.customModules Path on the volume to the custom modules directory. For more details, see custom modules. persistence.userDefinedVariables Path on the volume to the user-defined-variable.json file. For more details, see user defined variables. serviceAccount.create If true, a service account is created and assigned to the deployment. Default: false. serviceAccount.name The service account to assign to the deployment. If serviceAccount.create is true, then this name is used when creating the service account. serviceAccount.annotations The annotations to add to the service account if serviceAccount.create is set to true. removeJobsLog Default Kubernetes doesn't include a jobs/log resource. Set this to true to remove it from the role if needed. Default: false. headlessService.serviceName The name of the headless service to associate to the StatefulSet. If not set a name is generated using the fullname template. appArmorProfileName The AppArmor profile name that will be applied to the Minion and Runner pods. If set, then the AppArmor profile must exist on the Kubernetes node(s) for this to work. podSecurityContextRunAsUser A UID that can be set to either 0 (root) or between [2000, 4000], inclusive. If set, runs the CPM as the given UID. Default: 2379.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.6993,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Containerized <em>private</em> minion (CPM) configuration",
        "sections": "Containerized <em>private</em> minion (CPM) configuration",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " * <em>synthetics</em>.heavyWorkers, where <em>synthetics</em>.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on <em>monitor</em> types, see Types of <em>synthetic</em> monitors. <em>synthetics</em>.minionApiEndpoint For US-based accounts, the endpoint"
      },
      "id": "603ea540196a67e50da83d95"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms": [
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.13408,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and <em>private</em> <em>locations</em>. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials <em>Private</em> <em>locations</em> (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Containerized private minion (CPM) configuration",
        "Guidelines for mounting volumes",
        "Custom npm modules",
        "Custom module directory",
        "Node version-specific overrides",
        "Docker",
        "Kubernetes",
        "Change package.json for custom modules",
        "Caution",
        "Permanent data storage",
        "User-defined environment variables for scripted monitors",
        "Mounting JSON file",
        "Passing as an environment variable",
        "Tip",
        "Accessing user-defined environment variables from scripts",
        "Environment variables",
        "Docker environment configuration",
        "Kubernetes environment configuration"
      ],
      "title": "Containerized private minion (CPM) configuration",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "5c65dd79f361d23da2154f6a4227515a40dae944",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration/",
      "published_at": "2021-12-09T21:13:26Z",
      "updated_at": "2021-11-15T07:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to configure your containerized private minion (CPM). You can do the following to customize your CPMs: Set up custom modules for scripted browsers in New Relic. Preserve launch data with permanent data storage. Use environment variables in your configuration. You may not modify any CPM files and New Relic is not liable for any modifications you make. Guidelines for mounting volumes All directories and files must be assigned group ownership as 3729 with read/write permissions. This ensures that the Runner, which uses uid: 1000 and gid: 3729, has access to all the mounted volumes. However, the Minion is able to run as root (uid: 0) or with any uid between the range of [2000, 4000], inclusive. For more information, see running as non-root in Kubernetes or Docker. Docker Directories are mounted onto a container as volumes by specifying a -v argument within docker run For example, docker run ... -v /path/to/src:/path/to/dest:rw Kubernetes It is possible to add a directory onto a persistent volume (PV) by using kubectl cp. However, alternative approaches are supported as long as the file permissions are set appropriately. For example, kubectl cp /path/to/src <POD_NAME>:/path/to/dest will add a directory onto each PV in the specified pod Each PV must have a separate copy of the directories. For example, a cluster with n Minion replicas must have n PVs, each with their own copy of directories The directories and files must be added prior to the Minion boot up, otherwise the Minion must be restarted to detect the updates Custom npm modules Custom npm modules are exclusive to the CPM. They allow you to provide an arbitrary set of npm modules, and make them available for scripted monitors in Synthetics. To set up the modules: Create a directory which contains a package.json, following the npm official guidelines, in the root of the directory. Anything contained in the dependencies field will be installed by the CPM at start, and made available when running monitors on that private minion. Optionally, you can override the root level package.json with a Node version-specific directory. This allows a script to be updated per monitor runtime if a Node version of a runtime is no longer compatible with your dependencies. See an example of this below. Custom module directory In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file Copy The package.json defines dependencies as both a local module (for example, counter) and an npm hosted modules (for example, async version ^2.6.1): { \"name\": \"custom-modules\", \"version\": \"1.0.0\", ⇦ optional \"description\": \"example custom modules directory\", ⇦ optional \"dependencies\": { \"async\": \"^2.6.1\", ⇦ npm hosted module \"counter\": \"file:./counter\" ⇦ Local module } } Copy Node version-specific overrides You can declare a package.json per Node version that will override the root level package.json. This allows a monitor script to be updated per monitor runtime in the event that the Node version of a runtime is no longer compatible with your dependencies. As shown in the first example, local modules can still be defined within a version specific directory. If a package.json is not defined for a specific Node version, then the root level package.json will be used to install dependencies. In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── 6.11.2 ⇦ optional Node specific directory │ └── package.json └── 10.15.0 ⇦ optional Node specific directory │ └── package.json ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file ​ Copy Once you create the custom modules directory and the package.json you can apply it to your CPM for Docker and Kubernetes. Docker For Docker, launch CPM mounting the directory at /var/lib/newrelic/synthetics/modules. For example: docker run ... -v /example-custom-modules-dir:/var/lib/newrelic/synthetics/modules:rw ... Copy Kubernetes Complete the following: Launch the CPM, setting a value for the persistence.customModules configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where your custom modules files exist. For example: helm install ... --set persistence.customModules=<custom-modules-subpath> ... Copy Make sure that your custom modules directory is available on the Minion Pod. You can use kubectl cp as one method to copy the directory from your host to the Minion. For example: kubectl cp /example-custom-modules-dir <namespace>/<pod_name>:/var/lib/newrelic/synthetics/modules Copy Look at the CPM logs for \"... Initialization of Custom Modules ...\" to see if the modules were installed properly, or if there were any errors. The npm installation logs will be shown. Now you can add \"require('async');\" into the script of monitors you send to this private location. Change package.json for custom modules Along with npm modules, you can also use Node.js modules. To change the custom modules used by your CPM, modify package.json and reboot the CPM. It will detect the change in configuration during the reboot, and then clean up and re-install. Caution Local modules: While your package.json can include any local module, these modules must reside inside the tree under your custom module directory. If stored outside the tree, the initialization process will fail and you will see an error message in the docker logs after launching CPM. Permanent data storage CPM is a stateless application and does not preserve information from prior requests or sessions by default. However, you can preserve data between launches by enabling permanent data storage. For example, you can permanently set how the minion identifies itself (for example, Minion_ID), and use it to associate the data visible in Synthetics and Insights events with the exact minion that produced it. To set permanent data storage on Docker: Create a directory. Launch the CPM, mounting the directory at /var/lib/newrelic/synthetics. Example: docker run ... -v /example-permanent-dir:/var/lib/newrelic/synthetics:rw ... Copy To set permanent data storage on Kubernetes: Launch the CPM, setting a value for the persistence.permanentData configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where you want the data to be saved. Example: helm install ... --set persistence.permanentData=<permanent-data-subpath> ... Copy User-defined environment variables for scripted monitors Containerized private minions let you configure environment variables for use in scripted monitors. These variables are hosted locally on the CPM and can be accessed via $env.USER_DEFINED_VARIABLES. There are two ways to set user-defined variables: by mounting a JSON file or by supplying an environment variable to the CPM on launch. If both are provided, the CPM will use values provided from the environment only. Mounting JSON file The JSON file must have read permissions and contain a JSON formatted map. Example user-defined variable file: { \"KEY\" : \"VALUE\", \"User_Name\": \"MINION\", \"My_Password\": \"PASSW0RD 1 2 3\", \"my_URL\": \"https://newrelic.com/\", \"ETC\" : \"ETC\" } Copy The file must be available or mounted to the path in your container: /var/lib/newrelic/synthetics/variables/user_defined_variables.json Docker example: docker run ... -v /example-user-defined-variables.json:/var/lib/newrelic/synthetics/variables/user_defined_variables.json:rw ... Copy Kubernetes example: When mounting a JSON file to your Minion Pod in Kubernetes, you can either copy the file directly to the Minion Pod or to a Pod that has access to the same Persistent Volume and Persistent Volume Claim that the Minion will use. After successfully loading the file, you may need to restart your Minion Pod for the change to take effect. kubectl cp path/to/user_defined_variables.json <namespace>/<pod_name>:/var/lib/newrelic/synthetics/variables/user_defined_variables.json Copy Passing as an environment variable Use the -e flag to set up an environment variable named MINION_USER_DEFINED_VARIABLES and give it a value of a JSON formatted map string. docker run ... -e MINION_USER_DEFINED_ENV_VARIABLES='{\"KEY\":\"VALUE\",\"NAME\":\"MINION\",\"ETC\":\"ETC\"}' ... Copy Tip The CPM on Kubernetes does not currently support loading user-defined environment variables via environment variable. You will have to configure your Kubernetes CPM by mounting a JSON file. Accessing user-defined environment variables from scripts To reference a configured user-defined environment variable, use the reserved $env.USER_DEFINED_VARIABLES followed by the name of a given variable with dot notation. For example, $env.USER_DEFINED_VARIABLES.MY_VARIABLE Caution User-defined environment variables are not sanitized from logs. For sensitive information, consider using the secure credentials feature. Environment variables Environmental variables allow you to fine-tune the CPM configuration to meet your specific environmental and functional needs. Docker environment configuration The variables are provided at startup using the -e, --env argument. The following table shows all the environment variables that CPM supports. MINION_PRIVATE_LOCATION_KEY is required, and all other variables are optional. Name Description MINION_PRIVATE_LOCATION_KEY REQUIRED. UUID of the Private Location, as found on the Private Location Web page. DOCKER_API_VERSION Format: \"vX.Y\" API version to be used with the given Docker service. Default: v1.35. DOCKER_HOST Points the minion to a given DOCKER_HOST. If absent, the default value is /var/run/docker.sock. MINION_API_ENDPOINT For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. MINION_DOCKER_RUNNER_REGISTRY_ENDPOINT The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic). MINION_API_PROXY Format: \"host:port\". MINION_API_PROXY_AUTH Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. MINION_API_PROXY_SELF_SIGNED_CERT Acceptable values: true, 1, or yes (any case). MINION_CHECK_TIMEOUT The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. MINION_DOCKER_API_VERSION Synonym of DOCKER_API_VERSION. MINION_DOCKER_HOST Synonym of DOCKER_HOST. MINION_RUNNER_APPARMOR (CPM version > 3.0.2) OR MINION_DOCKER_RUNNER_APPARMOR (CPM version <= 3.0.2) The AppArmor profile name, if it has been applied to Docker containers running monitor scripts (for example, Docker Runner). The AppArmor profile name must exist and be set up on the machine to work. MINION_JVM_MB Default: \"2560\" (2.5GB). MINION_JVM_OPTS Passes command line options to the internal JVM. See Oracle's Java documentation for more information. Default: -server. MINION_LOG_LEVEL When contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. MINION_NETWORK_HEALTHCHECK_DISABLED (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. MINION_USER_DEFINED_ENV_VARIABLES Format: Example. A locally hosted set of user defined key value pairs. MINION_HEAVY_WORKERS The number of workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. MINION_LIGHTWEIGHT_WORKERS The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 1250. For more information on monitor types, see Types of Synthetics monitors. MINION_VSE_PASSPHRASE If set, enables verified script execution and uses this value as a passphrase. Kubernetes environment configuration The variables are provided at startup using the --set argument. The following list shows all the environment variables that CPM supports. synthetics.privateLocationKey is required, and all other variables are optional. Name Description synthetics.privateLocationKey REQUIRED if synthetics.privateLocationKeySecretName is not set. UUID/Private location key of the private location, as found on the private location web page. synthetics.privateLocationKeySecretName REQUIRED if synthetics.privateLocationKey is not set. Name of the Kubernetes secret that contains the key privateLocationKey, which contains the authentication key associated with your Synthetics private location. replicaCount Number of replicas to maintain with your StatefulSet installation Default: 1. imagePullSecrets The name of the secret object used to pull an image from a specified container registry. fullnameOverride Name override used for your StatefulSet installation, replacing the default. appVersionOverride Release version of CPM to use instead of the version specified in chart.yml. synthetics.minionLogLevel If contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. synthetics.heavyWorkers The number of concurrent workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use the value 2. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. synthetics.lightweightWorkers The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * synthetics.heavyWorkers, where synthetics.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on monitor types, see Types of synthetic monitors. synthetics.minionApiEndpoint For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. synthetics.minionDockerRunnerRegistryEndpoint The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic) synthetics.minionVsePassphrase If set, it enables verified script execution, and uses this value as a passphrase. synthetics.minionVsePassphraseSecretName If set, enables verified script execution and uses this value to retrieve the passphrase from a Kubernetes secret with a key called minionVsePassphrase. synthetics.minionApiProxy Format: \"host:port\". synthetics.minionApiProxySelfSignedCert Acceptable values: true, 1, or yes (any case). synthetics.minionApiProxyAuth Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. synthetics.minionCheckTimeout The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. synthetics.minionUserDefinedEnvVariable Format: Example. A locally hosted set of user-defined key value pairs. synthetics.minionJVMOpts Passes command line options to the internal JVM. Default: -server -XX:-UsePerfData synthetics.minionNetworkHealthCheckDisabled (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. image.repository The container to pull. Default: quay.io/newrelic/synthetics-minion image.pullPolicy The pull policy. Default: IfNotPresent persistence.claimName The name of the PVC to use. If undefined or not set, Statefulset will dynamically create a PVC for each replica. persistence.storageClass Overrides StorageClass for VolumeClaimTemplates, relevant only if claimName is undefined or empty. For more details see persistent volumes. persistence.accessMode Access mode to be defined for the PVC, relevant only if claimName is undefined or empty. Default: ReadWriteOnce. persistence.annotations Annotations to add to the PVC, relevant only if claimName is undefined or empty. persistence.size Size to be defined for the PVC, relevant only if claimName is undefined or empty. Default: 10Gi. persistence.permanentData Path on the volume to the permanent data storage directory. For more details, see permanent data storage. persistence.customModules Path on the volume to the custom modules directory. For more details, see custom modules. persistence.userDefinedVariables Path on the volume to the user-defined-variable.json file. For more details, see user defined variables. serviceAccount.create If true, a service account is created and assigned to the deployment. Default: false. serviceAccount.name The service account to assign to the deployment. If serviceAccount.create is true, then this name is used when creating the service account. serviceAccount.annotations The annotations to add to the service account if serviceAccount.create is set to true. removeJobsLog Default Kubernetes doesn't include a jobs/log resource. Set this to true to remove it from the role if needed. Default: false. headlessService.serviceName The name of the headless service to associate to the StatefulSet. If not set a name is generated using the fullname template. appArmorProfileName The AppArmor profile name that will be applied to the Minion and Runner pods. If set, then the AppArmor profile must exist on the Kubernetes node(s) for this to work. podSecurityContextRunAsUser A UID that can be set to either 0 (root) or between [2000, 4000], inclusive. If set, runs the CPM as the given UID. Default: 2379.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.69928,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Containerized <em>private</em> minion (CPM) configuration",
        "sections": "Containerized <em>private</em> minion (CPM) configuration",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " * <em>synthetics</em>.heavyWorkers, where <em>synthetics</em>.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on <em>monitor</em> types, see Types of <em>synthetic</em> monitors. <em>synthetics</em>.minionApiEndpoint For US-based accounts, the endpoint"
      },
      "id": "603ea540196a67e50da83d95"
    },
    {
      "sections": [
        "Private locations overview: Monitor internal sites and add new locations",
        "What you need",
        "Create a private location",
        "Tip",
        "Ping monitor checks",
        "Add jobs to the location queue",
        "Manage private locations",
        "Set proxy configuration"
      ],
      "title": "Private locations overview: Monitor internal sites and add new locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "169a071fc32eb5229ebc4e32deac6eb53481e61d",
      "image": "https://docs.newrelic.com/static/e24392abbb29035544f7fc902cf3deea/8c557/screen-assign-to-private-location-synthetics-monitor_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/private-locations-overview-monitor-internal-sites-add-new-locations/",
      "published_at": "2021-12-09T21:15:09Z",
      "updated_at": "2021-10-13T00:50:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In synthetic monitoring, a private location is a collection of private minions. A minion is a containerized application that receives and manages jobs set up through the Synthetics UI. A private location can contain any number of private minions. Private locations allow you to extend your synthetic monitoring coverage to new geographical locations, and to monitor websites behind your firewall (like an intranet site). What you need To use private locations, first review these requirements and other factors: Compatibility for... Requirements Check budget Checks from a private location count against your budget. Synthetics horde endpoint For US-based accounts: https://synthetics-horde.nr-data.net/ For EU-based accounts: https://synthetics-horde.eu01.nr-data.net/ Outbound network access The minion needs to connect to the synthetic monitoring's horde endpoint to receive and process jobs. If your firewall rules don't permit direct access, you must configure proxy access. Test your connection to the horde endpoint with a successful response from the following command: curl -X GET https://synthetics-horde.nr-data.net/synthetics/api/v1/ping Copy Account access and permissions How access works depends on your user model: Original user model: If a private location is set up by an account with child accounts, it can be used by users with access to those child accounts. But if it's set up on a child account, it can only be used by users in that account. New Relic One user model: user access to an account depends on whether they've been granted access to that account. Create a private location one.newrelic.com > Synthetics > Private Locations: Use the Private Locations page to create, edit, and delete private locations. Before installing private minions, you need to create a private location. To create a new private location: Ensure you meet the requirements, including account access requirements. Go to one.newrelic.com > Synthetics > Private locations. Then select Create private location. Tip The private locations sub menu becomes available after you create your first monitor. Type a location name. Optional: Configure these additional settings: Description: Describe your private location for other account users. Verified script execution: Require a passphrase when assigning scripts to this location, or when adding minions to the location. Select Create. After creating the location, Synthetics lists your Private location key so you can install a private minion. Ping monitor checks Each minion can run about 200 ping monitor checks per minute (about 8,640,000 checks per month). If the job queue for a particular location is growing, add additional minions. The exact capacity of the minions can vary, depending on: Your network performance The complexity of your scripts The hardware configuration for the private minion Add jobs to the location queue To add jobs to the queue for your location, follow standard procedures to add or edit a monitor, and select your location from the Private locations list. To assign an existing monitor, edit that monitor's settings. one.newrelic.com > Synthetics > Create monitor: To assign new jobs to your private location and its minions, select its name from the Create monitor page. Manage private locations Tip If you can't access this feature, check the Factors affecting access to features and data. Synthetic monitoring includes tools to manage locations and individual minions. You can also install new minions, and clear the job queue if it backs up. To access these tools, go to one.newrelic.com > Synthetics > Private locations. Then follow the steps: If you want to... Do this... Clear the job queue Click the icon, and select Clear queue. This is useful when the number of scheduled jobs has increased faster than the minions can process them, such as when the minion is offline. View the status of an individual minion Select the parent location's name from the list. The green health status indicator identifies active minions. You can also view the last reported time for each minion, and check whether the minion software is out of date. Change location or view the private location key Click the icon, and select Edit. Delete a location Click the icon for the location, and select Delete. This does not shut down any minions assigned to that location. The minions must be shut down manually or reassigned. Enable or disable verified script execution Legacy minions: Verified script execution requires that you set up a passphrase on the minion before assigning any scripts to the location. CPM: You need to pass the MINION_VSE_PASSPHRASE variable to the minion. Then, at the Private locations tab, click on Edit and, in the menu, enable the Verified script execution option. Set proxy configuration You can set proxy server configuration for synthetic scripted monitors that run from local private locations. For more information, see Synthetic's proxy settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.49991,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "sections": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In <em>synthetic</em> <em>monitoring</em>, a <em>private</em> location is a collection of <em>private</em> minions. A minion is a containerized application that receives and manages jobs set up through the <em>Synthetics</em> UI. A <em>private</em> location can contain any number of <em>private</em> minions. <em>Private</em> <em>locations</em> allow you to extend your <em>synthetic</em>"
      },
      "id": "604525f1e7b9d2d88d579a1c"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/monitor-private-locations": [
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-12-09T21:14:22Z",
      "updated_at": "2021-11-26T09:10:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher. macOS: 10.11 or higher. Windows: Windows 10 64-bit or higher. You must also configure Docker to run Linux containers in order for CPMs to work on Windows systems. Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution The Docker CPM is not designed for use with container orchestrators like AWS ECS, Docker Swarm, Apache Mesos, Azure Container Instances, etc. Running the Docker CPM in a container orchestrator will result in unexpected issues because it is itself a container orchestrator. If you're using container orchestration, see our Kubernetes CPM requirements. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Unless hosting the images in a local image repository, connections to either quay.io or docker.io will need to be allowed through your firewall in order for Docker to pull the synthetics-minion and synthetics-minion-runner images. The \"runner\" image is pulled automatically on startup of the synthetics-minion container. See Docker environment configuration and Kubernetes environment configuration for details on how to set a local repository and the runner registry endpoint. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.63367,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.13408,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and <em>private</em> <em>locations</em>. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials <em>Private</em> <em>locations</em> (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Containerized private minion (CPM) configuration",
        "Guidelines for mounting volumes",
        "Custom npm modules",
        "Custom module directory",
        "Node version-specific overrides",
        "Docker",
        "Kubernetes",
        "Change package.json for custom modules",
        "Caution",
        "Permanent data storage",
        "User-defined environment variables for scripted monitors",
        "Mounting JSON file",
        "Passing as an environment variable",
        "Tip",
        "Accessing user-defined environment variables from scripts",
        "Environment variables",
        "Docker environment configuration",
        "Kubernetes environment configuration"
      ],
      "title": "Containerized private minion (CPM) configuration",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "5c65dd79f361d23da2154f6a4227515a40dae944",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration/",
      "published_at": "2021-12-09T21:13:26Z",
      "updated_at": "2021-11-15T07:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to configure your containerized private minion (CPM). You can do the following to customize your CPMs: Set up custom modules for scripted browsers in New Relic. Preserve launch data with permanent data storage. Use environment variables in your configuration. You may not modify any CPM files and New Relic is not liable for any modifications you make. Guidelines for mounting volumes All directories and files must be assigned group ownership as 3729 with read/write permissions. This ensures that the Runner, which uses uid: 1000 and gid: 3729, has access to all the mounted volumes. However, the Minion is able to run as root (uid: 0) or with any uid between the range of [2000, 4000], inclusive. For more information, see running as non-root in Kubernetes or Docker. Docker Directories are mounted onto a container as volumes by specifying a -v argument within docker run For example, docker run ... -v /path/to/src:/path/to/dest:rw Kubernetes It is possible to add a directory onto a persistent volume (PV) by using kubectl cp. However, alternative approaches are supported as long as the file permissions are set appropriately. For example, kubectl cp /path/to/src <POD_NAME>:/path/to/dest will add a directory onto each PV in the specified pod Each PV must have a separate copy of the directories. For example, a cluster with n Minion replicas must have n PVs, each with their own copy of directories The directories and files must be added prior to the Minion boot up, otherwise the Minion must be restarted to detect the updates Custom npm modules Custom npm modules are exclusive to the CPM. They allow you to provide an arbitrary set of npm modules, and make them available for scripted monitors in Synthetics. To set up the modules: Create a directory which contains a package.json, following the npm official guidelines, in the root of the directory. Anything contained in the dependencies field will be installed by the CPM at start, and made available when running monitors on that private minion. Optionally, you can override the root level package.json with a Node version-specific directory. This allows a script to be updated per monitor runtime if a Node version of a runtime is no longer compatible with your dependencies. See an example of this below. Custom module directory In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file Copy The package.json defines dependencies as both a local module (for example, counter) and an npm hosted modules (for example, async version ^2.6.1): { \"name\": \"custom-modules\", \"version\": \"1.0.0\", ⇦ optional \"description\": \"example custom modules directory\", ⇦ optional \"dependencies\": { \"async\": \"^2.6.1\", ⇦ npm hosted module \"counter\": \"file:./counter\" ⇦ Local module } } Copy Node version-specific overrides You can declare a package.json per Node version that will override the root level package.json. This allows a monitor script to be updated per monitor runtime in the event that the Node version of a runtime is no longer compatible with your dependencies. As shown in the first example, local modules can still be defined within a version specific directory. If a package.json is not defined for a specific Node version, then the root level package.json will be used to install dependencies. In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── 6.11.2 ⇦ optional Node specific directory │ └── package.json └── 10.15.0 ⇦ optional Node specific directory │ └── package.json ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file ​ Copy Once you create the custom modules directory and the package.json you can apply it to your CPM for Docker and Kubernetes. Docker For Docker, launch CPM mounting the directory at /var/lib/newrelic/synthetics/modules. For example: docker run ... -v /example-custom-modules-dir:/var/lib/newrelic/synthetics/modules:rw ... Copy Kubernetes Complete the following: Launch the CPM, setting a value for the persistence.customModules configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where your custom modules files exist. For example: helm install ... --set persistence.customModules=<custom-modules-subpath> ... Copy Make sure that your custom modules directory is available on the Minion Pod. You can use kubectl cp as one method to copy the directory from your host to the Minion. For example: kubectl cp /example-custom-modules-dir <namespace>/<pod_name>:/var/lib/newrelic/synthetics/modules Copy Look at the CPM logs for \"... Initialization of Custom Modules ...\" to see if the modules were installed properly, or if there were any errors. The npm installation logs will be shown. Now you can add \"require('async');\" into the script of monitors you send to this private location. Change package.json for custom modules Along with npm modules, you can also use Node.js modules. To change the custom modules used by your CPM, modify package.json and reboot the CPM. It will detect the change in configuration during the reboot, and then clean up and re-install. Caution Local modules: While your package.json can include any local module, these modules must reside inside the tree under your custom module directory. If stored outside the tree, the initialization process will fail and you will see an error message in the docker logs after launching CPM. Permanent data storage CPM is a stateless application and does not preserve information from prior requests or sessions by default. However, you can preserve data between launches by enabling permanent data storage. For example, you can permanently set how the minion identifies itself (for example, Minion_ID), and use it to associate the data visible in Synthetics and Insights events with the exact minion that produced it. To set permanent data storage on Docker: Create a directory. Launch the CPM, mounting the directory at /var/lib/newrelic/synthetics. Example: docker run ... -v /example-permanent-dir:/var/lib/newrelic/synthetics:rw ... Copy To set permanent data storage on Kubernetes: Launch the CPM, setting a value for the persistence.permanentData configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where you want the data to be saved. Example: helm install ... --set persistence.permanentData=<permanent-data-subpath> ... Copy User-defined environment variables for scripted monitors Containerized private minions let you configure environment variables for use in scripted monitors. These variables are hosted locally on the CPM and can be accessed via $env.USER_DEFINED_VARIABLES. There are two ways to set user-defined variables: by mounting a JSON file or by supplying an environment variable to the CPM on launch. If both are provided, the CPM will use values provided from the environment only. Mounting JSON file The JSON file must have read permissions and contain a JSON formatted map. Example user-defined variable file: { \"KEY\" : \"VALUE\", \"User_Name\": \"MINION\", \"My_Password\": \"PASSW0RD 1 2 3\", \"my_URL\": \"https://newrelic.com/\", \"ETC\" : \"ETC\" } Copy The file must be available or mounted to the path in your container: /var/lib/newrelic/synthetics/variables/user_defined_variables.json Docker example: docker run ... -v /example-user-defined-variables.json:/var/lib/newrelic/synthetics/variables/user_defined_variables.json:rw ... Copy Kubernetes example: When mounting a JSON file to your Minion Pod in Kubernetes, you can either copy the file directly to the Minion Pod or to a Pod that has access to the same Persistent Volume and Persistent Volume Claim that the Minion will use. After successfully loading the file, you may need to restart your Minion Pod for the change to take effect. kubectl cp path/to/user_defined_variables.json <namespace>/<pod_name>:/var/lib/newrelic/synthetics/variables/user_defined_variables.json Copy Passing as an environment variable Use the -e flag to set up an environment variable named MINION_USER_DEFINED_VARIABLES and give it a value of a JSON formatted map string. docker run ... -e MINION_USER_DEFINED_ENV_VARIABLES='{\"KEY\":\"VALUE\",\"NAME\":\"MINION\",\"ETC\":\"ETC\"}' ... Copy Tip The CPM on Kubernetes does not currently support loading user-defined environment variables via environment variable. You will have to configure your Kubernetes CPM by mounting a JSON file. Accessing user-defined environment variables from scripts To reference a configured user-defined environment variable, use the reserved $env.USER_DEFINED_VARIABLES followed by the name of a given variable with dot notation. For example, $env.USER_DEFINED_VARIABLES.MY_VARIABLE Caution User-defined environment variables are not sanitized from logs. For sensitive information, consider using the secure credentials feature. Environment variables Environmental variables allow you to fine-tune the CPM configuration to meet your specific environmental and functional needs. Docker environment configuration The variables are provided at startup using the -e, --env argument. The following table shows all the environment variables that CPM supports. MINION_PRIVATE_LOCATION_KEY is required, and all other variables are optional. Name Description MINION_PRIVATE_LOCATION_KEY REQUIRED. UUID of the Private Location, as found on the Private Location Web page. DOCKER_API_VERSION Format: \"vX.Y\" API version to be used with the given Docker service. Default: v1.35. DOCKER_HOST Points the minion to a given DOCKER_HOST. If absent, the default value is /var/run/docker.sock. MINION_API_ENDPOINT For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. MINION_DOCKER_RUNNER_REGISTRY_ENDPOINT The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic). MINION_API_PROXY Format: \"host:port\". MINION_API_PROXY_AUTH Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. MINION_API_PROXY_SELF_SIGNED_CERT Acceptable values: true, 1, or yes (any case). MINION_CHECK_TIMEOUT The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. MINION_DOCKER_API_VERSION Synonym of DOCKER_API_VERSION. MINION_DOCKER_HOST Synonym of DOCKER_HOST. MINION_RUNNER_APPARMOR (CPM version > 3.0.2) OR MINION_DOCKER_RUNNER_APPARMOR (CPM version <= 3.0.2) The AppArmor profile name, if it has been applied to Docker containers running monitor scripts (for example, Docker Runner). The AppArmor profile name must exist and be set up on the machine to work. MINION_JVM_MB Default: \"2560\" (2.5GB). MINION_JVM_OPTS Passes command line options to the internal JVM. See Oracle's Java documentation for more information. Default: -server. MINION_LOG_LEVEL When contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. MINION_NETWORK_HEALTHCHECK_DISABLED (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. MINION_USER_DEFINED_ENV_VARIABLES Format: Example. A locally hosted set of user defined key value pairs. MINION_HEAVY_WORKERS The number of workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. MINION_LIGHTWEIGHT_WORKERS The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 1250. For more information on monitor types, see Types of Synthetics monitors. MINION_VSE_PASSPHRASE If set, enables verified script execution and uses this value as a passphrase. Kubernetes environment configuration The variables are provided at startup using the --set argument. The following list shows all the environment variables that CPM supports. synthetics.privateLocationKey is required, and all other variables are optional. Name Description synthetics.privateLocationKey REQUIRED if synthetics.privateLocationKeySecretName is not set. UUID/Private location key of the private location, as found on the private location web page. synthetics.privateLocationKeySecretName REQUIRED if synthetics.privateLocationKey is not set. Name of the Kubernetes secret that contains the key privateLocationKey, which contains the authentication key associated with your Synthetics private location. replicaCount Number of replicas to maintain with your StatefulSet installation Default: 1. imagePullSecrets The name of the secret object used to pull an image from a specified container registry. fullnameOverride Name override used for your StatefulSet installation, replacing the default. appVersionOverride Release version of CPM to use instead of the version specified in chart.yml. synthetics.minionLogLevel If contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. synthetics.heavyWorkers The number of concurrent workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use the value 2. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. synthetics.lightweightWorkers The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * synthetics.heavyWorkers, where synthetics.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on monitor types, see Types of synthetic monitors. synthetics.minionApiEndpoint For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. synthetics.minionDockerRunnerRegistryEndpoint The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic) synthetics.minionVsePassphrase If set, it enables verified script execution, and uses this value as a passphrase. synthetics.minionVsePassphraseSecretName If set, enables verified script execution and uses this value to retrieve the passphrase from a Kubernetes secret with a key called minionVsePassphrase. synthetics.minionApiProxy Format: \"host:port\". synthetics.minionApiProxySelfSignedCert Acceptable values: true, 1, or yes (any case). synthetics.minionApiProxyAuth Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. synthetics.minionCheckTimeout The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. synthetics.minionUserDefinedEnvVariable Format: Example. A locally hosted set of user-defined key value pairs. synthetics.minionJVMOpts Passes command line options to the internal JVM. Default: -server -XX:-UsePerfData synthetics.minionNetworkHealthCheckDisabled (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. image.repository The container to pull. Default: quay.io/newrelic/synthetics-minion image.pullPolicy The pull policy. Default: IfNotPresent persistence.claimName The name of the PVC to use. If undefined or not set, Statefulset will dynamically create a PVC for each replica. persistence.storageClass Overrides StorageClass for VolumeClaimTemplates, relevant only if claimName is undefined or empty. For more details see persistent volumes. persistence.accessMode Access mode to be defined for the PVC, relevant only if claimName is undefined or empty. Default: ReadWriteOnce. persistence.annotations Annotations to add to the PVC, relevant only if claimName is undefined or empty. persistence.size Size to be defined for the PVC, relevant only if claimName is undefined or empty. Default: 10Gi. persistence.permanentData Path on the volume to the permanent data storage directory. For more details, see permanent data storage. persistence.customModules Path on the volume to the custom modules directory. For more details, see custom modules. persistence.userDefinedVariables Path on the volume to the user-defined-variable.json file. For more details, see user defined variables. serviceAccount.create If true, a service account is created and assigned to the deployment. Default: false. serviceAccount.name The service account to assign to the deployment. If serviceAccount.create is true, then this name is used when creating the service account. serviceAccount.annotations The annotations to add to the service account if serviceAccount.create is set to true. removeJobsLog Default Kubernetes doesn't include a jobs/log resource. Set this to true to remove it from the role if needed. Default: false. headlessService.serviceName The name of the headless service to associate to the StatefulSet. If not set a name is generated using the fullname template. appArmorProfileName The AppArmor profile name that will be applied to the Minion and Runner pods. If set, then the AppArmor profile must exist on the Kubernetes node(s) for this to work. podSecurityContextRunAsUser A UID that can be set to either 0 (root) or between [2000, 4000], inclusive. If set, runs the CPM as the given UID. Default: 2379.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.69928,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Containerized <em>private</em> minion (CPM) configuration",
        "sections": "Containerized <em>private</em> minion (CPM) configuration",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " * <em>synthetics</em>.heavyWorkers, where <em>synthetics</em>.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on <em>monitor</em> types, see Types of <em>synthetic</em> monitors. <em>synthetics</em>.minionApiEndpoint For US-based accounts, the endpoint"
      },
      "id": "603ea540196a67e50da83d95"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/private-locations-overview-monitor-internal-sites-add-new-locations": [
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-12-09T21:14:22Z",
      "updated_at": "2021-11-26T09:10:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher. macOS: 10.11 or higher. Windows: Windows 10 64-bit or higher. You must also configure Docker to run Linux containers in order for CPMs to work on Windows systems. Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution The Docker CPM is not designed for use with container orchestrators like AWS ECS, Docker Swarm, Apache Mesos, Azure Container Instances, etc. Running the Docker CPM in a container orchestrator will result in unexpected issues because it is itself a container orchestrator. If you're using container orchestration, see our Kubernetes CPM requirements. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Unless hosting the images in a local image repository, connections to either quay.io or docker.io will need to be allowed through your firewall in order for Docker to pull the synthetics-minion and synthetics-minion-runner images. The \"runner\" image is pulled automatically on startup of the synthetics-minion container. See Docker environment configuration and Kubernetes environment configuration for details on how to set a local repository and the runner registry endpoint. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.63364,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.13405,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and <em>private</em> <em>locations</em>. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials <em>Private</em> <em>locations</em> (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Containerized private minion (CPM) configuration",
        "Guidelines for mounting volumes",
        "Custom npm modules",
        "Custom module directory",
        "Node version-specific overrides",
        "Docker",
        "Kubernetes",
        "Change package.json for custom modules",
        "Caution",
        "Permanent data storage",
        "User-defined environment variables for scripted monitors",
        "Mounting JSON file",
        "Passing as an environment variable",
        "Tip",
        "Accessing user-defined environment variables from scripts",
        "Environment variables",
        "Docker environment configuration",
        "Kubernetes environment configuration"
      ],
      "title": "Containerized private minion (CPM) configuration",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "5c65dd79f361d23da2154f6a4227515a40dae944",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration/",
      "published_at": "2021-12-09T21:13:26Z",
      "updated_at": "2021-11-15T07:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to configure your containerized private minion (CPM). You can do the following to customize your CPMs: Set up custom modules for scripted browsers in New Relic. Preserve launch data with permanent data storage. Use environment variables in your configuration. You may not modify any CPM files and New Relic is not liable for any modifications you make. Guidelines for mounting volumes All directories and files must be assigned group ownership as 3729 with read/write permissions. This ensures that the Runner, which uses uid: 1000 and gid: 3729, has access to all the mounted volumes. However, the Minion is able to run as root (uid: 0) or with any uid between the range of [2000, 4000], inclusive. For more information, see running as non-root in Kubernetes or Docker. Docker Directories are mounted onto a container as volumes by specifying a -v argument within docker run For example, docker run ... -v /path/to/src:/path/to/dest:rw Kubernetes It is possible to add a directory onto a persistent volume (PV) by using kubectl cp. However, alternative approaches are supported as long as the file permissions are set appropriately. For example, kubectl cp /path/to/src <POD_NAME>:/path/to/dest will add a directory onto each PV in the specified pod Each PV must have a separate copy of the directories. For example, a cluster with n Minion replicas must have n PVs, each with their own copy of directories The directories and files must be added prior to the Minion boot up, otherwise the Minion must be restarted to detect the updates Custom npm modules Custom npm modules are exclusive to the CPM. They allow you to provide an arbitrary set of npm modules, and make them available for scripted monitors in Synthetics. To set up the modules: Create a directory which contains a package.json, following the npm official guidelines, in the root of the directory. Anything contained in the dependencies field will be installed by the CPM at start, and made available when running monitors on that private minion. Optionally, you can override the root level package.json with a Node version-specific directory. This allows a script to be updated per monitor runtime if a Node version of a runtime is no longer compatible with your dependencies. See an example of this below. Custom module directory In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file Copy The package.json defines dependencies as both a local module (for example, counter) and an npm hosted modules (for example, async version ^2.6.1): { \"name\": \"custom-modules\", \"version\": \"1.0.0\", ⇦ optional \"description\": \"example custom modules directory\", ⇦ optional \"dependencies\": { \"async\": \"^2.6.1\", ⇦ npm hosted module \"counter\": \"file:./counter\" ⇦ Local module } } Copy Node version-specific overrides You can declare a package.json per Node version that will override the root level package.json. This allows a monitor script to be updated per monitor runtime in the event that the Node version of a runtime is no longer compatible with your dependencies. As shown in the first example, local modules can still be defined within a version specific directory. If a package.json is not defined for a specific Node version, then the root level package.json will be used to install dependencies. In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── 6.11.2 ⇦ optional Node specific directory │ └── package.json └── 10.15.0 ⇦ optional Node specific directory │ └── package.json ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file ​ Copy Once you create the custom modules directory and the package.json you can apply it to your CPM for Docker and Kubernetes. Docker For Docker, launch CPM mounting the directory at /var/lib/newrelic/synthetics/modules. For example: docker run ... -v /example-custom-modules-dir:/var/lib/newrelic/synthetics/modules:rw ... Copy Kubernetes Complete the following: Launch the CPM, setting a value for the persistence.customModules configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where your custom modules files exist. For example: helm install ... --set persistence.customModules=<custom-modules-subpath> ... Copy Make sure that your custom modules directory is available on the Minion Pod. You can use kubectl cp as one method to copy the directory from your host to the Minion. For example: kubectl cp /example-custom-modules-dir <namespace>/<pod_name>:/var/lib/newrelic/synthetics/modules Copy Look at the CPM logs for \"... Initialization of Custom Modules ...\" to see if the modules were installed properly, or if there were any errors. The npm installation logs will be shown. Now you can add \"require('async');\" into the script of monitors you send to this private location. Change package.json for custom modules Along with npm modules, you can also use Node.js modules. To change the custom modules used by your CPM, modify package.json and reboot the CPM. It will detect the change in configuration during the reboot, and then clean up and re-install. Caution Local modules: While your package.json can include any local module, these modules must reside inside the tree under your custom module directory. If stored outside the tree, the initialization process will fail and you will see an error message in the docker logs after launching CPM. Permanent data storage CPM is a stateless application and does not preserve information from prior requests or sessions by default. However, you can preserve data between launches by enabling permanent data storage. For example, you can permanently set how the minion identifies itself (for example, Minion_ID), and use it to associate the data visible in Synthetics and Insights events with the exact minion that produced it. To set permanent data storage on Docker: Create a directory. Launch the CPM, mounting the directory at /var/lib/newrelic/synthetics. Example: docker run ... -v /example-permanent-dir:/var/lib/newrelic/synthetics:rw ... Copy To set permanent data storage on Kubernetes: Launch the CPM, setting a value for the persistence.permanentData configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where you want the data to be saved. Example: helm install ... --set persistence.permanentData=<permanent-data-subpath> ... Copy User-defined environment variables for scripted monitors Containerized private minions let you configure environment variables for use in scripted monitors. These variables are hosted locally on the CPM and can be accessed via $env.USER_DEFINED_VARIABLES. There are two ways to set user-defined variables: by mounting a JSON file or by supplying an environment variable to the CPM on launch. If both are provided, the CPM will use values provided from the environment only. Mounting JSON file The JSON file must have read permissions and contain a JSON formatted map. Example user-defined variable file: { \"KEY\" : \"VALUE\", \"User_Name\": \"MINION\", \"My_Password\": \"PASSW0RD 1 2 3\", \"my_URL\": \"https://newrelic.com/\", \"ETC\" : \"ETC\" } Copy The file must be available or mounted to the path in your container: /var/lib/newrelic/synthetics/variables/user_defined_variables.json Docker example: docker run ... -v /example-user-defined-variables.json:/var/lib/newrelic/synthetics/variables/user_defined_variables.json:rw ... Copy Kubernetes example: When mounting a JSON file to your Minion Pod in Kubernetes, you can either copy the file directly to the Minion Pod or to a Pod that has access to the same Persistent Volume and Persistent Volume Claim that the Minion will use. After successfully loading the file, you may need to restart your Minion Pod for the change to take effect. kubectl cp path/to/user_defined_variables.json <namespace>/<pod_name>:/var/lib/newrelic/synthetics/variables/user_defined_variables.json Copy Passing as an environment variable Use the -e flag to set up an environment variable named MINION_USER_DEFINED_VARIABLES and give it a value of a JSON formatted map string. docker run ... -e MINION_USER_DEFINED_ENV_VARIABLES='{\"KEY\":\"VALUE\",\"NAME\":\"MINION\",\"ETC\":\"ETC\"}' ... Copy Tip The CPM on Kubernetes does not currently support loading user-defined environment variables via environment variable. You will have to configure your Kubernetes CPM by mounting a JSON file. Accessing user-defined environment variables from scripts To reference a configured user-defined environment variable, use the reserved $env.USER_DEFINED_VARIABLES followed by the name of a given variable with dot notation. For example, $env.USER_DEFINED_VARIABLES.MY_VARIABLE Caution User-defined environment variables are not sanitized from logs. For sensitive information, consider using the secure credentials feature. Environment variables Environmental variables allow you to fine-tune the CPM configuration to meet your specific environmental and functional needs. Docker environment configuration The variables are provided at startup using the -e, --env argument. The following table shows all the environment variables that CPM supports. MINION_PRIVATE_LOCATION_KEY is required, and all other variables are optional. Name Description MINION_PRIVATE_LOCATION_KEY REQUIRED. UUID of the Private Location, as found on the Private Location Web page. DOCKER_API_VERSION Format: \"vX.Y\" API version to be used with the given Docker service. Default: v1.35. DOCKER_HOST Points the minion to a given DOCKER_HOST. If absent, the default value is /var/run/docker.sock. MINION_API_ENDPOINT For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. MINION_DOCKER_RUNNER_REGISTRY_ENDPOINT The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic). MINION_API_PROXY Format: \"host:port\". MINION_API_PROXY_AUTH Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. MINION_API_PROXY_SELF_SIGNED_CERT Acceptable values: true, 1, or yes (any case). MINION_CHECK_TIMEOUT The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. MINION_DOCKER_API_VERSION Synonym of DOCKER_API_VERSION. MINION_DOCKER_HOST Synonym of DOCKER_HOST. MINION_RUNNER_APPARMOR (CPM version > 3.0.2) OR MINION_DOCKER_RUNNER_APPARMOR (CPM version <= 3.0.2) The AppArmor profile name, if it has been applied to Docker containers running monitor scripts (for example, Docker Runner). The AppArmor profile name must exist and be set up on the machine to work. MINION_JVM_MB Default: \"2560\" (2.5GB). MINION_JVM_OPTS Passes command line options to the internal JVM. See Oracle's Java documentation for more information. Default: -server. MINION_LOG_LEVEL When contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. MINION_NETWORK_HEALTHCHECK_DISABLED (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. MINION_USER_DEFINED_ENV_VARIABLES Format: Example. A locally hosted set of user defined key value pairs. MINION_HEAVY_WORKERS The number of workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. MINION_LIGHTWEIGHT_WORKERS The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 1250. For more information on monitor types, see Types of Synthetics monitors. MINION_VSE_PASSPHRASE If set, enables verified script execution and uses this value as a passphrase. Kubernetes environment configuration The variables are provided at startup using the --set argument. The following list shows all the environment variables that CPM supports. synthetics.privateLocationKey is required, and all other variables are optional. Name Description synthetics.privateLocationKey REQUIRED if synthetics.privateLocationKeySecretName is not set. UUID/Private location key of the private location, as found on the private location web page. synthetics.privateLocationKeySecretName REQUIRED if synthetics.privateLocationKey is not set. Name of the Kubernetes secret that contains the key privateLocationKey, which contains the authentication key associated with your Synthetics private location. replicaCount Number of replicas to maintain with your StatefulSet installation Default: 1. imagePullSecrets The name of the secret object used to pull an image from a specified container registry. fullnameOverride Name override used for your StatefulSet installation, replacing the default. appVersionOverride Release version of CPM to use instead of the version specified in chart.yml. synthetics.minionLogLevel If contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. synthetics.heavyWorkers The number of concurrent workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use the value 2. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. synthetics.lightweightWorkers The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * synthetics.heavyWorkers, where synthetics.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on monitor types, see Types of synthetic monitors. synthetics.minionApiEndpoint For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. synthetics.minionDockerRunnerRegistryEndpoint The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic) synthetics.minionVsePassphrase If set, it enables verified script execution, and uses this value as a passphrase. synthetics.minionVsePassphraseSecretName If set, enables verified script execution and uses this value to retrieve the passphrase from a Kubernetes secret with a key called minionVsePassphrase. synthetics.minionApiProxy Format: \"host:port\". synthetics.minionApiProxySelfSignedCert Acceptable values: true, 1, or yes (any case). synthetics.minionApiProxyAuth Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. synthetics.minionCheckTimeout The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. synthetics.minionUserDefinedEnvVariable Format: Example. A locally hosted set of user-defined key value pairs. synthetics.minionJVMOpts Passes command line options to the internal JVM. Default: -server -XX:-UsePerfData synthetics.minionNetworkHealthCheckDisabled (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. image.repository The container to pull. Default: quay.io/newrelic/synthetics-minion image.pullPolicy The pull policy. Default: IfNotPresent persistence.claimName The name of the PVC to use. If undefined or not set, Statefulset will dynamically create a PVC for each replica. persistence.storageClass Overrides StorageClass for VolumeClaimTemplates, relevant only if claimName is undefined or empty. For more details see persistent volumes. persistence.accessMode Access mode to be defined for the PVC, relevant only if claimName is undefined or empty. Default: ReadWriteOnce. persistence.annotations Annotations to add to the PVC, relevant only if claimName is undefined or empty. persistence.size Size to be defined for the PVC, relevant only if claimName is undefined or empty. Default: 10Gi. persistence.permanentData Path on the volume to the permanent data storage directory. For more details, see permanent data storage. persistence.customModules Path on the volume to the custom modules directory. For more details, see custom modules. persistence.userDefinedVariables Path on the volume to the user-defined-variable.json file. For more details, see user defined variables. serviceAccount.create If true, a service account is created and assigned to the deployment. Default: false. serviceAccount.name The service account to assign to the deployment. If serviceAccount.create is true, then this name is used when creating the service account. serviceAccount.annotations The annotations to add to the service account if serviceAccount.create is set to true. removeJobsLog Default Kubernetes doesn't include a jobs/log resource. Set this to true to remove it from the role if needed. Default: false. headlessService.serviceName The name of the headless service to associate to the StatefulSet. If not set a name is generated using the fullname template. appArmorProfileName The AppArmor profile name that will be applied to the Minion and Runner pods. If set, then the AppArmor profile must exist on the Kubernetes node(s) for this to work. podSecurityContextRunAsUser A UID that can be set to either 0 (root) or between [2000, 4000], inclusive. If set, runs the CPM as the given UID. Default: 2379.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.69926,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Containerized <em>private</em> minion (CPM) configuration",
        "sections": "Containerized <em>private</em> minion (CPM) configuration",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " * <em>synthetics</em>.heavyWorkers, where <em>synthetics</em>.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on <em>monitor</em> types, see Types of <em>synthetic</em> monitors. <em>synthetics</em>.minionApiEndpoint For US-based accounts, the endpoint"
      },
      "id": "603ea540196a67e50da83d95"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/troubleshoot-private-locations": [
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-12-09T21:14:22Z",
      "updated_at": "2021-11-26T09:10:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher. macOS: 10.11 or higher. Windows: Windows 10 64-bit or higher. You must also configure Docker to run Linux containers in order for CPMs to work on Windows systems. Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution The Docker CPM is not designed for use with container orchestrators like AWS ECS, Docker Swarm, Apache Mesos, Azure Container Instances, etc. Running the Docker CPM in a container orchestrator will result in unexpected issues because it is itself a container orchestrator. If you're using container orchestration, see our Kubernetes CPM requirements. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Unless hosting the images in a local image repository, connections to either quay.io or docker.io will need to be allowed through your firewall in order for Docker to pull the synthetics-minion and synthetics-minion-runner images. The \"runner\" image is pulled automatically on startup of the synthetics-minion container. See Docker environment configuration and Kubernetes environment configuration for details on how to set a local repository and the runner registry endpoint. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.63364,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.13405,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and <em>private</em> <em>locations</em>. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials <em>Private</em> <em>locations</em> (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Containerized private minion (CPM) configuration",
        "Guidelines for mounting volumes",
        "Custom npm modules",
        "Custom module directory",
        "Node version-specific overrides",
        "Docker",
        "Kubernetes",
        "Change package.json for custom modules",
        "Caution",
        "Permanent data storage",
        "User-defined environment variables for scripted monitors",
        "Mounting JSON file",
        "Passing as an environment variable",
        "Tip",
        "Accessing user-defined environment variables from scripts",
        "Environment variables",
        "Docker environment configuration",
        "Kubernetes environment configuration"
      ],
      "title": "Containerized private minion (CPM) configuration",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "5c65dd79f361d23da2154f6a4227515a40dae944",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration/",
      "published_at": "2021-12-09T21:13:26Z",
      "updated_at": "2021-11-15T07:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to configure your containerized private minion (CPM). You can do the following to customize your CPMs: Set up custom modules for scripted browsers in New Relic. Preserve launch data with permanent data storage. Use environment variables in your configuration. You may not modify any CPM files and New Relic is not liable for any modifications you make. Guidelines for mounting volumes All directories and files must be assigned group ownership as 3729 with read/write permissions. This ensures that the Runner, which uses uid: 1000 and gid: 3729, has access to all the mounted volumes. However, the Minion is able to run as root (uid: 0) or with any uid between the range of [2000, 4000], inclusive. For more information, see running as non-root in Kubernetes or Docker. Docker Directories are mounted onto a container as volumes by specifying a -v argument within docker run For example, docker run ... -v /path/to/src:/path/to/dest:rw Kubernetes It is possible to add a directory onto a persistent volume (PV) by using kubectl cp. However, alternative approaches are supported as long as the file permissions are set appropriately. For example, kubectl cp /path/to/src <POD_NAME>:/path/to/dest will add a directory onto each PV in the specified pod Each PV must have a separate copy of the directories. For example, a cluster with n Minion replicas must have n PVs, each with their own copy of directories The directories and files must be added prior to the Minion boot up, otherwise the Minion must be restarted to detect the updates Custom npm modules Custom npm modules are exclusive to the CPM. They allow you to provide an arbitrary set of npm modules, and make them available for scripted monitors in Synthetics. To set up the modules: Create a directory which contains a package.json, following the npm official guidelines, in the root of the directory. Anything contained in the dependencies field will be installed by the CPM at start, and made available when running monitors on that private minion. Optionally, you can override the root level package.json with a Node version-specific directory. This allows a script to be updated per monitor runtime if a Node version of a runtime is no longer compatible with your dependencies. See an example of this below. Custom module directory In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file Copy The package.json defines dependencies as both a local module (for example, counter) and an npm hosted modules (for example, async version ^2.6.1): { \"name\": \"custom-modules\", \"version\": \"1.0.0\", ⇦ optional \"description\": \"example custom modules directory\", ⇦ optional \"dependencies\": { \"async\": \"^2.6.1\", ⇦ npm hosted module \"counter\": \"file:./counter\" ⇦ Local module } } Copy Node version-specific overrides You can declare a package.json per Node version that will override the root level package.json. This allows a monitor script to be updated per monitor runtime in the event that the Node version of a runtime is no longer compatible with your dependencies. As shown in the first example, local modules can still be defined within a version specific directory. If a package.json is not defined for a specific Node version, then the root level package.json will be used to install dependencies. In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── 6.11.2 ⇦ optional Node specific directory │ └── package.json └── 10.15.0 ⇦ optional Node specific directory │ └── package.json ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file ​ Copy Once you create the custom modules directory and the package.json you can apply it to your CPM for Docker and Kubernetes. Docker For Docker, launch CPM mounting the directory at /var/lib/newrelic/synthetics/modules. For example: docker run ... -v /example-custom-modules-dir:/var/lib/newrelic/synthetics/modules:rw ... Copy Kubernetes Complete the following: Launch the CPM, setting a value for the persistence.customModules configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where your custom modules files exist. For example: helm install ... --set persistence.customModules=<custom-modules-subpath> ... Copy Make sure that your custom modules directory is available on the Minion Pod. You can use kubectl cp as one method to copy the directory from your host to the Minion. For example: kubectl cp /example-custom-modules-dir <namespace>/<pod_name>:/var/lib/newrelic/synthetics/modules Copy Look at the CPM logs for \"... Initialization of Custom Modules ...\" to see if the modules were installed properly, or if there were any errors. The npm installation logs will be shown. Now you can add \"require('async');\" into the script of monitors you send to this private location. Change package.json for custom modules Along with npm modules, you can also use Node.js modules. To change the custom modules used by your CPM, modify package.json and reboot the CPM. It will detect the change in configuration during the reboot, and then clean up and re-install. Caution Local modules: While your package.json can include any local module, these modules must reside inside the tree under your custom module directory. If stored outside the tree, the initialization process will fail and you will see an error message in the docker logs after launching CPM. Permanent data storage CPM is a stateless application and does not preserve information from prior requests or sessions by default. However, you can preserve data between launches by enabling permanent data storage. For example, you can permanently set how the minion identifies itself (for example, Minion_ID), and use it to associate the data visible in Synthetics and Insights events with the exact minion that produced it. To set permanent data storage on Docker: Create a directory. Launch the CPM, mounting the directory at /var/lib/newrelic/synthetics. Example: docker run ... -v /example-permanent-dir:/var/lib/newrelic/synthetics:rw ... Copy To set permanent data storage on Kubernetes: Launch the CPM, setting a value for the persistence.permanentData configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where you want the data to be saved. Example: helm install ... --set persistence.permanentData=<permanent-data-subpath> ... Copy User-defined environment variables for scripted monitors Containerized private minions let you configure environment variables for use in scripted monitors. These variables are hosted locally on the CPM and can be accessed via $env.USER_DEFINED_VARIABLES. There are two ways to set user-defined variables: by mounting a JSON file or by supplying an environment variable to the CPM on launch. If both are provided, the CPM will use values provided from the environment only. Mounting JSON file The JSON file must have read permissions and contain a JSON formatted map. Example user-defined variable file: { \"KEY\" : \"VALUE\", \"User_Name\": \"MINION\", \"My_Password\": \"PASSW0RD 1 2 3\", \"my_URL\": \"https://newrelic.com/\", \"ETC\" : \"ETC\" } Copy The file must be available or mounted to the path in your container: /var/lib/newrelic/synthetics/variables/user_defined_variables.json Docker example: docker run ... -v /example-user-defined-variables.json:/var/lib/newrelic/synthetics/variables/user_defined_variables.json:rw ... Copy Kubernetes example: When mounting a JSON file to your Minion Pod in Kubernetes, you can either copy the file directly to the Minion Pod or to a Pod that has access to the same Persistent Volume and Persistent Volume Claim that the Minion will use. After successfully loading the file, you may need to restart your Minion Pod for the change to take effect. kubectl cp path/to/user_defined_variables.json <namespace>/<pod_name>:/var/lib/newrelic/synthetics/variables/user_defined_variables.json Copy Passing as an environment variable Use the -e flag to set up an environment variable named MINION_USER_DEFINED_VARIABLES and give it a value of a JSON formatted map string. docker run ... -e MINION_USER_DEFINED_ENV_VARIABLES='{\"KEY\":\"VALUE\",\"NAME\":\"MINION\",\"ETC\":\"ETC\"}' ... Copy Tip The CPM on Kubernetes does not currently support loading user-defined environment variables via environment variable. You will have to configure your Kubernetes CPM by mounting a JSON file. Accessing user-defined environment variables from scripts To reference a configured user-defined environment variable, use the reserved $env.USER_DEFINED_VARIABLES followed by the name of a given variable with dot notation. For example, $env.USER_DEFINED_VARIABLES.MY_VARIABLE Caution User-defined environment variables are not sanitized from logs. For sensitive information, consider using the secure credentials feature. Environment variables Environmental variables allow you to fine-tune the CPM configuration to meet your specific environmental and functional needs. Docker environment configuration The variables are provided at startup using the -e, --env argument. The following table shows all the environment variables that CPM supports. MINION_PRIVATE_LOCATION_KEY is required, and all other variables are optional. Name Description MINION_PRIVATE_LOCATION_KEY REQUIRED. UUID of the Private Location, as found on the Private Location Web page. DOCKER_API_VERSION Format: \"vX.Y\" API version to be used with the given Docker service. Default: v1.35. DOCKER_HOST Points the minion to a given DOCKER_HOST. If absent, the default value is /var/run/docker.sock. MINION_API_ENDPOINT For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. MINION_DOCKER_RUNNER_REGISTRY_ENDPOINT The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic). MINION_API_PROXY Format: \"host:port\". MINION_API_PROXY_AUTH Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. MINION_API_PROXY_SELF_SIGNED_CERT Acceptable values: true, 1, or yes (any case). MINION_CHECK_TIMEOUT The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. MINION_DOCKER_API_VERSION Synonym of DOCKER_API_VERSION. MINION_DOCKER_HOST Synonym of DOCKER_HOST. MINION_RUNNER_APPARMOR (CPM version > 3.0.2) OR MINION_DOCKER_RUNNER_APPARMOR (CPM version <= 3.0.2) The AppArmor profile name, if it has been applied to Docker containers running monitor scripts (for example, Docker Runner). The AppArmor profile name must exist and be set up on the machine to work. MINION_JVM_MB Default: \"2560\" (2.5GB). MINION_JVM_OPTS Passes command line options to the internal JVM. See Oracle's Java documentation for more information. Default: -server. MINION_LOG_LEVEL When contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. MINION_NETWORK_HEALTHCHECK_DISABLED (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. MINION_USER_DEFINED_ENV_VARIABLES Format: Example. A locally hosted set of user defined key value pairs. MINION_HEAVY_WORKERS The number of workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. MINION_LIGHTWEIGHT_WORKERS The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 1250. For more information on monitor types, see Types of Synthetics monitors. MINION_VSE_PASSPHRASE If set, enables verified script execution and uses this value as a passphrase. Kubernetes environment configuration The variables are provided at startup using the --set argument. The following list shows all the environment variables that CPM supports. synthetics.privateLocationKey is required, and all other variables are optional. Name Description synthetics.privateLocationKey REQUIRED if synthetics.privateLocationKeySecretName is not set. UUID/Private location key of the private location, as found on the private location web page. synthetics.privateLocationKeySecretName REQUIRED if synthetics.privateLocationKey is not set. Name of the Kubernetes secret that contains the key privateLocationKey, which contains the authentication key associated with your Synthetics private location. replicaCount Number of replicas to maintain with your StatefulSet installation Default: 1. imagePullSecrets The name of the secret object used to pull an image from a specified container registry. fullnameOverride Name override used for your StatefulSet installation, replacing the default. appVersionOverride Release version of CPM to use instead of the version specified in chart.yml. synthetics.minionLogLevel If contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. synthetics.heavyWorkers The number of concurrent workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use the value 2. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. synthetics.lightweightWorkers The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * synthetics.heavyWorkers, where synthetics.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on monitor types, see Types of synthetic monitors. synthetics.minionApiEndpoint For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. synthetics.minionDockerRunnerRegistryEndpoint The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic) synthetics.minionVsePassphrase If set, it enables verified script execution, and uses this value as a passphrase. synthetics.minionVsePassphraseSecretName If set, enables verified script execution and uses this value to retrieve the passphrase from a Kubernetes secret with a key called minionVsePassphrase. synthetics.minionApiProxy Format: \"host:port\". synthetics.minionApiProxySelfSignedCert Acceptable values: true, 1, or yes (any case). synthetics.minionApiProxyAuth Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. synthetics.minionCheckTimeout The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. synthetics.minionUserDefinedEnvVariable Format: Example. A locally hosted set of user-defined key value pairs. synthetics.minionJVMOpts Passes command line options to the internal JVM. Default: -server -XX:-UsePerfData synthetics.minionNetworkHealthCheckDisabled (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. image.repository The container to pull. Default: quay.io/newrelic/synthetics-minion image.pullPolicy The pull policy. Default: IfNotPresent persistence.claimName The name of the PVC to use. If undefined or not set, Statefulset will dynamically create a PVC for each replica. persistence.storageClass Overrides StorageClass for VolumeClaimTemplates, relevant only if claimName is undefined or empty. For more details see persistent volumes. persistence.accessMode Access mode to be defined for the PVC, relevant only if claimName is undefined or empty. Default: ReadWriteOnce. persistence.annotations Annotations to add to the PVC, relevant only if claimName is undefined or empty. persistence.size Size to be defined for the PVC, relevant only if claimName is undefined or empty. Default: 10Gi. persistence.permanentData Path on the volume to the permanent data storage directory. For more details, see permanent data storage. persistence.customModules Path on the volume to the custom modules directory. For more details, see custom modules. persistence.userDefinedVariables Path on the volume to the user-defined-variable.json file. For more details, see user defined variables. serviceAccount.create If true, a service account is created and assigned to the deployment. Default: false. serviceAccount.name The service account to assign to the deployment. If serviceAccount.create is true, then this name is used when creating the service account. serviceAccount.annotations The annotations to add to the service account if serviceAccount.create is set to true. removeJobsLog Default Kubernetes doesn't include a jobs/log resource. Set this to true to remove it from the role if needed. Default: false. headlessService.serviceName The name of the headless service to associate to the StatefulSet. If not set a name is generated using the fullname template. appArmorProfileName The AppArmor profile name that will be applied to the Minion and Runner pods. If set, then the AppArmor profile must exist on the Kubernetes node(s) for this to work. podSecurityContextRunAsUser A UID that can be set to either 0 (root) or between [2000, 4000], inclusive. If set, runs the CPM as the given UID. Default: 2379.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.69926,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Containerized <em>private</em> minion (CPM) configuration",
        "sections": "Containerized <em>private</em> minion (CPM) configuration",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " * <em>synthetics</em>.heavyWorkers, where <em>synthetics</em>.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on <em>monitor</em> types, see Types of <em>synthetic</em> monitors. <em>synthetics</em>.minionApiEndpoint For US-based accounts, the endpoint"
      },
      "id": "603ea540196a67e50da83d95"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/verified-script-execution-private-locations": [
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-12-09T21:14:22Z",
      "updated_at": "2021-11-26T09:10:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher. macOS: 10.11 or higher. Windows: Windows 10 64-bit or higher. You must also configure Docker to run Linux containers in order for CPMs to work on Windows systems. Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution The Docker CPM is not designed for use with container orchestrators like AWS ECS, Docker Swarm, Apache Mesos, Azure Container Instances, etc. Running the Docker CPM in a container orchestrator will result in unexpected issues because it is itself a container orchestrator. If you're using container orchestration, see our Kubernetes CPM requirements. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Unless hosting the images in a local image repository, connections to either quay.io or docker.io will need to be allowed through your firewall in order for Docker to pull the synthetics-minion and synthetics-minion-runner images. The \"runner\" image is pulled automatically on startup of the synthetics-minion container. See Docker environment configuration and Kubernetes environment configuration for details on how to set a local repository and the runner registry endpoint. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 240.6336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.13402,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and <em>private</em> <em>locations</em>. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials <em>Private</em> <em>locations</em> (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Containerized private minion (CPM) configuration",
        "Guidelines for mounting volumes",
        "Custom npm modules",
        "Custom module directory",
        "Node version-specific overrides",
        "Docker",
        "Kubernetes",
        "Change package.json for custom modules",
        "Caution",
        "Permanent data storage",
        "User-defined environment variables for scripted monitors",
        "Mounting JSON file",
        "Passing as an environment variable",
        "Tip",
        "Accessing user-defined environment variables from scripts",
        "Environment variables",
        "Docker environment configuration",
        "Kubernetes environment configuration"
      ],
      "title": "Containerized private minion (CPM) configuration",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "5c65dd79f361d23da2154f6a4227515a40dae944",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration/",
      "published_at": "2021-12-09T21:13:26Z",
      "updated_at": "2021-11-15T07:14:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to configure your containerized private minion (CPM). You can do the following to customize your CPMs: Set up custom modules for scripted browsers in New Relic. Preserve launch data with permanent data storage. Use environment variables in your configuration. You may not modify any CPM files and New Relic is not liable for any modifications you make. Guidelines for mounting volumes All directories and files must be assigned group ownership as 3729 with read/write permissions. This ensures that the Runner, which uses uid: 1000 and gid: 3729, has access to all the mounted volumes. However, the Minion is able to run as root (uid: 0) or with any uid between the range of [2000, 4000], inclusive. For more information, see running as non-root in Kubernetes or Docker. Docker Directories are mounted onto a container as volumes by specifying a -v argument within docker run For example, docker run ... -v /path/to/src:/path/to/dest:rw Kubernetes It is possible to add a directory onto a persistent volume (PV) by using kubectl cp. However, alternative approaches are supported as long as the file permissions are set appropriately. For example, kubectl cp /path/to/src <POD_NAME>:/path/to/dest will add a directory onto each PV in the specified pod Each PV must have a separate copy of the directories. For example, a cluster with n Minion replicas must have n PVs, each with their own copy of directories The directories and files must be added prior to the Minion boot up, otherwise the Minion must be restarted to detect the updates Custom npm modules Custom npm modules are exclusive to the CPM. They allow you to provide an arbitrary set of npm modules, and make them available for scripted monitors in Synthetics. To set up the modules: Create a directory which contains a package.json, following the npm official guidelines, in the root of the directory. Anything contained in the dependencies field will be installed by the CPM at start, and made available when running monitors on that private minion. Optionally, you can override the root level package.json with a Node version-specific directory. This allows a script to be updated per monitor runtime if a Node version of a runtime is no longer compatible with your dependencies. See an example of this below. Custom module directory In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file Copy The package.json defines dependencies as both a local module (for example, counter) and an npm hosted modules (for example, async version ^2.6.1): { \"name\": \"custom-modules\", \"version\": \"1.0.0\", ⇦ optional \"description\": \"example custom modules directory\", ⇦ optional \"dependencies\": { \"async\": \"^2.6.1\", ⇦ npm hosted module \"counter\": \"file:./counter\" ⇦ Local module } } Copy Node version-specific overrides You can declare a package.json per Node version that will override the root level package.json. This allows a monitor script to be updated per monitor runtime in the event that the Node version of a runtime is no longer compatible with your dependencies. As shown in the first example, local modules can still be defined within a version specific directory. If a package.json is not defined for a specific Node version, then the root level package.json will be used to install dependencies. In this example, a custom module directory is used with the following structure: /example-custom-modules-dir/ ├── 6.11.2 ⇦ optional Node specific directory │ └── package.json └── 10.15.0 ⇦ optional Node specific directory │ └── package.json ├── counter │ ├── index.js │ └── package.json └── package.json ⇦ the only mandatory file ​ Copy Once you create the custom modules directory and the package.json you can apply it to your CPM for Docker and Kubernetes. Docker For Docker, launch CPM mounting the directory at /var/lib/newrelic/synthetics/modules. For example: docker run ... -v /example-custom-modules-dir:/var/lib/newrelic/synthetics/modules:rw ... Copy Kubernetes Complete the following: Launch the CPM, setting a value for the persistence.customModules configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where your custom modules files exist. For example: helm install ... --set persistence.customModules=<custom-modules-subpath> ... Copy Make sure that your custom modules directory is available on the Minion Pod. You can use kubectl cp as one method to copy the directory from your host to the Minion. For example: kubectl cp /example-custom-modules-dir <namespace>/<pod_name>:/var/lib/newrelic/synthetics/modules Copy Look at the CPM logs for \"... Initialization of Custom Modules ...\" to see if the modules were installed properly, or if there were any errors. The npm installation logs will be shown. Now you can add \"require('async');\" into the script of monitors you send to this private location. Change package.json for custom modules Along with npm modules, you can also use Node.js modules. To change the custom modules used by your CPM, modify package.json and reboot the CPM. It will detect the change in configuration during the reboot, and then clean up and re-install. Caution Local modules: While your package.json can include any local module, these modules must reside inside the tree under your custom module directory. If stored outside the tree, the initialization process will fail and you will see an error message in the docker logs after launching CPM. Permanent data storage CPM is a stateless application and does not preserve information from prior requests or sessions by default. However, you can preserve data between launches by enabling permanent data storage. For example, you can permanently set how the minion identifies itself (for example, Minion_ID), and use it to associate the data visible in Synthetics and Insights events with the exact minion that produced it. To set permanent data storage on Docker: Create a directory. Launch the CPM, mounting the directory at /var/lib/newrelic/synthetics. Example: docker run ... -v /example-permanent-dir:/var/lib/newrelic/synthetics:rw ... Copy To set permanent data storage on Kubernetes: Launch the CPM, setting a value for the persistence.permanentData configuration value either in the command line or in a YAML file during installation. The value should specify the subpath on your Minion's Persistent Volume where you want the data to be saved. Example: helm install ... --set persistence.permanentData=<permanent-data-subpath> ... Copy User-defined environment variables for scripted monitors Containerized private minions let you configure environment variables for use in scripted monitors. These variables are hosted locally on the CPM and can be accessed via $env.USER_DEFINED_VARIABLES. There are two ways to set user-defined variables: by mounting a JSON file or by supplying an environment variable to the CPM on launch. If both are provided, the CPM will use values provided from the environment only. Mounting JSON file The JSON file must have read permissions and contain a JSON formatted map. Example user-defined variable file: { \"KEY\" : \"VALUE\", \"User_Name\": \"MINION\", \"My_Password\": \"PASSW0RD 1 2 3\", \"my_URL\": \"https://newrelic.com/\", \"ETC\" : \"ETC\" } Copy The file must be available or mounted to the path in your container: /var/lib/newrelic/synthetics/variables/user_defined_variables.json Docker example: docker run ... -v /example-user-defined-variables.json:/var/lib/newrelic/synthetics/variables/user_defined_variables.json:rw ... Copy Kubernetes example: When mounting a JSON file to your Minion Pod in Kubernetes, you can either copy the file directly to the Minion Pod or to a Pod that has access to the same Persistent Volume and Persistent Volume Claim that the Minion will use. After successfully loading the file, you may need to restart your Minion Pod for the change to take effect. kubectl cp path/to/user_defined_variables.json <namespace>/<pod_name>:/var/lib/newrelic/synthetics/variables/user_defined_variables.json Copy Passing as an environment variable Use the -e flag to set up an environment variable named MINION_USER_DEFINED_VARIABLES and give it a value of a JSON formatted map string. docker run ... -e MINION_USER_DEFINED_ENV_VARIABLES='{\"KEY\":\"VALUE\",\"NAME\":\"MINION\",\"ETC\":\"ETC\"}' ... Copy Tip The CPM on Kubernetes does not currently support loading user-defined environment variables via environment variable. You will have to configure your Kubernetes CPM by mounting a JSON file. Accessing user-defined environment variables from scripts To reference a configured user-defined environment variable, use the reserved $env.USER_DEFINED_VARIABLES followed by the name of a given variable with dot notation. For example, $env.USER_DEFINED_VARIABLES.MY_VARIABLE Caution User-defined environment variables are not sanitized from logs. For sensitive information, consider using the secure credentials feature. Environment variables Environmental variables allow you to fine-tune the CPM configuration to meet your specific environmental and functional needs. Docker environment configuration The variables are provided at startup using the -e, --env argument. The following table shows all the environment variables that CPM supports. MINION_PRIVATE_LOCATION_KEY is required, and all other variables are optional. Name Description MINION_PRIVATE_LOCATION_KEY REQUIRED. UUID of the Private Location, as found on the Private Location Web page. DOCKER_API_VERSION Format: \"vX.Y\" API version to be used with the given Docker service. Default: v1.35. DOCKER_HOST Points the minion to a given DOCKER_HOST. If absent, the default value is /var/run/docker.sock. MINION_API_ENDPOINT For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. MINION_DOCKER_RUNNER_REGISTRY_ENDPOINT The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic). MINION_API_PROXY Format: \"host:port\". MINION_API_PROXY_AUTH Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. MINION_API_PROXY_SELF_SIGNED_CERT Acceptable values: true, 1, or yes (any case). MINION_CHECK_TIMEOUT The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. MINION_DOCKER_API_VERSION Synonym of DOCKER_API_VERSION. MINION_DOCKER_HOST Synonym of DOCKER_HOST. MINION_RUNNER_APPARMOR (CPM version > 3.0.2) OR MINION_DOCKER_RUNNER_APPARMOR (CPM version <= 3.0.2) The AppArmor profile name, if it has been applied to Docker containers running monitor scripts (for example, Docker Runner). The AppArmor profile name must exist and be set up on the machine to work. MINION_JVM_MB Default: \"2560\" (2.5GB). MINION_JVM_OPTS Passes command line options to the internal JVM. See Oracle's Java documentation for more information. Default: -server. MINION_LOG_LEVEL When contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. MINION_NETWORK_HEALTHCHECK_DISABLED (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. MINION_USER_DEFINED_ENV_VARIABLES Format: Example. A locally hosted set of user defined key value pairs. MINION_HEAVY_WORKERS The number of workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. MINION_LIGHTWEIGHT_WORKERS The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * NUM_CPUS where NUM_CPUS is the number of CPUs available to the minion. The maximum allowed value for this variable is 1250. For more information on monitor types, see Types of Synthetics monitors. MINION_VSE_PASSPHRASE If set, enables verified script execution and uses this value as a passphrase. Kubernetes environment configuration The variables are provided at startup using the --set argument. The following list shows all the environment variables that CPM supports. synthetics.privateLocationKey is required, and all other variables are optional. Name Description synthetics.privateLocationKey REQUIRED if synthetics.privateLocationKeySecretName is not set. UUID/Private location key of the private location, as found on the private location web page. synthetics.privateLocationKeySecretName REQUIRED if synthetics.privateLocationKey is not set. Name of the Kubernetes secret that contains the key privateLocationKey, which contains the authentication key associated with your Synthetics private location. replicaCount Number of replicas to maintain with your StatefulSet installation Default: 1. imagePullSecrets The name of the secret object used to pull an image from a specified container registry. fullnameOverride Name override used for your StatefulSet installation, replacing the default. appVersionOverride Release version of CPM to use instead of the version specified in chart.yml. synthetics.minionLogLevel If contacting New Relic Support, they may ask you to increase this to \"DEBUG\" or \"TRACE\". Default: INFO. synthetics.heavyWorkers The number of concurrent workers the minion will use to run heavy jobs (BROWSER, SCRIPT_BROWSER, SCRIPT_API). If undefined, the minion will use the value 2. The maximum allowed value for this variable is 50. For more information on monitor types, see Types of Synthetics monitors. synthetics.lightweightWorkers The number of workers the minion will use to run lightweight jobs (SIMPLE ping jobs). If undefined, the minion will use 25 * synthetics.heavyWorkers, where synthetics.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on monitor types, see Types of synthetic monitors. synthetics.minionApiEndpoint For US-based accounts, the endpoint is: https://synthetics-horde.nr-data.net. For EU-based accounts, the endpoint is: https://synthetics-horde.eu01.nr-data.net/ Ensure your CPM can connect to the appropriate endpoint in order to serve your monitor. synthetics.minionDockerRunnerRegistryEndpoint The Docker Registry and Organization where the Minion Runner image is hosted. Use this to override quay.io/newrelic as the default (for example, docker.io/newrelic) synthetics.minionVsePassphrase If set, it enables verified script execution, and uses this value as a passphrase. synthetics.minionVsePassphraseSecretName If set, enables verified script execution and uses this value to retrieve the passphrase from a Kubernetes secret with a key called minionVsePassphrase. synthetics.minionApiProxy Format: \"host:port\". synthetics.minionApiProxySelfSignedCert Acceptable values: true, 1, or yes (any case). synthetics.minionApiProxyAuth Format: \"username:password\" - Support HTTP Basic Auth + additional authentication protocols supported by Chrome. synthetics.minionCheckTimeout The maximum amount of seconds that your monitor checks are allowed to run. This value must be an integer between 0 seconds (excluded) and 900 seconds (included) (for example, from 1 second to 15 minutes). Default: 65 seconds for ping monitors, 180 seconds for the other monitor types. synthetics.minionUserDefinedEnvVariable Format: Example. A locally hosted set of user-defined key value pairs. synthetics.minionJVMOpts Passes command line options to the internal JVM. Default: -server -XX:-UsePerfData synthetics.minionNetworkHealthCheckDisabled (CPM version >= 3.0.11) The Minion Network Healthcheck disabled state, to manage the CPM check for public internet access. Default is 'false', when set as 'true' the CPM will bypass this healthcheck. image.repository The container to pull. Default: quay.io/newrelic/synthetics-minion image.pullPolicy The pull policy. Default: IfNotPresent persistence.claimName The name of the PVC to use. If undefined or not set, Statefulset will dynamically create a PVC for each replica. persistence.storageClass Overrides StorageClass for VolumeClaimTemplates, relevant only if claimName is undefined or empty. For more details see persistent volumes. persistence.accessMode Access mode to be defined for the PVC, relevant only if claimName is undefined or empty. Default: ReadWriteOnce. persistence.annotations Annotations to add to the PVC, relevant only if claimName is undefined or empty. persistence.size Size to be defined for the PVC, relevant only if claimName is undefined or empty. Default: 10Gi. persistence.permanentData Path on the volume to the permanent data storage directory. For more details, see permanent data storage. persistence.customModules Path on the volume to the custom modules directory. For more details, see custom modules. persistence.userDefinedVariables Path on the volume to the user-defined-variable.json file. For more details, see user defined variables. serviceAccount.create If true, a service account is created and assigned to the deployment. Default: false. serviceAccount.name The service account to assign to the deployment. If serviceAccount.create is true, then this name is used when creating the service account. serviceAccount.annotations The annotations to add to the service account if serviceAccount.create is set to true. removeJobsLog Default Kubernetes doesn't include a jobs/log resource. Set this to true to remove it from the role if needed. Default: false. headlessService.serviceName The name of the headless service to associate to the StatefulSet. If not set a name is generated using the fullname template. appArmorProfileName The AppArmor profile name that will be applied to the Minion and Runner pods. If set, then the AppArmor profile must exist on the Kubernetes node(s) for this to work. podSecurityContextRunAsUser A UID that can be set to either 0 (root) or between [2000, 4000], inclusive. If set, runs the CPM as the given UID. Default: 2379.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.69925,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Containerized <em>private</em> minion (CPM) configuration",
        "sections": "Containerized <em>private</em> minion (CPM) configuration",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " * <em>synthetics</em>.heavyWorkers, where <em>synthetics</em>.heavyWorkers is number defined in the previous environment variable. The maximum allowed value for this variable is 1,250. For more information on <em>monitor</em> types, see Types of <em>synthetic</em> monitors. <em>synthetics</em>.minionApiEndpoint For US-based accounts, the endpoint"
      },
      "id": "603ea540196a67e50da83d95"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/add-custom-attributes-synthetic-monitoring-data": [
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-12-09T21:17:32Z",
      "updated_at": "2021-11-15T07:23:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy Here's an example of setting up a proxied network via proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, 'anotherExample.com': {username: 'authUsername', password: 'authPassword'}, } $network.setProxyPAC(\"https://www.example.com/pacScript\", authCredentialsMap) Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples Here's an example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy Here's an example of setting up a proxied network with mixed network zone assets: var proxyRules = {singleProxy: {host:\"http://entproxy.mycompany.com\"}, bypassList:['s3.amazonaws.com','*.localcdn.com'] } $network.setProxyAdvanced(proxyRules) Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.19344,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    },
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-12-09T21:18:24Z",
      "updated_at": "2021-11-07T09:33:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. (Note that Request is deprecated, but these options still apply.) Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. We recommend using SSL to avoid exposing plain text credentials in your headers. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(duration)%20FROM%20Transaction', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.39879,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ". If any assert functions fail, the entire <em>monitor</em> will be considered a failed check. This may trigger alert notifications and affect your metrics. Important <em>Synthetic</em> <em>monitoring</em> does not allow thrown exceptions. Thrown exceptions result in <em>script</em> failure. Use the assert module to validate your results"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
        "Selenium Webdriver APIs",
        "Top-level functions: Build your script",
        "Deny list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "Tip"
      ],
      "title": "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "47ceb711bcb322760a428f1e7c03c4444b777998",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050/",
      "published_at": "2021-12-09T20:49:25Z",
      "updated_at": "2021-10-31T07:57:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes scripted browser functions available for synthetic monitors versions 0.5.x or higher. If you are using older monitor versions, see the monitor version 0.4.0 and lower documentation. For more on monitor versions and runtime differences, see Runtime environments. Selenium Webdriver APIs The synthetic scripted browsers provide access to the Selenium Webdriver APIs 3.6.0 for monitor version 0.6.x and Selenium Webdriver APIs 3.5.0 for monitor version 0.5.x via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic monitoring instance of selenium-webdriver.WebDriver(). It exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Description $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence. Return value: void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. Return value: void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. Return value: void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. Return value: void $browser.deleteHeaders(header: [string]) Deletes all headers in the argument from runtime. Return value: void $browser.addHostnameToBlacklist(hostname: string) Adds a hostname to your deny list. Allows using wildcards. Return value: void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Adds all hostnames in an array of arguments to your deny list. Allows using wildcards. Return value: void $browser.addHostnameToWhitelist(hostname: string) Adds a hostname blocked by default in synthetic monitoring to your allow list. Return value: void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Adds all hostnames in the argument to your allow list. Return value: void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname for this browser instance from your deny list. Return value: void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in the argument from your deny list. Return value: void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname for this browser instance from your allow list. Return value: void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in the argument from your allow list for this browser instance. Return value: void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. Return value: promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. Return value: promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, synthetic monitoring returns an error. Return value: WebElementPromise $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. Return value: promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, synthetic monitoring returns an error. The timeout value is optional. It is applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). Return value: WebElementPromise $browser.get(url: string) Loads a webpage in a synthetic browser. Return value: promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. Return value: promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. Return value: promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. Return value: promise $browser.getHeaders() Returns a map of currently configured headers. Return value: map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM. Do not expect it to be formatted or escaped in the same way as the response sent from the web server. Return value: promise $browser.getSession() A promise for this client's session. Return value: promise $browser.getTitle() Schedules a command to retrieve the current page's title. Return value: promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. Return value: promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. Return value: void $browser.navigate() The navigation interface (history of browser functions) for this instance. Return value: void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. Return value: promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. Return value: promise $browser.switchTo() The target locator interface for this instance. Return value: void $browser.takeScreenshot() Schedules a command to take a screenshot. Return value: promise $browser.wait(fn: $driver.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by your supplied function. Return value: WebElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. Return value: promise Deny list: Wildcard use If you want to add domains to the deny list for your browser instance, the wildcards must match the URL syntax of the URL to be blocked. An overall .com deny list must contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance, such as cookies, timeouts, and window size. Access these options through the $browser.manage() function. Function Description $browser.manage().addCookie(spec: object) Schedules a command to add a cookie. spec is a record object describing a browser cookie. For more information, see the Selenium documentation. Return value: promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. Return value: promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. Return value: promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. Return value: promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. Return value: promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. Return value: promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. Return value: promise $browser.manage().window().getSize() Retrieves the window's current size. Return value: promise $browser.manage().window().maximize() Maximizes the current window. Return value: promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. Return value: promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. Return value: promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement. Call them through $driver.By. Function Description $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. Return value: locator $driver.By.css(cssName: string) Locates an element using a CSS selector. Return value: locator $driver.By.id(id: string) Locates an element by its ID. Return value: locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. Return value: locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. Return value: locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. Return value: locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. Return value: locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. Return value: locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. Return value: locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. For example, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Description click() Clicks on this element. Return value: self reference sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. Return value: WebElement getTagName() Schedules a command to query for the tag/node name of this element. Return value: WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). Return value: promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. Return value: promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. Return value: promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. Return value: promise getLocation() Schedules a command to compute the location of this element, in page space. Return value: promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. Return value: promise isSelected() Schedules a command to query whether this element is selected. Return value: promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. Return value: promise clear() Schedules a command to clear the value of this element. Return value: promise isDisplayed() Schedules a command to test whether this element is currently displayed. Return value: promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation on GitHub. Function Description click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). Return value: actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. Return value: actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a drag and drop maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. Return value: actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. Return value: actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. Return value: actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. Return value: actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). Return value: actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). Return value: actionsequence perform() Executes this action sequence. Return value: promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation on GitHub. Return value: actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, finally() and catch(). For more information, see Sequence actions. Function Description isPending() Whether this promise's value is still being computed. Return value: boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. Return value: promise finally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. Return value: promise catch(callback: fn()) Registers a listener for when this promise is rejected. Return value: promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Description back() Move back by one step in the browser's history. Return value: void forward() Move forward by one step in the browser's history. Return value: void refresh() Refresh the current page. Return value: void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). Return value: void Conditions: Pause and wait for conditions Tip You can learn more about waits in Selenium here. Used with $browser.wait, until pauses your script execution until the condition is matched. For more information, see Selenium's WebDriver until documentation. The following are available functions for $driver.until.Condition: Function Description ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. Return value: condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. Return value: condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. Return value: condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. Return value: condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. Return value: condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. Return value: condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. Return value: condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. Return value: condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. Return value: condition n elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. Return value: condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. Return value: condition n elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. Return value: condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM or a new page has loaded. Return value: condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. Return value: condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. Return value: condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. Return value: condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.52078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "sections": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "This document describes scripted browser functions available for <em>synthetic</em> <em>monitors</em> versions 0.5.x or higher. If you are using older <em>monitor</em> versions, see the <em>monitor</em> version 0.4.0 and lower documentation. For more on <em>monitor</em> versions and runtime differences, see Runtime environments. Selenium"
      },
      "id": "603e7f27e7b9d2b2912a07ab"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/import-nodejs-modules": [
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-12-09T21:17:32Z",
      "updated_at": "2021-11-15T07:23:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy Here's an example of setting up a proxied network via proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, 'anotherExample.com': {username: 'authUsername', password: 'authPassword'}, } $network.setProxyPAC(\"https://www.example.com/pacScript\", authCredentialsMap) Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples Here's an example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy Here's an example of setting up a proxied network with mixed network zone assets: var proxyRules = {singleProxy: {host:\"http://entproxy.mycompany.com\"}, bypassList:['s3.amazonaws.com','*.localcdn.com'] } $network.setProxyAdvanced(proxyRules) Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.19342,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    },
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-12-09T21:18:24Z",
      "updated_at": "2021-11-07T09:33:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. (Note that Request is deprecated, but these options still apply.) Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. We recommend using SSL to avoid exposing plain text credentials in your headers. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(duration)%20FROM%20Transaction', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.39879,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ". If any assert functions fail, the entire <em>monitor</em> will be considered a failed check. This may trigger alert notifications and affect your metrics. Important <em>Synthetic</em> <em>monitoring</em> does not allow thrown exceptions. Thrown exceptions result in <em>script</em> failure. Use the assert module to validate your results"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
        "Selenium Webdriver APIs",
        "Top-level functions: Build your script",
        "Deny list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "Tip"
      ],
      "title": "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "47ceb711bcb322760a428f1e7c03c4444b777998",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050/",
      "published_at": "2021-12-09T20:49:25Z",
      "updated_at": "2021-10-31T07:57:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes scripted browser functions available for synthetic monitors versions 0.5.x or higher. If you are using older monitor versions, see the monitor version 0.4.0 and lower documentation. For more on monitor versions and runtime differences, see Runtime environments. Selenium Webdriver APIs The synthetic scripted browsers provide access to the Selenium Webdriver APIs 3.6.0 for monitor version 0.6.x and Selenium Webdriver APIs 3.5.0 for monitor version 0.5.x via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic monitoring instance of selenium-webdriver.WebDriver(). It exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Description $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence. Return value: void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. Return value: void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. Return value: void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. Return value: void $browser.deleteHeaders(header: [string]) Deletes all headers in the argument from runtime. Return value: void $browser.addHostnameToBlacklist(hostname: string) Adds a hostname to your deny list. Allows using wildcards. Return value: void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Adds all hostnames in an array of arguments to your deny list. Allows using wildcards. Return value: void $browser.addHostnameToWhitelist(hostname: string) Adds a hostname blocked by default in synthetic monitoring to your allow list. Return value: void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Adds all hostnames in the argument to your allow list. Return value: void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname for this browser instance from your deny list. Return value: void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in the argument from your deny list. Return value: void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname for this browser instance from your allow list. Return value: void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in the argument from your allow list for this browser instance. Return value: void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. Return value: promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. Return value: promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, synthetic monitoring returns an error. Return value: WebElementPromise $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. Return value: promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, synthetic monitoring returns an error. The timeout value is optional. It is applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). Return value: WebElementPromise $browser.get(url: string) Loads a webpage in a synthetic browser. Return value: promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. Return value: promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. Return value: promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. Return value: promise $browser.getHeaders() Returns a map of currently configured headers. Return value: map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM. Do not expect it to be formatted or escaped in the same way as the response sent from the web server. Return value: promise $browser.getSession() A promise for this client's session. Return value: promise $browser.getTitle() Schedules a command to retrieve the current page's title. Return value: promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. Return value: promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. Return value: void $browser.navigate() The navigation interface (history of browser functions) for this instance. Return value: void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. Return value: promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. Return value: promise $browser.switchTo() The target locator interface for this instance. Return value: void $browser.takeScreenshot() Schedules a command to take a screenshot. Return value: promise $browser.wait(fn: $driver.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by your supplied function. Return value: WebElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. Return value: promise Deny list: Wildcard use If you want to add domains to the deny list for your browser instance, the wildcards must match the URL syntax of the URL to be blocked. An overall .com deny list must contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance, such as cookies, timeouts, and window size. Access these options through the $browser.manage() function. Function Description $browser.manage().addCookie(spec: object) Schedules a command to add a cookie. spec is a record object describing a browser cookie. For more information, see the Selenium documentation. Return value: promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. Return value: promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. Return value: promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. Return value: promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. Return value: promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. Return value: promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. Return value: promise $browser.manage().window().getSize() Retrieves the window's current size. Return value: promise $browser.manage().window().maximize() Maximizes the current window. Return value: promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. Return value: promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. Return value: promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement. Call them through $driver.By. Function Description $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. Return value: locator $driver.By.css(cssName: string) Locates an element using a CSS selector. Return value: locator $driver.By.id(id: string) Locates an element by its ID. Return value: locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. Return value: locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. Return value: locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. Return value: locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. Return value: locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. Return value: locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. Return value: locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. For example, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Description click() Clicks on this element. Return value: self reference sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. Return value: WebElement getTagName() Schedules a command to query for the tag/node name of this element. Return value: WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). Return value: promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. Return value: promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. Return value: promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. Return value: promise getLocation() Schedules a command to compute the location of this element, in page space. Return value: promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. Return value: promise isSelected() Schedules a command to query whether this element is selected. Return value: promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. Return value: promise clear() Schedules a command to clear the value of this element. Return value: promise isDisplayed() Schedules a command to test whether this element is currently displayed. Return value: promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation on GitHub. Function Description click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). Return value: actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. Return value: actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a drag and drop maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. Return value: actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. Return value: actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. Return value: actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. Return value: actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). Return value: actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). Return value: actionsequence perform() Executes this action sequence. Return value: promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation on GitHub. Return value: actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, finally() and catch(). For more information, see Sequence actions. Function Description isPending() Whether this promise's value is still being computed. Return value: boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. Return value: promise finally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. Return value: promise catch(callback: fn()) Registers a listener for when this promise is rejected. Return value: promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Description back() Move back by one step in the browser's history. Return value: void forward() Move forward by one step in the browser's history. Return value: void refresh() Refresh the current page. Return value: void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). Return value: void Conditions: Pause and wait for conditions Tip You can learn more about waits in Selenium here. Used with $browser.wait, until pauses your script execution until the condition is matched. For more information, see Selenium's WebDriver until documentation. The following are available functions for $driver.until.Condition: Function Description ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. Return value: condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. Return value: condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. Return value: condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. Return value: condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. Return value: condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. Return value: condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. Return value: condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. Return value: condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. Return value: condition n elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. Return value: condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. Return value: condition n elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. Return value: condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM or a new page has loaded. Return value: condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. Return value: condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. Return value: condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. Return value: condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.52078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "sections": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "This document describes scripted browser functions available for <em>synthetic</em> <em>monitors</em> versions 0.5.x or higher. If you are using older <em>monitor</em> versions, see the <em>monitor</em> version 0.4.0 and lower documentation. For more on <em>monitor</em> versions and runtime differences, see Runtime environments. Selenium"
      },
      "id": "603e7f27e7b9d2b2912a07ab"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/introduction-scripted-browser-monitors": [
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-12-09T21:17:32Z",
      "updated_at": "2021-11-15T07:23:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy Here's an example of setting up a proxied network via proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, 'anotherExample.com': {username: 'authUsername', password: 'authPassword'}, } $network.setProxyPAC(\"https://www.example.com/pacScript\", authCredentialsMap) Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples Here's an example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy Here's an example of setting up a proxied network with mixed network zone assets: var proxyRules = {singleProxy: {host:\"http://entproxy.mycompany.com\"}, bypassList:['s3.amazonaws.com','*.localcdn.com'] } $network.setProxyAdvanced(proxyRules) Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.19342,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    },
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-12-09T21:18:24Z",
      "updated_at": "2021-11-07T09:33:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. (Note that Request is deprecated, but these options still apply.) Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. We recommend using SSL to avoid exposing plain text credentials in your headers. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(duration)%20FROM%20Transaction', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.39879,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ". If any assert functions fail, the entire <em>monitor</em> will be considered a failed check. This may trigger alert notifications and affect your metrics. Important <em>Synthetic</em> <em>monitoring</em> does not allow thrown exceptions. Thrown exceptions result in <em>script</em> failure. Use the assert module to validate your results"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
        "Selenium Webdriver APIs",
        "Top-level functions: Build your script",
        "Deny list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "Tip"
      ],
      "title": "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "47ceb711bcb322760a428f1e7c03c4444b777998",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050/",
      "published_at": "2021-12-09T20:49:25Z",
      "updated_at": "2021-10-31T07:57:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes scripted browser functions available for synthetic monitors versions 0.5.x or higher. If you are using older monitor versions, see the monitor version 0.4.0 and lower documentation. For more on monitor versions and runtime differences, see Runtime environments. Selenium Webdriver APIs The synthetic scripted browsers provide access to the Selenium Webdriver APIs 3.6.0 for monitor version 0.6.x and Selenium Webdriver APIs 3.5.0 for monitor version 0.5.x via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic monitoring instance of selenium-webdriver.WebDriver(). It exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Description $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence. Return value: void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. Return value: void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. Return value: void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. Return value: void $browser.deleteHeaders(header: [string]) Deletes all headers in the argument from runtime. Return value: void $browser.addHostnameToBlacklist(hostname: string) Adds a hostname to your deny list. Allows using wildcards. Return value: void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Adds all hostnames in an array of arguments to your deny list. Allows using wildcards. Return value: void $browser.addHostnameToWhitelist(hostname: string) Adds a hostname blocked by default in synthetic monitoring to your allow list. Return value: void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Adds all hostnames in the argument to your allow list. Return value: void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname for this browser instance from your deny list. Return value: void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in the argument from your deny list. Return value: void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname for this browser instance from your allow list. Return value: void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in the argument from your allow list for this browser instance. Return value: void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. Return value: promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. Return value: promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, synthetic monitoring returns an error. Return value: WebElementPromise $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. Return value: promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, synthetic monitoring returns an error. The timeout value is optional. It is applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). Return value: WebElementPromise $browser.get(url: string) Loads a webpage in a synthetic browser. Return value: promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. Return value: promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. Return value: promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. Return value: promise $browser.getHeaders() Returns a map of currently configured headers. Return value: map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM. Do not expect it to be formatted or escaped in the same way as the response sent from the web server. Return value: promise $browser.getSession() A promise for this client's session. Return value: promise $browser.getTitle() Schedules a command to retrieve the current page's title. Return value: promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. Return value: promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. Return value: void $browser.navigate() The navigation interface (history of browser functions) for this instance. Return value: void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. Return value: promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. Return value: promise $browser.switchTo() The target locator interface for this instance. Return value: void $browser.takeScreenshot() Schedules a command to take a screenshot. Return value: promise $browser.wait(fn: $driver.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by your supplied function. Return value: WebElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. Return value: promise Deny list: Wildcard use If you want to add domains to the deny list for your browser instance, the wildcards must match the URL syntax of the URL to be blocked. An overall .com deny list must contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance, such as cookies, timeouts, and window size. Access these options through the $browser.manage() function. Function Description $browser.manage().addCookie(spec: object) Schedules a command to add a cookie. spec is a record object describing a browser cookie. For more information, see the Selenium documentation. Return value: promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. Return value: promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. Return value: promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. Return value: promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. Return value: promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. Return value: promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. Return value: promise $browser.manage().window().getSize() Retrieves the window's current size. Return value: promise $browser.manage().window().maximize() Maximizes the current window. Return value: promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. Return value: promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. Return value: promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement. Call them through $driver.By. Function Description $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. Return value: locator $driver.By.css(cssName: string) Locates an element using a CSS selector. Return value: locator $driver.By.id(id: string) Locates an element by its ID. Return value: locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. Return value: locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. Return value: locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. Return value: locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. Return value: locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. Return value: locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. Return value: locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. For example, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Description click() Clicks on this element. Return value: self reference sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. Return value: WebElement getTagName() Schedules a command to query for the tag/node name of this element. Return value: WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). Return value: promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. Return value: promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. Return value: promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. Return value: promise getLocation() Schedules a command to compute the location of this element, in page space. Return value: promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. Return value: promise isSelected() Schedules a command to query whether this element is selected. Return value: promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. Return value: promise clear() Schedules a command to clear the value of this element. Return value: promise isDisplayed() Schedules a command to test whether this element is currently displayed. Return value: promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation on GitHub. Function Description click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). Return value: actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. Return value: actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a drag and drop maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. Return value: actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. Return value: actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. Return value: actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. Return value: actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). Return value: actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). Return value: actionsequence perform() Executes this action sequence. Return value: promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation on GitHub. Return value: actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, finally() and catch(). For more information, see Sequence actions. Function Description isPending() Whether this promise's value is still being computed. Return value: boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. Return value: promise finally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. Return value: promise catch(callback: fn()) Registers a listener for when this promise is rejected. Return value: promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Description back() Move back by one step in the browser's history. Return value: void forward() Move forward by one step in the browser's history. Return value: void refresh() Refresh the current page. Return value: void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). Return value: void Conditions: Pause and wait for conditions Tip You can learn more about waits in Selenium here. Used with $browser.wait, until pauses your script execution until the condition is matched. For more information, see Selenium's WebDriver until documentation. The following are available functions for $driver.until.Condition: Function Description ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. Return value: condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. Return value: condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. Return value: condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. Return value: condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. Return value: condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. Return value: condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. Return value: condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. Return value: condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. Return value: condition n elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. Return value: condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. Return value: condition n elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. Return value: condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM or a new page has loaded. Return value: condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. Return value: condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. Return value: condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. Return value: condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.52078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "sections": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "This document describes scripted browser functions available for <em>synthetic</em> <em>monitors</em> versions 0.5.x or higher. If you are using older <em>monitor</em> versions, see the <em>monitor</em> version 0.4.0 and lower documentation. For more on <em>monitor</em> versions and runtime differences, see Runtime environments. Selenium"
      },
      "id": "603e7f27e7b9d2b2912a07ab"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/scripted-browser-examples": [
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-12-09T21:17:32Z",
      "updated_at": "2021-11-15T07:23:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy Here's an example of setting up a proxied network via proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, 'anotherExample.com': {username: 'authUsername', password: 'authPassword'}, } $network.setProxyPAC(\"https://www.example.com/pacScript\", authCredentialsMap) Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples Here's an example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy Here's an example of setting up a proxied network with mixed network zone assets: var proxyRules = {singleProxy: {host:\"http://entproxy.mycompany.com\"}, bypassList:['s3.amazonaws.com','*.localcdn.com'] } $network.setProxyAdvanced(proxyRules) Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.1934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    },
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-12-09T21:18:24Z",
      "updated_at": "2021-11-07T09:33:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. (Note that Request is deprecated, but these options still apply.) Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. We recommend using SSL to avoid exposing plain text credentials in your headers. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(duration)%20FROM%20Transaction', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.39877,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ". If any assert functions fail, the entire <em>monitor</em> will be considered a failed check. This may trigger alert notifications and affect your metrics. Important <em>Synthetic</em> <em>monitoring</em> does not allow thrown exceptions. Thrown exceptions result in <em>script</em> failure. Use the assert module to validate your results"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-12-09T21:17:32Z",
      "updated_at": "2021-10-31T07:57:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.52078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors": [
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-12-09T21:18:24Z",
      "updated_at": "2021-11-07T09:33:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. (Note that Request is deprecated, but these options still apply.) Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. We recommend using SSL to avoid exposing plain text credentials in your headers. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(duration)%20FROM%20Transaction', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.39877,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ". If any assert functions fail, the entire <em>monitor</em> will be considered a failed check. This may trigger alert notifications and affect your metrics. Important <em>Synthetic</em> <em>monitoring</em> does not allow thrown exceptions. Thrown exceptions result in <em>script</em> failure. Use the assert module to validate your results"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-12-09T21:17:32Z",
      "updated_at": "2021-10-31T07:57:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.52078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    },
    {
      "sections": [
        "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
        "Selenium Webdriver APIs",
        "Top-level functions: Build your script",
        "Deny list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "Tip"
      ],
      "title": "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "47ceb711bcb322760a428f1e7c03c4444b777998",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050/",
      "published_at": "2021-12-09T20:49:25Z",
      "updated_at": "2021-10-31T07:57:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes scripted browser functions available for synthetic monitors versions 0.5.x or higher. If you are using older monitor versions, see the monitor version 0.4.0 and lower documentation. For more on monitor versions and runtime differences, see Runtime environments. Selenium Webdriver APIs The synthetic scripted browsers provide access to the Selenium Webdriver APIs 3.6.0 for monitor version 0.6.x and Selenium Webdriver APIs 3.5.0 for monitor version 0.5.x via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic monitoring instance of selenium-webdriver.WebDriver(). It exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Description $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence. Return value: void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. Return value: void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. Return value: void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. Return value: void $browser.deleteHeaders(header: [string]) Deletes all headers in the argument from runtime. Return value: void $browser.addHostnameToBlacklist(hostname: string) Adds a hostname to your deny list. Allows using wildcards. Return value: void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Adds all hostnames in an array of arguments to your deny list. Allows using wildcards. Return value: void $browser.addHostnameToWhitelist(hostname: string) Adds a hostname blocked by default in synthetic monitoring to your allow list. Return value: void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Adds all hostnames in the argument to your allow list. Return value: void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname for this browser instance from your deny list. Return value: void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in the argument from your deny list. Return value: void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname for this browser instance from your allow list. Return value: void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in the argument from your allow list for this browser instance. Return value: void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. Return value: promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. Return value: promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, synthetic monitoring returns an error. Return value: WebElementPromise $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. Return value: promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, synthetic monitoring returns an error. The timeout value is optional. It is applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). Return value: WebElementPromise $browser.get(url: string) Loads a webpage in a synthetic browser. Return value: promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. Return value: promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. Return value: promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. Return value: promise $browser.getHeaders() Returns a map of currently configured headers. Return value: map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM. Do not expect it to be formatted or escaped in the same way as the response sent from the web server. Return value: promise $browser.getSession() A promise for this client's session. Return value: promise $browser.getTitle() Schedules a command to retrieve the current page's title. Return value: promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. Return value: promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. Return value: void $browser.navigate() The navigation interface (history of browser functions) for this instance. Return value: void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. Return value: promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. Return value: promise $browser.switchTo() The target locator interface for this instance. Return value: void $browser.takeScreenshot() Schedules a command to take a screenshot. Return value: promise $browser.wait(fn: $driver.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by your supplied function. Return value: WebElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. Return value: promise Deny list: Wildcard use If you want to add domains to the deny list for your browser instance, the wildcards must match the URL syntax of the URL to be blocked. An overall .com deny list must contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance, such as cookies, timeouts, and window size. Access these options through the $browser.manage() function. Function Description $browser.manage().addCookie(spec: object) Schedules a command to add a cookie. spec is a record object describing a browser cookie. For more information, see the Selenium documentation. Return value: promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. Return value: promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. Return value: promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. Return value: promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. Return value: promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. Return value: promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. Return value: promise $browser.manage().window().getSize() Retrieves the window's current size. Return value: promise $browser.manage().window().maximize() Maximizes the current window. Return value: promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. Return value: promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. Return value: promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement. Call them through $driver.By. Function Description $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. Return value: locator $driver.By.css(cssName: string) Locates an element using a CSS selector. Return value: locator $driver.By.id(id: string) Locates an element by its ID. Return value: locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. Return value: locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. Return value: locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. Return value: locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. Return value: locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. Return value: locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. Return value: locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. For example, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Description click() Clicks on this element. Return value: self reference sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. Return value: WebElement getTagName() Schedules a command to query for the tag/node name of this element. Return value: WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). Return value: promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. Return value: promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. Return value: promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. Return value: promise getLocation() Schedules a command to compute the location of this element, in page space. Return value: promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. Return value: promise isSelected() Schedules a command to query whether this element is selected. Return value: promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. Return value: promise clear() Schedules a command to clear the value of this element. Return value: promise isDisplayed() Schedules a command to test whether this element is currently displayed. Return value: promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation on GitHub. Function Description click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). Return value: actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. Return value: actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a drag and drop maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. Return value: actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. Return value: actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. Return value: actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. Return value: actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). Return value: actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). Return value: actionsequence perform() Executes this action sequence. Return value: promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation on GitHub. Return value: actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, finally() and catch(). For more information, see Sequence actions. Function Description isPending() Whether this promise's value is still being computed. Return value: boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. Return value: promise finally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. Return value: promise catch(callback: fn()) Registers a listener for when this promise is rejected. Return value: promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Description back() Move back by one step in the browser's history. Return value: void forward() Move forward by one step in the browser's history. Return value: void refresh() Refresh the current page. Return value: void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). Return value: void Conditions: Pause and wait for conditions Tip You can learn more about waits in Selenium here. Used with $browser.wait, until pauses your script execution until the condition is matched. For more information, see Selenium's WebDriver until documentation. The following are available functions for $driver.until.Condition: Function Description ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. Return value: condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. Return value: condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. Return value: condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. Return value: condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. Return value: condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. Return value: condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. Return value: condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. Return value: condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. Return value: condition n elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. Return value: condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. Return value: condition n elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. Return value: condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM or a new page has loaded. Return value: condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. Return value: condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. Return value: condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. Return value: condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.52077,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "sections": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "This document describes scripted browser functions available for <em>synthetic</em> <em>monitors</em> versions 0.5.x or higher. If you are using older <em>monitor</em> versions, see the <em>monitor</em> version 0.4.0 and lower documentation. For more on <em>monitor</em> versions and runtime differences, see Runtime environments. Selenium"
      },
      "id": "603e7f27e7b9d2b2912a07ab"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower": [
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-12-09T21:17:32Z",
      "updated_at": "2021-11-15T07:23:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy Here's an example of setting up a proxied network via proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, 'anotherExample.com': {username: 'authUsername', password: 'authPassword'}, } $network.setProxyPAC(\"https://www.example.com/pacScript\", authCredentialsMap) Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples Here's an example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy Here's an example of setting up a proxied network with mixed network zone assets: var proxyRules = {singleProxy: {host:\"http://entproxy.mycompany.com\"}, bypassList:['s3.amazonaws.com','*.localcdn.com'] } $network.setProxyAdvanced(proxyRules) Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.19339,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    },
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-12-09T21:18:24Z",
      "updated_at": "2021-11-07T09:33:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. (Note that Request is deprecated, but these options still apply.) Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. We recommend using SSL to avoid exposing plain text credentials in your headers. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(duration)%20FROM%20Transaction', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.39877,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ". If any assert functions fail, the entire <em>monitor</em> will be considered a failed check. This may trigger alert notifications and affect your metrics. Important <em>Synthetic</em> <em>monitoring</em> does not allow thrown exceptions. Thrown exceptions result in <em>script</em> failure. Use the assert module to validate your results"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
        "Selenium Webdriver APIs",
        "Top-level functions: Build your script",
        "Deny list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "Tip"
      ],
      "title": "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "47ceb711bcb322760a428f1e7c03c4444b777998",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050/",
      "published_at": "2021-12-09T20:49:25Z",
      "updated_at": "2021-10-31T07:57:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes scripted browser functions available for synthetic monitors versions 0.5.x or higher. If you are using older monitor versions, see the monitor version 0.4.0 and lower documentation. For more on monitor versions and runtime differences, see Runtime environments. Selenium Webdriver APIs The synthetic scripted browsers provide access to the Selenium Webdriver APIs 3.6.0 for monitor version 0.6.x and Selenium Webdriver APIs 3.5.0 for monitor version 0.5.x via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic monitoring instance of selenium-webdriver.WebDriver(). It exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Description $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence. Return value: void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. Return value: void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. Return value: void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. Return value: void $browser.deleteHeaders(header: [string]) Deletes all headers in the argument from runtime. Return value: void $browser.addHostnameToBlacklist(hostname: string) Adds a hostname to your deny list. Allows using wildcards. Return value: void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Adds all hostnames in an array of arguments to your deny list. Allows using wildcards. Return value: void $browser.addHostnameToWhitelist(hostname: string) Adds a hostname blocked by default in synthetic monitoring to your allow list. Return value: void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Adds all hostnames in the argument to your allow list. Return value: void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname for this browser instance from your deny list. Return value: void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in the argument from your deny list. Return value: void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname for this browser instance from your allow list. Return value: void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in the argument from your allow list for this browser instance. Return value: void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. Return value: promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. Return value: promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, synthetic monitoring returns an error. Return value: WebElementPromise $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. Return value: promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, synthetic monitoring returns an error. The timeout value is optional. It is applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). Return value: WebElementPromise $browser.get(url: string) Loads a webpage in a synthetic browser. Return value: promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. Return value: promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. Return value: promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. Return value: promise $browser.getHeaders() Returns a map of currently configured headers. Return value: map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM. Do not expect it to be formatted or escaped in the same way as the response sent from the web server. Return value: promise $browser.getSession() A promise for this client's session. Return value: promise $browser.getTitle() Schedules a command to retrieve the current page's title. Return value: promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. Return value: promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. Return value: void $browser.navigate() The navigation interface (history of browser functions) for this instance. Return value: void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. Return value: promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. Return value: promise $browser.switchTo() The target locator interface for this instance. Return value: void $browser.takeScreenshot() Schedules a command to take a screenshot. Return value: promise $browser.wait(fn: $driver.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by your supplied function. Return value: WebElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. Return value: promise Deny list: Wildcard use If you want to add domains to the deny list for your browser instance, the wildcards must match the URL syntax of the URL to be blocked. An overall .com deny list must contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance, such as cookies, timeouts, and window size. Access these options through the $browser.manage() function. Function Description $browser.manage().addCookie(spec: object) Schedules a command to add a cookie. spec is a record object describing a browser cookie. For more information, see the Selenium documentation. Return value: promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. Return value: promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. Return value: promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. Return value: promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. Return value: promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. Return value: promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. Return value: promise $browser.manage().window().getSize() Retrieves the window's current size. Return value: promise $browser.manage().window().maximize() Maximizes the current window. Return value: promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. Return value: promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. Return value: promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement. Call them through $driver.By. Function Description $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. Return value: locator $driver.By.css(cssName: string) Locates an element using a CSS selector. Return value: locator $driver.By.id(id: string) Locates an element by its ID. Return value: locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. Return value: locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. Return value: locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. Return value: locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. Return value: locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. Return value: locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. Return value: locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. For example, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Description click() Clicks on this element. Return value: self reference sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. Return value: WebElement getTagName() Schedules a command to query for the tag/node name of this element. Return value: WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). Return value: promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. Return value: promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. Return value: promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. Return value: promise getLocation() Schedules a command to compute the location of this element, in page space. Return value: promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. Return value: promise isSelected() Schedules a command to query whether this element is selected. Return value: promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. Return value: promise clear() Schedules a command to clear the value of this element. Return value: promise isDisplayed() Schedules a command to test whether this element is currently displayed. Return value: promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation on GitHub. Function Description click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). Return value: actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. Return value: actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a drag and drop maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. Return value: actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. Return value: actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. Return value: actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. Return value: actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). Return value: actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). Return value: actionsequence perform() Executes this action sequence. Return value: promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation on GitHub. Return value: actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, finally() and catch(). For more information, see Sequence actions. Function Description isPending() Whether this promise's value is still being computed. Return value: boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. Return value: promise finally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. Return value: promise catch(callback: fn()) Registers a listener for when this promise is rejected. Return value: promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Description back() Move back by one step in the browser's history. Return value: void forward() Move forward by one step in the browser's history. Return value: void refresh() Refresh the current page. Return value: void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). Return value: void Conditions: Pause and wait for conditions Tip You can learn more about waits in Selenium here. Used with $browser.wait, until pauses your script execution until the condition is matched. For more information, see Selenium's WebDriver until documentation. The following are available functions for $driver.until.Condition: Function Description ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. Return value: condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. Return value: condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. Return value: condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. Return value: condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. Return value: condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. Return value: condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. Return value: condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. Return value: condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. Return value: condition n elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. Return value: condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. Return value: condition n elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. Return value: condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM or a new page has loaded. Return value: condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. Return value: condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. Return value: condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. Return value: condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.52077,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "sections": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "This document describes scripted browser functions available for <em>synthetic</em> <em>monitors</em> versions 0.5.x or higher. If you are using older <em>monitor</em> versions, see the <em>monitor</em> version 0.4.0 and lower documentation. For more on <em>monitor</em> versions and runtime differences, see Runtime environments. Selenium"
      },
      "id": "603e7f27e7b9d2b2912a07ab"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050": [
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-12-09T21:17:32Z",
      "updated_at": "2021-11-15T07:23:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy Here's an example of setting up a proxied network via proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, 'anotherExample.com': {username: 'authUsername', password: 'authPassword'}, } $network.setProxyPAC(\"https://www.example.com/pacScript\", authCredentialsMap) Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples Here's an example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy Here's an example of setting up a proxied network with mixed network zone assets: var proxyRules = {singleProxy: {host:\"http://entproxy.mycompany.com\"}, bypassList:['s3.amazonaws.com','*.localcdn.com'] } $network.setProxyAdvanced(proxyRules) Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.19339,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    },
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-12-09T21:18:24Z",
      "updated_at": "2021-11-07T09:33:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. (Note that Request is deprecated, but these options still apply.) Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. We recommend using SSL to avoid exposing plain text credentials in your headers. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(duration)%20FROM%20Transaction', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.39877,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ". If any assert functions fail, the entire <em>monitor</em> will be considered a failed check. This may trigger alert notifications and affect your metrics. Important <em>Synthetic</em> <em>monitoring</em> does not allow thrown exceptions. Thrown exceptions result in <em>script</em> failure. Use the assert module to validate your results"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-12-09T21:17:32Z",
      "updated_at": "2021-10-31T07:57:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.52077,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests": [
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-12-09T21:17:32Z",
      "updated_at": "2021-11-15T07:23:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy Here's an example of setting up a proxied network via proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, 'anotherExample.com': {username: 'authUsername', password: 'authPassword'}, } $network.setProxyPAC(\"https://www.example.com/pacScript\", authCredentialsMap) Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples Here's an example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy Here's an example of setting up a proxied network with mixed network zone assets: var proxyRules = {singleProxy: {host:\"http://entproxy.mycompany.com\"}, bypassList:['s3.amazonaws.com','*.localcdn.com'] } $network.setProxyAdvanced(proxyRules) Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.19337,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-12-09T21:17:32Z",
      "updated_at": "2021-10-31T07:57:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.52077,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    },
    {
      "sections": [
        "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
        "Selenium Webdriver APIs",
        "Top-level functions: Build your script",
        "Deny list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "Tip"
      ],
      "title": "Synthetic's scripted browser reference (monitor versions 0.5.0+)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "47ceb711bcb322760a428f1e7c03c4444b777998",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050/",
      "published_at": "2021-12-09T20:49:25Z",
      "updated_at": "2021-10-31T07:57:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes scripted browser functions available for synthetic monitors versions 0.5.x or higher. If you are using older monitor versions, see the monitor version 0.4.0 and lower documentation. For more on monitor versions and runtime differences, see Runtime environments. Selenium Webdriver APIs The synthetic scripted browsers provide access to the Selenium Webdriver APIs 3.6.0 for monitor version 0.6.x and Selenium Webdriver APIs 3.5.0 for monitor version 0.5.x via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic monitoring instance of selenium-webdriver.WebDriver(). It exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Description $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence. Return value: void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. Return value: void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. Return value: void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. Return value: void $browser.deleteHeaders(header: [string]) Deletes all headers in the argument from runtime. Return value: void $browser.addHostnameToBlacklist(hostname: string) Adds a hostname to your deny list. Allows using wildcards. Return value: void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Adds all hostnames in an array of arguments to your deny list. Allows using wildcards. Return value: void $browser.addHostnameToWhitelist(hostname: string) Adds a hostname blocked by default in synthetic monitoring to your allow list. Return value: void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Adds all hostnames in the argument to your allow list. Return value: void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname for this browser instance from your deny list. Return value: void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in the argument from your deny list. Return value: void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname for this browser instance from your allow list. Return value: void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in the argument from your allow list for this browser instance. Return value: void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. Return value: promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. Return value: promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, synthetic monitoring returns an error. Return value: WebElementPromise $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. Return value: promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, synthetic monitoring returns an error. The timeout value is optional. It is applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). Return value: WebElementPromise $browser.get(url: string) Loads a webpage in a synthetic browser. Return value: promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. Return value: promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. Return value: promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. Return value: promise $browser.getHeaders() Returns a map of currently configured headers. Return value: map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM. Do not expect it to be formatted or escaped in the same way as the response sent from the web server. Return value: promise $browser.getSession() A promise for this client's session. Return value: promise $browser.getTitle() Schedules a command to retrieve the current page's title. Return value: promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. Return value: promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. Return value: void $browser.navigate() The navigation interface (history of browser functions) for this instance. Return value: void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. Return value: promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. Return value: promise $browser.switchTo() The target locator interface for this instance. Return value: void $browser.takeScreenshot() Schedules a command to take a screenshot. Return value: promise $browser.wait(fn: $driver.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by your supplied function. Return value: WebElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. Return value: promise Deny list: Wildcard use If you want to add domains to the deny list for your browser instance, the wildcards must match the URL syntax of the URL to be blocked. An overall .com deny list must contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance, such as cookies, timeouts, and window size. Access these options through the $browser.manage() function. Function Description $browser.manage().addCookie(spec: object) Schedules a command to add a cookie. spec is a record object describing a browser cookie. For more information, see the Selenium documentation. Return value: promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. Return value: promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. Return value: promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. Return value: promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. Return value: promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. Return value: promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. Return value: promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. Return value: promise $browser.manage().window().getSize() Retrieves the window's current size. Return value: promise $browser.manage().window().maximize() Maximizes the current window. Return value: promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. Return value: promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. Return value: promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement. Call them through $driver.By. Function Description $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. Return value: locator $driver.By.css(cssName: string) Locates an element using a CSS selector. Return value: locator $driver.By.id(id: string) Locates an element by its ID. Return value: locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. Return value: locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. Return value: locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. Return value: locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. Return value: locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. Return value: locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. Return value: locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. For example, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Description click() Clicks on this element. Return value: self reference sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. Return value: WebElement getTagName() Schedules a command to query for the tag/node name of this element. Return value: WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). Return value: promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. Return value: promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. Return value: promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. Return value: promise getLocation() Schedules a command to compute the location of this element, in page space. Return value: promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. Return value: promise isSelected() Schedules a command to query whether this element is selected. Return value: promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. Return value: promise clear() Schedules a command to clear the value of this element. Return value: promise isDisplayed() Schedules a command to test whether this element is currently displayed. Return value: promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation on GitHub. Function Description click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). Return value: actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. Return value: actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a drag and drop maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. Return value: actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. Return value: actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. Return value: actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. Return value: actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). Return value: actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). Return value: actionsequence perform() Executes this action sequence. Return value: promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation on GitHub. Return value: actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, finally() and catch(). For more information, see Sequence actions. Function Description isPending() Whether this promise's value is still being computed. Return value: boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. Return value: promise finally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. Return value: promise catch(callback: fn()) Registers a listener for when this promise is rejected. Return value: promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Description back() Move back by one step in the browser's history. Return value: void forward() Move forward by one step in the browser's history. Return value: void refresh() Refresh the current page. Return value: void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). Return value: void Conditions: Pause and wait for conditions Tip You can learn more about waits in Selenium here. Used with $browser.wait, until pauses your script execution until the condition is matched. For more information, see Selenium's WebDriver until documentation. The following are available functions for $driver.until.Condition: Function Description ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. Return value: condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. Return value: condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. Return value: condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. Return value: condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. Return value: condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. Return value: condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. Return value: condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. Return value: condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. Return value: condition n elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. Return value: condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. Return value: condition n elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. Return value: condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM or a new page has loaded. Return value: condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. Return value: condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. Return value: condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. Return value: condition",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.52075,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "sections": "<em>Synthetic&#x27;s</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.5.0+)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "This document describes scripted browser functions available for <em>synthetic</em> <em>monitors</em> versions 0.5.x or higher. If you are using older <em>monitor</em> versions, see the <em>monitor</em> version 0.4.0 and lower documentation. For more on <em>monitor</em> versions and runtime differences, see Runtime environments. Selenium"
      },
      "id": "603e7f27e7b9d2b2912a07ab"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/troubleshooting/monitor-produces-no-traffic": [
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-10T13:37:34Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.56621,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results page To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results page to locate interesting runs of your <em>monitor</em> for <em>troubleshooting</em>"
      },
      "id": "603eb5da64441f07ae4e8850"
    },
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.900024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-12-09T21:12:39Z",
      "updated_at": "2021-11-07T09:25:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. Avoid extra noise and get notified after three failures Read our blog post on the three strikes rule.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.02294,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: <em>Troubleshoot</em> downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: <em>Troubleshoot</em> downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and <em>troubleshoot</em>. View the failures page To access your <em>monitor</em>&#x27;s failures: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Failures. Hover the mouse over a failure to get"
      },
      "id": "603e9efd64441faf344e8865"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/troubleshooting/non-scripted-monitor-errors": [
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-10T13:37:34Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.5662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results page To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results page to locate interesting runs of your <em>monitor</em> for <em>troubleshooting</em>"
      },
      "id": "603eb5da64441f07ae4e8850"
    },
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.90001,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-12-09T21:12:39Z",
      "updated_at": "2021-11-07T09:25:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. Avoid extra noise and get notified after three failures Read our blog post on the three strikes rule.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.022934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: <em>Troubleshoot</em> downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: <em>Troubleshoot</em> downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and <em>troubleshoot</em>. View the failures page To access your <em>monitor</em>&#x27;s failures: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Failures. Hover the mouse over a failure to get"
      },
      "id": "603e9efd64441faf344e8865"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/troubleshooting/private-location-hmac-errors": [
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-10T13:37:34Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.5662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results page To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results page to locate interesting runs of your <em>monitor</em> for <em>troubleshooting</em>"
      },
      "id": "603eb5da64441f07ae4e8850"
    },
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.90001,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-12-09T21:12:39Z",
      "updated_at": "2021-11-07T09:25:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. Avoid extra noise and get notified after three failures Read our blog post on the three strikes rule.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.022934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: <em>Troubleshoot</em> downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: <em>Troubleshoot</em> downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and <em>troubleshoot</em>. View the failures page To access your <em>monitor</em>&#x27;s failures: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Failures. Hover the mouse over a failure to get"
      },
      "id": "603e9efd64441faf344e8865"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/troubleshooting/simple-scripted-or-scripted-api-non-ping-errors": [
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-10T13:37:34Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.56619,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results page To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results page to locate interesting runs of your <em>monitor</em> for <em>troubleshooting</em>"
      },
      "id": "603eb5da64441f07ae4e8850"
    },
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.899994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-12-09T21:12:39Z",
      "updated_at": "2021-11-07T09:25:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. Avoid extra noise and get notified after three failures Read our blog post on the three strikes rule.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.02293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: <em>Troubleshoot</em> downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: <em>Troubleshoot</em> downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and <em>troubleshoot</em>. View the failures page To access your <em>monitor</em>&#x27;s failures: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Failures. Hover the mouse over a failure to get"
      },
      "id": "603e9efd64441faf344e8865"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/troubleshooting/troubleshoot-isolated-monitor-failures": [
    {
      "sections": [
        "Synthetic monitoring: Access individual monitor runs",
        "View the Results page",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Access individual monitor runs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "dde194950b9db1ed2e9aa6c6d3c822757185ab5c",
      "image": "https://docs.newrelic.com/static/b4f40751e7cd27e781d6829e975e585f/8c557/results.png",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs/",
      "published_at": "2021-12-10T13:37:34Z",
      "updated_at": "2021-10-31T10:07:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Results page to view individual monitor results. Locate interesting results by sorting the list to identify slow, fast, or other unusual results. Or filter by location to understand how monitor performance varies with geography. The Page Load Time graph gives a snapshot of how page performance has varied over time. View the Results page To access your monitor's Results: Go to one.newrelic.com > Synthetics > (select a monitor) > Results. one.newrelic.com > Synthetics > (select a monitor) > Results: Use the Results page to locate interesting runs of your monitor for troubleshooting, and see where your monitors spend the most time. Use page functions The Results page supports the following features: If you want to... Do this... Sort the results list From the Sort By dropdown, select an option: To view your fastest and slowest results, sort by Duration (select descending to view your slowest, or ascending to view the fastest). Find unusually large or small response packets by sorting by Response Size (select descending or ascending, as appropriate). Sort your results by timestamp by selecting Newest or Oldest. Filter by location Select a location label to hide results from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Hide and unhide chart elements Select chart elements to hide and unhide them from the Page Load Time chart. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.56619,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Access individual <em>monitor</em> runs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " performance has varied over time. View the Results page To access your <em>monitor</em>&#x27;s Results: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results. one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Results: Use the Results page to locate interesting runs of your <em>monitor</em> for <em>troubleshooting</em>"
      },
      "id": "603eb5da64441f07ae4e8850"
    },
    {
      "sections": [
        "User roles in synthetic monitoring",
        "Users on original user model",
        "Default access",
        "Customize access",
        "Users on New Relic One user model"
      ],
      "title": "User roles in synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "955d31ad885f2de3218e6d6c5963eba857bd5fa6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring/",
      "published_at": "2021-12-10T13:22:39Z",
      "updated_at": "2021-11-25T11:27:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Access to synthetic monitoring features varies whether a user is on the newer New Relic One user model or our original user model. For an explanation of user models and how they relate to our pricing models, see Overview of pricing and user changes. Users on original user model For users on our original user model, access will vary depending on whether you have default roles or custom roles: Default access Admins have full access to all synthetic monitoring features on an account. Users have access to all synthetic monitoring features except secure credentials and the ability to delete monitors, monitor downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all synthetic monitoring features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users with this role do not have access to all create, edit, and delete capabilities for synthetic monitoring features (as well as view capability for secure credentials) until they are given a role with the appropriate capabilities. Customize access To get started, follow standard procedures to create a custom role. You can add View and Edit capabilities to any role for the following: Monitors Monitor scripts Private locations Monitor downtimes Secure credentials Users on New Relic One user model For users on the New Relic One user model, full platform users have the ability to use the synthetic monitoring UI to create and manage synthetic monitors, while basic users cannot do that. For limitations related to API usage, see User limitations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.899994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "sections": "User roles in <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " monitors, <em>monitor</em> downtime, and private locations. Restricted Users on accounts with original product-based pricing have view-only access to all <em>synthetic</em> <em>monitoring</em> features except: Secure credentials Private locations (although they can query a limited amount of data via NRQL) This means that users"
      },
      "id": "603eab2e64441f63844e88b2"
    },
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-12-09T21:12:39Z",
      "updated_at": "2021-11-07T09:25:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. Avoid extra noise and get notified after three failures Read our blog post on the three strikes rule.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.02293,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: <em>Troubleshoot</em> downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: <em>Troubleshoot</em> downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and <em>troubleshoot</em>. View the failures page To access your <em>monitor</em>&#x27;s failures: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Failures. Hover the mouse over a failure to get"
      },
      "id": "603e9efd64441faf344e8865"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors": [
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-09T20:54:03Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-09T20:52:08Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.8109,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    },
    {
      "sections": [
        "Store secure credentials for scripted browsers and API tests",
        "Requirements and limits",
        "Add or update secure credentials",
        "Update the script",
        "Security for secure credentials",
        "Redacted information"
      ],
      "title": "Store secure credentials for scripted browsers and API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ee8bec412a7cb3223e6164d653ca9fc9307e672a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests/",
      "published_at": "2021-12-09T20:53:01Z",
      "updated_at": "2021-10-13T00:42:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use secure credentials with synthetic monitoring to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted monitor users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). You can set secure credentials in New Relic One or with the API. Requirements and limits Before using secure credentials, review these requirements and guidelines: Secure credentials Comments Applicable monitors The secure credentials feature is available only for synthetic scripted browsers and API test monitors. Permissions Account administrators can control which users can create, view, or delete secure credentials by managing users' permissions. Limit You can have a maximum of 1,000 secure credentials. Add or update secure credentials You can add or update secure credentials using the UI or the Synthetics REST API. To add, view, edit, or delete a secure credential for a scripted browser or API test monitor from the UI: Go to one.newrelic.com > Synthetics > Secure credentials. To add a new secure credential, look for the Create secure credential + button. If you have credentials already added, this button is at the top right. Tips for creating the Key: choose a username or other meaningful key name to identify the secure credential. Use alphanumeric or underscore _ characters. Key names must be UPPERCASE. Tips for creating the Value: Use any combination of alphanumeric or special characters. 10000 characters maximum. This field is not accessible via the API. To edit an existing credential, click the ellipsis icon for options. Associate the secure credential with a scripted browser or API test by editing the script. After you add the secure credential to the script, the Secure credentials UI shows how many scripted monitors use that credential. This number is approximate and only updates after a monitor with a secure credential has actually been run. Update the script When using the Synthetics UI editor to create scripted browsers or API test monitors, follow these guidelines: Script Guidelines Format Anywhere in the script where you reference the secure credential, it is accessed via the reserved New Relic $secure JavaScript object with dot notation. For example, $secure.MY_SECURE_CREDENTIAL. Properties on $secure are not accessible through bracket notation. Existing credentials To view or select from a list of available secure credentials: Type $secure. OR Select from the dropdown in the editor UI. Validation To validate the secure credential, follow standard procedures to test the script or write an API test. Any changes to the secure credential's value will automatically take effect across all monitors that use it. You do not need to also update the script. Exception: If you update the script and jobs are already processing, the secure credential change will not take effect until the next time the job begins. Security for secure credentials To ensure the security of your secure credentials, New Relic scrubs the secure value out of all data that goes to results in synthetic monitoring data and alerts. New Relic employees cannot access secure credential values and must be added to the account to be able to view secure credentials. Example A secure credential is named PASSWORD and the value is Pass123!. New Relic replaces Pass123! with _SECURECREDENTIAL_ For example, a script includes: $browser.get(\"https://example.com/\" + $secure.PASSWORD) Copy The script results will show that New Relic Synthetics went to https://example.com/_SECURECREDENTIAL_, even though it actually went to https://example.com/Pass123!. This ensures the value of the secure credential will not appear in the results. Redacted information We currently redact the following from the results of your monitor: The exact values of your secure credentials Any percent-encoded values of your secure credentials",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.66237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can <em>use</em> secure credentials with <em>synthetic</em> <em>monitoring</em> to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted <em>monitor</em> users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely"
      },
      "id": "60452772196a67195c960f3b"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/alerts-synthetic-monitoring": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-09T21:19:08Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.74074,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-09T20:54:03Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-09T20:52:08Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.8109,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/collect-synthetic-transaction-traces": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-09T21:19:08Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.74072,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-09T20:54:03Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-09T20:52:08Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/handle-sites-authentication": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-09T21:19:08Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.74072,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-09T20:54:03Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-09T20:52:08Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/manage-monitor-runtimes": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-09T21:19:08Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.74069,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-09T20:54:03Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-09T20:52:08Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-09T21:19:08Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.74069,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-09T20:54:03Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Store secure credentials for scripted browsers and API tests",
        "Requirements and limits",
        "Add or update secure credentials",
        "Update the script",
        "Security for secure credentials",
        "Redacted information"
      ],
      "title": "Store secure credentials for scripted browsers and API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ee8bec412a7cb3223e6164d653ca9fc9307e672a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests/",
      "published_at": "2021-12-09T20:53:01Z",
      "updated_at": "2021-10-13T00:42:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use secure credentials with synthetic monitoring to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted monitor users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). You can set secure credentials in New Relic One or with the API. Requirements and limits Before using secure credentials, review these requirements and guidelines: Secure credentials Comments Applicable monitors The secure credentials feature is available only for synthetic scripted browsers and API test monitors. Permissions Account administrators can control which users can create, view, or delete secure credentials by managing users' permissions. Limit You can have a maximum of 1,000 secure credentials. Add or update secure credentials You can add or update secure credentials using the UI or the Synthetics REST API. To add, view, edit, or delete a secure credential for a scripted browser or API test monitor from the UI: Go to one.newrelic.com > Synthetics > Secure credentials. To add a new secure credential, look for the Create secure credential + button. If you have credentials already added, this button is at the top right. Tips for creating the Key: choose a username or other meaningful key name to identify the secure credential. Use alphanumeric or underscore _ characters. Key names must be UPPERCASE. Tips for creating the Value: Use any combination of alphanumeric or special characters. 10000 characters maximum. This field is not accessible via the API. To edit an existing credential, click the ellipsis icon for options. Associate the secure credential with a scripted browser or API test by editing the script. After you add the secure credential to the script, the Secure credentials UI shows how many scripted monitors use that credential. This number is approximate and only updates after a monitor with a secure credential has actually been run. Update the script When using the Synthetics UI editor to create scripted browsers or API test monitors, follow these guidelines: Script Guidelines Format Anywhere in the script where you reference the secure credential, it is accessed via the reserved New Relic $secure JavaScript object with dot notation. For example, $secure.MY_SECURE_CREDENTIAL. Properties on $secure are not accessible through bracket notation. Existing credentials To view or select from a list of available secure credentials: Type $secure. OR Select from the dropdown in the editor UI. Validation To validate the secure credential, follow standard procedures to test the script or write an API test. Any changes to the secure credential's value will automatically take effect across all monitors that use it. You do not need to also update the script. Exception: If you update the script and jobs are already processing, the secure credential change will not take effect until the next time the job begins. Security for secure credentials To ensure the security of your secure credentials, New Relic scrubs the secure value out of all data that goes to results in synthetic monitoring data and alerts. New Relic employees cannot access secure credential values and must be added to the account to be able to view secure credentials. Example A secure credential is named PASSWORD and the value is Pass123!. New Relic replaces Pass123! with _SECURECREDENTIAL_ For example, a script includes: $browser.get(\"https://example.com/\" + $secure.PASSWORD) Copy The script results will show that New Relic Synthetics went to https://example.com/_SECURECREDENTIAL_, even though it actually went to https://example.com/Pass123!. This ensures the value of the secure credential will not appear in the results. Redacted information We currently redact the following from the results of your monitor: The exact values of your secure credentials Any percent-encoded values of your secure credentials",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.66235,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can <em>use</em> secure credentials with <em>synthetic</em> <em>monitoring</em> to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted <em>monitor</em> users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely"
      },
      "id": "60452772196a67195c960f3b"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/recheck-failed-monitors": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-09T21:19:08Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.74066,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-09T20:54:03Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81136,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-09T20:52:08Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-09T21:19:08Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.74066,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-09T20:54:03Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81136,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-09T20:52:08Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-09T21:19:08Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.74065,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-09T20:52:08Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    },
    {
      "sections": [
        "Store secure credentials for scripted browsers and API tests",
        "Requirements and limits",
        "Add or update secure credentials",
        "Update the script",
        "Security for secure credentials",
        "Redacted information"
      ],
      "title": "Store secure credentials for scripted browsers and API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ee8bec412a7cb3223e6164d653ca9fc9307e672a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests/",
      "published_at": "2021-12-09T20:53:01Z",
      "updated_at": "2021-10-13T00:42:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use secure credentials with synthetic monitoring to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted monitor users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). You can set secure credentials in New Relic One or with the API. Requirements and limits Before using secure credentials, review these requirements and guidelines: Secure credentials Comments Applicable monitors The secure credentials feature is available only for synthetic scripted browsers and API test monitors. Permissions Account administrators can control which users can create, view, or delete secure credentials by managing users' permissions. Limit You can have a maximum of 1,000 secure credentials. Add or update secure credentials You can add or update secure credentials using the UI or the Synthetics REST API. To add, view, edit, or delete a secure credential for a scripted browser or API test monitor from the UI: Go to one.newrelic.com > Synthetics > Secure credentials. To add a new secure credential, look for the Create secure credential + button. If you have credentials already added, this button is at the top right. Tips for creating the Key: choose a username or other meaningful key name to identify the secure credential. Use alphanumeric or underscore _ characters. Key names must be UPPERCASE. Tips for creating the Value: Use any combination of alphanumeric or special characters. 10000 characters maximum. This field is not accessible via the API. To edit an existing credential, click the ellipsis icon for options. Associate the secure credential with a scripted browser or API test by editing the script. After you add the secure credential to the script, the Secure credentials UI shows how many scripted monitors use that credential. This number is approximate and only updates after a monitor with a secure credential has actually been run. Update the script When using the Synthetics UI editor to create scripted browsers or API test monitors, follow these guidelines: Script Guidelines Format Anywhere in the script where you reference the secure credential, it is accessed via the reserved New Relic $secure JavaScript object with dot notation. For example, $secure.MY_SECURE_CREDENTIAL. Properties on $secure are not accessible through bracket notation. Existing credentials To view or select from a list of available secure credentials: Type $secure. OR Select from the dropdown in the editor UI. Validation To validate the secure credential, follow standard procedures to test the script or write an API test. Any changes to the secure credential's value will automatically take effect across all monitors that use it. You do not need to also update the script. Exception: If you update the script and jobs are already processing, the secure credential change will not take effect until the next time the job begins. Security for secure credentials To ensure the security of your secure credentials, New Relic scrubs the secure value out of all data that goes to results in synthetic monitoring data and alerts. New Relic employees cannot access secure credential values and must be added to the account to be able to view secure credentials. Example A secure credential is named PASSWORD and the value is Pass123!. New Relic replaces Pass123! with _SECURECREDENTIAL_ For example, a script includes: $browser.get(\"https://example.com/\" + $secure.PASSWORD) Copy The script results will show that New Relic Synthetics went to https://example.com/_SECURECREDENTIAL_, even though it actually went to https://example.com/Pass123!. This ensures the value of the secure credential will not appear in the results. Redacted information We currently redact the following from the results of your monitor: The exact values of your secure credentials Any percent-encoded values of your secure credentials",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.66235,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can <em>use</em> secure credentials with <em>synthetic</em> <em>monitoring</em> to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted <em>monitor</em> users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely"
      },
      "id": "60452772196a67195c960f3b"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/view-ping-monitor-results": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-09T21:19:08Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.74065,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-09T20:54:03Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81136,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-09T20:52:08Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/view-simple-scripted-monitor-results": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-12-09T21:19:08Z",
      "updated_at": "2021-11-25T11:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also: Capture aggregate numbers, including an overview or summary for ping monitors. Provide detailed statistics for each page resource, and downtime incidents. Collect custom response codes for more detail on your monitor runs. You'll be able to add and configure synthetic monitors to suit your environnment after you create a New Relic account. (It's free, forever!) Add a monitor You can add several types of synthetic monitors: Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. The default timeout for a new monitor is 180 seconds. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL (may be any valid HTTP or HTTPS URL). Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor (may be any valid HTTP or HTTPS URL). Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Generate some traffic and wait a few minutes, then check your monitor from the Monitors index. Tip You can also add monitors with the Synthetics REST API. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor You cannot change a monitor's type after the monitor is created, but you can edit other monitor settings. From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also delete a monitor with the Synthetics REST API. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.74062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts, click Manage alerts. Select Save changes to confirm. Delete a <em>monitor</em> To delete a <em>monitor</em>: From the <em>Monitors</em> tab in one.newrelic.com &gt; <em>Synthetics</em>, select the <em>monitor</em> you want to edit. From the selected <em>monitor</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring response codes",
        "Response codes"
      ],
      "title": "Synthetic monitoring response codes",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ea5ea3ee3a21a108db952a861421c11e092e2611",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes/",
      "published_at": "2021-12-09T20:54:03Z",
      "updated_at": "2021-10-31T08:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium's response codes and give you more detail on the behavior of your monitors. Response codes Synthetic monitoring returns the following additional response codes: Response Code Definition -2 net::ERR_FAILED, \"Generic network error\" -3 net::ERR_ABORTED, \"An operation was aborted (due to user action)\" A Chrome-specific response code when the script hits a timeout and the runner is shutting down. To do that, the runner ends all pending requests. -7 net::ERR_TIMED_OUT, \"Timed out\" -10 net::ERR_ACCESS_DENIED, \"Access denied\" -20 net::ERR_BLOCKED_BY_CLIENT, \"Blocked\" -100 net::ERR_CONNECTION_CLOSED, \"Connection was closed (TCP FIN)\" -101 net::ERR_CONNECTION_RESET, \"Connection was reset (TCP RST)\" -102 net::ERR_CONNECTION_REFUSED, \"Connection was refused\" -103 net::ERR_CONNECTION_ABORTED, \"Connection was aborted (no ACK received)\" -104 net::ERR_CONNECTION_FAILED, \"Connection attempt failed\" -105 net::ERR_NAME_NOT_RESOLVED, \"Host name could not be resolved\" -106 net::ERR_INTERNET_DISCONNECTED, \"Internet connection lost\" -107 net::ERR_SSL_PROTOCOL_ERROR, \"SSL protocol error\" -108 net::ERR_ADDRESS_INVALID, \"Invalid IP address and/or port number\" -109 net::ERR_ADDRESS_UNREACHABLE, \"Unreachable IP address\" -110 net::ERR_SSL_CLIENT_AUTH_CERT_NEEDED, \"Server requested a client certificate for SSL client authentication\" -112 net::ERR_NO_SSL_VERSIONS_ENABLED, \"No SSL protocol versions are enabled\" -113 net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH, \"Client and server don't support a common SSL protocol version or cipher suite\" -114 net::ERR_SSL_RENEGOTIATION_REQUESTED, \"Server requested a renegotiation (re-handshake)\" -116 net::ERR_CERT_ERROR_IN_SSL_RENEGOTIATION, \"During SSL renegotiation (re-handshake), the server sent a certificate with an error\" -117 net::ERR_BAD_SSL_CLIENT_AUTH_CERT, \"SSL handshake failed because of a bad or missing client certificate\" -118 net::ERR_CONNECTION_TIMED_OUT, \"Timed out\" -123 net::ERR_SSL_NO_RENEGOTIATION, \"Peer sent an SSL no_renegotiation alert message\" -138 net::ERR_ACCESS_DENIED, \"Access denied\" -141 net::ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED, \"Unable to sign the CertificateVerify data of an SSL client auth handshake with the client certificate's private key\" -145 net::ERR_WS_PROTOCOL_ERROR, \"WebSocket protocol error - connection terminated due to a malformed frame or other protocol violation\" -147 net::ERR_ADDRESS_IN_USE, \"Failed to bind to an address because already in use\" -148 net::ERR_SSL_HANDSHAKE_NOT_COMPLETED, \"SSL handshake has not completed\" -149 net::ERR_SSL_BAD_PEER_PUBLIC_KEY, \"SSL peer's public key is invalid\" -150 net::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN, \"Certificate didn't match built-in public key pins for the host name\" -151 net::ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED, \"Server request for client certificate did not contain any types we support\" -152 net::ERR_ORIGIN_BOUND_CERT_GENERATION_TYPE_MISMATCH, \"Server requested one type of cert, then requested a different type while the first was still being generated\" -153 net::ERR_SSL_DECRYPT_ERROR_ALERT, \"SSL peer sent us a fatal decrypt_error alert\" -156 net::ERR_SSL_SERVER_CERT_CHANGED, \"SSL server certificate changed in a renegotiation\" -157 net::ERR_SSL_INAPPROPRIATE_FALLBACK, \"SSL server indicated that an unnecessary TLS version fallback was performed\" -158 net::ERR_CT_NO_SCTS_VERIFIED_OK, \"All Signed Certificate Timestamps failed to verify\" -159 net::ERR_SSL_UNRECOGNIZED_NAME_ALERT, \"SSL server sent us a fatal unrecognized_name alert\" -164 net::ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT, \"Failed to import a client certificate from the platform store into the SSL library\" -165 net::ERR_SSL_FALLBACK_BEYOND_MINIMUM_VERSION\", \"SSL server requires falling back to a version older than the configured minimum fallback version\" -166 net::ERR_ICANN_NAME_COLLISION\", \"Resolving a hostname to an IP address list included the IPv4 address \\\"127.0.53.53\\\". This is a special IP address which ICANN has recommended to indicate there was a name collision, and alert admins to a potential problem\" -200 net::ERR_CERT_COMMON_NAME_INVALID, \"Server responded with a certificate whose common name did not match the host name\" -201 net::ERR_CERT_DATE_INVALID\", \"Server responded with a certificate that is either expired or not valid yet\" -202 net::ERR_CERT_AUTHORITY_INVALID, \"Server responsde with a certificate signed by an untrusted authority\" -203 net::ERR_CERT_CONTAINS_ERRORS\", \"Server responded with a certificate that contains errors\" -204 net::ERR_CERT_NO_REVOCATION_MECHANISM, \"Certificate has no mechanism for determining if it is revoked\" -205 net::ERR_CERT_UNABLE_TO_CHECK_REVOCATION\", \"Revocation information for the security certificate for this site is not available\" -206 net::ERR_CERT_REVOKED, \"Server responded with a certificate that has been revoked\" -207 net::ERR_CERT_INVALID, \"Server responded with a certificate that is invalid\" -208 net::ERR_CERT_WEAK_SIGNATURE_ALGORITHM, \"server responded with a certificate that is signed using a weak signature algorithm\" -210 net::ERR_CERT_NON_UNIQUE_NAME, \"Host name specified in the certificate is not unique\" -211 net::ERR_CERT_WEAK_KEY, \"Server responded with a certificate that contains a weak key\" -212 net::ERR_CERT_NAME_CONSTRAINT_VIOLATION, \"Certificate claimed DNS names that are in violation of name constraints\" -213 net::ERR_CERT_VALIDITY_TOO_LONG, \"Certificate's validity period is too long\" -324 net::ERR_EMPTY_RESPONSE, \"Server closed the connection without sending any data\" -803 net::ERR_DNS_TIMED_OUT, \"DNS lookup timed out\" -9999 \"unknown error, error not mapped\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "sections": "<em>Synthetic</em> <em>monitoring</em> response codes",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> <em>monitors</em> returns a number of additional response codes beyond standard HTTP response codes, visible in the Resources page. These response codes are based on Chromium&#x27;s response codes and give you more detail on the behavior of your <em>monitors</em>. Response codes <em>Synthetic</em> <em>monitoring</em> returns"
      },
      "id": "6045276ee7b9d22729579a22"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Create recurring monitor downtimes",
        "Tip",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-12-09T20:52:08Z",
      "updated_at": "2021-10-31T08:36:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Create recurring monitor downtimes Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Delete a monitor downtime Tip If you are unable to delete a window, check your permissions. To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.81087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    }
  ],
  "/docs/using-new-relic/data/understand-data/new-relic-event-limits-sampling": [
    {
      "sections": [
        "Introduction to APM",
        "Tip",
        "Ready to get started?",
        "Identify problems before your users do",
        "Monitor all aspects of your business"
      ],
      "title": "Introduction to APM",
      "type": "docs",
      "tags": [
        "APM",
        "Getting started"
      ],
      "external_id": "317c07d4b32daa51186fd7d2cb857c392b595b5c",
      "image": "https://docs.newrelic.com/static/576604215ce4407c00e97b1072e557b5/c1b63/apm-screenshot.png",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/getting-started/introduction-apm/",
      "published_at": "2021-12-11T01:42:43Z",
      "updated_at": "2021-12-04T01:47:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Application performance monitoring (APM) is exactly what it sounds like: monitoring of your web or non-web application's performance. APM supports apps for several programming languages, including Go, Java, .NET, Node.js, PHP, Python, and Ruby, as well as a C SDK. View the status of all your services at a glance with APM. Tip This doc gives you detailed information about why APM matters to your business. But if you want to skip ahead, just sign up for a New Relic account. (It's free, forever!) Then, after you install the agent, you can start working with your data. Ready to get started? Start benefiting from APM in five simple steps (and just a few minutes!). Sign up for a New Relic account (it's free, forever!). Install and customize the language agent for your app. Generate some traffic for your app. Wait a few minutes for New Relic to start receiving your data. Log in to your account, and start exploring New Relic! Use the Explorer in New Relic One to access and observe the full stack of your software, including your apps, see performance data and alerting status at a glance, and check relationships. We provide you with a simple, yet powerful visual tool to monitor all your entities, that is, anything we can identify that reports data. In the New Relic ecosystem, entities include basic components like applications, hosts, containers, or database services, but it can also refer to custom groupings of such elements. You can also create your own entities. If data does not appear after waiting a few minutes, follow the troubleshooting tips for your APM agent. Identify problems before your users do Our APM agents report and store the state of your application so you can quickly identify potential problems before they affect your end users. With APM, your DevOps teams don't need to guess whether a performance blocker comes from the app itself, CPU availability, database loads, or something entirely unexpected. Use our APM solutions to gather both current and historical information about memory usage, CPU utilization, database query performance, web browser rendering performance, app availability, error analysis, external services, and other useful metrics. Monitor all aspects of your business Take advantage of these APM features, and more: Features Description App performance at a glance When you sign in to APM and select an app for your account, use the Summary page to quickly examine relationships across different aspects of your environment; for example: Web transactions response time: Where is the most time being spent? In the request queue, during different stages of page rendering and execution, from external services, or something else? Transaction traces: Which transactions are the slowest, and why? Error rate and throughput: What relationship is there between a spike in errors or slower throughput for a particular time period? Was there a deployment or outage at that time? Hosts: What kind of impact does this have on CPU usage, memory, etc.? Apdex: How are these events affecting customers' satisfaction with the site? Web and non-web transactions Start by comparing the top twenty web transactions or non-web transactions in terms of most time consuming, slowest average response time, highest throughput, or worst Apdex. From there, drill down into deeper trace levels for individual transactions, which in turn break down into smaller segments and components, from HTTPS requests on down to SQL queries. Want to explore even deeper? Set up distributed tracing to see how requests move across a distributed system. Select the transactions that are most important to your business (key transactions). APM and Infrastructure When your APM and Infrastructure accounts are linked, you will have access to APM data charts on these Infrastructure UI pages: Hosts, Network, Storage, and Processes. Distributed tracing Distributed tracing gives you visibility across distributed systems, showing you the path of a request as it travels between services. This feature is especially valuable for large, distributed systems that rely on many small services and microservices. Logs Bring your logs and application's data together to make troubleshooting easier and faster. With logs in context, you can see log messages related to your errors and traces directly in your app's UI. You can also see logs in context of your infrastructure data, such as Kubernetes clusters. No need to switch to another UI page in New Relic One. Service maps APM's service maps show your app's connections and dependencies, including databases and external services. Health indicators and performance metrics show you the current operational status for every part of your architecture. You can create and customize service maps to visualize and monitor your complex architectures. Query your data You can query and visualize your data: Sample and search APM transaction and error data to gain full understanding of the data being collected. Browse your data visually with the data explorer. Create custom SQL-like queries of your data using the New Relic Query Language (NRQL), or using our PromQL-style queries. Use dashboards to build advanced data visualizations, contextualize data, and understand what's going on in your system, real-time. These are just a few of APM's features. To find out more, see the table of contents for APM.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 65.28732,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>APM</em>",
        "sections": "Introduction to <em>APM</em>",
        "tags": "<em>APM</em>",
        "body": " not appear after waiting a few minutes, follow the <em>troubleshooting</em> tips for your <em>APM</em> agent. Identify problems before your users do Our <em>APM</em> agents report and store the state of your application so you can quickly identify potential problems before they affect your end users. With <em>APM</em>, your DevOps teams"
      },
      "id": "60440835e7b9d29c2f5799e0"
    },
    {
      "sections": [
        "Introduction to New Relic for Python",
        "Monitor app performance",
        "Install the Python agent",
        "Monitor non-web scripts, background tasks, and functions",
        "What's next after installation?",
        "Troubleshooting",
        "Check the source code"
      ],
      "title": "Introduction to New Relic for Python",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Getting started"
      ],
      "external_id": "e3621b5589469c2b3b20d5d140027e5c105e1dd3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/python-agent/getting-started/introduction-new-relic-python/",
      "published_at": "2021-12-10T01:17:02Z",
      "updated_at": "2021-12-05T09:30:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Python agent monitors your Python application to help you identify and solve performance issues. You can also extend your performance monitoring to collect and analyze business data to help you improve the customer experience and make data-driven business decisions. With flexible options for custom instrumentation and APIs, The Python agent offers multiple building blocks to customize the data you need from your app. Our Python works with a wide variety of web frameworks and hosting mechanisms, including Django, Gunicorn, WSGI, CherryPy, uWSGI, and more. You can also install the Python agent in a Google App Engine flexible environment. Monitor app performance After you install the Python agent, it begins to collect data about your app. You can view the data as charts and tables in New Relic One. View the big picture of your app. Monitor your app's Apdex (user satisfaction). Get a high-level summary of your app with Summary page. Enable distributed tracing to see activity across an architecture having many services. Install Infrastructure monitoring and view detailed server/host data for your app. Find errors and problems quickly. Track key transactions specific to your business. Create custom dashboards for important metrics. Alert your team when an error or problem occurs before it affects your users. View performance after a deployment. Drill down into performance details. Examine code-level transaction traces. Examine database query traces. Examine error traces. Use thread profiler sessions to see detailed stack traces of sampled threads View logs for your APM and infrastructure data Bring your logs and application's data together to make troubleshooting easier and faster. No need to switch to another UI page in New Relic One. With logs in context, you can see log messages related to your errors and traces directly in your app's UI. You can also see logs in context of your infrastructure data, such as Kubernetes clusters. Extend agent instrumentation Other helpful tools include: Tools Description Browser monitoring Integrate the Python agent with browser monitoring to gain visibility into end-user browser activity. Simple scripts and background tasks Monitor job-based or task queuing systems, like Celery, or other standalone non-web functions. Business data analysis with data exploration. Use the Python agent with our data explorer to organize, query, and visualize your data to answer key questions about application performance and customer experience. Use default transaction attributes, or add your own. Query your data using the New Relic Query Language (NRQL). Send your own event data. Create and share customizable, interactive dashboards. Install the Python agent Before you install the Python agent, make sure your system meets the system requirements. You must also create a New Relic account. We support a number of web frameworks and libraries right out of the box, including Django, WSGI, and Gunicorn. If you use one of the supported web frameworks, installation is easy. If you use an unsupported framework, the process will involve some additions to your app code and/or web server files. For a quick and simple install process that will work for the majority of setups, follow these simple steps: Download and install the Python package. Create config file. Integrate the Python agent with your application. Read the Quick Start guide Add Python data Monitor non-web scripts, background tasks, and functions The Python agent also lets you monitor non-web scripts, worker processes, tasks, and functions. The installation process for these non-web transactions is similar to the one used for a web app, with one major difference: instead of going through the standard integration process described in the install instructions, you would manually \"wrap\" any function you want to monitor. For more information, see Non-web tasks and processes. For instructions on monitoring Celery tasks, see Celery background tasks. What's next after installation? Once you get the agent up and running, some suggested next steps are: Explore your data in and get comfortable with the user interface. Read our docs on our other observability solutions and the APM page. Change your application's name, or other configuration options. Learn about setting up custom instrumentation for application activity not monitored by default. Consider the Python Telemetry SDK. Troubleshooting After you complete the install process, your data should appear in the APM UI within five minutes. If it does not, use these troubleshooting resources: If no data appears, follow these troubleshooting steps. If you experience issues when installing or running the Python agent on a new host, test that the package is installed correctly and that it can contact New Relic's data collector service. For other problems, see the full list of troubleshooting documentation. Check the source code The Python agent is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more information, see the README.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.97345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Troubleshooting</em>",
        "body": " thread profiler sessions to see detailed stack traces of sampled threads View logs for your <em>APM</em> and infrastructure data Bring your logs and application&#x27;s data together to make <em>troubleshooting</em> easier and faster. No need to switch to another UI page in New Relic One. With logs in context, you can see"
      },
      "id": "61749d4d196a6727702f1368"
    },
    {
      "sections": [
        "Install New Relic",
        "Install APM",
        "Install browser monitoring",
        "Install infrastructure monitoring",
        "Install mobile monitoring",
        "Install synthetic monitors",
        "Troubleshooting"
      ],
      "title": "Install New Relic ",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "069bcbf7a447dbab6466939200375e5cc3b8c394",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/install-configure/install-new-relic/",
      "published_at": "2021-12-09T21:21:14Z",
      "updated_at": "2021-11-25T21:38:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you sign up for a New Relic account (it's free, forever!) and install any of our monitoring services, you can start working with your data. Here are links to instructions on how to install New Relic monitoring services: APM Browser Infrastructure Mobile Synthetic monitors Integrations for third-party telemetry services Data ingest APIs (metrics, events, logs, traces) To search these and other monitoring solutions, see New Relic Instant Observability. Install APM C Go Java .NET For Windows .NET applications on IIS, use our guided install in New Relic One to get started with APM. If you're on an EU server, use our launcher for EU accounts instead. Node.js PHP Python Ruby Install browser monitoring See browser monitoring install. Install infrastructure monitoring Linux guided install for infrastructure monitoring Linux procedures for infrastructure monitoring Windows Kubernetes Prometheus On-host integrations (for services like NGINX, StatsD, MySQL, etc.) AWS cloud integrations Azure cloud integrations Google Cloud Platform Install mobile monitoring Android iOS Install synthetic monitors Synthetic monitoring doesn't require installation, except for its private minions feature. Troubleshooting You should start seeing your data in the New Relic UI after installing the agent, generating some traffic, and waiting a few minutes. If no data appears, follow our troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 53.312756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install <em>APM</em>",
        "body": "After you sign up for a New Relic account (it&#x27;s free, forever!) and install any of our monitoring services, you can start working with your data. Here are links to instructions on how to install New Relic monitoring services: <em>APM</em> Browser Infrastructure Mobile Synthetic monitors Integrations"
      },
      "id": "603eb6f328ccbcb565eba752"
    }
  ],
  "/docs/using-new-relic/user-interface-functions/view-your-data/supported-browsers-new-relics-ui": [
    {
      "sections": [
        "Metric normalization rules",
        "Metric normalization rules management"
      ],
      "title": "Metric normalization rules",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "3c55e4717f145ac7ae0d88e860878f4e8d18cd6b",
      "image": "https://docs.newrelic.com/static/83edfb6f5b1b68712cac34d138bb8cb8/3996e/create-new-rule-window.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/metric-normalization-rules/",
      "published_at": "2021-12-09T14:57:55Z",
      "updated_at": "2021-12-04T18:10:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There may be cases where an application sends many individual metrics that could be better managed in groups. Most of these occur with web transactions metrics named from URLs. For more information on this issue, see Metric grouping issues (MGIs). To reduce high cardinality and prevent metric grouping issues, New Relic supports rules for grouping or filtering out metrics (normalization). In some cases, when MGIs with a significant high number of metrics are detected, a rule is created automatically to protect the platform from performance degradation. Metric normalization rules management You can create and manage new rules that deal with the noise produced from high cardinality metrics by using the metric normalization tool, which is accessible from each service dashboard in the New Relic Explorer. Once there, select Metric Normalization in the left sidebar. There you can see the existing rules or create new ones. Click a rule to modify it, or click Create a new rule to create a new one. A new pane to configure the rule will be displayed. Available fields are: Match expression: enter the regular expression to group all the metrics you want to include in the rule. Matches: here you will see a preview of the metrics matched by the regular expression above. Action: the action you want to perform on the metrics. Replace: replace the matched metrics by the regular expression with the value described in the Replacement field. Ignore: ignore any metric that matches the regular expression. Deny new metrics: only write metrics that have already been reported, and ignore those that match the regular expression. Replacement: only active when Replace is enabled. Matched metrics are replaced with the field's value. If the regular expression is capturing groups, you can use placeholders for them with \\1 or \\2 for the groups 1 and 2 respectively. Active: rules can’t be deleted, but can be deactivated. Click the toggle to enable or disable the rule. If you want the rule to be removed, reach out to New Relic's support. Terminate: When enabled, the rules waterfall is exited when the associated pattern is matched. Notes: internal notes on the rule. Has no effect on the rule. Once you have set up the fields, click Create (or Edit in case you are editing an existing rule), and the rule will be applied immediately as long as it's Active.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 312.32935,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " grouping issues, <em>New</em> <em>Relic</em> supports rules for grouping or filtering out metrics (normalization). In some cases, when MGIs with a significant high number of metrics are detected, a rule is created automatically to protect the platform from performance degradation. Metric normalization rules management You"
      },
      "id": "603e810b64441ff3a74e8862"
    },
    {
      "sections": [
        "Basic platform UI: search, share, chart UI, customize navigation, and more",
        "Observe your platform",
        "Customize the navigation bar and shortcuts",
        "Light and dark mode",
        "Search accounts and entities",
        "Chart and query features",
        "Share New Relic views with others",
        "Account and user settings",
        "Other UI experiences"
      ],
      "title": "Basic platform UI: search, share, chart UI, customize navigation, and more",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "b3cdcfc60a2821dfa5bee9766aba483cc3389398",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/basic-ui-features/",
      "published_at": "2021-12-10T06:07:59Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic One has some basic UI functions that are widely available across the platform. Understanding these features will help you find and analyze your data more easily. Observe your platform New Relic One gives you full access to the data from all the entities in your stack. Go to the New Relic Explorer at one.newrelic.com to see a full list of entities, identify overall behaviors, filter them to locate sources of performance issues, or plan improvements for your system. Customize the navigation bar and shortcuts Select the edit icon at the right end of the navigation bar to customize your view. Home, Explorer, Browse data, Dashboards, and Alerts & AI are fixed, but you can favorite up to six more elements to display on the bar as well. The rest will go on the More group. Navigation shortcuts are a faster way to find entities and apps that are relevant to you. Mouse over any menu item for quick access to your favorite entities, those you recently visited, or just to search without having to navigate to a specific section. If you click on an entity, you can choose to open it in the same browser tab or in a new one. Light and dark mode See Light and dark mode. Search accounts and entities Access Quick find clicking the button, near the top right of the New Relic One UI. Some details about your search: You can search across all accounts that you have been granted access to in your organization. For more about account access, see Factors affecting access. Entities that cease to exist are available in search for eight days. If your organization has multiple accounts, use the account picker at the top left corner to select accounts. Chart and query features You can add most charts to a new or existing dashboard. Here are some query and chart features available across all or most of the platform: If you want to... Do this... Start querying your data Mouse over Browse data and select metrics, events, logs, or traces for a direct access to any of those types of data. Also, at the top of any UI page, select Query your data to access the data explorer and query builder. View a chart's query For some charts, you can view the NRQL query used to generate that chart. This can help you understand a chart better or use it as the basis for a new query. Choose time range Drag across a section of a chart to zoom in on that time range. Or, use the time picker in the top right corner of the UI to select pre-set time ranges or set a custom one. View chart details Mouse over a chart to see a pop-up with more detail. For some charts, selecting a point on the chart will take you to a UI page with more information about that metric. Hide or return chart elements To hide or unhide a displayed chart element, select that element's name below the chart. The chart display will adjust to reflect the absence or presence of that element. Share New Relic views with others Here are some options for sharing New Relic UI pages and visualizations. If you want to... Do this... Share UI pages and dashboards To share an entire New Relic UI page, click Share near the top of the UI to copy the URL. Share charts If New Relic charts are built with NRQL queries, they have a menu that exposes various options, including sharing options like Get as image and Get chart link. Some notes about sharing: The person you share with may not have access to view the data from that account. To solve that, someone on your team with New Relic user management abilities must add that person to the account. If someone can't access a custom dashboard, it may be that it is set to private. Read more about dashboard permissions. Some sharing options have associated time ranges, which may impact later viewings of it. For example, if you use a chart's Get chart link option and that chart is set to 'Last 30 minutes', when viewed it will show the last 30 minutes, not the time range displayed when it was shared. To share a specific time range, you must select that time range in the UI. Account and user settings To find account settings and user preferences, use the account dropdown, located at the top right of the UI, beside your user name. Other UI experiences This has been a look at a few basic platform UI experiences. For more about the UI, search for docs related to the specific New Relic solution you're using.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.79105,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Basic platform <em>UI</em>: search, share, chart <em>UI</em>, customize navigation, <em>and</em> more",
        "sections": "Share <em>New</em> <em>Relic</em> views with others",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> has some basic <em>UI</em> functions that are widely available across the platform. Understanding these features will help you find and analyze your <em>data</em> more easily. Observe your platform <em>New</em> <em>Relic</em> <em>One</em> gives you full access to the <em>data</em> from all the entities in your stack. Go to the <em>New</em> <em>Relic</em>"
      },
      "id": "603ec1f964441f5b0e4e8860"
    },
    {
      "sections": [
        "Dependencies UI: View an entity's upstream and downstream dependencies",
        "Requirements",
        "View dependencies"
      ],
      "title": "Dependencies UI: View an entity's upstream and downstream dependencies",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "UI and data"
      ],
      "external_id": "2b2f328a6281bb155bcde07efec7f42eae943048",
      "image": "https://docs.newrelic.com/static/aabc5f64a91cc01b6e226df53c62458f/c1b63/new-relic-one-dependencies-UI.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/ui-data/explore-downstream-dependencies-new-relic-one/",
      "published_at": "2021-12-10T06:08:10Z",
      "updated_at": "2021-08-21T09:29:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In the New Relic Explorer, an entity's Dependencies page shows a filterable list of all the applications, services, databases, and hosts connected to the entity. It shows upstream and downstream dependencies, and provides paths to explore them. Similar to service maps, the dependencies page helps you understand how all of your upstream and downstream services are connected. It also uses the same color coding system used by service maps to show you what's performing well and what isn't. Requirements To view an entity's dependencies, make sure your app uses the minimum required APM agent version: C 1.0.0 or higher Go 1.11 or higher Java 3.9.0 or higher .NET 4.2 or higher Node.js 2.0.0 or higher PHP 4.19.0 or higher Python 2.38.0.31 or higher Ruby 4.3.0 or higher View dependencies To view dependencies for applications, services, databases, and hosts connected to an entity: Go to one.newrelic.com, select Explorer, and select an entity. Select Dependencies. To drill down further, filter the apps, services, databases, or hosts. one.newrelic.com > Explorer > (select an entity) > Dependencies: View a filterable list of all the apps, services, databases, and hosts connected to an entity, and their color-coded health status. You can filter the dependencies page to view specific things that report to the entity. Dependencies include: Services: APM-monitored applications and services. Mobile applications: your mobile apps. Browser applications: your front-end browser apps. External services: external services monitored by APM. External services include out-of-process services such as web services, resources in the cloud, and any other network calls. Databases: your application's database and cache data. Databases are agentless. Because of this, alerts cannot be set for the database, as only the service call is reported to New Relic. Hosts: your infrastructure (servers and hosts).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 199.79105,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dependencies <em>UI</em>: View an entity&#x27;s upstream <em>and</em> downstream dependencies",
        "sections": "Dependencies <em>UI</em>: View an entity&#x27;s upstream <em>and</em> downstream dependencies",
        "tags": "<em>Use</em> <em>New</em> <em>Relic</em> <em>One</em>",
        "body": " services: external services monitored by APM. External services include out-of-process services such as web services, resources in the cloud, and any other network calls. Databases: your application&#x27;s database and cache <em>data</em>. Databases are agentless. Because of this, alerts cannot be set for the database, as only the service call is reported to <em>New</em> <em>Relic</em>. Hosts: your infrastructure (servers and hosts)."
      },
      "id": "603eb2e564441f0fe44e889b"
    }
  ]
}